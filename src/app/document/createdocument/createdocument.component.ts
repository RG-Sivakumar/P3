import { Component, OnInit, Renderer2, ViewChild, ElementRef, AfterViewInit, Input, HostListener, OnDestroy, ViewChildren, QueryList, ChangeDetectorRef, Injectable, Inject, Output } from "@angular/core";
import { MatDialogConfig, MatDialog} from "@angular/material/dialog";
import { environment } from "src/environments/environment.prod";
import { PDFDocumentProxy, PdfViewerComponent } from 'ng2-pdf-viewer';
import { SwitchToolbarComponent } from "../switch-toolbar/switch-toolbar.component";
import { ToolbardesignService } from "src/app/toolbar/services/toolbardesign.service";
import { ActivatedRoute, Router } from "@angular/router";
import { HeadertitleService } from "src/app/headertitle.service";
import { element } from "src/app/toolbar/model/toolbarelement.model";
import { SharedService } from "src/app/shared/shared.service";

import { EventGlobalService } from "src/app/event-global.service";
import { ToolbarlistService } from "src/app/toolbar/services/toolbarlist.service";
import panzoom from "panzoom";
import { forkJoin, fromEvent, Subscription } from "rxjs";
import { switchMap, takeUntil, pairwise } from "rxjs/operators";
import { v1 as uuidv1 } from "uuid";
import { login } from "src/app/projectmanagement/models/login-model";
import { SwitchFormComponent } from "../switch-form/switch-form.component";
import { elements } from "src/app/formbuilder/Model/controlmodel";
import { AnnotationMenuComponent } from "./annotation-menu/annotation-menu.component";
import { ProjectfolderService } from 'src/app/projects/services/projectfolder.service';
import * as _ from 'lodash';
import {
  trigger,
  transition,
  style,
  animate,
  state,
} from "@angular/animations";
import {
  Addform,
  getFormById,
  getFormBy_Id,
  ext_getFormById,
  layer_mapping_copy_btw_doc,
} from "./formOperations";
import { data } from "jquery";
import { DatePipe, DOCUMENT } from "@angular/common";
import { LinkOptionMenuComponent } from "./link-option-menu/link-option-menu.component";
import { MediamenuComponent } from "./mediamenu/mediamenu.component";
import { FormnameService } from "src/app/formname.service";
import { CreateDocumentService } from "../services/create-document.service";
import { DataserviceService } from "../services/dataservice.service";
import { DocumentshareddataService } from "../services/documentshareddata.service";
import { ReadonlyService } from "../services/readonly.service";
import { StubdataService } from "../services/stubdata.service";
import { DocumentPagesService } from "../services/document-pages.service";
import { TextAnnotationComponent } from "./text-annotation/text-annotation.component";
import { FormmappingService } from "../services/formmapping.service";
import { StubphotosComponent } from "../media/stubphotos/stubphotos.component";
import { DataimageService } from "src/app/dataimage.service";
import { LinkToUrlComponent } from "./add-links-option/link-to-url/link-to-url.component";
import { LinksToDocumentComponent } from "./add-links-option/links-to-document/links-to-document.component";
import { AnnotationDeleteComponent } from "./annotation-delete/annotation-delete.component";
import { MatSnackBar } from '@angular/material/snack-bar';
import { SearchService } from "src/app/search.service";
import * as _moment from "moment";
import { default as _rollupMoment } from "moment";
import { NativeDateAdapter, DateAdapter, MAT_DATE_LOCALE, } from "@angular/material/core";
import { DataService } from "src/app/data.service";
import { AddMultipleImagesComponent } from "./add-multiple-images/add-multiple-images.component";
import { ShapeService } from "../services/shape.service";
import { GlobalUserRoleService } from "src/app/global-user-role.service";
import html2canvas from "html2canvas";
import jsPDF from "jspdf";
import { EventEmitter } from "events";
import heic2any from "heic2any";
import { createDocumentVar, createDocumentVar_1 } from "./createdocumentvariables";
import { ClayeralertComponent } from "../clayeralert/clayeralert.component";
import { RemainderPopupComponent } from "./remainder-popup/remainder-popup.component";
import { AttributeconfromComponent } from "./remainder-popup/attributeconfrom/attributeconfrom.component";
import { get_annot_draw_model, get_user_role, linewidthchanges } from "./documentfunctions1";
import { EncryptDecryptService } from "src/app/commonshared/services/encrypt-decrypt.service";
import { annotation_keys, annotation_key_part, layerdata_sharing, scale_locator, switch_form, switch_toolbar } from "../models/documentmodel";
import { documentfunction_maintain } from "../models/documentfunction.model";
import { WarningrotateresizeComponent } from "./warningrotateresize/warningrotateresize.component";
import { DocumenttagService } from "../services/documenttag.service";
import { DocumentdetailsService } from "../services/documentdetails.service";
import { StateChange } from "ng-lazyload-image";
import { ImportautocardService } from "./share-option/importautocard.service";
import { FormControl, FormGroup } from "@angular/forms";
import { weld_form_main } from "../../commonshared/components/weldform/weldform_main.model";
import { GroupAnntsFormsComponent } from "../createdocument/group-annts-forms/group-annts-forms.component";


const moment = _rollupMoment || _moment;
export class CustomDateAdapter extends NativeDateAdapter {
  format(date: Date, displayFormat: Object): string {
    var formatString = "yyyy-MM-DD";
    return moment(date).format(formatString);
  }
}

class ImageSnippet {
  constructor(public src: string, public file: File, private datePipe: DatePipe) { }
}

// import { IntersectionObserverHooks, Attributes, LAZYLOAD_IMAGE_HOOKS } from 'ng-lazyload-image';

// class LazyLoadImageHooks extends IntersectionObserverHooks {
//   setErrorImage12({ element, errorImagePath }: Attributes) {
//     element.src = errorImagePath;
//   }
// }
// {provide: LAZYLOAD_IMAGE_HOOKS, useClass: LazyLoadImageHooks},

export const globalLayerData = {
  previousValue: [],
}

@Component({
  selector: "app-createdocument",
  templateUrl: "./createdocument.component.html",
  styleUrls: ["./createdocument.component.css"],
  providers: [DatePipe,
    { provide: MAT_DATE_LOCALE, useValue: "en-GB" },
    {
      provide: DateAdapter,
      useClass: CustomDateAdapter,
    },
  ],
  animations: [trigger("fade", [
    state("void", style({ opacity: 0 })),
    transition("void <=> *", [animate("0.5s ease")])
  ]),
  ]
})


export class CreatedocumentComponent implements OnInit, AfterViewInit, OnDestroy {
  linksarray: any[];
  textsize:number;
  dragmovenenable: boolean = false;
  resizebutton: boolean = false;
  showFiller = false;
  colorvalid = false;
  getPositionActive = false;
  changeArrow: boolean = false;
  selectedannotations: any = [];
  documentName: string;
  projectId: string;
  sub: string;
  folderId: string;
  toolbatlist: any[];
  copydata:boolean=false
  isforResize: Boolean = false;
  documentDetails: any[];
  documentURL: any[] = [];
  slideIndex: number = 0;
  slideIndex1 = 1;
  currentPageNumber: number = 1;
  loggedin: any = this.encrptdecrpt.getItem("loggedIn") || "{}";
  parent = document.getElementsByClassName("mySlides");
  arrayUpdated: boolean = false;
  public toolbar: any[];
  labelView: boolean = false;
  imgUrl: any;
  nonSecurityImgUrl: any = "";
  show: boolean = false;
  isReadonly: any = false;
  isRapidmode: any = false;
  copyOfModelfield: element[];
  copyOfFormModelfield: elements[];
  url: string;
  filepath: any;
  comment: any;
  annotationid: any;
  annotation_type: any;
  formName: any;
  formCount: any = "0";
  mediaCount: any = "0";
  linkCount: number = 0;
  tagCount: any = "0";
  toolbarId: string;
  layerid: any;
  formId: string;
  su: login;
  loader: boolean = false;
  fill: any;
  annotNameAnnotation: string;
  annotLabelAnnotation: string;
  annotShapeAnnotation: string;
  annotMoveAnnotation: string = "noValue";
  propertiesannotationData: any = {};
  propertiesannotationDataCopy: any = {};
  propertiesannotationDataString: string;
  annotationtagsName: string;
  visibleLayerIds: string[] = [];
  activeLayerIdDraw: string;
  annotationTags: any[] = [];
  finalArray: any = []
  finalArray1: any = []
  finalArray2: any = []
  outputArray: any = []
  usecaseCopyArray: any = []
  undoArray: any = []
  redoArray: any = []
  datas: any;
  select_autocad=false;
  resizedone:boolean=false;
  condition_field_name: any;
  current_if_value: string;
  current_if_state: string;
  current_if_do: string;
  multipleSelectOnTags: boolean = false;
  buttoncolorsSet: any[] = [{ "color": "blue", "color_code": "#002F5F" },
  { "color": "red", "color_code": "#BC0900" },
  { "color": "orange", "color_code": "#F48F00" },
  { "color": "yellow", "color_code": "#FFFF00" },
  { "color": "green", "color_code": "#98D133" },
  { "color": "default_blue", "color_code": "#015ECD" },
  { "color": "purple", "color_code": "#6C2EA7" },
  { "color": "pink", "color_code": "#DF1ED3" },
  { "color": "dark_pink", "color_code": "#C832B1" },
  { "color": "light_blue", "color_code": "#80F1FE" },
  { "color": "brown", "color_code": "#7C4E40" },
  { "color": "grey", "color_code": "#949494" },
  { "color": "medium_grey", "color_code": "#CCCCCC" },
  { "color": "black", "color_code": "#000000" },
  { "color": "white", "color_code": "#FFFFFF" }];

  buttonColors: any[] = [
    { "color": "blue", "color_code": "#002F5F" },
    { "color": "red", "color_code": "#BC0900" },
    { "color": "orange", "color_code": "#F48F00" },
    { "color": "yellow", "color_code": "#FFFF00" },
    { "color": "green", "color_code": "#98D133" },
    { "color": "default_blue", "color_code": "#015ECD" },
    { "color": "purple", "color_code": "#6C2EA7" },
    { "color": "pink", "color_code": "#DF1ED3" },
  ];

  buttonColors2: any[] = [
    { "color": "dark_pink", "color_code": "#C832B1" },
    { "color": "light_blue", "color_code": "#80F1FE" },
    { "color": "brown", "color_code": "#7C4E40" },
    { "color": "grey", "color_code": "#949494" },
    { "color": "medium_grey", "color_code": "#CCCCCC" },
    { "color": "black", "color_code": "#000000" },
    { "color": "white", "color_code": "#FFFFFF" },
  ];
  Setprefix: any;
  SetNumber: any;
  NoofStubs: any;
  projectName: string;
  drawShapeDonePolygon: boolean = false;
  drawShapeDonePolyline: boolean = false;
  drawShapeDonePolylineArrow: boolean = false;
  drawShapeDoneLine: boolean = false;
  drawShapeDoneLineAxial: boolean = false;
  drawFreehandMenu: boolean = false;
  receiveString: string;
  toolbarBg: number = -1;
  annotationName: string;
  accessMenuFeatureStop: Boolean = true;
  accessPolygonMenuFeatureStop: boolean = true;
  accessPolylineMenuFeatureStop: boolean = true;
  accessPolylineArrowMenuFeatureStop: boolean = true;
  accessLineMenuFeatureStop: boolean = true;
  accessLineAxialMenuFeatureStop: boolean = true;
  accessRectangleMenuFeatureStop: boolean = true;
  copyannotation: boolean = false;
  multipleSelectOn: boolean = false;
  useasToolbar: boolean = false;
  showAllAnnotations: any[];
  copyAnnotationStart: boolean = false;
  selectedAnnotationLength: number = 0;
  rotateandresize: boolean = false;
  addshapeToolbar: boolean = false;
  singleCopyAnnotation: boolean = false;
  setBaseIconSize: any = {
    setBaseIconSizeHeight: "35",
    setBaseIconSizeWidth: "35",
    setBaseIconPagesAllowed: [],
  };
  colorchange: boolean;
  createdDate: any;
  modifiedDate: string;
  initialHeight: any;
  initialWidth: any;
  addstampToolbar: boolean = false;
  createDocument$: any;
  htmlelementtype$: any;
  mediaTags$: any;
  searchfilterid: any;
  //unsubscribe
  subscription: Subscription;
  layerPage$: Subscription;
  renameMediaSubscribe: any;
  deleteMediaSubscribe: any;
  setScaleTriggerSubscribe: any;
  rapidShotModeOn: boolean = false;
  setScaleOn: boolean = false;
  areaValue: any = 0;
  mediaId: string;
  searchannotationIdsBackup: any = [];
  checkedAnnotationIdsBackup: any[] = [];
  searchAnnotationId$: Subscription;
  checkedAnnotationIdPage$: Subscription;
  checkedAnnotationId$: Subscription;
  groupAnntsEnbled$: Subscription;
  toolbarFilter: any = {};
  layerPageUpdateData$: Subscription;
  lastAnnotationId: string = "";
  needUpdateFormCount: number = 0;
  mainPlaceWidth: string = "99%";
  centerImageHeight: boolean = false;
  drawFunctionActive: boolean = false;
  public canvasElement: CanvasRenderingContext2D;
  currentPageId: string = "";
  createJson: any;
  coordinateX: number = 0;
  coordinateY: number = 0;
  optionPositionX: number = 0;
  optionPositionY: number = 0;
  optionClick: boolean = false;
  layerBoxPositionX: number = 0;
  layerBoxPositionY: number = 0;
  moreOptionClick: boolean = false;
  public scale = 1.0;
  public scaleMultiplier = 0.8;
  folderLevel: any = 0;
  parentFolderId: string = "";
  searchLayerClick: boolean = false;
  lockedLayerActive: boolean;
  toolbarList = [];
  modelFields: Array<element> = [];
  toolbar_name = "";
  tempModelFields: any[] = [];
  updateNewToolbarData: any[] = [];
  currentStrokeColor: string = "";
  currentFillColor: string = "";
  currentLineWidth: number = 1;
  currentSelectedItems: any = {};
  previousRoute: string;
  getOpenLinkWindow: any = false;
  pageId: string = "";
  moveElementValue: boolean = false;
  copyMode: string = "withData";
  formList: any[] = [];
  multiclickdisabled: boolean = false;
  copyAnnotationDatas: any = [];
  copyAnnotation_svg_view: any[] = [];
  stringPath: string;
  a: number;
  pdfSource: string = "";
  itemIndexNumber: number = -1;
  conditionSelected: any;
  csSelected: any;
  elementFields: any;
  fieldQuantity: number;
  countedCheck: any;
  showHtmlFields: boolean;
  unratedQuantity: any;
  csValue: any;
  seticonwidth: number = 0;
  seticonheight: number = 0;
  // @ViewChild(PdfViewerComponent, { static: false })
  currentFormHiddenStatus: boolean = false;
  drawRectangleDone: boolean = false;
  drawEllipseDone: boolean = false;
  datavalues: any;
  baseUrl: string;
  sKey1: string;
  sKey2: string;
  editIndex: number;
  activeIndex: any;
  DummyField: any;
  FieldResult: any;
  pdfViewControl: any;
  checkAllPageSetScaleStatus: boolean = true;
  scaleValue: number = 0;
  oldScaleValue: number = 1;
  pdfScaleValue: number = 1;
  setScaleActivatedStatus: boolean = false;
  changeShapeEnable: boolean = false;
  shapeIdName: any[] = [{ shape: "Circle", id: 1 }, { shape: "Octagon", id: 2 }, { shape: "Square", id: 3 }, { shape: "Triangle", id: 4 }, { shape: "Star", id: 5 }, { shape: "Diamond", id: 6 }, { shape: "Flag", id: 7 }, { shape: "Camera", id: 8 }, { shape: "Arrow", id: 9 }];
  synAction: boolean = false;
  pageChange$: Subscription;
  pageSync$: Subscription;
  linkedpageDataSubscribe: Subscription;
  linkedpageAIdSubscribe: Subscription;
  deleteAnnotation$: Subscription;
  toolbarSet: boolean = false;
  @ViewChild("scene", { static: false }) scene: ElementRef;
  panZoomController;
  zoomLevels: number[];
  currentZoomLevel: number;
  useastoolbarUpdate$: Subscription;
  undoActionService: Subscription;
  tagsMediaSubscribe: Subscription;
  addToolbarShapes$: Subscription;
  layerDataget$: Subscription;
  formListDefaultValues: any[] = [];
  layerDatas: any[];
  layerDatas$: Subscription;
  layerEnable: boolean = false;
  projectid: string;
  userrole: string;
  layerpageActive$: Subscription;
  layerPageUpdateAllData$: Subscription;
  redoActionService: Subscription;
  linkedPageSubscribe: Subscription;
  undoDatataForForms: any;
  totalElementQuantity: number = 0;
  pdfWidthHeight: any = { width: 0, height: 0 };
  tempTagLayerDatas: any[] = [];
  searchOption$: Subscription;
  searchOption: boolean;
  moveCurrentSelectedItem: any;
  private subscriptions: Subscription[] = [];
  singleDataReceived: any;
  dbxposition: number = 0;
  dbyposition: number = 0;
  annotationstring: any;
  search$: any
  ref1;
  iconsize1: any;
  seticonheight$: Subscription;
  currentpageid1: string;
  layerdata: any[];
  htmlelementtype1$: Subscription;
  annotMetadata: any;
  annotMetadataArea: any; annotMetadataLength: any; annotMetadataHeight: any;
  scaleFactor: any;
  scaleHeight: any = 0;
  scaleBoxHeight: any = 0;
  scaleWidth: any = 0;
  scaleBoxWidth: any = 0;
  scalefeetValue: any = 0;
  scaleVertical: boolean = false;
  scaleHorizontal: boolean = false;
  createdtime: string;
  firstname: any;
  lastname: any;
  modifytime: string;
  userdetail: any;
  firstname1: any;
  lastname1: any;
  updateduserid: any;
  list: any;
  createdbyuserid: any;
  list1: any;
  createduserid: any;
  list2: any;
  changesSubscription$: Subscription;
  annotationSelectEvent: boolean = false;
  @ViewChild('dropdownselect') dropdowncolors: ElementRef;
  accessdrawEllipseMenuStop: boolean = true;
  cloneLayerDataBeforeMoving: any[] = [];
  moveAnnotationsStore: any[] = [];
  resizeAnnotationsStore: any[] = [];
  moveAccess$: Subscription;
  copydataclose$: Subscription;
  canclose: any;
  showvisible: boolean;
  findlayerid: any[];
  copytoolhead: boolean = false;
  createDocumentStore: createDocumentVar = null;
  button1: any;
  value: any[];
  rotateResize$: Subscription;
  removeGroupAnnts$: Subscription;
  removeGroupAnntsSingle$: Subscription;
  alignAnnotations$: Subscription;
  getsearchoption: boolean;
  transform_date: any;
  inputBox: any;
  enableGrap: boolean = false;
  enableGrapTop: boolean = false;
  enableGrapTopStyle: boolean = false;
  enableGrapRight: boolean = true;
  enableGrapRightStyle: boolean = true;
  enableGrapBottom: boolean = false;
  enableGrapBottomStyle: boolean = false;
  enableGrapBorderTop: boolean = false;
  enableGrapBorderRight: boolean = true;
  enableGrapBorderBottom: boolean = false;
  extentToolbarSize: boolean = true;
  previousDataValue: string = "right";
  toolbarplaceBackup: string = "right";
  enablerightChangeHeightValue: boolean = false;
  topWidth: string = "92%";
  rightSideDrop: boolean = true;
  deleteannotationId: string;
  shape: boolean = false;
  toolbarnone: boolean = false;
  search_displayannotation: any[] = [];
  undoFreehandflag: boolean = false;
  filterdata$: Subscription;
  annotId_: any;
  annotation_click: boolean;
  attribute_change: boolean = false;
  rotateresizeAnnotationStore: any[] = [];
  resizeactionpending: boolean = false;
  opcitychange: boolean = false;
  red: boolean = false;
  single_view_svg: any = "";
  single_view_preview_svg: any = "";
  toolbarElements_view_svg: any[] = [];
  multiselectionList_svg_view: any = [];
  functionlistner: any;
  toolbarData: any;
  totalPages: number = 0;
  realWidth: any = 0;
  realHeight: any = 0;
  pageName: string = "";
  pngFormat: boolean = true;
  custome_form_object = { "location": "", "decibels": "", "previouscondition": "", "flagforrReview": "", "Condition": "", "Comment": "" };
  element_details: any = [
    { element_name: "single_line_text", width: 175, height: 60 },
    {
      element_name: "text_area",
      width: 175,
      height: 153
    },
    {
      element_name: "number",
      width: 175,
      height: 59
    },
    {
      element_name: "text_label",
      width: 175,
      height: 24
    },
    {
      element_name: "empty_cell",
      width: 0,
      height: 0
    },
    {
      element_name: "Divider",
      width: 175,
      height: 30
    }
    , {
      element_name: "checkbox",
      element_alias_name: 'option 1',
      width: 175,
      height: 35
    }
    , {
      element_name: "dropdown",
      width: 175,
      height: 60
    }
    , {
      element_name: "single_choice",
      width: 175,
      height: 114
    }
    , {
      element_name: "multiple_choice",
      width: 175,
      height: 120
    }
    , {
      element_name: "date",
      width: 175,
      height: 68
    }, {
      element_name: "calculation",
      width: 175,
      height: 59.8
    },
    {
      element_name: "address",
      width: 175,
      height: 190
    }
  ];
  finalarray2_uuids: any[] = [];
  savebuttoncheck: boolean = false;

  @ViewChild('pdfViewerAutoLoad') pdfViewerAutoLoad;
  @ViewChild('searchpage') Searchpage;
  copyannotation_single$: Subscription;
  copyannotation_multiple$: Subscription;
  copyannotation_multiple_option$: Subscription;
  formCountmultiselect: any = 0;
  labelChange: boolean = false;
  editButton: boolean = false;
  setscaleValue: number;
  currentAnnotationName: any;
  repoint_AnnotationStore: any[] = [];
  repoint_AnnotationStore_Id: any[] = [];
  moveOverBoundary: boolean = false;
  createDocumentStore_1: createDocumentVar_1 = null;
  array_update: any = [];
  multiselectionList: any[] = [];
  multiselectchangeBgToggle: boolean = false;
  getAllDocumentPagesValue: any[] = [];
  toolbar_detail: any;
  backUpTextProperties: { size: number; xPosition: any; yPosition: any; };
  fontSizeShapes: number;
  fontLeftShapes: number;
  fontTopShapes: number;
  textsizeOriginal: number;
  resizeMoveBackUp: any = {};
  resizeMove: boolean = false;
  resizeLabelText: boolean = false;
  multitextlabel: boolean =false;
  setbgBool: any = false;
  copyMultiAnn: boolean = false;
  objectCol: { positionX: number; positionY: number; ann_id: any; name: any;toolbar_id: any};
  objectColHTML: { positionX: number; positionY: number; ann_id: any; name: any; Height: any; Width:any };
  cpyMultiAnnPos:any[] = []
  arrNewPosition:any[] = [];
  copymultiannenabled :boolean = false;
  autocadresponse$: Subscription;
  autocad_import: any;
  process_id: any;
  lineStartPosition: { x: number; y: number; };
  lineEndPosition: { x: number; y: number; };
  borderLine: string;
  borderLinePresent : boolean = false;
  borderLineArray:any[] = [];
  lineDraw: boolean = false;
  copyMultiselectionList: any[];
  newcopyAnnotations: any[] = [];
  center: { x: number; y: number; };
  alignAnnEnabled: boolean = false;
  clonemultiselect_align: any[];
  alignAnnBaseAnn: any;
  alignAnnotationArr: any[]=[];
  weldform: boolean =false;
  copyweldForm:any;
  left: boolean = false;
	right: boolean = false;
	formContentleft: any[] = [];
	formContentright: any[] = [];
	// show: boolean = false;
	output: boolean = false;
	// form structure
	weld_FormStructure: FormGroup = new FormGroup({
		weldId: new FormControl(),
		areaEntire: new FormControl(),
		interpretation: new FormControl(),
		repairType: new FormControl(),
		areaSpecific: new FormControl(),
		remarks: new FormControl()
	})
	weld_form_table: weld_form_main[] = []
   // The below boolean is used to hide or show weld wmata add form
	formShow: boolean = false;
	fieldsWeld: any[] = [];
  formValuesArray: any[]=[];
  clone_model_useconditions = {
    element_type: "empty_cell_useCase",
    element_name: "empty_cell_useCase",
    element_uuid: '',
    clone_uuid: '',
    element_id: 14,
    is_hidden: 0,
    is_removed: 0,
    width: 0,
    height: 40,
    version_number: 0,
    element_order: 0,
    element_data: {
      reference_id: ""
    }
  }
  useCaseEmptycellIds: any[] = [];
  formFields_weld: any[] = ["checkbox", "single_choice", "date", "multiple_choice", "dropdown"];
  weldformPresent: boolean = false;
  grpAnntsEnbled: boolean = false;
  selectedGroupFormId: any;
  alreadySelectedGrpAnnts: any[] = [];
  selectedGrpAnnForm: any[];
  createJSON_grpAnnts: any;
  objectColHTML_GrpAnnts: { positionX: number; positionY: number; ann_id: any; Height: any; Width: any };
  cpyMultiAnnPos_GrpAnnts: any[] = []
  showGroupBox: boolean = false;
  groupValueUpdate: boolean = false;
  dropDownColorDetails: any;

  //dont use the "drag-scroll-content" class name any elements.  
  constructor(
   private rightclickable: CreateDocumentService,
    private service: ProjectfolderService,
    private shapeService1: ShapeService,
    public dialogBox: MatDialog,
    private documentService: CreateDocumentService,
    private renderer: Renderer2,
    private toolbardesginService: ToolbardesignService,
    private route: ActivatedRoute,
    private headerTitleService: HeadertitleService,
    public dataService: DataserviceService,
    public dataService1: DocumentshareddataService,
    private eventsService: EventGlobalService,
    private dataService2: DataserviceService,
    private toolbarlistService: ToolbarlistService,
    private readonlydataService: ReadonlyService,
    public stubdataService: StubdataService,
    private dataService4: DataService,
    private datePipe: DatePipe,
    public messageService: FormnameService,
    private documentPage: DocumentPagesService,
    private sharedService: SharedService,
    private router: Router,
    private imgdataService: DataimageService,
    private elementRef: ElementRef,
    private _snackBar: MatSnackBar,
    private routingState: SearchService,
    private activateRoute: ActivatedRoute,
    private cdRef: ChangeDetectorRef,
    public userRoleGlobal: GlobalUserRoleService,
    private encrptdecrpt: EncryptDecryptService,
    private document_service_2: DocumenttagService,
    private document_credential: DocumentdetailsService,
    @Inject(DOCUMENT) private document123: any,public autocad:ImportautocardService
  ) {
    this.projectId = this.route.snapshot.queryParamMap.get("project_id");
    this.folderId = this.route.snapshot.queryParamMap.get("folderId");
    this.createDocumentStore = new createDocumentVar();
    this.createDocumentStore_1 = new createDocumentVar_1();
    this.autocadresponse$=this.service.autocademit.subscribe(res=>{
      console.log(res)
      if(res.selected==true){
        this.show=true;
      }
      this.autocad_import=res.response
     this.select_autocad=res.selected
     this.process_id=res.process_id
     this.getAnnotationForm()
      
    })
    this.cpyMultiAnnPos_GrpAnnts = [];
    this.htmlelementtype$ = this.dataService.htmlelement.subscribe((statuss: boolean) => {
      if (statuss == true) {
        this.doc1()
      }
    })

    this.htmlelementtype1$ = this.dataService.htmlelement1.subscribe((statuss: boolean) => {
      if (statuss == true) {
        this.doc2()
      }
    })

    //search button in createdocument
    this.dataService2.searchselector.subscribe(async (statuss: boolean) => {
      console.log(statuss);
      await this.automatic_update_form();
      if (this.attribute_change == true) {
        await this.attribute_value_changes();
      }
      this.searchOption = statuss;
      this.getsearchoption = statuss;
      //this.dataService2.currentpageidsearch.emit(this.currentPageId);
      // localStorage.setItem(this.projectId + "currentpage", this.currentPageId);
      this.encrptdecrpt.setItem(this.projectId + "currentpage", this.currentPageId);//security
      console.log(this.currentPageId)
      console.log(this.searchOption)
    })
    this.userRoleGlobal.findUserProjectRole(this.projectId).then((res_userrole) => {
      this.userrole = res_userrole;
    })
    this.dataService2.userroleshare.emit(this.userrole);
    this.dataService2.copyAnnotationMultiple.emit("false")
    this.undoActionService = this.dataService2.undoAction.subscribe((ids: any) => {
      // previous undo method this.annotationUndo();  
      this.createDocumentStore.undovaluesstore = this.documentService.createDocumentStore_values.undovaluesstore;
      if (this.createDocumentStore.undovaluesstore.length > 0) {
        if (this.createDocumentStore.undovaluesstore.length > 10) {
          let total_undo_list = this.createDocumentStore.undovaluesstore;
          let last_10_values = total_undo_list.slice(-10);
          this.createDocumentStore.undovaluesstore = last_10_values;
          this.documentService.createDocumentStore_values.undovaluesstore = last_10_values;
        }
        if (this.createDocumentStore.forms_changes_status == true) {
          let generateCloneLayer: any = "";
          let annotation_id = "";
          let layer_id = "";
          let multiselectionlist = [];
          let create_temp_object = new Object();
          if (this.multipleSelectOn == false) {
            generateCloneLayer = _.cloneDeep(this.layerDatas);
            annotation_id = this.getId;
            layer_id = this.activeLayerIdDraw;
            create_temp_object["layer_data"] = generateCloneLayer;
            create_temp_object["annotation_id"] = annotation_id;
            create_temp_object["layer_id"] = layer_id;
          }
          else {
            generateCloneLayer = _.cloneDeep(this.layerDatas);
            multiselectionlist = this.multiselectionList;
            create_temp_object["layer_data"] = generateCloneLayer;
            create_temp_object["multiselectionlist"] = multiselectionlist;
          }
          console.log(create_temp_object);
          this.createDocumentStore.forms_changes_status = false;
          this.documentService.createDocumentStore_values.redovaluesstore.push(create_temp_object);
          if (this.multipleSelectOn == false) {
            this.previousSelectAnnotation = [];

            this.createDocumentStore.single_select_annotation = [];
            if (this.getId != "" && this.getId != undefined) {
              this.getId = "";
              this.deselectAnnotation();
            }
          }
          else {
            this.multipleSelectOn = false;
            this.changeShapeEnable = false;
            for (let changestyle = 0; changestyle < this.multiselectionList.length; changestyle++) {
              let get_change_style_element = document.getElementById(this.multiselectionList[changestyle].annotation_id);
              if (get_change_style_element != null) {

                get_change_style_element.removeAttribute('multimoving');
                this.transparentBorder(get_change_style_element);
                this.getMultipleMovingLabelElementRemove(this.multiselectionList[changestyle].annotation_id);
              }
            }
            this.multiselectionList = [];
            // multiselection svg drawing empty place
            this.multiselectionList_svg_view = [];
            this.previousSelectAnnotation = [];

            this.createDocumentStore.single_select_annotation = [];
            this.createDocumentStore.selectedAnnotations = [];
            this.selectAnnotationZero();
            this.deselectAnnotation();
            this.copyAnnotationStart = false;
            // drag multiple annotation selection
            this.dataService.getannotationid.emit("");
            this.dataService.imageChangeDocHeader.emit(false);
            this.removeCanvasAttribute('customeMultipleAttribute');
          }
          this.getAnnotationForm();
        }
        else {
          this.show = true;
          let getundo_uuid = this.createDocumentStore.undovaluesstore.pop();
          this.documentService.createDocumentStore_values.redovaluesstore.push(getundo_uuid);
          this.documentService.getundodatafromdb(getundo_uuid, this.folderId, "undo").subscribe((res) => {
            if (res["response_code"] == 200) {
              console.log(res);
              if (this.multipleSelectOn == false) {
                this.previousSelectAnnotation = [];

                this.createDocumentStore.single_select_annotation = [];
                if (this.getId != "" && this.getId != undefined) {
                  this.getId = "";
                  this.deselectAnnotation();
                }
              }
              else {
                this.multipleSelectOn = false;
                this.changeShapeEnable = false;
                for (let changestyle = 0; changestyle < this.multiselectionList.length; changestyle++) {
                  let get_change_style_element = document.getElementById(this.multiselectionList[changestyle].annotation_id);
                  if (get_change_style_element != null) {

                    get_change_style_element.removeAttribute('multimoving');
                    this.getMultipleMovingLabelElementRemove(this.multiselectionList[changestyle].annotation_id);
                    this.transparentBorder(get_change_style_element);
                  }
                }
                this.multiselectionList = [];
                // multiselection svg drawing empty place
                this.multiselectionList_svg_view = [];
                this.previousSelectAnnotation = [];

                this.createDocumentStore.single_select_annotation = [];
                this.createDocumentStore.selectedAnnotations = [];
                this.selectAnnotationZero();
                this.deselectAnnotation();
                this.copyAnnotationStart = false;
                // drag multiple annotation selection
                this.dataService.getannotationid.emit("");
                this.dataService.imageChangeDocHeader.emit(false);
                this.removeCanvasAttribute('customeMultipleAttribute');
              }
              this.getAnnotationForm();
            }
            else if (res["response_code"] == 202) {
              this.show = false;
              // remove undovaluesstore
              let remove_uuid_index_undo = this.documentService.createDocumentStore_values.undovaluesstore.findIndex((ids) => ids == getundo_uuid);
              if (remove_uuid_index_undo > -1) {
                this.documentService.createDocumentStore_values.undovaluesstore.splice(remove_uuid_index_undo, 1);
                this.createDocumentStore.undovaluesstore = this.documentService.createDocumentStore_values.undovaluesstore;
              }
              // remove redovaluesstore
              let remove_uuid_index_redo = this.documentService.createDocumentStore_values.redovaluesstore.findIndex((ids) => ids == getundo_uuid);
              if (remove_uuid_index_redo > -1) {
                this.documentService.createDocumentStore_values.redovaluesstore.splice(remove_uuid_index_redo, 1);
                this.createDocumentStore.redovaluesstore = this.documentService.createDocumentStore_values.redovaluesstore;
              }
            }
            else {
              this.errorMessage();
              // revert the stored ids
              console.log('undo', this.createDocumentStore.undovaluesstore);
              console.log('redo', this.documentService.createDocumentStore_values.redovaluesstore);
              this.createDocumentStore.undovaluesstore.push(getundo_uuid);
              this.documentService.createDocumentStore_values.redovaluesstore.pop();
            }
          },
            (error) => {
              this.errorMessage();
              // revert the stored ids
              console.log('undo', this.createDocumentStore.undovaluesstore);
              console.log('redo', this.documentService.createDocumentStore_values.redovaluesstore);
              this.createDocumentStore.undovaluesstore.push(getundo_uuid);
              this.documentService.createDocumentStore_values.redovaluesstore.pop();
            });
        }
      }

    });

    this.redoActionService = this.dataService2.redoAction.subscribe(async (ids: any) => {
      // this.annotationRedo();
      this.createDocumentStore.redovaluesstore = this.documentService.createDocumentStore_values.redovaluesstore;
      if (this.createDocumentStore.redovaluesstore.length > 0) {
        if (this.createDocumentStore.redovaluesstore.length > 10) {
          let total_redo_list = this.createDocumentStore.redovaluesstore;
          let last_10_values = total_redo_list.slice(-10);
          this.createDocumentStore.redovaluesstore = last_10_values;
          this.documentService.createDocumentStore_values.redovaluesstore = last_10_values;
        }
        this.show = true;
        let getredo_uuid = this.createDocumentStore.redovaluesstore.pop();
        this.documentService.createDocumentStore_values.undovaluesstore.push(getredo_uuid);
        // when forms data changes and normal sync uuid seperated condition added.
        if (typeof getredo_uuid == 'object') {
          // reassign the backup datas because of forms submit 
          let multiselect = false;
          if (getredo_uuid.hasOwnProperty('multiselectionlist')) {
            this.layerDatas = getredo_uuid.layer_data;
            // need to work svg
            this.multiselectionList = getredo_uuid.multiselectionlist;
            // draw side bar multiple_annotations when local changes happened in the multiselection list 
            await this.drawing_multiple_annotations();
            multiselect = true;
          }
          else {
            this.layerDatas = getredo_uuid.layer_data;
            this.getId = getredo_uuid.annotation_id;
            this.activeLayerIdDraw = getredo_uuid.annotation_id;
          }
     
          await this.formSubmit(multiselect, '');

          if (multiselect == false) {
            this.previousSelectAnnotation = [];

            this.createDocumentStore.single_select_annotation = [];
            if (this.getId != "" && this.getId != undefined) {
              this.getId = "";
              this.deselectAnnotation();
            }
          }
          else {
            this.multipleSelectOn = false;
            this.changeShapeEnable = false;
            for (let changestyle = 0; changestyle < this.multiselectionList.length; changestyle++) {
              let get_change_style_element = document.getElementById(this.multiselectionList[changestyle].annotation_id);
              if (get_change_style_element != null) {

                get_change_style_element.removeAttribute('multimoving');
                this.getMultipleMovingLabelElementRemove(this.multiselectionList[changestyle].annotation_id);
                this.transparentBorder(get_change_style_element);
              }
            }
            this.multiselectionList = [];
            // multiselection svg drawing empty place
            this.multiselectionList_svg_view = [];
            this.previousSelectAnnotation = [];

            this.createDocumentStore.single_select_annotation = [];
            this.createDocumentStore.selectedAnnotations = [];
            this.selectAnnotationZero();
            this.deselectAnnotation();
            this.copyAnnotationStart = false;
            // drag multiple annotation selection
            this.dataService.getannotationid.emit("");
            this.dataService.imageChangeDocHeader.emit(false);
            this.removeCanvasAttribute('customeMultipleAttribute');
          }
          this.getAnnotationForm();
        }
        else {
          this.documentService.getundodatafromdb(getredo_uuid, this.folderId, "redo").subscribe((res) => {
            if (res["response_code"] == 200) {
              if (this.multipleSelectOn == false) {
                this.previousSelectAnnotation = [];
                this.createDocumentStore.single_select_annotation = [];
                if (this.getId != "" && this.getId != undefined) {
                  this.getId = "";
                  this.deselectAnnotation();
                }
              }
              else {
                this.multipleSelectOn = false;
                this.changeShapeEnable = false;
                for (let changestyle = 0; changestyle < this.multiselectionList.length; changestyle++) {
                  let get_change_style_element = document.getElementById(this.multiselectionList[changestyle].annotation_id);
                  if (get_change_style_element != null) {

                    get_change_style_element.removeAttribute('multimoving');
                    this.getMultipleMovingLabelElementRemove(this.multiselectionList[changestyle].annotation_id);
                    this.transparentBorder(get_change_style_element);
                  }
                }
                this.multiselectionList = [];
                // multiselection svg drawing empty place
                this.multiselectionList_svg_view = [];
                this.previousSelectAnnotation = [];

                this.createDocumentStore.single_select_annotation = [];
                this.createDocumentStore.selectedAnnotations = [];
                this.selectAnnotationZero();
                this.deselectAnnotation();
                this.copyAnnotationStart = false;
                // drag multiple annotation selection
                this.dataService.getannotationid.emit("");
                this.dataService.imageChangeDocHeader.emit(false);
                this.removeCanvasAttribute('customeMultipleAttribute');
              }
              this.getAnnotationForm();
            }
            else if (res["response_code"] == 202) {
              this.show = false;
              // remove redovaluesstore
              let remove_uuid_index_redo = this.documentService.createDocumentStore_values.redovaluesstore.findIndex((ids) => ids == getredo_uuid);
              if (remove_uuid_index_redo > -1) {
                this.documentService.createDocumentStore_values.redovaluesstore.splice(remove_uuid_index_redo, 1);
                this.createDocumentStore.redovaluesstore = this.documentService.createDocumentStore_values.redovaluesstore;
              }
              // remove undovaluesstore
              let remove_uuid_index_undo = this.documentService.createDocumentStore_values.undovaluesstore.findIndex((ids) => ids == getredo_uuid);
              if (remove_uuid_index_undo > -1) {
                this.documentService.createDocumentStore_values.undovaluesstore.splice(remove_uuid_index_undo, 1);
                this.createDocumentStore.undovaluesstore = this.documentService.createDocumentStore_values.undovaluesstore;
              }
            }
            else {
              this.errorMessage();
              // revert the stored ids
              this.createDocumentStore.redovaluesstore.push(getredo_uuid);
              this.documentService.createDocumentStore_values.undovaluesstore.pop();

            }
          },
            (error) => {
              this.errorMessage();
              // revert the stored ids`
              this.createDocumentStore.redovaluesstore.push(getredo_uuid);
              this.documentService.createDocumentStore_values.undovaluesstore.pop();
            })
        }
      }
    });

    this.layerpageActive$ = this.dataService2.layeractiveEnable.subscribe(async (receiveCondition: boolean) => {
      await this.automatic_update_form();
      if (this.attribute_change == true) {
        await this.attribute_value_changes();
      }
      this.layerEnable = receiveCondition;
      console.log(this.layerEnable);
      this.cdRef.detectChanges();
      let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
      let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: this.checkedAnnotationIdsBackup, currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, initial_click: true, scaleFactor: this.scaleFactor };
      console.log(data);
      if (this.layerEnable == true) {
        this.show = true;
      }
      if (this.layerEnable == false) {
        this.dataService2.layerBoxCloseTrigger.emit();
      }
      this.dataService2.layerDatafromnavigation.emit(data);
      this.show = false;
    });


    this.useastoolbarUpdate$ = this.dataService2.useasToolbarlistUpdate.subscribe(() => {
      this.show = true;
      this.getId = "";
      this.previousSelectAnnotation = [];
      this.refreshToolbarList();
    });


    this.seticonheight$ = this.dataService1.set_base_icon_changes.subscribe(data => {
      this.checksetbaseiconINorNot();
    });
    this.previousRoute = this.routingState.getPreviousUrl();
    console.log(this.previousRoute);
    // if (this.showMultiSelectFooter == true) {
    //   this.useasToolbar = false;
    //   this.addshapeToolbar = false;
    //   this.addstampToolbar = false;
    // }
    this.renderer.setProperty(this.elementRef.nativeElement, 'draggable', true);
    this.renderer.addClass(this.elementRef.nativeElement, 'app-draggable');
    this.documentName = this.route.snapshot.queryParamMap.get("documentName");
    console.log(this.documentName);
    this.headerTitleService.setTitle(this.documentName);

    this.folderLevel = this.route.snapshot.queryParamMap.get("folderlevel");
    this.parentFolderId = this.route.snapshot.queryParamMap.get("pfolderid");
    this.getOpenLinkWindow = this.route.snapshot.queryParamMap.get("openLinkWindow");
    this.pageId = this.route.snapshot.queryParamMap.get("page_id");

    this.projectName = this.encrptdecrpt.getItem("projectName");
    this.su = this.encrptdecrpt.getItem("loggedIn") || "{}";
    this.isReadonly = this.encrptdecrpt.getItem("viewonlys");
    this.pageChange$ = this.dataService1.switchPagesendPageNumber.subscribe(async (data) => {
      var start1 = new Date().getTime();
      console.log('page function' + ' Start time: ' + start1);
      var startTime = performance.now();
      console.log('start time', startTime);
      // page change remainder popup disable
      this.previousRoute = "/index";
      await this.automatic_update_form();
      if (this.attribute_change == true) {
        await this.attribute_value_changes();
      }
      this.deselectAnnotation();
      console.log(this.layerDatas);
      //hide search tab when next / prev page clicked
      this.searchOption = false;
      // this.dataService2.closesearchfromdocument.emit(true);
      // this.Searchpage.disablesearchbutton();
      console.log('pdf', data);
      this.slideIndex = data - 1;
      this.currentPageNumber = data;
      this.scaleHorizontal = false;
      this.scaleVertical = false;
      // previous page annotation selection removed.
      this.previousSelectAnnotation = [];
      // svg annotation clear for previous page
      this.createDocumentStore.view_annotation_array = [];
      // remove annotation labels
      let getannotationLabelElement = document.querySelectorAll("p[annotationLabel]");
      if (getannotationLabelElement.length > 0) {
        for (var al = 0; al < getannotationLabelElement.length; al++) {
          getannotationLabelElement[al].remove();
        }
      }
      // selected annotation stored array should be empty
      this.createDocumentStore.single_select_annotation = [];
      this.arrSingleSelectionHistory = [];
      //shape drop down
      this.changeShapeEnable = false;
      // document last view page Storage function
      this.lastseendocument_storage('changing');
      if (this.pngFormat == true) {
        this.show = true;
        this.switchPageChangeAction();
      }
      else {
        this.show = true;
        this.switchPageChangeActionPdf();
      }
    });
    //stubdata

    this.stubdataService.getMessage().subscribe((Stubsenddata) => {
      this.Setprefix = Stubsenddata.setPrefix;
      this.SetNumber = Stubsenddata.setNumber;
      this.NoofStubs = Stubsenddata.NoOfStubs;
    });

    //getAnnotationForm Refresh
    this.createDocument$ = this.documentService.listen().subscribe((data) => {
      this.getAnnotationForm();
    });

    this.deleteAnnotation$ = this.dataService2.statusUpdated.subscribe((receiveLayerData: any) => {
      
      console.log(receiveLayerData.delete)
      console.log(this.deleteOptionClick);
      this.deleteOptionClick = false;
      this.deselectAnnotation();
      if (this.multipleSelectOn == true) {
        this.getAnnotationForm1(receiveLayerData.delete);
        this.dataService2.imageChangeDocHeader.emit();
      }
      else if (this.multipleSelectOn == false) {
        this.deleteAnnotationRemove(receiveLayerData.delete, receiveLayerData.id);

      }
      console.log(this.createJSON_grpAnnts);
      if (this.createJSON_grpAnnts != undefined) {
        let findCurGroupIndex = this.findGroupindex(receiveLayerData.id);
        if(findCurGroupIndex != -1){
          let MyDateString = new Date().toISOString();
          let getGroupAnnList = this.createJSON_grpAnnts.group_data[findCurGroupIndex].annotation_ids;
          let getGroupId = this.createJSON_grpAnnts.group_data[findCurGroupIndex].group_annotation_id;
          let cloneGrpAnnList = _.cloneDeep(getGroupAnnList);
          let filterlist = this.checkAnnIDfromDOM(cloneGrpAnnList,getGroupAnnList);
          
          // for(let i = 0;i < getGroupAnnList.length;i++){
          //   let id = document.getElementById(getGroupAnnList[i]);
          //   if(id == undefined){
          //     cloneGrpAnnList.splice(i,1)
          //   }
          // }
          let borderGroupIndex = this.createDocumentStore.view_annotation_array.findIndex(id => id.hasOwnProperty("grouping_border_id") && id.grouping_border_id == getGroupId);
          let pathBox = this.calcMinandMaxforGrpAnnts_getAnns(filterlist);
          console.log(pathBox);
          let getBorderBoxWidthandHeight: any = this.getAnnotationWidthandHeightAction(pathBox);
          console.log(getBorderBoxWidthandHeight);
          
          if(borderGroupIndex != -1){
            this.createDocumentStore.view_annotation_array[borderGroupIndex].annotation_data = pathBox;
            this.createDocumentStore.view_annotation_array[borderGroupIndex].width = getBorderBoxWidthandHeight.width;
            this.createDocumentStore.view_annotation_array[borderGroupIndex].height = getBorderBoxWidthandHeight.height;
            this.createDocumentStore.view_annotation_array[borderGroupIndex].left = getBorderBoxWidthandHeight.left;
            this.createDocumentStore.view_annotation_array[borderGroupIndex].top = getBorderBoxWidthandHeight.top;
          }
        }
      }
      // this.getAnnotationForm1(receiveLayerData);
    });
    //searchAnnotation Id get Area
    this.searchAnnotationId$ = this.dataService2.searchannotationId.subscribe((ids: any) => {
      this.searchannotationIdsBackup = ids;
      this.getSearchAnnotationId(ids);
    });
    //searchAnnotation Id get Area
    this.checkedAnnotationId$ = this.dataService2.checkedAnnotationId.subscribe((ids: any) => {
      if (ids != undefined && ids.hasOwnProperty('ids')) {
        let getIdOptions = ids;
        this.checkedAnnotationIdsBackup = getIdOptions.ids;
        this.getCheckedAnnotationId(getIdOptions);
      }

    });
    //document rename after recieve data;
    this.checkedAnnotationIdPage$ = this.dataService2.documentlistReceive.subscribe((receivePageData: any) => {
      this.pageRenameSetup(receivePageData);
    });
    //viewonlymodetrigger
    this.dataService2.viewOnlyModeTrigger.subscribe((isReadyOnly: any) => {
      this.isReadonly = isReadyOnly;
      if(this.isReadonly == false){
         this.multiclickdisabled = false;
      }
    });
    //Rapid mode trigger
    this.dataService2.rapidModeTrigger.subscribe((isRapidmode: any) => {
      this.isRapidmode = isRapidmode;
      if(this.isRapidmode == true){
        if(this.toolbar_name != "Copy mode Enabled"){
          this.sub = this.toolbar_name;
        }
        this.toolbar_name = "Rapid Shot Mode Enabled";
      }
      else if(this.isRapidmode == false){
        this.toolbar_name = this.sub;
      }
    });
    //Grouping Annotations trigger
    this.groupAnntsEnbled$ = this.dataService2.groupingAnntsTrigger.subscribe((data: any) => {
      if(data == true){
        this.deselectAnnotation();
      }
      if(this.multipleSelectOn != true && data == true){
        this.dataService2.multiSelectFooter.emit(true);
      }
      this.grpAnntsEnbled = data;
    })
    //removeForm 
    this.dataService2.removeForm.subscribe(async (data) => {
      // need to work svg
      this.multiselectionList = data;
      // draw side bar multiple_annotations when local changes happened in the multiselection list 
      await this.drawing_multiple_annotations();
    });
    //mediatags Refresh
    this.mediaTags$ = this.dataService2.mediaTagsUpdate.subscribe(
      async (layerData: any) => {

        this.layerDatas = layerData.layer_data;
        console.log(this.layerDatas);

        // this.multiselectionList_svg_view=this.layerDatas;
        this.createDocumentStore.undovaluesstore = this.documentService.createDocumentStore_values.undovaluesstore;
        //When deleting the stub image the annotations are erased and redrawn.So removed the below line.
        // this.getActiveLayerId();
        if (this.media == true) {
          // this.dataService1.getmediaCount().subscribe((count) => {
          //   this.mediaCount = count;
          // });
          this.getMediaStubList();
        }

        // multiselection svg drawing 
        let ids = layerData.ids;
        if (this.multipleSelectOn == true && ids != -1) {
          let annotationId = ids.annotation_id;
          let stubId = ids.stub_id;


          console.log(layerData.index, 1, layerData.ids)

          console.log(this.multiselectionList_svg_view, layerData.ids)
          for (let i = 0; i < this.multiselectionList_svg_view.length; i++) {

            if (this.multiselectionList_svg_view[i].annotation_id == layerData.ids.annotation_id) {
              if (this.multiselectionList_svg_view[i].annotation_links.length != 0) {
                for (let j = 0; j < this.multiselectionList_svg_view[i].annotation_links.length; j++) {

                  if (this.multiselectionList_svg_view[i].annotation_links[j].annotation_link_id == layerData.ids.annotation_links[0].annotation_link_id) {

                    this.multiselectionList_svg_view[i].annotation_links[j].link_type = layerData.ids.annotation_links[0].link_type
                    console.log('DDDD')
                  }
                  else {
                    console.log('noo')
                  }
                }

              }

            } else {
              console.log('DDDsss')
            }
          }
          // var ms=this.multiselectionList_svg_view.splice(layerData.index,1,layerData.curren_data[0],this.layerDatas)
          // await this.replacecurrentChangeInSVG(this.multiselectionList_svg_view[layerData.index], true);
          console.log(layerData, this.multiselectionList_svg_view)
          if (this.multiselectionList_svg_view.length != undefined) {
            let filter_svg_view_index = this.multiselectionList_svg_view.findIndex((svg_view_media) => svg_view_media.annotation_id == annotationId);
            let annotationvalue=_.cloneDeep(this.multiselectionList_svg_view);
            if (filter_svg_view_index > -1) {
              let get_media_list = this.multiselectionList_svg_view[filter_svg_view_index].annotation_media;
              let filter_media_index = get_media_list.findIndex((media_level) => media_level.stub_id == stubId);
              if (filter_media_index > -1) {
                this.multiselectionList_svg_view[filter_svg_view_index].annotation_media.splice(filter_media_index, 1);
                annotationvalue[filter_svg_view_index].annotation_media=_.cloneDeep(this.multiselectionList_svg_view[filter_svg_view_index].annotation_media);
                annotationvalue[filter_svg_view_index].annotation_media=annotationvalue[filter_svg_view_index].annotation_media.filter((data) => this.createDocumentStore.data_allow_condition.includes(data.is_removed))
                console.log(annotationvalue[filter_svg_view_index].annotation_media);
              }
            }
          }
        }
      });

    //layer page every actions receive this place data
    // layer page update new code after 05.03.2021
    this.layerPageUpdateAllData$ = this.dataService2.layerPageAllUpdateReceive.subscribe(async (getTypeofData: any) => {
      // this.deselectAnnotation();
      // already selected annotation deselect in the toolbar element place
      this.receiveString = "";
      this.previousRoute = "/index";
      this.toolbarBg = -1;
      this.drawFunctionActive = false;
      this.getPositionActive = false;
      this.shapeStringInorNot = false;
      this.getPositionString = "";
      this.stringPathArray = [];
      this.getPositionSetMove = 1;
      this.toolbarSet = false;
      if (this.rotateandresize == false) {
        if (getTypeofData.type == 'lockupdate') {
          this.layerDatas = getTypeofData.structureData;
          let get_response = await this.getActiveLayerId();
          this.loaderStop_after_response(get_response);
        }
        else if (getTypeofData.type == 'visibleupdate') {
          this.show = true;
          let get_response = await this.getAnnotationForm();
          this.loaderStop_after_response(get_response);

        }
        else if (getTypeofData.type == 'activeupdate') {
          // this.getDocumentDetails(); need to change document_load function
          // this.document_load();
          // once active layer_id change need to do 
          //1.document_details update, 2. activelayeriddraw key update
          this.activeLayerIdDraw = getTypeofData.active_layer_id;
          let find_current_document_page = this.documentDetails.findIndex((data_page) => data_page.page_id == this.currentPageId);
          if (find_current_document_page > -1) {
            this.documentDetails[find_current_document_page].active_layer_id = getTypeofData.active_layer_id;
          }
          this.checkCurrentActiveLayerProperties();
        }
      }

    });


    // layer page update old code before 05.03.2021
    this.layerPageUpdateData$ = this.dataService2.layerPageUpdateData.subscribe(
      (layerData: any) => {
        this.layerDatas = layerData;
        this.previousRoute = "/index";
        console.log(this.layerDatas);
        this.layerDatas = this.layerDatas.filter((list) => {
          let layerCurrentPageData = list.associated_pages.filter((ele => ele.page_id == this.currentPageId));
          if (layerCurrentPageData.length > 0) {
            if (layerCurrentPageData[0].hasOwnProperty("is_removed") && layerCurrentPageData[0].hasOwnProperty("is_hidden") && layerCurrentPageData[0].is_removed == false && layerCurrentPageData[0].is_hidden == false) {
              return true;
            }
            else if(!layerCurrentPageData[0].hasOwnProperty("is_hidden")){
              if(layerCurrentPageData[0].is_removed == true){
                return false;
              }
              else{
                return true;
              }
            }
            else if (!layerCurrentPageData[0].hasOwnProperty("is_removed") || !layerCurrentPageData[0].hasOwnProperty("is_hidden")) {
              if (list.is_removed == "true" || list.is_removed == true || list.is_removed == "1") {
                return false;
              }
              else {
                return true;
              }
            }

          }
          else { //current page is not in associated pages
            return false;
          }
        });
        this.getActiveLayerId();
        // this.checkLayerPagesBasedShowData();
      }
    );


    this.layerDataget$ = this.dataService2.navgiationgetData.subscribe((string: any) => {
      this.dataService2.navgiationSendData.emit(this.layerDatas);
    });
    this.filterdata$ = this.dataService2.filterOptions.subscribe((response) => {
      this.toolbarFilter = response;
      this.toolbarFilterMethod();
    });
    this.rotateResize$ = this.dataService2.rotateandResize.subscribe((status: string) => {
      this.rotateandresize = true;
      this.dataService1.changeRotateandResizeMessage(this.rotateandresize);
      this.createDocumentStore.repointAccessValid = true;
      this.currentSelectedCanvas(this.propertiesannotationData,undefined);
      if (this.getId) {
        this.backup_annot_storage(this.propertiesannotationData); // already annotation selection we should store that too
      }
      // let getSelectedElement = document.getElementById(this.propertiesannotationData["annotation_id"]);
      // this.colorBorder(getSelectedElement);
      this.repointvalidcheck();
    });

    this.alignAnnotations$ = this.dataService2.annotationAlignment.subscribe((status: any) => {
      if (status.type == 'start') {
        this.alignAnnEnabled = true;
        this.alignAnnBaseAnn = status.annotationData;
        console.log(this.propertiesannotationData);
        let get_current_element = document.getElementById(this.getId);
        if (get_current_element != null) {
          this.colorBorderSVG_align(get_current_element);
        }
      }
    });

    this.linkedpageDataSubscribe = this.dataService2.getIdUpdated.subscribe(async (layerData: any) => {
      if (this.multipleSelectOn == false) {
        this.layerDatas = layerData;
        // project list refresh
        this.show = true;
        let get_response = await this.getProjectfolderlist(true);
        this.loaderStop_after_response(get_response);
      }
      else {
        if(layerData.layervalue!=undefined && layerData.multiplelist!=undefined){
          this.layerDatas = layerData.layervalue;
          // need to work svg
          this.multiselectionList = layerData.multiplelist;
        }
        // The below lines are commented and above if condition is added for ticket no 2399
        // this.layerDatas = layerData.layervalue;
        // need to work svg
        // this.multiselectionList = layerData.multiplelist;
        this.show = true;
        let get_folder_response = await this.getProjectfolderlist(true);
        if (get_folder_response == 200) {
          // draw side bar multiple_annotations when local changes happened in the multiselection list 
          await this.drawing_multiple_annotations();
          // this.annotationlinkGet("");
          this.loaderStop_after_response(get_folder_response);
        }
      }

    });
    // single annotation
    this.removeGroupAnntsSingle$ = this.dataService2.removeGroupSingle.subscribe((response) => {
      let findCurGroupIndex = this.findGroupindex(this.getId);
      let MyDateString = new Date().toISOString();
      let getGroupAnnList = this.createJSON_grpAnnts.group_data[findCurGroupIndex].annotation_ids;
      let getGroupId = this.createJSON_grpAnnts.group_data[findCurGroupIndex].group_annotation_id;
      console.log(this.layerDatas);
      let borderGroupIndex = this.createDocumentStore.view_annotation_array.findIndex(id => id.hasOwnProperty("grouping_border_id") && id.grouping_border_id == getGroupId);
      let filter_annId = this.createJSON_grpAnnts.group_data[findCurGroupIndex].annotation_ids.findIndex(id => id == this.getId);
      var annotationIds;
      if(filter_annId != -1){
        this.createJSON_grpAnnts.group_data[findCurGroupIndex].annotation_ids.splice(filter_annId,1)
        annotationIds = this.createJSON_grpAnnts.group_data[findCurGroupIndex].annotation_ids;
        this.createJSON_grpAnnts.group_data[findCurGroupIndex].last_updated_date = MyDateString;
      }
      let filter_color = this.createJSON_grpAnnts.group_data[findCurGroupIndex].color_details.filter(id => id.annotation_id == this.getId);
      if(filter_color.length > 0){
        filter_color[0].is_removed = true;
        filter_color[0].last_updated_date = MyDateString;
      }
        let filterAnn = this.layerDatas[0].annotations.filter(id => id.annotation_id == this.getId);
        if(filterAnn.length > 0){
          let fillColor = filterAnn[0].fill_color;
          let strokeColor = filterAnn[0].stroke_color;
          let opacity = filterAnn[0].opacity;
          console.log(filterAnn);
          let currAnn = this.createDocumentStore.view_annotation_array.filter(item => item.annotation_id == this.getId);
          if(currAnn.length > 0){
            let get_strokecolor = this.checkStrokeColor1(fillColor);
            currAnn[0].stroke_color = get_strokecolor;
            let get_fillcolor = this.checkStrokeColor1(strokeColor);
            currAnn[0].fill_color = get_fillcolor;
            currAnn[0].opacity = opacity;
          }
        }
        let cloneGrpAnnList = _.cloneDeep(annotationIds)
        let filterlist = this.checkAnnIDfromDOM(cloneGrpAnnList, annotationIds);
        let pathBox = this.calcMinandMaxforGrpAnnts_getAnns(filterlist);
        console.log(pathBox);
        let getBorderBoxWidthandHeight: any = this.getAnnotationWidthandHeightAction(pathBox);
        if(borderGroupIndex != -1){
          this.createDocumentStore.view_annotation_array[borderGroupIndex].annotation_data = pathBox;
          this.createDocumentStore.view_annotation_array[borderGroupIndex].width = getBorderBoxWidthandHeight.width;
          this.createDocumentStore.view_annotation_array[borderGroupIndex].height = getBorderBoxWidthandHeight.height;
          this.createDocumentStore.view_annotation_array[borderGroupIndex].left = getBorderBoxWidthandHeight.left;
          this.createDocumentStore.view_annotation_array[borderGroupIndex].top = getBorderBoxWidthandHeight.top;
        }
      const ids = {
        proj_id: this.projectId,
        folder_id: this.folderId,
        user_id: this.su.user_id,
        group_id: getGroupId
      }
      this.documentService.updatingGroupAnntsService(ids, this.createJSON_grpAnnts).subscribe((response) => {
        console.log(response);
        this.dataService2.multiSelectFooter.emit(false);
        this.dataService.groupingAnntsTrigger.emit(false);
      })
    })
    // whole group
    this.removeGroupAnnts$ = this.dataService2.removeGroup.subscribe((response) => {
      console.log(response);
      let findCurGroupIndex = this.findGroupindex1(response);
      let MyDateString = new Date().toISOString();
      let getGroupAnnList = this.createJSON_grpAnnts.group_data[findCurGroupIndex].annotation_ids;
      let getGroupId = this.createJSON_grpAnnts.group_data[findCurGroupIndex].group_annotation_id;
      this.createJSON_grpAnnts.group_data[findCurGroupIndex].is_removed = true;
      this.createJSON_grpAnnts.group_data[findCurGroupIndex].last_updated_date = MyDateString;
      let borderGroupIndex = this.createDocumentStore.view_annotation_array.findIndex(id => id.hasOwnProperty("grouping_border_id") && id.grouping_border_id == getGroupId);
      this.createDocumentStore.view_annotation_array.splice(borderGroupIndex,1);
      console.log(this.layerDatas);
      getGroupAnnList.forEach(data => {
        let filterAnn = this.layerDatas[0].annotations.filter(id => id.annotation_id == data);
        if(filterAnn.length > 0){
          let fillColor = filterAnn[0].fill_color;
          let strokeColor = filterAnn[0].stroke_color;
          let opacity = filterAnn[0].opacity;
          console.log(filterAnn);
          let currAnn = this.createDocumentStore.view_annotation_array.filter(item => item.annotation_id == data);
          if(currAnn.length > 0){
            let get_strokecolor = this.checkStrokeColor1(strokeColor);
            currAnn[0].stroke_color = get_strokecolor;
            let get_fillcolor = this.checkStrokeColor1(fillColor);
            currAnn[0].fill_color = get_fillcolor;
            currAnn[0].opacity = opacity;
          }
        }
      })
      const ids = {
        proj_id: this.projectId,
        folder_id: this.folderId,
        user_id: this.su.user_id,
        group_id: getGroupId
      }
      this.documentService.updatingGroupAnntsService(ids,this.createJSON_grpAnnts).subscribe((response) => {
        console.log(response);
        this.dataService.groupingAnntsTrigger.emit(false);
        this.dataService2.multiSelectFooter.emit(false);
      })
    })

    

    this.setScaleTriggerSubscribe = this.dataService2.setScaleTrigger.subscribe(
      (status: any) => {

        if (status == true) {
          this.setScaleMethod();
        }
      }
    );

    this.dataService2.setIconBaseSize.subscribe((status: any) => {
      this.checkIconSizeandPages();
    });
    this.copyannotation_single$ = this.dataService2.copyAnnotationSingle.subscribe(async (status: any) => {
      console.log(this.copyMultiAnn)
      this.copytoolhead = true;
      this.toolcopyname('copy');
      this.copyMode = status;
      // this.useCaseEmptycellIds = []
      this.copyAnnotationDatas = [];
      this.copyAnnotation_svg_view = [];
      console.log(this.propertiesannotationData);
      this.currentAnnotationName = this.propertiesannotationData.annotation_name;
      let copy_ann = _.cloneDeep(this.currentSelectedAnnotationData);
      copy_ann.annotation_media = [];
      this.copyAnnotationDatas.push(copy_ann);
      // empty current annotation selection set to false data after take copy
      this.annotationSelected = false;
      this.copyAnnotationCreatePage();
      // convert SVG method view UI
      let svg_changes = await this.annotation_view_svg(copy_ann);
      //line shapes I have assigned extra 
      let lines = [13, 14, 15, 16];
      if (lines.includes(Number(svg_changes.toolbar_element_id))) {
        svg_changes.linewidth = svg_changes.linewidth * 2;
      }
      // check resize shapes line width increase simple shapes only
      svg_changes = linewidthchanges(svg_changes);
      this.copyAnnotation_svg_view.push(svg_changes);
    });
    this.copyannotation_multiple$ = this.dataService2.copyAnnotation.subscribe(async (status: any) => {
      console.log(status);
      this.copyMode = status;
      this.copyAnnotationDatas = [];
      this.copyAnnotation_svg_view = [];
      this.multiselectionList.forEach((data) => {
        data.annotation_media = []
      })
      this.copyAnnotationDatas = this.multiselectionList;
      this.toolcopyname('copy');
      console.log(this.multiselectionList);
      this.copyAnnotationCreatePage();
      // convert SVG method view UI
      for (let s = 0; s < this.copyAnnotationDatas.length; s++) {
        let svg_changes = await this.annotation_view_svg(this.copyAnnotationDatas[s]);
        //line shapes I have assigned extra 
        let lines = [13, 14, 15, 16];
        if (lines.includes(Number(svg_changes.toolbar_element_id))) {
          svg_changes.linewidth = svg_changes.linewidth * 2;
        }
        // check resize shapes line width increase simple shapes only
        svg_changes = linewidthchanges(svg_changes);
        this.copyAnnotation_svg_view.push(svg_changes);
      }
      this.dataService2.imageChangeDocHeader.emit();
      this.getCurrentCopyData(this.propertiesannotationData,0);
    });
    this.copyannotation_multiple_option$ = this.dataService2.copyAnnotationMultiple.subscribe(async (status: any) => {
      if (status == "withData") {
        console.log(status);
        this.copymultiannenabled = true
        // this.copyMode = status;
        this.copyAnnotationDatas = [];
        this.copyAnnotation_svg_view = [];
        this.multiselectionList.forEach((data) => {
          data.annotation_media = []
        })
        this.copyAnnotationDatas = this.multiselectionList;
        // this.selectedAnnotationLength = this.multiselectionList.length;
        this.toolcopyname('copy');
        console.log(this.multiselectionList);
        this.copyMultiselectionList = _.cloneDeep(this.multiselectionList)
        this.calcPosforCpyMultiAnn(this.multiselectionList);
        // this.copyAnnotationCreatePage();
        // convert SVG method view UI
        for (let s = 0; s < this.copyAnnotationDatas.length; s++) {
          this.copyMultiAnn = true;
          let svg_changes = await this.annotation_view_svg(this.copyAnnotationDatas[s]);
          //line shapes I have assigned extra 
          let lines = [13, 14, 15, 16];
          if (lines.includes(Number(svg_changes.toolbar_element_id))) {
            svg_changes.linewidth = svg_changes.linewidth * 2;
          }
          // check resize shapes line width increase simple shapes only
          svg_changes = linewidthchanges(svg_changes);
          // this.copyAnnotation_svg_view.push(svg_changes);
        }
        this.dataService2.imageChangeDocHeader.emit();
        this.getCurrentCopyData(this.propertiesannotationData, 0);
        this.displayCopyMultiMessage("enabled");
      }
    });
    this.moveAccess$ = this.dataService2.moveAccess.subscribe(async (status: boolean) => {
      //modify here;
      this.moveElementValue = status;
      await this.automatic_update_form();
      if (this.attribute_change == true) {
        await this.attribute_value_changes();
      }
      console.log(this.moveElementValue);
      if (this.moveElementValue == true) {
        this.cloneLayerDataBeforeMoving = _.cloneDeep(this.layerDatas);
        this.panZoomController.pause();
        // this.all
        this.toolcopyname('move');
        if (this.multipleSelectOn == false) {
          if (this.getId) {
            this.backup_annot_storage(this.propertiesannotationData); // already annotation selection we should store that too
          }
          this.captureEventsMoveSingle();
        }
        else {
          this.captureEventsMove();
        }
      }
      else {
        this.toolcopyname('remove');
        this.cancelMoveElements();
        // this.removeMoveEvents();
      }

    });
    this.copydataclose$ = this.dataService2.copydatadialogclose.subscribe((data) => {
      console.log(data);

      this.closeCopyFooter();
    });

    this.createDocumentStore.multiselection_$ = this.dataService2.multiSelectFooter.subscribe(async (status: boolean) => {
      console.log(status);
      // this.showMultiSelectFooter = status;
      await this.automatic_update_form();
      if (this.attribute_change == true) {
        await this.attribute_value_changes();
      }
      this.multipleSelectOn = status;
      this.addshapeToolbar = false;
      this.selectedAnnotationLength = this.multiselectionList.length;
      if (this.drawFreehandMenu == false && this.drawShapeDonePolylineArrow == false
        && this.drawShapeDonePolygon == false && this.drawShapeDoneLineAxial == false && this.drawShapeDonePolyline == false
        && this.drawRectangleDone == false && this.drawEllipseDone == false && this.drawShapeDoneLine == false) {

        if (this.multipleSelectOn == true) {
        
          this.multiselectionList = [];
          // multiselection svg drawing empty place
          this.multiselectionList_svg_view = [];
          this.previousSelectAnnotation = [];
          if (this.annotationSelected == true) {
          

            
            this.multiselectionList.push(this.currentSelectedAnnotationData);
            this.createDocumentStore.selectedAnnotations.push(this.currentSelectedAnnotationData.annotation_id);
            let alraedy_selected_name = document.getElementById(this.currentSelectedAnnotationData.annotation_id);
            if (alraedy_selected_name != null) {
              alraedy_selected_name.setAttribute('multimoving', "1");
            }
            this.multipleAnnotationCall(this.currentSelectedAnnotationData);
          }
          this.panZoomController.pause();
          console.log('multiple selected');
          if (this.moveElementValue == true) {
            if (this.multiselectionList.length > 0) {
              let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
              getElement.setAttribute('multimoving', "1");
              if (this.multiselectionList[0].annotation_label != "") {
                this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
              }
              this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
              let tempArray = this.createDocumentStore.selectedAnnotations;
              this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
                return index === self.indexOf(elem);
              })
              this.multipleAnnotationCallAPI();
            }
            this.captureEventsMove();
          }
          else {
            this.captureEventsMultiple();
          }
        }
        else if (this.copyAnnotationCreatePageValue == false || status == false) {
          //shape drop down
          this.changeShapeEnable = false;
          for (let changestyle = 0; changestyle < this.multiselectionList.length; changestyle++) {
            let get_change_style_element = document.getElementById(this.multiselectionList[changestyle].annotation_id);
            if (get_change_style_element != null) {
              get_change_style_element.removeAttribute('multimoving');
              this.getMultipleMovingLabelElementRemove(this.multiselectionList[changestyle].annotation_id)

              this.transparentBorderSVG(get_change_style_element);
            }
          }
          this.multiselectionList = [];
          this.useCaseEmptycellIds = []
          // multiselection svg drawing empty place
          this.multiselectionList_svg_view = [];
          this.previousSelectAnnotation = [];
          this.createDocumentStore.single_select_annotation = [];
          this.createDocumentStore.selectedAnnotations = [];
          this.selectAnnotationZero();
          this.deselectAnnotation();
          this.copyAnnotationStart = false;
          // drag multiple annotation selection
          this.dataService.getannotationid.emit("");
          console.log(this.createDocumentStore.selectedAnnotations)
          this.removeCanvasAttribute('customeMultipleAttribute');
          if (this.moveElementValue == true) {
            let getSetMoveElements = document.querySelectorAll('canvas[multimoving]');
            if (getSetMoveElements.length > 0) {
              for (let rMove = 0; rMove < getSetMoveElements.length; rMove++) {

                getSetMoveElements[rMove].removeAttribute("multimoving");
              }
            }
            this.removeCanvasAttribute("customeMoveAttribute");
            this.currentSelectedAnnotationData = {};
            this.captureEventsMoveSingle();
          }
          console.log('trigger border remove');
        }
      }
      else if (this.copyAnnotationCreatePageValue == false || status == false) {
        this.changeShapeEnable = false;
        for (let changestyle = 0; changestyle < this.multiselectionList.length; changestyle++) {
          let get_change_style_element = document.getElementById(this.multiselectionList[changestyle].annotation_id);
          if (get_change_style_element != null) {
            get_change_style_element.removeAttribute('multimoving');
            this.getMultipleMovingLabelElementRemove(this.multiselectionList[changestyle].annotation_id)

            this.transparentBorderSVG(get_change_style_element);
          }
        }
        this.multiselectionList = [];
        // multiselection svg drawing empty place
        this.multiselectionList_svg_view = [];
        this.previousSelectAnnotation = [];
        this.createDocumentStore.single_select_annotation = [];
        this.createDocumentStore.selectedAnnotations = [];
        this.selectAnnotationZero();
        this.deselectAnnotation();
        this.copyAnnotationStart = false;
        // drag multiple annotation selection
        this.dataService.getannotationid.emit("");
        console.log(this.createDocumentStore.selectedAnnotations)
        this.removeCanvasAttribute('customeMultipleAttribute');
      }
    });
    this.dataService2.editAnnotation.subscribe((selectAnnotations: any) => {
      // this.showMultiSelectFooter = false;

      this.annotationSelected = true;
      if (this.multiselectionList.length > 0) {
        this.multipleSelectOn = true;
        this.multipleSelectOnTags = true;
        this.selectedAnnotationLength = this.multiselectionList.length;

        this.getCounts();
      } else {
        this.multipleSelectOn = false;
      }
      if (this.multipleSelectOn == false) {
        this.propertiesannotationData = selectAnnotations;
        this.annotNameAnnotation = selectAnnotations.annotation_name;
        this.propertiesannotationDataString = selectAnnotations.annotation_data;
        this.annotLabelAnnotation = selectAnnotations.annotation_label;
        this.annotShapeAnnotation = selectAnnotations.annotation_name;
        this.formsheaderCanvas("headerCanvasForms", selectAnnotations, 'annotationLabelForms');
      }
    });
    this.dataService.currentMessage.subscribe((message) => {
      this.labelView = message;
    });

    this.pageSync$ = this.dataService.synActionNew.subscribe(async (state1) => {
      this.synAction = state1;
      this.previousRoute = "/index";
      this.show = true;
      await this.automatic_update_form_sync('sync');
      if (this.attribute_change == true) {
        await this.attribute_value_changes();
      }
      //Removed the below two lines for set scale blinking on every sync
      // this.scaleHorizontal = false;
      // this.scaleVertical = false;
      // remove svg annotations when sync is loading
      // this.createDocumentStore.view_annotation_array = [];
      this.previousSelectAnnotation = [];
      this.createDocumentStore.single_select_annotation = [];

      // Undo and Redo values cleared when syncing start
      this.documentService.createDocumentStore_values.undovaluesstore = [];
      this.documentService.createDocumentStore_values.redovaluesstore = [];
      this.createDocumentStore.undovaluesstore = [];
      this.createDocumentStore.redovaluesstore = [];
      // Undo and Redo values cleared when syncing end

      if (this.getId != "" && this.getId != undefined) {
        this.getId = "";
        this.deselectAnnotation();
      }
      this.toolbarBg = -1;
      // refresh toolbar list
      
      this.refreshToolbarListSync();
      this.encrptdecrpt.setItem("rapidmodes",false);
      this.isRapidmode = false;
      this.toolbarSet = false;
      if(this.copymultiannenabled == true){
        this.toolbarSet = true;
        this.toolbar_name = "Copy mode Enabled";
        this.closeCopyFooter();
      }
      this.rapidmodeData = {}
      // if (this.pngFormat == false) {
      //   this.oldScaleValue = this.scaleValue;
      //   // await this.pdfPanzoomSync(1);
      //   this.getAnnotationForm();
      // }
      // else {
      //   this.getAnnotationForm();
      // }
      // if(this.copymultiannenabled == true){
      //   this.closeCopyFooter();
      // }
      if(this.alignAnnEnabled == true){
        this.closeAlignAnn();
      }
    });
    this.eventsService.on("labelView", (a) => {
      this.labelView = a;
    });

    //Add Image to Stub
    this.messageService.getMessage().subscribe((message) => {
      var stubid = message.stubIdData;
      let layers = [];
      console.log(this.layerDatas);
      if (this.layerDatas != undefined && this.layerDatas.length != 0) {
        for (var i = 0; i < this.layerDatas.length; i++) {
          var currentAnnotationData = this.layerDatas[i].annotations.filter(ele => ele.annotation_id == this.getId)
          if(currentAnnotationData.length>0){
            this.udoArrayChange(_.cloneDeep(currentAnnotationData[0]))
            let StubData = currentAnnotationData[0].annotation_media.filter(item => item.stub_id == message.stubIdData);
            if (StubData.length > 0) {
              StubData[0].media_url = message.url;
              StubData[0].is_changed = true;
              StubData[0].media_name = message.filepath;
              // StubData[0].created_date = new Date().toISOString();
              StubData[0].last_updated_date = new Date().toISOString();
              StubData[0].annotation_id = this.getId;
              StubData[0].is_changed = true;
            }
          }
          layers.push(this.layerDatas[i]);
        }
        // multiselection svg view array should be update
        let filter_svg_view_index = this.multiselectionList_svg_view.findIndex((svg_view_media) => svg_view_media.annotation_id == this.getId);
        if (filter_svg_view_index > -1) {
          let get_media_list = this.multiselectionList_svg_view[filter_svg_view_index].annotation_media;
          let filter_media_index = get_media_list.findIndex((media_level) => media_level.stub_id == message.stubIdData);
          if (filter_media_index > -1) {
            this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].media_url = message.url;
            this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].is_changed = true;
            this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].media_name = message.filepath;
            this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].created_date = new Date().toISOString();
            this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].last_updated_date = new Date().toISOString();
            this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].annotation_id = this.getId;
            this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].is_changed = true;
          }
        }
        let generateCloneLayer = _.cloneDeep(this.layerDatas);
        this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw).subscribe((response) => {
      
          console.log(response)
          if (response["response_code"] == 200) {
            this.show = false;
          }
          else {
            this.errorMessage();
          }
        });
      }
    });
    //rename media
    this.renameMediaSubscribe = this.dataService.getMessageMedia().subscribe((data) => {
      console.log(data);

      this.show = true;
      if (this.layerDatas != undefined) {
        for (var i = 0; i < this.layerDatas.length; i++) {
          var currentAnnotationData = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == data.annotation_id))
          if (currentAnnotationData.length > 0) {
            this.udoArrayChange(_.cloneDeep(currentAnnotationData[0]))
            let StubData = currentAnnotationData[0].annotation_media.filter(item => item.stub_id == data.stubId);
            if (StubData.length > 0) {
              StubData[0].media_name = data.filename;
              StubData[0].is_changed = true;
              StubData[0].last_updated_date = new Date().toISOString();
            }
          }
        }
        let generateCloneLayer = _.cloneDeep(this.layerDatas);
        this.documentService.annotationUpdateForm1(generateCloneLayer, data.annotation_id, this.activeLayerIdDraw,'media').subscribe((response) => {
          console.log(response);
          if (response["response_code"] == 200) {
            this.show = false;
          }
          else {
            this.errorMessage();
          }
        });
      }
      // multiselection svg view array should be update
      let filter_svg_view_index = this.multiselectionList_svg_view.findIndex((svg_view_media) => svg_view_media.annotation_id == data.annotation_id);
      if (filter_svg_view_index > -1) {
        let get_media_list = this.multiselectionList_svg_view[filter_svg_view_index].annotation_media;
        let filter_media_index = get_media_list.findIndex((media_level) => media_level.stub_id == data.stubId);
        if (filter_media_index > -1) {
          this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].media_name = data.filename;
          this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].is_changed = true;
          this.multiselectionList_svg_view[filter_svg_view_index].annotation_media[filter_media_index].last_updated_date = new Date().toISOString();
        }
      }
    });
    //delete media
    this.deleteMediaSubscribe = this.dataService.getMessage().subscribe((data) => {
      this.udoArrayChange(_.cloneDeep(data))
      // console.log(data);
      // var stubid = data;
      // console.log(stubid);
      // let layers = [];
      // if (this.layerDatas != undefined) {
      //   for (var i = 0; i < this.layerDatas.length; i++) {
      //     var currentAnnotationData = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
      //     this.udoArrayChange(_.cloneDeep(currentAnnotationData[0]))
      //     let StubData = currentAnnotationData[0].annotation_media.filter(item => item.stub_id == stubid);
      //     if (StubData.length > 0) {
      //       StubData[0].is_removed = true;
      //     }
      //     layers.push(this.layerDatas[i]);
      //   }
      //   this.layerDatas = layers;
      //   let generateCloneLayer = _.cloneDeep(this.layerDatas);
      //   this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw).subscribe((response) => {
      //     if (response["response_code"] == 200) {
      //       this.show = false;
      //     }
      //     else {
      //       this.errorMessage();
      //     }
      //   });
      // }
    });
    //Add mediaTags
    this.tagsMediaSubscribe = this.dataService.getMediaTagsMessage().subscribe((data) => {
      this.udoArrayChange(_.cloneDeep(data))
    });
    //Link to Document subscription included excat copy,copy, and url
    this.linkedPageSubscribe = this.dataService.getLinkedPageData().subscribe((data) => {
      this.udoArrayChange(_.cloneDeep(data))
    });

    //copy annotations
    this.readonlydataService.getMessage().subscribe((message) => {
      console.log(message);
      this.copyannotation = message.copy;
      console.log(message.layerdata);
      this.copyAnnotationShapes(message.layerdata);
      this.copyannotation = message;
      this.addshapeToolbar = false;
    });
    // add to toolbar- shape
    this.readonlydataService.getAnnotationMessage().subscribe((message) => {
      if (message.addtoolbar == true) {
        this.addshapeToolbar = message.addtoolbar;
        console.log(this.addshapeToolbar);
        // this.addShaprToToolbar("addshapeToolbars",message.addlayerdata);
      }
      else if (message.addtoolbar == false) {
        this.addshapeToolbar = message.addtoolbar;
      }
    });
    // add to toolbar- stamp
    this.readonlydataService.getStampMessage().subscribe((message) => {
      this.addstampToolbar = message.addstamptoolbar;
      console.log(this.addshapeToolbar);
      // if (this.addstampToolbar == true) {
      //   this.addShaprToToolbar("stamp",message.addlayerdata);
      // }
    });
    
    this.addToolbarShapes$ = this.dataService.toolbarDataShapes.subscribe((toolbarData) => {
     
       
     
      console.log(toolbarData);
      this.updateNewToolbarData = toolbarData;
      this.getId = "";
      this.transparentBorderSVGSelected();
      this.previousSelectAnnotation = [];
      for (let i = 0; i < toolbarData.length; i++) {
        console.log(toolbarData[i].toolbarId, this.toolbar_id);
        if (toolbarData[i].toolbar_id == this.toolbar_id) {
          toolbarData[i].convertJsonList = this.dataService4.changeSpecialtokeyformatList(toolbarData[i].convertJsonList, 'toolbarbuilder');
          this.modelFields = toolbarData[i].convertJsonList;
          // toolbar svg Drawing
          this.ngForRendred1();
          console.log(this.modelFields);
        }
        for (let j = 0; j < this.toolbarListData.length; j++) {
          if (this.toolbarListData[j].toolbar_id == toolbarData[i].toolbar_id) {
            this.toolbarListData[j].toolbar_data = JSON.stringify(toolbarData[i].convertJsonList);
          }
        }
      }
    });
    this.dataService2.layerBoxCloseTrigger.emit();

    // preview page data it is deleted or tags added trigger start 
    this.functionlistner = this.different_tab_function.bind(this);
    window.addEventListener("storage", this.functionlistner);


    // preview page data it is deleted or tags added trigger end
  }
  // constructor ends
  
  cancelALignAnnts() {
    if (this.alignAnnotationArr.length == 0 && this.multipleSelectOn == false) {
      this.closeAlignAnn();
      return true;
    }
    this.revert_annotaionsAlign();
    this.closeAlignAnn();
  }
  
  revert_annotaionsAlign() {
    console.log(this.alignAnnotationArr);
    if(this.alignAnnotationArr.length > 1){
      this.clonemultiselect_align = this.alignAnnotationArr
    }
    if (this.multipleSelectOn == true || this.alignAnnotationArr.length > 1) {
      this.clonemultiselect_align.forEach(data => {
        this.createDocumentStore.view_annotation_array.forEach(element => {
          if (element.annotation_id == data.annotation_id) {
            let leftNum;
            let TopNum;
            if (data.toolbar_element_id > 11) {
              let shapeStringValue = this.shapeService1.getCanvaswidthandHeight(data);
              leftNum = shapeStringValue.left - 7;
              TopNum = shapeStringValue.top - 7;
            }
            else {
              leftNum = Number(data.initial_position_x) - 17.5;
              TopNum = Number(data.initial_position_y) - 17.5;
            }
            const leftString = leftNum.toString();
            element.left = leftString;
            const topString = TopNum.toString();
            element.top = topString;
          }
        })
      })
    }
    else {
      console.log(this.propertiesannotationData);
      let currentAnn = this.createDocumentStore.view_annotation_array.filter((id) => id.annotation_id == this.propertiesannotationData.annotation_id)
      if (currentAnn[0].annotation_id == this.propertiesannotationData.annotation_id) {
        let leftNum;
        let TopNum;
        if (this.propertiesannotationData.toolbar_element_id > 11) {
          let shapeStringValue = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
          leftNum = shapeStringValue.left - 7;
          TopNum = shapeStringValue.top - 7;
        }
        else {
          leftNum = Number(this.propertiesannotationData.initial_position_x) - 17.5;
          TopNum = Number(this.propertiesannotationData.initial_position_y) - 17.5;
        }
        const leftString = leftNum.toString();
        currentAnn[0].left = leftString;
        const topString = TopNum.toString();
        currentAnn[0].top = topString;
      }
    }
    this.alignAnnotationArr = [];
  }

  updateAlignAnn() {
    if (this.alignAnnotationArr.length == 0 && this.multipleSelectOn == false) {
      this.closeAlignAnn();
      return true;
    }
    var alignAnnStore: any[] = [];
    let selectedAnnCount = this.alignAnnotationArr.length;
    let cloneViewArray = this.createDocumentStore.view_annotation_array;
    if (selectedAnnCount > 1) {
      cloneViewArray = cloneViewArray.filter((id) => {
        return this.alignAnnotationArr.find(ele => {
          return ele.annotation_id === id.annotation_id
        })
      })
    }
    if (this.multipleSelectOn == true || selectedAnnCount > 1) {
      if (this.layerDatas != undefined) {
        this.layerDatas.forEach((data) => {
          if (data.layer_id === this.activeLayerIdDraw) {
            data.annotations.forEach(ann => {
              cloneViewArray.forEach(element => {
                if (element.annotation_id == ann.annotation_id) {
                  ann.initial_position_x = Number(element.left) + 17.5;
                  ann.initial_position_y = Number(element.top) + 17.5;
                  alignAnnStore.push(ann)
                }
              })
            })
          }
        })
      }
    }
    else {
      let currentAnn = this.createDocumentStore.view_annotation_array.filter((id) => id.annotation_id == this.propertiesannotationData.annotation_id)
      if (this.layerDatas != undefined) {
        this.layerDatas.forEach((data) => {
          if (data.layer_id === this.activeLayerIdDraw) {
            data.annotations.forEach(ann => {
              if (currentAnn[0].annotation_id == ann.annotation_id) {
                ann.initial_position_x = currentAnn[0].left + 17.5;
                ann.initial_position_y = currentAnn[0].top + 17.5;
                alignAnnStore.push(ann)
              }
            })
          }
        })
      }
    }
    console.log(alignAnnStore);
    let cloneLayers = _.cloneDeep(this.layerDatas);
    this.show = true;
    this.documentService.annotationMRRUpdate(cloneLayers, alignAnnStore).subscribe((response) => {
      console.log(response);
      if (response["response_code"] == 200) {
        console.log(response);
        this.closeAlignAnn();
        this.show = false;
        this.alignAnnotationArr = [];
      }
    });
  }
 
  verticalAlign(){
    console.log(this.propertiesannotationData)
    if (this.multipleSelectOn == true) {
      let clonemultiselect = this.multiselectionList;
      clonemultiselect = clonemultiselect.filter((id) => id.annotation_id != this.alignAnnBaseAnn.annotation_id);
      let xPosition;
      if (this.alignAnnBaseAnn.toolbar_element_id > 11) {
        let shapeStringValue = this.shapeService1.getCanvaswidthandHeight(this.alignAnnBaseAnn);
        xPosition = shapeStringValue.left + 7;
      }
      else {
        xPosition = this.alignAnnBaseAnn.initial_position_x;
      }
      console.log(this.createDocumentStore.view_annotation_array);
      clonemultiselect.forEach(data => {
        this.createDocumentStore.view_annotation_array.forEach(org => {
          if (org.annotation_id == data.annotation_id) {
            org.left = Number(xPosition) - 17.5;
          }
        })
      })
    }
    else {
      if(this.alignAnnBaseAnn.annotation_id == this.propertiesannotationData.annotation_id){
        return
     }
      const clonecurrAnn = _.cloneDeep(this.propertiesannotationData)
      this.alignAnnotationArr.push(clonecurrAnn);
      let cloneAnnotation = this.propertiesannotationData;
      let xPosition;
      if (this.alignAnnBaseAnn.toolbar_element_id > 11) {
        let shapeStringValue = this.shapeService1.getCanvaswidthandHeight(this.alignAnnBaseAnn);
        xPosition = shapeStringValue.left + 7;
      }
      else {
        xPosition = this.alignAnnBaseAnn.initial_position_x;
      }
      let cloneDisplayAnn = this.createDocumentStore.view_annotation_array.filter((id) => id.annotation_id == cloneAnnotation.annotation_id)
      if(cloneDisplayAnn.length > 0){
        cloneDisplayAnn[0].left =  Number(xPosition) - 17.5;
      }
    }
  }

  horizontalAlign() {
    console.log(this.multipleSelectOn);
    if (this.multipleSelectOn == true) {
      let clonemultiselect = this.multiselectionList;
      clonemultiselect = clonemultiselect.filter((id) => id.annotation_id != this.alignAnnBaseAnn.annotation_id);
      let yPosition;
      if (this.alignAnnBaseAnn.toolbar_element_id > 11) {
        let shapeStringValue = this.shapeService1.getCanvaswidthandHeight(this.alignAnnBaseAnn);
        yPosition = shapeStringValue.top + 7;
      }
      else {
        yPosition = this.alignAnnBaseAnn.initial_position_y;
      }
      console.log(this.createDocumentStore.view_annotation_array);
      clonemultiselect.forEach(data => {
        this.createDocumentStore.view_annotation_array.forEach(org => {
          if (org.annotation_id == data.annotation_id) {
            org.top = Number(yPosition) - 17.5;
          }
        })
      })
    } else {
      if(this.alignAnnBaseAnn.annotation_id == this.propertiesannotationData.annotation_id){
        return
     }
      const clonecurrAnn = _.cloneDeep(this.propertiesannotationData)
      this.alignAnnotationArr.push(clonecurrAnn);
      let cloneAnnotation = this.propertiesannotationData;
      let yPosition;
      if (this.alignAnnBaseAnn.toolbar_element_id > 11) {
        let shapeStringValue = this.shapeService1.getCanvaswidthandHeight(this.alignAnnBaseAnn);
        yPosition = shapeStringValue.top + 7;
      }
      else {
        yPosition = this.alignAnnBaseAnn.initial_position_y;
      }
      let cloneDisplayAnn = this.createDocumentStore.view_annotation_array.filter((id) => id.annotation_id == cloneAnnotation.annotation_id)
      if (cloneDisplayAnn.length > 0) {
        cloneDisplayAnn[0].top = Number(yPosition) - 17.5;
      }
    }
  }
  
  calculateCornerpoints(start,end){
    const topX = start.x - 10;
    const bottomX = end.x + 10;
    let newPoint;
    let ydiff = start.y - end.y;
    let xdiff = end.x - start.x;
    xdiff =xdiff <0 ? xdiff * -1 : xdiff;
    ydiff = ydiff < 0 ? ydiff * -1 : ydiff;
    if(ydiff > 120){
      if(end.y < start.y){
        newPoint  = (ydiff / 5) + 5;
        var line_path = `M${topX} ${(start.y)-15}` + ` L${bottomX} ${(end.y)-newPoint}` + ` L${bottomX} ${(end.y)+15}` + ` L${topX} ${(start.y)+newPoint}` + ` L${topX} ${(start.y)-15}`;
      }
      else{
        newPoint  = ydiff / 6;
        var line_path = `M${topX} ${(start.y)-newPoint}` + ` L${bottomX} ${(end.y)-15}` + ` L${bottomX} ${(end.y)+newPoint}` + ` L${topX} ${(start.y)+15}` + ` L${topX} ${(start.y)-15}`;
      }
    }
    else{
      var line_path = `M${topX} ${(start.y)-15}` + ` L${bottomX} ${(end.y)-15}` + ` L${bottomX} ${(end.y)+15}` + ` L${topX} ${(start.y)+15}` + ` L${topX} ${(start.y)-15}`;
    }
    console.log(line_path)
    return line_path;
    
    
  }
  
  checkBorder(id,elementId){
    if(elementId == 15){
      if(this.selectedannotations.length > 0){
        let filtered = this.multiselectionList.filter((elem)=>elem.annotation_id == id)
        if(filtered.length > 1){
          return true
        }
      }else if(this.getId == id){
          return true
      }
      return false
    }
    // if(this.lineDraw == false){
    //   console.log(this.borderLineArray);
    //   if(this.borderLineArray.includes(id)){
    //      return false
    //   }
    //   return true;
    // }
    // else{
    //   return true;
    // }
  }
  calcPosforCpyMultiAnn(MultiAnnArr) {
    var copyMultiArr = _.cloneDeep(MultiAnnArr);
    const arrLength = copyMultiArr.length;
    let avgX = 0,avgY = 0,centerX = 0,centerY = 0;
    let xCoordinates = [],yCoordinates = [];
    let startx,starty,endx,endy;
    for (let a = 0; a < arrLength; a++) {
      let xPosition,height;
      let yPosition,width;
      let id = copyMultiArr[a].annotation_id;
      let name = copyMultiArr[a].annotation_name;
      let element = document.getElementById(copyMultiArr[a].annotation_id)
      let get_element_Style = getComputedStyle(element);
      let get_element_Left: any = get_element_Style.left;
      get_element_Left = get_element_Left.substring(get_element_Left.length - 2, 0);
      let get_element_Top: any = get_element_Style.top;
      get_element_Top = get_element_Top.substring(get_element_Top.length - 2, 0);
      let get_element_Width: any = get_element_Style.width;
      get_element_Width = get_element_Width.substring(get_element_Width.length - 2, 0);
      let get_element_Height: any = get_element_Style.height;
      get_element_Height = get_element_Height.substring(get_element_Height.length - 2, 0);
      xPosition = Number(get_element_Left);
      yPosition = Number(get_element_Top);
      height = Number(get_element_Height);
      width = Number(get_element_Width);
      xCoordinates.push(xPosition);
      yCoordinates.push(yPosition);
      copyMultiArr[a].initial_position_x = xPosition;
      copyMultiArr[a].initial_position_y = yPosition;
      this.objectColHTML = {
        positionX: xPosition,
        positionY: yPosition,
        ann_id: id,
        name: name,
        Height: height,
        Width : width
      }
      this.cpyMultiAnnPos.push(this.objectColHTML);
    }
    startx = Math.min.apply(null, xCoordinates);
    endx = Math.max.apply(null, xCoordinates);
    starty = Math.min.apply(null, yCoordinates);
    endy = Math.max.apply(null, yCoordinates);
    let xDiff = (endx - startx)/2;
    let yDiff = (endy - starty)/2;
    centerX = startx + xDiff;
    centerY = starty + yDiff;
    for (let s = 0; s < arrLength; s++) {
      let xDiff = centerX - Number(copyMultiArr[s].initial_position_x);
      let yDiff = centerY - Number(copyMultiArr[s].initial_position_y);
      let id = copyMultiArr[s].annotation_id;
      let name = copyMultiArr[s].annotation_name;
      let toolbarId = copyMultiArr[s].toolbar_element_id
      this.objectCol = {
        positionX: xDiff,
        positionY: yDiff,
        ann_id: id,
        name: name,
        toolbar_id: toolbarId
      }
      this.arrNewPosition.push(this.objectCol);
      this.center = {"x":centerX,"y":centerY}
    }

  }
  checkBoundaryforMultiCopy(moveelement, newPointX: number, newPointY: number) {
    let get_element_Left = moveelement.positionX;
    let get_element_Top = moveelement.positionY;
    let get_element_Width = moveelement.Width;
    get_element_Width = get_element_Width / 2;
    let get_element_Height = moveelement.Height;
    let checkBounds_left = newPointX;
    let checkBounds_top =  newPointY;
    let checkBounds_right = newPointX + Number(get_element_Width);
    let checkBounds_bottom = newPointY + Number(get_element_Height);
    console.log(checkBounds_right, checkBounds_bottom);
    if (checkBounds_left < 0) {
      console.log(checkBounds_left, checkBounds_top);
      newPointX = newPointX - (checkBounds_left);
      this.moveOverBoundary = true;
    }
    else if (checkBounds_right > this.realWidth) {
      let difference = Number(checkBounds_right) - Number(this.realWidth);
      newPointX = newPointX - difference;
      console.log(newPointX);
      this.moveOverBoundary = true;
    }
    if (checkBounds_top < 0) {
      newPointY = newPointY - (checkBounds_top);
      this.moveOverBoundary = true;
    }
    else if (checkBounds_bottom > this.realHeight) {
      let difference = Number(checkBounds_bottom) - Number(this.realHeight);
      newPointY = newPointY - difference;
      this.moveOverBoundary = true;
    }
    return { "newPointX": newPointX, "newPointY": newPointY }
  }
 

  //constructor 
  updatingAlreadyCreatedGroup(generateCloneLayer,clonemultiselectionList,ids){
      const first = this.documentService.annotationMultipleUpdate(generateCloneLayer, clonemultiselectionList, 'form');
      const second = this.documentService.updatingGroupAnntsService(ids,this.createJSON_grpAnnts);
      var filterGroupData = this.createJSON_grpAnnts.group_data.filter(id => id.group_annotation_id == ids.group_id);
      forkJoin([first,second]).subscribe(res => {
        let abc = res[0];
        console.log(res[0]);
        console.log(res[1]);
        if (abc["response_code"] == 200) {
          if (filterGroupData.length > 0) {
            let groupDatas = filterGroupData[0];
            let cloneGrpAnnList = _.cloneDeep(groupDatas.annotation_ids)
            let filterlist = this.checkAnnIDfromDOM(cloneGrpAnnList, groupDatas.annotation_ids);
            let pathBox = this.calcMinandMaxforGrpAnnts_getAnns(filterlist);
            console.log(pathBox);
            let copyFormList = _.cloneDeep(this.formList);
            let cloneFormList = this.convertArrtoJson(copyFormList);
            let getBorderBoxWidthandHeight: any = this.getAnnotationWidthandHeightAction(pathBox);
            let groupColorCode = groupDatas.group_state;
            let groupId = groupDatas.group_annotation_id;
            let groupFormUUId = groupDatas.formfield_details.checkbox_field_id;
            let dropDownProp = this.toCheckDropDownispresent(groupFormUUId,cloneFormList)
            console.log(this.dropDownColorDetails);
            let groupStateColor;
            let lineWidth;
            if (dropDownProp.properties != undefined) {
              groupStateColor = this.findAnnColor_FormBuilder(groupColorCode,dropDownProp.properties);
              if(this.dropDownColorDetails.hasOwnProperty('line_width')){
                lineWidth = Number(this.dropDownColorDetails.line_width);
              }
            }
            else {
              groupStateColor = this.findColor(groupColorCode)
            }
            let getsvgpath_borderBox = {
              linewidth: lineWidth,
              annotation_id: groupId + "-borderbox",
              grouping_border_id: groupId,
              annotation_type: "groupingBox",
              annotation_data: pathBox,
              groupingEnable: true,
              opacity: 1,
              width: (getBorderBoxWidthandHeight.width),
              height: (getBorderBoxWidthandHeight.height),
              left: getBorderBoxWidthandHeight.left,
              top: getBorderBoxWidthandHeight.top,
              fill_color: "transparent",
              stroke_color: groupStateColor
            }
            let filter_colorDetails = groupDatas.color_details.filter(id => id.is_removed == false);
            let filter_colorDetails_basedonDOM = filter_colorDetails.filter(id => document.getElementById(id.annotation_id) != null);
            filter_colorDetails_basedonDOM.forEach(data => {
              let filterAnn = this.createDocumentStore.view_annotation_array.filter(id => id.annotation_id == data.annotation_id);
              if (filterAnn.length > 0) {
                console.log(this.dropDownColorDetails);
                let findAnnColor;
                if (this.dropDownColorDetails != undefined) {
                  findAnnColor = this.findAnnColor_FormBuilder(data.color_state)
                }
                else {
                  findAnnColor = this.findColor(data.color_state);
                }
                filterAnn[0].opacity = 0.5;
                filterAnn[0].stroke_color = findAnnColor;
                if (filterAnn[0].toolbar_element_id != 11 && filterAnn[0].toolbar_element_id != 12 && filterAnn[0].toolbar_element_id != 13 && filterAnn[0].toolbar_element_id != 14) {
                  filterAnn[0].fill_color = findAnnColor;
                }
              }
            })
            this.createDocumentStore.view_annotation_array.push(getsvgpath_borderBox);
            this.show = false;
          }
          else {
            this.show = false;
          }
          // if(this.media != true && this.links != true && this.tags != true && this.properties != true){
          //   this.formContentleft = [];
          //   this.formContentright = [];
          // }
        }
        else {
          this.errorMessage();
        }
      })
  }
  findAnnColor_FormBuilder(state, properties?) {
    let color;
    let clonedropDownColorDet
    if (properties != undefined) {
      clonedropDownColorDet = _.cloneDeep(properties);
    }
    else{
      clonedropDownColorDet = _.cloneDeep(this.dropDownColorDetails);
    }
    console.log(state);
    if (state == 0) {
      if(clonedropDownColorDet != undefined && clonedropDownColorDet.hasOwnProperty('not_started')) {
        color = clonedropDownColorDet.not_started;
        if (color == "") {
          color = "blue";
        }
      }
      else {
        color = "blue"
      }
    }
    if (state == 1) {
      if(clonedropDownColorDet != undefined && clonedropDownColorDet.hasOwnProperty('inprogress')) {
        color = clonedropDownColorDet.inprogress;
        if (color == "") {
          color = "yellow";
        }
      }
      else {
        color = "yellow"
      }
    }
    if (state == 2) {
      if(clonedropDownColorDet != undefined && clonedropDownColorDet.hasOwnProperty('completed')) {
        color = clonedropDownColorDet.completed;
        if (color == "") {
          color = "green";
        }
      }
      else {
        color = "green"
      }
    }
    if (state == 3) {
      if(clonedropDownColorDet != undefined && clonedropDownColorDet.hasOwnProperty('error')) {
        color = clonedropDownColorDet.error;
        if (color == "") {
          color = "red";
        }
      }
      else {
        color = "red"
      }
    }
    let final_color = this.checkStrokeColor1(color);
    return final_color    
  }
  findGroupindex(currentId) {
    if (this.createJSON_grpAnnts == undefined) {
      return -1
    }
    let findCurGroup = this.createJSON_grpAnnts.group_data.findIndex((data) => {
      if (this.createDocumentStore.data_allow_condition.includes(data.is_removed)) {
        let curAnn = data.annotation_ids.filter(id => id == currentId);
        if (curAnn.length > 0) {
          return true;
        }
        else {
          return false;
        }
      }
    })
    return findCurGroup;
  }
  findGroupindex1(id){
    let splitId = id.split("-borderbox");
     let findCurrentGroup = this.createJSON_grpAnnts.group_data.findIndex(id => id.group_annotation_id == splitId[0]);
     console.log(findCurrentGroup)
     return findCurrentGroup
  }
  changeBorderforGroup(currentId,state,dropDownColorPresent?){
    //last_updated_date
    let MyDateString = new Date().toISOString();
    let findCurGroupIndex = this.findGroupindex(currentId);
    let colorDetailsAll = this.createJSON_grpAnnts.group_data[findCurGroupIndex].color_details;
    let colorDetails = colorDetailsAll.filter(id => id.is_removed == false)
    let curr_group_id = this.createJSON_grpAnnts.group_data[findCurGroupIndex].group_annotation_id;
    let selectedAnn = colorDetails.filter(id => id.annotation_id == currentId);
    this.createJSON_grpAnnts.group_data[findCurGroupIndex].last_updated_date = MyDateString;
    let groupAnnIds = this.createJSON_grpAnnts.group_data[findCurGroupIndex].annotation_ids;
    if(selectedAnn.length > 0){
      selectedAnn[0].color_state = state;
      selectedAnn[0].last_updated_date = MyDateString;
    }
    let colorChange;
    if(state == 3){
      colorChange = 3;
    }
    else{
      colorChange = this.findGroupcolor(colorDetails);
    }
    this.createJSON_grpAnnts.group_data[findCurGroupIndex].group_state = colorChange;
    let groupStateColor;
    if(dropDownColorPresent == true){
      groupStateColor = this.findAnnColor_FormBuilder(colorChange)
    }
    else{
      groupStateColor = this.findColor(colorChange)
    }
    let borderElement = this.createDocumentStore.view_annotation_array.filter(id => id.grouping_border_id == curr_group_id)
    if (borderElement.length > 0) {
      borderElement[0].stroke_color = groupStateColor;
    }
    const group_details = {groupColor:groupStateColor,groupAnnts:groupAnnIds,groupState:colorChange}
    return group_details;
  } 
  calculateCornerpoints_GrpAnnts(start, end) {
    var line_path = `M${start.x} ${start.y}` + ` L${start.x} ${end.y}` + ` L${end.x} ${end.y}` + ` L${end.x} ${start.y}` + ` L${end.x} ${start.y}`;
    console.log(line_path)
    return line_path;
  }

  calcMinandMaxforGrpAnnts(multiselectionList) {
    this.cpyMultiAnnPos_GrpAnnts = []
    var copyMultiArr = _.cloneDeep(multiselectionList);
    const arrLength = copyMultiArr.length;
    let xCoordinates = [],yCoordinates = [];
    let xCoordinatesRight = [], yCoordinatesBottom = [];
    let startx,starty,endx,endy;
    for (let a = 0; a < arrLength; a++) {
      let xPosition,height;
      let yPosition,width;
      let id = copyMultiArr[a].annotation_id;
      let element = document.getElementById(copyMultiArr[a].annotation_id)
      let get_element_Style = getComputedStyle(element);
      let get_element_Left: any = get_element_Style.left;
      get_element_Left = get_element_Left.substring(get_element_Left.length - 2, 0);
      let get_element_Top: any = get_element_Style.top;
      get_element_Top = get_element_Top.substring(get_element_Top.length - 2, 0);
      let get_element_Width: any = get_element_Style.width;
      get_element_Width = get_element_Width.substring(get_element_Width.length - 2, 0);
      let get_element_Height: any = get_element_Style.height;
      get_element_Height = get_element_Height.substring(get_element_Height.length - 2, 0);
      height = Number(get_element_Height);
      width = Number(get_element_Width);
      xPosition = Number(get_element_Left);
      yPosition = Number(get_element_Top);
      let xRight = xPosition + width;
      let yBottom = yPosition + height;
      xCoordinates.push(xPosition);
      yCoordinates.push(yPosition);
      xCoordinatesRight.push(xRight);
      yCoordinatesBottom.push(yBottom);
      copyMultiArr[a].initial_position_x = xPosition;
      copyMultiArr[a].initial_position_y = yPosition;
      this.objectColHTML_GrpAnnts = {
        positionX: xPosition,
        positionY: yPosition,
        ann_id: id,
        Height: height,
        Width : width
      }
      this.cpyMultiAnnPos_GrpAnnts.push(this.objectColHTML_GrpAnnts);
    }
    startx = Math.min.apply(null, xCoordinates);
    endx = Math.max.apply(null, xCoordinatesRight);
    starty = Math.min.apply(null, yCoordinates);
    endy = Math.max.apply(null, yCoordinatesBottom);
    let findWidth = this.cpyMultiAnnPos_GrpAnnts.filter(id => id.positionX == endx);
    let width;
    if(findWidth.length > 0){
       width = findWidth[0].Width;
    }
    let findHeight = this.cpyMultiAnnPos_GrpAnnts.filter(id => id.positionY == endy);
    let height;
    if(findHeight.length > 0){
      height = findHeight[0].Height;
    }
    let start = {x:(startx),y:(starty)};
    let end = {x:(endx + width) ,y:(endy + height)};
    let rectString = "drawRect" + "-" + startx + ":" + starty + ":" + endx + ":" + endy;
    return rectString;
  }
  calcMinandMaxforGrpAnnts_getAnns(multiselectionList) {
    this.cpyMultiAnnPos_GrpAnnts = []
    var copyMultiArr = _.cloneDeep(multiselectionList);
    const arrLength = copyMultiArr.length;
    let xCoordinates = [],yCoordinates = [];
    let xCoordinatesRight = [], yCoordinatesBottom = [];
    let startx,starty,endx,endy;
    for (let a = 0; a < arrLength; a++) {
      let xPosition,height;
      let yPosition,width;
      let id = copyMultiArr[a];
      let element = document.getElementById(id)
      let get_element_Style = getComputedStyle(element);
      let get_element_Left: any = get_element_Style.left;
      get_element_Left = get_element_Left.substring(get_element_Left.length - 2, 0);
      let get_element_Top: any = get_element_Style.top;
      get_element_Top = get_element_Top.substring(get_element_Top.length - 2, 0);
      let get_element_Width: any = get_element_Style.width;
      get_element_Width = get_element_Width.substring(get_element_Width.length - 2, 0);
      let get_element_Height: any = get_element_Style.height;
      get_element_Height = get_element_Height.substring(get_element_Height.length - 2, 0);
      height = Number(get_element_Height);
      width = Number(get_element_Width);
      xPosition = Number(get_element_Left);
      yPosition = Number(get_element_Top);
      let xRight = xPosition + width;
      let yBottom = yPosition + height;
      xCoordinates.push(xPosition);
      yCoordinates.push(yPosition);
      xCoordinatesRight.push(xRight);
      yCoordinatesBottom.push(yBottom);
      // copyMultiArr[a].initial_position_x = xPosition;
      // copyMultiArr[a].initial_position_y = yPosition;
      this.objectColHTML_GrpAnnts = {
        positionX: xPosition,
        positionY: yPosition,
        ann_id: id,
        Height: height,
        Width : width
      }
      this.cpyMultiAnnPos_GrpAnnts.push(this.objectColHTML_GrpAnnts);
    }
    startx = Math.min.apply(null, xCoordinates);
    endx = Math.max.apply(null, xCoordinatesRight);
    starty = Math.min.apply(null, yCoordinates);
    endy = Math.max.apply(null, yCoordinatesBottom);
    let findWidth = this.cpyMultiAnnPos_GrpAnnts.filter(id => id.positionX == endx);
    let width;
    if(findWidth.length > 0){
       width = findWidth[0].Width;
    }
    let findHeight = this.cpyMultiAnnPos_GrpAnnts.filter(id => id.positionY == endy);
    let height;
    if(findHeight.length > 0){
      height = findHeight[0].Height;
    }
    let start = {x:(startx),y:(starty)};
    let end = {x:(endx + width) ,y:(endy + height)};
    let rectString = "drawRect" + "-" + startx + ":" + starty + ":" + endx + ":" + endy;
    return rectString;
  }
  updateGroupAnnts(){
    let groupAnnFormList = this.findGrpAnnForms();
        let dialogref = this.dialogBox.open(GroupAnntsFormsComponent, {
          disableClose: true,
          width: "380px",
          data: {
            FormList: groupAnnFormList
          }
        });
        dialogref.afterClosed().subscribe((formId) => {
          if(this.multiselectionList.length == 0){
            this.cancelGroupAnnts();
            return
          }
          console.log(formId);
          this.selectedGroupFormId = formId;
          console.log(this.selectedGroupFormId);
          let selectedForm = this.formList.filter(id => id.form_id == formId);
          if(selectedForm[0].is_extend == 1){
            if(Array.isArray(selectedForm[0].ext_form_data) == false){
              selectedForm[0].ext_form_data = JSON.parse(selectedForm[0].ext_form_data);
            }
          }
          if(Array.isArray(selectedForm[0].form_data) == false){
            selectedForm[0].form_data = JSON.parse(selectedForm[0].form_data);
          }
          this.selectedGrpAnnForm = selectedForm[0];
          this.updateGroupAnnts_APIcall();
        })
  }
  updateGroupAnnts_APIcall() {
    let clonemultiselectionList = _.cloneDeep(this.multiselectionList);
    clonemultiselectionList.forEach(data => {
      let formList = data.annotation_forms;
      if (formList.length > 0) {
        let index = formList.findIndex(id => id.form_id == this.selectedGroupFormId);
        if (index == -1) {
          console.log(data.annotation_forms);
          data.annotation_forms.push(this.selectedGrpAnnForm);
          let filterAnn = this.layerDatas[0].annotations.filter(id => id.annotation_id == data.annotation_id);
          if(filterAnn.length > 0){
            filterAnn[0].annotation_forms = data.annotation_forms;
          }
          console.log(this.selectedGrpAnnForm);
        }
      }
    })
    this.grpAnntsEnbled = false;
    let generateCloneLayer = _.cloneDeep(this.layerDatas);
    this.show = true;
    let pathbox = this.calcMinandMaxforGrpAnnts(clonemultiselectionList);
    let getAnnotationWidthandHeight: any = this.getAnnotationWidthandHeightAction(pathbox);
    this.showGroupBox = true;
    this.show = true;
    this.dataService2.multiSelectFooter.emit(false);
    this.dataService.groupingAnntsTrigger.emit(false);
    var getGroupdetails = this.createGroupLayer(clonemultiselectionList);
    console.log(this.createJSON_grpAnnts);
    
    const ids = {
      proj_id: this.projectId,
      folder_id: this.folderId,
      user_id: this.su.user_id,
      group_id: getGroupdetails.group_id
    }
    if(getGroupdetails.groupUpdate == true){
      this.updatingAlreadyCreatedGroup(generateCloneLayer,clonemultiselectionList,ids);
    }
    else{
      const first = this.documentService.annotationMultipleUpdate(generateCloneLayer, clonemultiselectionList, 'form')
      const second = this.documentService.createGroupAnnts(ids, this.createJSON_grpAnnts)
      forkJoin([first,second]).subscribe(res => {
        let abc = res[0];
        let def = res[1];
        var filterGroupData = this.createJSON_grpAnnts.group_data.filter(id => id.group_annotation_id == ids.group_id);
        if (abc["response_code"] == 200) {
          console.log(clonemultiselectionList);
          let groupStateColor;
          let lineWidth;
          if (this.dropDownColorDetails != undefined) {
            groupStateColor = this.findAnnColor_FormBuilder(getGroupdetails.group_colorcode)
            if(this.dropDownColorDetails.hasOwnProperty('line_width')){
              lineWidth = Number(this.dropDownColorDetails.line_width);
            }
          }
          else {
            groupStateColor = this.findColor(getGroupdetails.group_colorcode)
          }
          let getsvgpath_borderBox = {
            linewidth:lineWidth,
            annotation_id: getGroupdetails.group_id + "-borderbox",
            grouping_border_id: getGroupdetails.group_id,
            annotation_type: "groupingBox",
            annotation_data: pathbox,
            groupingEnable: true,
            opacity: 1,
            width: (getAnnotationWidthandHeight.width),
            height: (getAnnotationWidthandHeight.height),
            left: getAnnotationWidthandHeight.left,
            top: getAnnotationWidthandHeight.top,
            fill_color: "transparent",
            stroke_color: groupStateColor
          }
          let groupDatas;
          if (filterGroupData.length > 0) {
            groupDatas = filterGroupData[0];
          }
          let filter_colorDetails = groupDatas.color_details.filter(id => id.is_removed == false);
          let filter_colorDetails_basedonDOM = filter_colorDetails.filter(id => document.getElementById(id.annotation_id) != null);
          filter_colorDetails_basedonDOM.forEach(data => {
            let filterAnn = this.createDocumentStore.view_annotation_array.filter(id => id.annotation_id == data.annotation_id);
            if (filterAnn.length > 0) {
              console.log(this.dropDownColorDetails);
              let findAnnColor;
              if (this.dropDownColorDetails != undefined) {
                findAnnColor = this.findAnnColor_FormBuilder(data.color_state)
              }
              else {
                findAnnColor = this.findColor(data.color_state);
              }
              filterAnn[0].opacity = 0.5;
              filterAnn[0].stroke_color = findAnnColor;
              if (filterAnn[0].toolbar_element_id != 11 && filterAnn[0].toolbar_element_id != 12 && filterAnn[0].toolbar_element_id != 13 && filterAnn[0].toolbar_element_id != 14) {
                filterAnn[0].fill_color = findAnnColor;
              }
            }
          })
          this.createDocumentStore.view_annotation_array.push(getsvgpath_borderBox);
          this.show = false;
        }
      })
    }
  }
  findColor(state){
    switch (state) {
      case 0:
        return "#002F5F";
        break;
      case 1:
        return "#FFFF00";
        break;
      case 2:
        return "#98D133";
        break;
      case 3:
        return "#BC0900";
        break;
    } 
  }
  borderColorCheck(cloneMultiselectionList){
    cloneMultiselectionList.forEach(data => {
      let filterForm = data.annotation_forms.filter(id => id.form_id == this.selectedGrpAnnForm["form_id"]);
      console.log(this.createDocumentStore.view_annotation_array);
      if (filterForm.length > 0) {
        let cloneFormData;
        if(filterForm[0].hasOwnProperty('is_extend') && this.createDocumentStore.data_allow_conditionT.includes(filterForm[0].is_extend)){
          cloneFormData = [...filterForm[0].form_data,...filterForm[0].ext_form_data];
        }
        else{
          cloneFormData = _.cloneDeep(filterForm[0].form_data)
        }
        const checkBoxFields = cloneFormData.filter(data => data.element_type == "group_field");
        if (checkBoxFields.length > 0) {
          let groupEnableCheck = checkBoxFields.filter(data => data.element_data.grouping_enable == true);
          if (groupEnableCheck.length > 0) {
            let defaultCheck = groupEnableCheck[0].element_data.options[0].default;
            let borderElement = this.createDocumentStore.view_annotation_array.filter(id => id.annotation_type == "groupingBox")
            if (defaultCheck == false) {
              let borderElement = this.createDocumentStore.view_annotation_array.filter(id => id.annotation_type == "groupingBox")
              if (borderElement.length > 0) {
                borderElement[0].stroke_color = "#FFFF00";
                return
              }
            }
            if (borderElement.length > 0) {
              borderElement[0].stroke_color = "#98D133";
              return
            }
          }
        }
      }
    })
  }
  createGroupLayer(groupAnnotationList) {
    const count = groupAnnotationList.length;
    let MyDateString = new Date().toISOString();
    let multiListIds = [];
    let groupCheckBoxid: string;
    let errorCheckBoxid: string;
    var color_details: any[] = [];
    let uuid = this.dataService4.generateUUID();
    let group_data_arr:any[] = [];
    let stateDetails;
    for (var item of groupAnnotationList) {
      let id = item.annotation_id;
      multiListIds.push(id);
      stateDetails = this.findstatecolor(item)
      let state_color = stateDetails.state; 
      let colorDetSyntax = {
        annotation_id: id,
        color_state: state_color,
        last_updated_date: MyDateString,
        last_updated_by_userid: this.su.user_id,
        is_removed: false
      }
      color_details.push(colorDetSyntax);
    }
    let cloneFormData;

    if(this.selectedGrpAnnForm.hasOwnProperty('is_extend') && this.createDocumentStore.data_allow_conditionT.includes(this.selectedGrpAnnForm["is_extend"])){
      cloneFormData = [...this.selectedGrpAnnForm["form_data"],...this.selectedGrpAnnForm["ext_form_data"]]
    }
    else{
      cloneFormData = _.cloneDeep(this.selectedGrpAnnForm["form_data"])
    }
    const checkBoxFields = cloneFormData.filter(data => data.element_type == "group_field");
    if (checkBoxFields.length > 0) {
      groupCheckBoxid = checkBoxFields[0].element_uuid;
    }
    let groupState_colorcode;
    if(stateDetails.default == true){
      groupState_colorcode = stateDetails.state;
    }
    else{
      groupState_colorcode = this.findGroupcolor(color_details);
    }
    let group_data = {
      group_no: 1,
      no_of_annotations: count,
      annotation_ids: multiListIds,
      associate_form: this.selectedGrpAnnForm["form_id"],
      formfield_details: {
        checkbox_field_id: groupCheckBoxid,
        error_label_id: errorCheckBoxid
      },
      group_state: groupState_colorcode,
      group_annotation_id: uuid + "-GroupAnno",
      color_details: color_details,
      page_id: this.currentPageId,
      is_removed: false,
      is_hidden: false,
      is_lock: false,
      created_date: MyDateString,
      last_updated_date: MyDateString,
      createdby_userid: this.su.user_id,
      updatedby_userid: this.su.user_id,
      version_number: 1
    }
    let group_id = group_data.group_annotation_id;
    group_data_arr.push(group_data)
    let updateGroupData = false;
    if(this.createJSON_grpAnnts == undefined){
      this.createJSON_grpAnnts = {
        group_id: uuid + "-Group",
        is_removed: true,
        project_id: this.projectId,
        group_data: group_data_arr,
        document_id: this.folderId,
        created_date: MyDateString,
        is_active_flag: true,
        is_locked_flag: false,
        is_default_flag: true,
        is_visible_flag: true,
        created_by_user_id: this.su.user_id
      }
    }
    else{
      this.createJSON_grpAnnts.group_data.push(group_data_arr[0]);
      updateGroupData = true;
    }
    
    console.log(this.createJSON_grpAnnts);
    let groupData = {
      group_id: group_id,
      group_colorcode: groupState_colorcode,
      groupUpdate: updateGroupData
    }
    return groupData;
  }
    findGroupcolor(colorDetails){
    let count = 0;
    let colorCode:number = 0;
    console.log(colorDetails);
    for(let i = 0; i < colorDetails.length;i++){
      let notstartedCheck = colorDetails.filter(id => id.color_state == 0);
      if(notstartedCheck.length > 0 && notstartedCheck.length == colorDetails.length){
        colorCode = 0;
        break;
      }
      let errorSelected = colorDetails.filter(id => id.color_state == 3);
      if(errorSelected.length > 0){
        colorCode = 3;
        break;
      }
      if(colorDetails[i].color_state == 1 || colorDetails[i].color_state == 3){
        colorCode = colorDetails[i].color_state;
        break;
      }
      if(colorDetails[i].color_state == 2){
          count++;
      }
    }
    if(colorCode == 1){
      return colorCode;
    }
    console.log(colorDetails);
    if(count == colorDetails.length){
      colorCode = 2;
      return colorCode;
    }
    else if(count != 0){
      colorCode = 1;
      return colorCode;
    }
    else{
      return colorCode;
    }
  }
  findstatecolor(data) {
    let filterForm = data.annotation_forms.filter(id => id.form_id == this.selectedGrpAnnForm["form_id"]);
    if (filterForm.length > 0) {
      let cloneFormData;
      if(filterForm[0].hasOwnProperty('is_extend') && this.createDocumentStore.data_allow_conditionT.includes(filterForm[0].is_extend)){
        cloneFormData = [...filterForm[0].form_data,...filterForm[0].ext_form_data];
      }
      else{
        cloneFormData = _.cloneDeep(filterForm[0].form_data)
      }
      const checkBoxFields = cloneFormData.filter(data => data.element_type == "group_field");
      if (checkBoxFields.length > 0) {
        let groupEnableCheck = checkBoxFields.filter(data => data.element_data.hasOwnProperty('group_color_details'));
        if (groupEnableCheck.length > 0) {
          this.dropDownColorDetails = groupEnableCheck[0].element_data.group_color_details;
        }
        let checkDefaultIndex = checkBoxFields[0].element_data.options.findIndex(id => id.default == true);
        if (checkDefaultIndex != -1) {
          const stateDetails = {
            state: checkDefaultIndex,
            default: true
          }
          return stateDetails;
        }
        if (this.dropDownColorDetails == undefined) {
          const stateDetails = {
            state: 0,
            default: false
          }
          return stateDetails;
        }
      }
      const stateDetails = {
        state: 0,
        default: false
      }
      return stateDetails;
    }
  }
  cancelGroupAnnts(){
    this.grpAnntsEnbled = false;
    this.dataService2.multiSelectFooter.emit(false);
    this.dataService.groupingAnntsTrigger.emit(false);
  }
  findGrpAnnForms() {
    console.log(this.formList);
    var grpAnnFormList = [];
    let cloneFormList = _.cloneDeep(this.formList);
    for (let index of cloneFormList) {
      console.log(index);
      if (Array.isArray(index.form_data) == false) {
        index.form_data = JSON.parse(index.form_data);
      }
      let cloneFormData = _.cloneDeep(index.form_data);
      if (cloneFormData != null) {
        const checkBoxFields = cloneFormData.filter(data => data.element_type == "group_field");
        if (checkBoxFields.length > 0) {
            const formDetails = { "name": index.form_name, "form_id": index.form_id };
            grpAnnFormList.push(formDetails)
        }
      }
      if (this.createDocumentStore.data_allow_conditionT.includes(index.is_extend)) {
        if (index.hasOwnProperty('ext_form_data') && Array.isArray(index.ext_form_data) == false) {
          index.ext_form_data = JSON.parse(index.ext_form_data);
        }
        let cloneExtFormData = _.cloneDeep(index.ext_form_data);
        if (cloneExtFormData != null) {
          const checkBoxFields = cloneExtFormData.filter(data => data.element_type == "group_field");
          if (checkBoxFields.length > 0) {
              const formDetails = { "name": index.form_name, "form_id": index.form_id };
              grpAnnFormList.push(formDetails)
          }
        }
      }
    }
    return grpAnnFormList;
  }
  checkAlign_usecase() {
    let weldformindex = this.modelFieldsForm.findIndex((id) => id.element_type == "uti-entry-field-WMATA_WELD");
		if (weldformindex == -1) {
			return
		}
		let check_condition = ["false", false, 0, "0"];
		let column_one = _.cloneDeep(this.modelFieldsForm);
		let column_two = _.cloneDeep(this.extend_modelFieldsForm);
		column_one = column_one.filter((data) => data.is_removed == 0 || data.is_removed == "0");
		column_two = column_two.filter((data) => data.is_removed == 0 || data.is_removed == "0");
		let cloneLeftColumn = _.cloneDeep(column_one);
		let cloneRighttColumn = _.cloneDeep(column_two);
		let cloneLeft1 = _.cloneDeep(column_one);
		let cloneRightt1 = _.cloneDeep(column_two);
		let elements_height = _.cloneDeep(this.element_details);
		cloneRighttColumn = cloneRighttColumn.filter(id => id.element_type != "uti-entry-field-WMATA_WELD");
		let useConditionsCheck = [...cloneLeftColumn, ...cloneRighttColumn];
    cloneRighttColumn.forEach((data, index) => {
      let check = data.element_data.use_conditions;
      let hiddenCheck = Number(data.is_hidden);
      let uuid = cloneRighttColumn[index].element_uuid;
      if (check === true && hiddenCheck == 0) {
        console.log(hiddenCheck);
        let usecaseEmptycell = cloneRighttColumn.filter((id) => id.clone_uuid == uuid);
        if (usecaseEmptycell.length > 0) {
          if (usecaseEmptycell[0].clone_uuid == uuid) {
            console.log(cloneRighttColumn)
            let origIndex = cloneRightt1.findIndex((id) => id.clone_uuid == uuid && id.element_type == "empty_cell_useCase")
            if (origIndex != -1) {
              cloneRightt1.splice(origIndex, 1);
              let id_index = this.useCaseEmptycellIds.indexOf(uuid);
              if (id_index != -1) {
                this.useCaseEmptycellIds.splice(id_index, 1)
              }
            }
          }
        }
      }
      else if (check === true && !this.useCaseEmptycellIds.includes(uuid)) {
        const refId = data.element_data.reference_id;
        const indexcolumn = useConditionsCheck.findIndex((id) => id.element_uuid == refId);
        if (indexcolumn != -1) {
          console.log("Aaaaaaa");
          console.log(index);
          let name = useConditionsCheck[indexcolumn].element_type;
          console.log(typeof (this.element_details));
          let index_elementdetails = this.element_details.findIndex((id) => id.element_name == name);
          // let fieldHeight;
          let height = useConditionsCheck[indexcolumn].height;
          // if (index_elementdetails != -1) {
          //   fieldHeight = this.element_details[index_elementdetails].height;
          // }
          // let uuid = cloneRighttColumn[index].element_uuid;
          let clonemodel = _.cloneDeep(this.clone_model_useconditions);
          clonemodel.height = height;
          clonemodel.clone_uuid = uuid;
          this.useCaseEmptycellIds.push(uuid);
          clonemodel.element_uuid = this.dataService4.generateUUID();
          cloneRightt1.splice(index, 0, clonemodel)
        }
      }
    })
    cloneLeftColumn.forEach((data, index) => {
      let check = data.element_data.use_conditions;
      let hiddenCheck = Number(data.is_hidden);
      let uuid = cloneLeftColumn[index].element_uuid;
      if (check === true && hiddenCheck == 0) {
        console.log(hiddenCheck);
        let usecaseEmptycell = cloneLeftColumn.filter((id) => id.clone_uuid == uuid);
        if (usecaseEmptycell.length > 0) {
          if (usecaseEmptycell[0].clone_uuid == uuid) {
            console.log(cloneLeftColumn)
            let origIndex = cloneLeft1.findIndex((id) => id.clone_uuid == uuid && id.element_type == "empty_cell_useCase")
            if (origIndex != -1) {
              cloneLeft1.splice(origIndex, 1);
              let id_index = this.useCaseEmptycellIds.indexOf(uuid);
              if (id_index != -1) {
                this.useCaseEmptycellIds.splice(id_index, 1)
              }
            }
          }
        }
      }
      else if (check === true && !this.useCaseEmptycellIds.includes(uuid)) {
        const refId = data.element_data.reference_id;
        const indexcolumn = useConditionsCheck.findIndex((id) => id.element_uuid == refId);
        if (indexcolumn != -1) {
          console.log("Aaaaaaa");
          console.log(index);
          let index_elementdetails = this.element_details.findIndex((id) => id.element_name == name);
          // let fieldHeight;
          let height = useConditionsCheck[indexcolumn].height;
          // if (index_elementdetails != -1) {
          //   fieldHeight = this.element_details[index_elementdetails].height;
          // }
          // let height = useConditionsCheck[indexcolumn].height;
          // let id = cloneLeftColumn[indexcolumn].element_uuid;
          let clonemodel = _.cloneDeep(this.clone_model_useconditions)
          clonemodel.height = height;
          clonemodel.clone_uuid = uuid;
          this.useCaseEmptycellIds.push(uuid);
          clonemodel.element_uuid = this.dataService4.generateUUID();
          cloneLeft1.splice(index, 0, clonemodel)
        }

      }
    })
		this.modelFieldsForm = cloneLeft1;
		this.extend_modelFieldsForm = cloneRightt1;
    this.usecaseCopyArray = [...cloneLeft1,...cloneRightt1]
    // this.cdRef.detectChanges();
    this.alignmenprocess();
	}  
  selectLastUpdatedForm(formList){
    if(formList.length > 0){
     var copyFormlist = _.cloneDeep(formList);
     copyFormlist.sort((a, b) => new Date(b.last_updated_date).getTime() - new Date(a.last_updated_date).getTime())
    }
    let formId = copyFormlist[0].form_id;
    return formId;
  }
  getTextWidthandHeight(name,fontsize){
    let numberOfLineBreaks = (name.match(/\n/g) || []).length;
    if (numberOfLineBreaks > 0) {
      numberOfLineBreaks = numberOfLineBreaks + 1;
    }
    let canvas12 = document.createElement("canvas");
    canvas12.style.width = "200px";
    let context = canvas12.getContext("2d");
    context.font = `${fontsize}px sans-serif`;
    context.fillText(name, 0, 0);
    let oldWidth = context.measureText(name).width;
    var oldHeight = parseInt(context.font);
    if (numberOfLineBreaks != 0) {
      oldWidth = oldWidth / numberOfLineBreaks;
      let linesHeight = numberOfLineBreaks*2;
      oldHeight = oldHeight/25;
    }
    let WHValues={width:oldWidth,height:oldHeight}
    return WHValues;
  }
  stringToNumberConversion(valueInString: string) {
    valueInString = valueInString.substring(valueInString.length - 2, 0);
    let sizeInNumber = Number(valueInString);
    return sizeInNumber;
  }
  shapesLabelSize(shape?){
    let getannotationLabelElement = document.querySelectorAll("p[annotationLabel]");
    if (getannotationLabelElement.length > 0) {
      let currentAttributeElement = document.getElementById("label" + shape.annotation_id);
      let fontSizeString = currentAttributeElement.style.fontSize;
      if(this.textsize==undefined){
        this.textsize=this.stringToNumberConversion(fontSizeString);
      }
      this.textsizeOriginal = this.stringToNumberConversion(fontSizeString);
      let fontLeftString = currentAttributeElement.style.left;
      this.fontLeftShapes = this.stringToNumberConversion(fontLeftString);
      let fontTopString = currentAttributeElement.style.top;
      this.fontTopShapes =this.stringToNumberConversion(fontTopString);
    }
  }
  sizedecreaseText(){
    if(this.multipleSelectOn == true){
      for (let ma = 0; ma < this.multiselectionList.length; ma++) {
        let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.multiselectionList[ma].layer_id);
        if (findLayerIndex != -1) {
          let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == this.multiselectionList[ma].annotation_id);
          if (findAnnotationIndexS != -1) {
            var currentAnnotation = this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS];
            let currentAttributeElement = document.getElementById("label" + currentAnnotation.annotation_id);
            let fontSizeString = currentAttributeElement.style.fontSize;
            this.textsize = this.stringToNumberConversion(fontSizeString);       
            this.sizedecrease1(currentAnnotation);
          }
        }
      }
    }
    else{
      this.sizedecrease1(this.propertiesannotationDataCopy);
    }
  }
  sizedecrease1(currentShape){
    if(currentShape.toolbar_element_id!=11){
      this.shapesLabelSize(currentShape)
    }
    let index=this.createDocumentStore.view_annotation_array.findIndex(item=>item.annotation_id==this.propertiesannotationDataCopy.annotation_id)
    if(index!=-1){
    var name=currentShape.annotation_label;
    var oldValues=this.getTextWidthandHeight(name,this.textsize);
    this.textsize=this.textsize-1;
    if(this.textsize<1){
      this.textsize = 1;
      return;
    }
    var newValues=this.getTextWidthandHeight(name,this.textsize)
    let difference=(oldValues.width-newValues.width)/2;
    if(currentShape.toolbar_element_id==11){
      var x=this.createDocumentStore.view_annotation_array[index].textshapetextx;
      x=x+difference;
      var y=this.createDocumentStore.view_annotation_array[index].textshapetexty;
      let heightDifference=(oldValues.height-newValues.height)/4;
      y=y-heightDifference;
    }
    else {
      x = this.fontLeftShapes;
      x = x + difference;
      y = this.fontTopShapes;
      let heightDifference = (oldValues.height - newValues.height) / 2;
      y = y + heightDifference;
    }
    this.textchange(x,y,index,currentShape);
    }
  }
  sizeincreaseText(){  
    if(this.multipleSelectOn == true){
      for (let ma = 0; ma < this.multiselectionList.length; ma++) {
        let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.multiselectionList[ma].layer_id);
        if (findLayerIndex != -1) {
          let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == this.multiselectionList[ma].annotation_id);
          if (findAnnotationIndexS != -1) {
            var currentAnnotation = this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS];
            let currentAttributeElement = document.getElementById("label" + currentAnnotation.annotation_id);
            let fontSizeString = currentAttributeElement.style.fontSize;
            this.textsize = this.stringToNumberConversion(fontSizeString);        
            this.sizeincrease1(currentAnnotation);
          }
        }
      }
    }
    else{
      this.sizeincrease1(this.propertiesannotationDataCopy);
    }
  }
  sizeincrease1(currentShape){
    if(currentShape.toolbar_element_id!=11){
      this.shapesLabelSize(currentShape)
    }
    let index=this.createDocumentStore.view_annotation_array.findIndex(item=>item.annotation_id==this.propertiesannotationDataCopy.annotation_id)
    if(index!=-1){
    var name = currentShape.annotation_label;
    var oldValues=this.getTextWidthandHeight(name,this.textsize)
    this.textsize=this.textsize+1;
    if(this.textsize>100){
      this.textsize = 100;
      return
    }
    var newValues=this.getTextWidthandHeight(name,this.textsize)
    let widthDifference=(newValues.width-oldValues.width)/2;
    var x,y;
      if (currentShape.toolbar_element_id==11) {
        x = this.createDocumentStore.view_annotation_array[index].textshapetextx;
        x = x - widthDifference;
        y = this.createDocumentStore.view_annotation_array[index].textshapetexty;
        let heightDifference = (newValues.height - oldValues.height) / 4;
        y = y + heightDifference;
      }
      else {
        x = this.fontLeftShapes;
        x = x - widthDifference;
        y = this.fontTopShapes;
        let heightDifference = (newValues.height - oldValues.height) / 2;
        y = y - heightDifference;
      }
      console.log(currentShape)
      this.textchange(x,y,index,currentShape);
    }
  }
  textchange(x,y,index,shape?){
    this.resizeLabelText = true;
    this.attribute_change = true;
    console.log(shape);
    console.log(this.createDocumentStore.view_annotation_array);
    
    if (this.createDocumentStore.view_annotation_array[index].toolbar_element_id==11) {
      if(this.backUpTextProperties == undefined){
        this.backUpTextProperties = { 'size': this.createDocumentStore.view_annotation_array[index].textfontSize, 'xPosition': this.createDocumentStore.view_annotation_array[index].textshapetextx, 'yPosition': this.createDocumentStore.view_annotation_array[index].textshapetexty }
      }

      this.createDocumentStore.view_annotation_array[index].textfontSize = this.textsize;
      this.createDocumentStore.view_annotation_array[index].textshapetextx = x;
      this.createDocumentStore.view_annotation_array[index].textshapetexty = y;
    }
    else{
      let currentAttributeElement = document.getElementById("label" + shape.annotation_id);

      if(this.backUpTextProperties == undefined){
        let font_old_size = Number(currentAttributeElement.style.fontSize.replace("px",""))
        let x = currentAttributeElement.style.left != undefined ? Number(currentAttributeElement.style.left.replace("px","")) : 0;
        let y = currentAttributeElement.style.top != undefined ? Number(currentAttributeElement.style.top.replace("px","")) : 0;
        this.backUpTextProperties = { 'size': font_old_size, 'xPosition': x, 'yPosition': y }
      }

      currentAttributeElement.style.fontSize=this.textsize + "px";
      currentAttributeElement.style.top=y + "px";
      currentAttributeElement.style.left=x + "px";
    }
  }
  textchangenumberText(size){
    console.log(size)
    if(this.multipleSelectOn == true){
      for (let ma = 0; ma < this.multiselectionList.length; ma++) {
        let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.multiselectionList[ma].layer_id);
        if (findLayerIndex != -1) {
          let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == this.multiselectionList[ma].annotation_id);
          if (findAnnotationIndexS != -1) {
            var currentAnnotation = this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS];
            let currentAttributeElement = document.getElementById("label" + currentAnnotation.annotation_id);
            let fontSizeString = currentAttributeElement.style.fontSize;
            this.textsize = this.stringToNumberConversion(fontSizeString);         
            this.textchangenumber(currentAnnotation,size);
          }
        }
      }
    }
    else{
      this.textchangenumber(this.propertiesannotationDataCopy,size)
    }
  }
  textchangenumber(shape?,size?) {
    let index = this.createDocumentStore.view_annotation_array.findIndex(item => item.annotation_id == shape.annotation_id)
    var oldValues:{'width':number,'height':number}, newValues:{'width':number,'height':number},xDifference: number, yDifference: number;
    if (shape.toolbar_element_id != 11) {
      this.shapesLabelSize(shape);
      var newTextSize1 = size;
      var oldTextSize1 = this.textsizeOriginal
      var name = shape.annotation_label;
      oldValues = this.getTextWidthandHeight(name, this.textsizeOriginal);
      console.log(typeof oldValues)
      newValues = this.getTextWidthandHeight(name, newTextSize1);
      this.textsize = newTextSize1;
      let x:number, y:number;
      if (oldTextSize1 < newTextSize1) {
        xDifference = (newValues.width - oldValues.width) / 2;
        yDifference = (newValues.height - oldValues.height) / 2;
        x = this.fontLeftShapes;
        if (xDifference < 0) {
          xDifference = -(xDifference);
        }
        if (yDifference < 0) {
          yDifference = -(yDifference);
        }
        x = x - xDifference;
        y = this.fontTopShapes;
        y = y - yDifference;
      }
      else {
        xDifference = (oldValues.width - newValues.width) / 2;
        yDifference = (oldValues.height - newValues.height) / 2;
        x = this.fontLeftShapes;
        if (xDifference < 0) {
          xDifference = -(xDifference);
        }
        if (yDifference < 0) {
          yDifference = -(yDifference);
        }
        x = x + xDifference;
        y = this.fontTopShapes;
        y = y + yDifference;
      }
      this.textchange(x, y, index,shape);
    }
    else {
      if (index != -1) {
        var oldTextSize = this.createDocumentStore.view_annotation_array[index].textfontSize;
        var name = shape.annotation_label;
        oldValues = this.getTextWidthandHeight(name, oldTextSize);
        newValues = this.getTextWidthandHeight(name, this.textsize);
        if (oldTextSize < this.textsize) {
          xDifference = (newValues.width - oldValues.width) / 2;
          yDifference = (newValues.height - oldValues.height) / 4;
          if (xDifference < 0) {
            xDifference = -(xDifference);
          }
          if (yDifference < 0) {
            yDifference = -(yDifference);
          }
          if (xDifference > 0 && yDifference > 0)
            var x = this.createDocumentStore.view_annotation_array[index].textshapetextx;
          x = x - xDifference;
          var y = this.createDocumentStore.view_annotation_array[index].textshapetexty;
          y = y + yDifference;
        }
        else {
          xDifference = (oldValues.width - newValues.width) / 2;
          yDifference = (oldValues.height - newValues.height) / 4;
          if (xDifference < 0) {
            xDifference = -(xDifference);
          }
          if (yDifference < 0) {
            yDifference = -(yDifference);
          }
          if (xDifference > 0 && yDifference > 0)
            var x = this.createDocumentStore.view_annotation_array[index].textshapetextx;
          x = x + xDifference;
          var y = this.createDocumentStore.view_annotation_array[index].textshapetexty;
          y = y - yDifference;
        }
        this.textchange(x, y, index);
      }
    }
  }

 
  checkCurrentActiveLayerProperties(){
    // current page details get from document pages
    let check_current_Page_active = this.documentDetails.filter((page_data_active) => page_data_active.page_id == this.currentPageId);
    if (check_current_Page_active.length > 0) {
      // active layer id based get data from document pages
      this.value = this.layerDatas.filter(layeritem => layeritem.layer_id == check_current_Page_active[0].active_layer_id);
      if(this.value.length==0){ 
        let find_layer_active_P2 =  this.layerDatas.filter(layeritem => this.createDocumentStore.data_allow_conditionT.includes(layeritem.is_active_flag));
        if(find_layer_active_P2.length>0){
          this.value = find_layer_active_P2;
        }
        else{
          this.value = [];
        }
      }
      if (this.value.length > 0) {
        this.activeLayerIdDraw = check_current_Page_active[0].active_layer_id;
        var p2=false;
        if(check_current_Page_active[0].active_layer_id == null){
          p2=true;
          this.activeLayerIdDraw = this.value[0].layer_id;
        }
        if(p2==false){
          let associated_pages = this.value[0].associated_pages;
        let page_element1 = associated_pages.filter(ele => ele.page_id == this.currentPageId)
        let get_lock = page_element1[0].is_lock;
        let get_visible = page_element1[0].is_hidden;
        if(get_lock == undefined){
          get_lock = this.value[0].is_locked_flag;
        }
        if(get_visible == undefined){
          get_visible = this.value[0].is_visible_flag;
          get_visible = Boolean(get_visible);
          get_visible = !get_visible;
        }
        if (this.createDocumentStore.data_allow_condition.includes(get_lock)) {
          this.lockedLayerActive = false;
        }
        else {
          this.lockedLayerActive = true;
        }
        if (this.createDocumentStore.data_allow_condition.includes(get_visible) && this.lockedLayerActive == false) {
          this.showvisible = true;
        }
        else {
          this.showvisible = false;
        }
        }
      }
    }
  }
  
  useUsToolbar() {
    this.addshapeToolbar = false;
    console.log(this.addshapeToolbar);
  }
  viewonly() {
    //VIEW ONLY MODE
    this.isReadonly = this.encrptdecrpt.getItem("viewonlys");
    console.log(this.isReadonly);
  }

  dataUndoArray: Array<any> = [];
  dataRedoArray: Array<any> = [];
  dataCurrentArray: Array<any> = [];
  undoLimit = 10;
  toolbar_id = "";
  getScaleValue: any[];
  toolbarListData: any;

  // ngOnInit(): void {
  //   this.show = true;
  //   this.securityCheck();
  //   this.getScaleValue = [];
  //   //remove pagezoom function

  //   // localStorage.removeItem('pagezoom');
  //   this.encrptdecrpt.removeItem("pagezoom");//security
  //   let time = performance.now();
  //   console.log(time);
  //   var start = new Date().getTime();
  //   console.log('toolbarlist' + ' Start time: ' + start);
  //   this.toolbarlistService.gettoolbarlist(this.projectId).subscribe((res) => {
  //     console.log(res);
  //     if(res["response_code"]==200){
  //       var end = new Date().getTime();
  //       var time = end - start;
  //       console.log('toolbarlist' + ' end time: ' + end);
  //       console.log('toolbarlist' + ' Execution time: ' + time);
  //     }
  //     if (res["response_code"] == 200 && res["response_body"]["toolbar_listing"] != null && res["response_body"]["toolbar_listing"].length > 0) {
  //       var toolData = res["response_body"]["toolbar_listing"];

  //       // let removeHiddenNum = toolData.filter((data) => { return data.is_hidden != 1 });
  //       // let removeHiddenBoolean = removeHiddenNum.filter((data) => { return data.is_hidden != true });

  //       let removeHiddenToolbar = toolData.filter((TData) => {
  //         if (TData.is_hidden != 1 && TData.is_hidden != true && TData.is_hidden != "1") {
  //           TData.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(TData.toolbar_name);
  //           return TData;
  //         }
  //       });
  //       this.toolbarListData = removeHiddenToolbar;

  //       if (removeHiddenToolbar.length == 0) {
  //         this.toolbarnone = true;

  //       }
  //       else {
  //         console.log(this.toolbarListData);
  //         this.dataService.sendMessagetoolbarlist(this.toolbarListData);
  //         this.toolbarListData.sort((a, b) => new Date(b.last_updated_date).getTime() - new Date(a.last_updated_date).getTime());
  //         console.log(this.toolbarListData);
  //         let data = this.toolbarListData[0];
  //         let localtoolbarId = this.lastseenToolbar_check();
  //         // check if toolbar delete or not. deleted mean show another toolbar
  //         let find_toolbar = this.toolbarListData.findIndex((tool)=>tool.toolbar_id==localtoolbarId);
  //         // let localtoolbarId = this.encrptdecrpt.getItem("toolbarId"); commented 20-01-2022
  //         if (localtoolbarId == "" || localtoolbarId == undefined || localtoolbarId == null || find_toolbar == -1) {
  //           this.toolbar_id = data.toolbar_id;
  //           // localStorage.setItem("toolbarId", this.toolbar_id);
  //         } else {
  //           this.toolbar_id = localtoolbarId;
  //           // localStorage.setItem("toolbarId", localtoolbarId);
  //         }
  //       }
  //       this.getDocumentDetails();
  //     }
  //     else if (res["response_code"] == 200 && res["response_body"]["toolbar_listing"] != null && res["response_body"]["toolbar_listing"].length == 0) {
  //       this.getDocumentDetails();
  //       this.toolbarListData = [];
  //     }
  //   });
  //   console.log(this.annotationSelected)


  //   this.dataService.deleteannotation.subscribe(
  //     data => {

  //       this.deleteannotationId = data;
  //     }
  //   );

  // }

  ngOnInit(): void {
    console.log(this.firstname, this.lastname)
    this.encrptdecrpt.setItem("rapidmodes",false);
    // load the document view first
    this.document_load();
  }

  document_load() {
    var start1 = new Date().getTime();
    console.log('function' + ' Start time: ' + start1);
    this.show = true;
    this.service.autocademit.emit({"response":[],"selected":false,"process_id":""})
    this.securityCheck();
    // last view page check function
    if (this.getOpenLinkWindow == false || this.getOpenLinkWindow == "false") {
      this.lastseendocument_storage('loading');
    }
    var start = new Date().getTime();
    console.log('getdocumentlist' + ' Start time: ' + start);
    this.documentService.getDocumentDetails(this.projectId, this.folderId).subscribe((response) => {
      console.log(response);
      if (response["response_code"] == 200) {
        var end = new Date().getTime();
        var time = end - start;
        console.log('getdocumentlist' + ' end time: ' + end);
        console.log('getdocumentlist' + ' Execution time: ' + time);
        this.documentDetails = response["response_body"]["document_list"];
        this.document_credential.set_current_document_value(response["response_body"]["document_list"]);
        if (this.documentDetails.length > 0) {
          if (this.getOpenLinkWindow == true || this.getOpenLinkWindow == "true") {
            // slide Index finding based on the page id becuase link pages navigate with page id only
            this.lastseendocument_storage_links('loading'); // find slideindex link documents open
          }
          this.currentPageNumber = Number(this.slideIndex) + 1;
          this.currentPageId = response["response_body"]["document_list"][this.slideIndex].page_id;
          this.realHeight = response["response_body"]["document_list"][this.slideIndex].height;
          this.realWidth = response["response_body"]["document_list"][this.slideIndex].width;
          console.log(this.projectId);
          let a = this.projectId.startsWith("1-")
          // Checking p2 or p3 project
          if(a == false){
            this.realHeight = this.realWidth < this.realHeight ? this.realHeight + 3 : this.realHeight
            this.realWidth = this.realWidth > this.realHeight ? this.realWidth + 3 : this.realWidth
          }
          this.documentService.createDocumentStore_values.document_width = this.realWidth;
          this.documentService.createDocumentStore_values.document_height = this.realHeight;
          if (response["response_body"]["document_path"] != "") {
            this.pngFormat = false;
            let imgurlTemp = response["response_body"]["document_path"];
            this.imgUrl = environment.APIBaseUrl + "get_web_singed_file?file=" + imgurlTemp + "&key1=" + this.imgdataService.securityKey1() + "&key2=" + this.imgdataService.securityKey2();
            this.pdfWidthHeight = { width: response["response_body"]["document_list"][this.slideIndex].width, height: response["response_body"]["document_list"][0].height };
            var start2 = new Date().getTime();
            console.log('pdf loading' + ' Start time: ' + start2);
            this.sequence_api_calling();
          }
          else {
            this.pngFormat = true;
            var end = new Date().getTime();
            var time = end - start;
            console.log('getdocumentlist' + ' end time: ' + end);
            console.log('getdocumentlist' + ' Execution time: ' + time);
            let imgurlTemp = response["response_body"]["document_list"][this.slideIndex].file_path;
            this.imgUrl = environment.APIBaseUrl + "get_web_singed_file?file=" + imgurlTemp + "&key1=" + this.imgdataService.securityKey1() + "&key2=" + this.imgdataService.securityKey2();
            this.sequence_api_calling();
            this.image_fit();
          }
          // user permission new api values get process
          this.userrole = get_user_role(response["response_body"]["user_permission"]);
          console.log(this.userrole);
          this.encrptdecrpt.setItem("userrole", this.projectId + "||" + this.userrole);//security
          // check set base icon size 
          if (response["response_body"]["document_list"][this.slideIndex].page_icon_data != null) {
            this.iconsize1 = response["response_body"]["document_list"][this.slideIndex].page_icon_data;
            var stringify = JSON.parse(this.iconsize1);
            this.seticonheight = stringify.height;
            this.seticonwidth = stringify.width;
          }
          // store current page details and share current page details to header
          this.currentPageId = this.documentDetails[this.slideIndex].page_id;
          this.totalPages = this.documentDetails.length;
          this.pageName = this.documentDetails[this.slideIndex].page_name;
          let document_input = {
            pageNumber: this.currentPageNumber, document_details: response["response_body"]["document_list"],
            pngFormat: this.pngFormat, imgUrl: this.imgUrl, currentPageId: this.currentPageId, pageName: this.pageName
          };
          this.document_credential.update_current_documents_data(document_input);
        }
      }
      else {
        this.errorMessage();
      }
      if (this.layerEnable == true) {
        let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
        let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: this.checkedAnnotationIdsBackup, currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
        console.log(data);
        this.dataService2.layerDatafromnavigation.emit(data);
      }
    });
  }


  // original document page
  // getDocumentDetails() {
  //   // last view page check function
  //   if(this.getOpenLinkWindow == false || this.getOpenLinkWindow == "false"){
  //     this.lastseendocument_storage('loading');
  //   }
  //   // last view page check function
  //   var start = new Date().getTime();
  //   console.log('document pages list' + ' Start time: ' + start);
  //   this.documentService.getDocumentDetails(this.projectId, this.folderId).subscribe((response) => {
  //     console.log(response);
  //     if(response["response_code"]==200){
  //       var end = new Date().getTime();
  //       var time = end - start;
  //       console.log('document pages list' + ' end time: ' + end);
  //       console.log('document pages list' + ' Execution time: ' + time);
  //     }
  //     if (response["response_code"] == 200) {
  //       // user permission new api values get process
  //       let get_user_permission = response["response_body"]["user_permission"];
  //       if (get_user_permission != undefined && get_user_permission != null &&
  //         get_user_permission.length > 0) {

  //         if (get_user_permission[0].admin_permission_flag == true) {
  //           this.userrole = "admin";
  //         }
  //         else if (get_user_permission[0].edit_permission_flag == true) {
  //           this.userrole = "edit";
  //         }
  //         else if (get_user_permission[0].view_permission_flag == true) {
  //           this.userrole = "view";
  //         }
  //         else if (get_user_permission[0].view_permission_flag == false && get_user_permission[0].edit_permission_flag == false
  //           && get_user_permission[0].admin_permission_flag == false) {
  //           this.userrole = "view";
  //         }
  //         this.encrptdecrpt.setItem("userrole", this.projectId + "||" + this.userrole);//security
  //       }
  //       if (response["response_body"]["document_path"] != "") {
  //         this.documentDetails = response["response_body"]["document_list"];
  //         if(this.getOpenLinkWindow == true || this.getOpenLinkWindow == "true"){
  //           this.lastseendocument_storage_links('loading');
  //         }
  //         this.documentURL.push(response["response_body"]["document_path"]);
  //         let imgurlTemp = response["response_body"]["document_path"];
  //         this.imgUrl = environment.APIBaseUrl + "get_web_singed_file?file=" + imgurlTemp + "&key1=" + this.imgdataService.securityKey1() + "&key2=" + this.imgdataService.securityKey2();
  //         this.dataService.documentlistSend.emit(this.documentDetails);
  //         this.pdfPageNumber = Number(this.slideIndex) + 1;
  //         this.pngFormat = false;
  //         this.datavalues = response["response_body"];
  //         this.dataService.sendMessagegetDocumentdetails(this.documentDetails);
  //         if(this.documentDetails.length>0){
  //           this.pdfWidthHeight = { width: response["response_body"]["document_list"][this.slideIndex].width, height: response["response_body"]["document_list"][0].height };
  //           this.realHeight = response["response_body"]["document_list"][this.slideIndex].height;
  //           this.realWidth = response["response_body"]["document_list"][this.slideIndex].width;
  //           if (response["response_body"]["document_list"][this.slideIndex].page_icon_data != null) {
  //             this.iconsize1 = response["response_body"]["document_list"][this.slideIndex].page_icon_data
  //             var stringify = JSON.parse(this.iconsize1);
  //             this.seticonheight = stringify.height;
  //             this.seticonwidth = stringify.width;
  //           }
  //           this.cdRef.detectChanges();
  //           if(this.getOpenLinkWindow == false || this.getOpenLinkWindow == "false"){
  //             this.currentPageId = this.documentDetails[this.slideIndex].page_id;
  //             this.documentPage.currentPageId.emit(this.currentPageId);
  //             this.totalPages = this.documentDetails.length;
  //             this.documentPage.sendPageNumber.emit(this.totalPages);
  //             this.pageName = this.documentDetails[this.slideIndex].page_name;
  //             let senddata = { data: this.documentDetails, pageno: this.documentDetails[this.slideIndex].page_number, pdfPath: this.imgUrl, pngFormat: this.pngFormat };
  //             this.dataService.sendPageDatawithNumber.emit(senddata);
  //             this.dataService.pageName.emit(this.pageName);
  //             this.documentPage.singlePagenumber.emit(this.documentDetails[this.slideIndex].page_number);
  //           }
  //           else if (this.getOpenLinkWindow == true || this.getOpenLinkWindow == "true") {
  //             let find_page_id_base =  this.documentDetails.findIndex((page_detail)=>page_detail.page_id==this.pageId);
  //             if(find_page_id_base > -1){
  //               this.currentPageId = this.documentDetails[find_page_id_base].page_id;
  //               this.documentPage.currentPageId.emit(this.currentPageId);
  //               this.totalPages = this.documentDetails.length;
  //               this.documentPage.sendPageNumber.emit(this.totalPages);
  //               this.pageName = this.documentDetails[find_page_id_base].page_name;
  //               let senddata = { data: this.documentDetails, pageno: this.documentDetails[find_page_id_base].page_number, pdfPath: this.imgUrl, pngFormat: this.pngFormat };
  //               this.dataService.sendPageDatawithNumber.emit(senddata);
  //               this.dataService.pageName.emit(this.pageName);
  //               this.documentPage.singlePagenumber.emit(this.documentDetails[find_page_id_base].page_number);
  //             }
  //           }
  //         }
  //         this.getActiveLayerIdMain();
  //       }
  //       else {
  //         this.pngFormat = true;
  //         this.documentDetails = response["response_body"]["document_list"];
  //         if(this.getOpenLinkWindow == true || this.getOpenLinkWindow == "true"){
  //           this.lastseendocument_storage_links('loading');
  //         }
  //         this.pageName = response["response_body"]["document_list"][this.slideIndex].page_name;
  //         this.dataService.pageName.emit(this.pageName);
  //         let senddata = { data: this.documentDetails, pageno: this.documentDetails[this.slideIndex].page_number, pdfPath: this.imgUrl, pngFormat: this.pngFormat };
  //         this.dataService.sendPageDatawithNumber.emit(senddata);
  //         this.dataService.documentlistSend.emit(this.documentDetails);
  //         if (this.documentDetails != undefined && this.documentDetails.length>0) {
  //           for (let i = 0; i < this.documentDetails.length; i++) {
  //             this.documentURL.push(this.documentDetails[i].file_path);
  //             if (this.slideIndex == i) {
  //               if (response["response_body"]["document_list"][i].page_icon_data != null) {
  //                 this.iconsize1 = response["response_body"]["document_list"][i].page_icon_data
  //                 var stringify = JSON.parse(this.iconsize1);
  //                 this.seticonheight = stringify.height;
  //                 this.seticonwidth = stringify.width;
  //               }
  //               this.currentPageId = this.documentDetails[i].page_id;
  //               this.documentPage.currentPageId.emit(this.currentPageId);
  //             }
  //           }
  //           this.totalPages = this.documentDetails.length;
  //           this.documentPage.sendPageNumber.emit(this.totalPages);
  //           //
  //           if (this.getOpenLinkWindow == false || this.getOpenLinkWindow == "false") {
  //             let imgurlTemp = this.documentDetails[this.slideIndex].file_path;
  //             this.imgUrl = environment.APIBaseUrl + "get_web_singed_file?file=" + imgurlTemp + "&key1=" + this.imgdataService.securityKey1() + "&key2=" + this.imgdataService.securityKey2();
  //             var img = document.createElement("img");
  //             this.documentPage.singlePagenumber.emit(this.documentDetails[this.slideIndex].page_number)
  //             img.onload = () => {
  //               this.realWidth = img.width;
  //               this.realHeight = img.height;
  //               this.documentService.createDocumentStore_values.document_width = img.width;
  //               this.documentService.createDocumentStore_values.document_height = img.height;
  //               console.log("this.realWidth", this.realWidth);
  //               console.log("this.realHeight", this.realHeight);
  //               let getImageContainer = document.getElementById("Imagecontainer");
  //               let getImageContainerSize = getImageContainer.getBoundingClientRect();
  //               if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
  //                 let disableScale = false;
  //                 var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
  //                 console.log(scale_val);
  //                 // this.scaleValue = scale_val;
  //                 this.getAnnotationForm();

  //                 this.scale = scale_val;
  //                 let currentViewX = this.realWidth * scale_val;
  //                 let currentViewY = this.realHeight * scale_val;
  //                 let centerX = getImageContainerSize.width - currentViewX;
  //                 let centerY = getImageContainerSize.height - currentViewY;
  //                 const x1 = this.realWidth;
  //                 const y1 = this.realHeight;
  //                 let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
  //                   initialZoom: scale_val,
  //                 });
  //                 let viewImageDiv = document.getElementById("pdfImg");
  //                 viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
  //                 viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
  //                 panZoomElement.on('transform', (e: any) => {
  //                   // This event will be called along with events above.
  //                   console.log('Fired when any transformation has happened', e);
  //                   console.log(panZoomElement.getTransform());
  //                   panZoomElement.pause();
  //                 });
  //                 // calling Page Zoom maintain function
  //                 this.pagewise_zoom_storage();
  //               }
  //               else {
  //                 let centerX = getImageContainerSize.width - this.realWidth;
  //                 let centerY = getImageContainerSize.height - this.realHeight;
  //                 let viewImageDiv = document.getElementById("pdfImg");
  //                 this.scale = 1;
  //                 this.scaleValue = 1;                  
  //                 this.getAnnotationForm();
  //                 viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
  //                 viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
  //                 // calling Page Zoom maintain function
  //                 this.pagewise_zoom_storage();
  //               }
  //             };
  //             img.onerror = (error) => {
  //               //this.show = false;
  //               fetch(this.imgUrl)
  //                 .then((res) => res.blob())
  //                 .then((blob) => heic2any({
  //                   blob,
  //                   toType: "image/jpeg", 
  //                 }).catch((e) => {
  //                   console.log(e);
  //                 }))
  //                 .then((conversionResult: any) => {
  //                   var url = URL.createObjectURL(conversionResult);
  //                   let element: any = document.getElementById('scene');
  //                   element.src = url;
  //                   var error_img = document.createElement("img");
  //                   error_img.onload = () => {
  //                     this.realWidth = error_img.width;
  //                     this.realHeight = error_img.height;
  //                     this.documentService.createDocumentStore_values.document_width = error_img.width;
  //                     this.documentService.createDocumentStore_values.document_height = error_img.height;
  //                     console.log("this.realWidth", this.realWidth);
  //                     console.log("this.realHeight", this.realHeight);
  //                     let getImageContainer = document.getElementById("Imagecontainer");
  //                     let getImageContainerSize = getImageContainer.getBoundingClientRect();
  //                     if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
  //                       let disableScale = false;
  //                       var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
  //                       console.log(scale_val);
  //                       // this.scaleValue = scale_val;
  //                       this.getAnnotationForm();

  //                       this.scale = scale_val;
  //                       let currentViewX = this.realWidth * scale_val;
  //                       let currentViewY = this.realHeight * scale_val;
  //                       let centerX = getImageContainerSize.width - currentViewX;
  //                       let centerY = getImageContainerSize.height - currentViewY;
  //                       const x1 = this.realWidth;
  //                       const y1 = this.realHeight;
  //                       let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
  //                         initialZoom: scale_val,
  //                       });
  //                       let viewImageDiv = document.getElementById("pdfImg");
  //                       viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
  //                       viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
  //                       panZoomElement.on('transform', (e: any) => {
  //                         // This event will be called along with events above.
  //                         console.log('Fired when any transformation has happened', e);
  //                         console.log(panZoomElement.getTransform());
  //                         panZoomElement.pause();

  //                         // panZoomElement.getTransform().scale = scale_val;
  //                       });
  //                     }
  //                     else {
  //                       let centerX = getImageContainerSize.width - this.realWidth;
  //                       let centerY = getImageContainerSize.height - this.realHeight;
  //                       let viewImageDiv = document.getElementById("pdfImg");
  //                       this.scaleValue = 1;
  //                       this.getAnnotationForm();
  //                       viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
  //                       viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
  //                     }
  //                   }
  //                   error_img.src = url;
  //                 })
  //                 .catch((e) => {
  //                   console.log(e);
  //                 });
  //             }
  //             img.src = this.imgUrl;
  //           }
  //           else if(this.getOpenLinkWindow == true || this.getOpenLinkWindow == "true") {
  //             let find_page_id_base = this.documentDetails.findIndex((page_detail_image) => page_detail_image.page_id == this.pageId);
  //             if (find_page_id_base > -1) {
  //               this.currentPageId = this.pageId;
  //               this.documentPage.currentPageId.emit(this.currentPageId);
  //               let imgurlTemp = this.documentDetails[find_page_id_base].file_path;
  //               this.imgUrl = environment.APIBaseUrl + "get_web_singed_file?file=" + imgurlTemp + "&key1=" + this.imgdataService.securityKey1() + "&key2=" + this.imgdataService.securityKey2();
  //               this.pageName = this.documentDetails[find_page_id_base].page_name;
  //               let senddata = { data: this.documentDetails, pageno: this.documentDetails[find_page_id_base].page_number, pdfPath: this.imgUrl, pngFormat: this.pngFormat };
  //               this.dataService.sendPageDatawithNumber.emit(senddata);
  //               this.dataService.pageName.emit(this.pageName);
  //               this.documentPage.singlePagenumber.emit(this.documentDetails[find_page_id_base].page_number);
  //               var img = document.createElement("img");
  //               img.onload = () => {
  //                 this.realWidth = img.width;
  //                 this.realHeight = img.height;
  //                 this.documentService.createDocumentStore_values.document_width = img.width;
  //                 this.documentService.createDocumentStore_values.document_height = img.height;
  //                 console.log("this.realWidth", this.realWidth);
  //                 console.log("this.realHeight", this.realHeight);
  //                 let getImageContainer = document.getElementById("Imagecontainer");
  //                 console.log(getImageContainer);
  //                 let getImageContainerSize = getImageContainer.getBoundingClientRect();
  //                 console.log(getImageContainerSize);
  //                 if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
  //                   let disableScale = false;
  //                   var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
  //                   console.log(scale_val);
  //                   this.scaleValue = scale_val;
  //                   this.getAnnotationForm();
  //                   this.scale = scale_val;
  //                   let currentViewX = this.realWidth * scale_val;
  //                   let currentViewY = this.realHeight * scale_val;
  //                   let centerX = getImageContainerSize.width - currentViewX;
  //                   let centerY = getImageContainerSize.height - currentViewY;
  //                   const x1 = this.realWidth;
  //                   const y1 = this.realHeight;
  //                   console.log(x1, y1, centerX, centerY);
  //                   let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
  //                     initialZoom: scale_val,
  //                   });
  //                   let viewImageDiv = document.getElementById("pdfImg");
  //                   viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
  //                   viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
  //                   panZoomElement.on('transform', (e: any) => {
  //                     // This event will be called along with events above.
  //                     console.log('Fired when any transformation has happened', e);
  //                     console.log(panZoomElement.getTransform());
  //                     panZoomElement.pause();

  //                     // panZoomElement.getTransform().scale = scale_val;
  //                   });

  //                 }
  //                 else {
  //                   let centerX = getImageContainerSize.width - this.realWidth;
  //                   let centerY = getImageContainerSize.height - this.realHeight;
  //                   let viewImageDiv = document.getElementById("pdfImg");
  //                   this.scaleValue = 1;
  //                   this.getAnnotationForm();
  //                   viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
  //                   viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
  //                 }
  //               };
  //               img.src = this.imgUrl;
  //             }
  //           }
  //         }
  //         this.getActiveLayerIdMain();
  //       }
  //     }
  //     else{
  //       this.errorMessage();
  //     }
  //     if (this.layerEnable == true) {
  //       let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
  //       let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: this.checkedAnnotationIdsBackup, currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
  //       console.log(data);
  //       this.dataService2.layerDatafromnavigation.emit(data);
  //     }
  //   });


  // }

  remainder() {
    this.previousRoute = "/index";
    let remainderbox = this.dialogBox.open(RemainderPopupComponent, {
      disableClose: true,
      width: '500px',
    });
  }

  getActiveLayerIdMain() {
    let findPageData = this.documentDetails.filter((pagedata) => pagedata.page_id == this.currentPageId);
    if (findPageData.length > 0) {
      this.activeLayerIdDraw = findPageData[0].active_layer_id;
    }
    if(this.activeLayerIdDraw==null && this.activeLayerIdDraw==undefined){
      if(this.layerDatas!=undefined && this.layerDatas!=null)
      {
        for(var i=0;i<this.layerDatas.length;i++)
        {
          if(this.createDocumentStore.data_allow_conditionT.includes(this.layerDatas[i].is_visible_flag))
          {
            this.activeLayerIdDraw=this.layerDatas[i].layer_id;
          }
        }
      }
    }
  }

  modelFieldsForm: any = [];
  extend_modelFieldsForm: any = [];
  is_extend: boolean = false;
  newFormData: any;
  
  callBackgetFormData = (value) => {
    var weldformswitch = false;
    this.formContentleft = [];
    this.formContentright = [];
    this.useCaseEmptycellIds = []
    if(Array.isArray(value.form_data) == false){
       value.form_data = JSON.parse(value.form_data)
    }
    let copymodelform = _.cloneDeep(value.form_data);
    if (copymodelform != null) {
      let weldIndex = copymodelform.findIndex((id) => id.element_type == "uti-entry-field-WMATA_WELD");
      if (weldIndex != -1) {
        weldformswitch = true;
      }
    }
    let isForm = null;
    if (this.multipleSelectOn == false && this.currentSelectedAnnotationData.annotation_forms!=undefined) {
      
      // let annotationForms = this.currentSelectedAnnotationData.annotation_forms;
      let annotationForms = this.currentSelectedAnnotationData.annotation_forms.filter((forms) => this.createDocumentStore.data_allow_condition.includes(forms.is_removed))
      let find_form_index = annotationForms.findIndex((data) => data.form_id == value.form_id);

      if (find_form_index > -1) {
        let find_layer = this.layerDatas.findIndex((layer) => layer.layer_id == this.currentSelectedAnnotationData.layer_id);
        if (find_layer > -1) {
          // find annotationIndex
          let annot_index = this.layerDatas[find_layer].annotations.findIndex((annot) => annot.annotation_id == this.currentSelectedAnnotationData.annotation_id);
          if (annot_index > -1) {
            if (this.layerDatas[find_layer].annotations[annot_index].annotation_forms.length > 0) {
              let change_form = this.layerDatas[find_layer].annotations[annot_index].annotation_forms;
              change_form.push(change_form.splice(find_form_index, 1)[0]);
              this.layerDatas[find_layer].annotations[annot_index].annotation_forms = change_form;
            }
          }
        }
        console.log('Form Already Attached', value.canClose);
        isForm = false;
      
        for (let a = 0; a < annotationForms.length; a++) {
          if (annotationForms[a].form_id == value.form_id) {
            let get_db_data_forms = annotationForms[a];
            if (get_db_data_forms != undefined) {
              get_db_data_forms.form_name = this.dataService4.changeSpecialtoKeyFormat(get_db_data_forms.form_name);
              let get_cur_formdata = get_db_data_forms.form_data;
              if (Array.isArray(get_cur_formdata)) {
                if (get_cur_formdata.length > 0) {
                  get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
                }
              } else {
                get_cur_formdata = JSON.parse(get_cur_formdata);
                if (get_cur_formdata != null && get_cur_formdata.length > 0) {
                  get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
                }
              }
              if (get_db_data_forms.is_extend == true) {
                if (get_db_data_forms.hasOwnProperty('ext_form_data')) {
                  if (get_db_data_forms.ext_form_data != null) {
                    let get_cur_ext_formdata = get_db_data_forms.ext_form_data;
                    if (Array.isArray(get_cur_ext_formdata)) {
                      if (get_cur_ext_formdata.length > 0) {
                        get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                      }
                    } else {
                      get_cur_ext_formdata = JSON.parse(get_cur_ext_formdata);
                      if (get_cur_ext_formdata.length > 0) {
                        get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                      }
                    }
                  }
                }
              }

            }
            annotationForms[a] = get_db_data_forms
            this.currentFormId = annotationForms[a].form_id;
          
            let check_form_name = this.formListDefaultValues.filter((f_name) => f_name.form_id == this.currentFormId);
            if (check_form_name.length > 0) {
              this.currentFormName = check_form_name[0].form_name;
            }
            else {
              this.currentFormName = annotationForms[a].form_name;
            }
            this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
            // this.currentFormName = annotationForms[a].form_name;
            this.currentFormHiddenStatus = JSON.parse(annotationForms[a].is_hidden);
            
            if (this.currentFormHiddenStatus == false) {
              this.colorvalid = false;
            } else {
              this.colorvalid = true;
            }
            if (annotationForms[a].hasOwnProperty('is_extend')) {
              this.is_extend = annotationForms[a].is_extend;
            } else {
              this.is_extend = false;
            }
            if (this.createDocumentStore.data_allow_condition.includes(this.is_extend)) {
              this.is_extend = false;
            } else {
              this.is_extend = true;
            }
            var newFormDataFelds;
            let ext_newFormDataFelds = [];
            if (Array.isArray(annotationForms[a].form_data) == false) {
              if(annotationForms[a].form_data!=undefined){
              newFormDataFelds = JSON.parse(annotationForms[a].form_data)
              }
            } else {
              newFormDataFelds = annotationForms[a].form_data
            }
            let clone_model_fiels = _.cloneDeep(annotationForms[a].form_data)
            if (check_form_name[0].form_data != undefined && check_form_name[0].form_data != null) {
              if (Array.isArray(check_form_name[0].form_data) == false) {
                check_form_name[0].form_data = JSON.parse(check_form_name[0].form_data)
              } else {
                check_form_name[0].form_data = check_form_name[0].form_data
              }
            }
            if(weldformswitch == true){
              let clonenewFormDataFelds = _.cloneDeep(clone_model_fiels);
              let weldform = clonenewFormDataFelds.filter((id) => id.element_type == "uti-entry-field-WMATA_WELD")
              if(weldform.length > 0){
              var welditem = weldform[0];
              }
            }
            newFormDataFelds = this.merge_form_process(clone_model_fiels, check_form_name[0].form_data, 'leftside');
            newFormDataFelds = newFormDataFelds == null ? [] : newFormDataFelds;
            newFormDataFelds = newFormDataFelds.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
            console.log(this.layerDatas);
            // The below codes are added to change the old form data in layer datas to new form data(merge form)
            let find_layer = this.layerDatas.findIndex((layer) => layer.layer_id == this.currentSelectedAnnotationData.layer_id);
            if (find_layer > -1) {
              let annot_index = this.layerDatas[find_layer].annotations.findIndex((annot) => annot.annotation_id == this.currentSelectedAnnotationData.annotation_id);
              if (annot_index > -1) {
                if (this.layerDatas[find_layer].annotations[annot_index].annotation_forms.length > 0) {
                  let change_form = this.layerDatas[find_layer].annotations[annot_index].annotation_forms;
                  let form_index =  change_form.findIndex((id)=>id.form_id == value.form_id);
                  if(form_index > -1){
                    change_form[form_index].form_data = newFormDataFelds
                  }
                }
              }
            }
            if (annotationForms[a].ext_form_data != null && annotationForms[a].ext_form_data != undefined && annotationForms[a].ext_form_data != "") {
              if (Array.isArray(annotationForms[a].ext_form_data) == false) {
                ext_newFormDataFelds = JSON.parse(annotationForms[a].ext_form_data)
              } else {
                ext_newFormDataFelds = annotationForms[a].ext_form_data;
              }
              let clone_extend_model_fiels = _.cloneDeep(annotationForms[a].ext_form_data)
              if (check_form_name[0].ext_form_data != undefined && check_form_name[0].ext_form_data != null) {
                if (Array.isArray(check_form_name[0].ext_form_data) == false) {
                  check_form_name[0].ext_form_data = JSON.parse(check_form_name[0].ext_form_data)
                } else {
                  check_form_name[0].ext_form_data = check_form_name[0].ext_form_data
                }
              }
              
              ext_newFormDataFelds = this.merge_form_process(clone_extend_model_fiels, check_form_name[0].ext_form_data, 'rightside');
              if(weldformswitch == true){
                let copyextendform = _.cloneDeep(ext_newFormDataFelds);
                  let index = copyextendform.findIndex((type) => type.element_type == "uti-entry-field-WMATA_WELD");
                  if (index == -1) {
                    ext_newFormDataFelds.push(welditem);
                  }
              }
            }
            // converting special characters
            let getforms = newFormDataFelds;
            if (getforms != undefined && getforms.length > 0) {
              //start converting
              let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
              newFormDataFelds = change_character_res;
            }
            this.modelFieldsForm = newFormDataFelds;
            this.modelFieldsForm = this.removeHiddenFields(newFormDataFelds, annotationForms[a].form_data);
            // this.toolbarElements_view_svg = this.removeHiddenFields(newFormDataFelds, annotationForms[a].form_data);

            if (this.is_extend == true) {
              if (ext_newFormDataFelds != undefined && ext_newFormDataFelds != null && ext_newFormDataFelds.length > 0) {
                ext_newFormDataFelds = ext_newFormDataFelds.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                // converting special characters
                let getforms = ext_newFormDataFelds;
                if (getforms != undefined && getforms.length > 0) {
                  //start converting
                  let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                  ext_newFormDataFelds = change_character_res;
                }
                this.extend_modelFieldsForm = ext_newFormDataFelds;
                if(weldformswitch == false){
                  this.extend_modelFieldsForm = this.removeHiddenFields(ext_newFormDataFelds, annotationForms[a].ext_form_data)
                }

                let merge_forms = [...newFormDataFelds, ...ext_newFormDataFelds]

                this.undoDatataForForms = _.cloneDeep(merge_forms);
                this.usecaseCopyArray = _.cloneDeep(merge_forms);

                this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                if (this.extend_modelFieldsForm.length > 0) {
                  for (let v = 0; v < this.extend_modelFieldsForm.length; v++) {
                    if (this.extend_modelFieldsForm[v].element_type == "uti-entry-field") {
                      this.outputArray = []
                      this.finalArray1 = []
                      var fff = this.extend_modelFieldsForm[v].element_data["fields"];
                      for (let k = 0; k < this.extend_modelFieldsForm[v].element_data['fields'].length; k++) {
                        if (this.extend_modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                          for (let j = 0; j < this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                            this.outputArray.push({ 'id': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                          }
                        }
                      }
                      this.elementFields = this.extend_modelFieldsForm[v].element_data['fields']
                      if (this.extend_modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                        if (this.extend_modelFieldsForm[v].element_data['default_values'] != "") {
                          this.finalArray = this.extend_modelFieldsForm[v].element_data['default_values']
                          this.displayArryChange(this.extend_modelFieldsForm[v].element_data['fields'], this.extend_modelFieldsForm[v].element_data['default_values'])
                        } else {
                          this.finalArray = []
                        }
                      } else {
                        this.finalArray = []
                      }
                    }
                    if (this.extend_modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                      this.totalElementQuantity = Number(this.extend_modelFieldsForm[v].element_data.default_value);
                      this.htmlcalculation();
                    }
                    if (this.extend_modelFieldsForm[v].element_type == "date") {
                    
                      if (this.extend_modelFieldsForm[v].element_data.default_date_time != "") {
                        if (this.extend_modelFieldsForm[v].element_data.default_date_time == "none" || this.extend_modelFieldsForm[v].element_data.default_date_time == "current") {
                          // this.extend_modelFieldsForm[v].element_data.default_value = this.assignDates(this.extend_modelFieldsForm[v].element_data.default_date_time)
                        } else {
                          this.extend_modelFieldsForm[v].element_data.default_date_time = new Date(this.extend_modelFieldsForm[v].element_data.default_date_time).toISOString();
                        }
                      }
                    }
                  }
                }
              }
            } else {
              this.undoDatataForForms = _.cloneDeep(newFormDataFelds);
              this.usecaseCopyArray = _.cloneDeep(newFormDataFelds);
            }

            this.process_use_conditions();
            this.FormulaCalc();
            this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
            if (this.modelFieldsForm.length > 0) {
              for (let v = 0; v < this.modelFieldsForm.length; v++) {
                if (this.modelFieldsForm[v].element_type == "uti-entry-field") {
                  this.outputArray = []
                  this.finalArray1 = []
                  var fff = this.modelFieldsForm[v].element_data["fields"];
                  for (let k = 0; k < this.modelFieldsForm[v].element_data['fields'].length; k++) {
                    if (this.modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                      for (let j = 0; j < this.modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                        this.outputArray.push({ 'id': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                      }
                    }
                  }
                  this.elementFields = this.modelFieldsForm[v].element_data['fields']
                  if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                    if (this.modelFieldsForm[v].element_data['default_values'] != "") {
                      this.finalArray = this.modelFieldsForm[v].element_data['default_values']
                      this.displayArryChange(this.modelFieldsForm[v].element_data['fields'], this.modelFieldsForm[v].element_data['default_values'])
                    } else {
                      this.finalArray = []
                    }
                  } else {
                    this.finalArray = []
                  }
                }
                else if (this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA") {
                  // make default values array of json
                  if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values') && this.modelFieldsForm[v].element_data.default_values != undefined && this.modelFieldsForm[v].element_data.default_values != "") {
                    let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                    let get_element_fields = this.modelFieldsForm[v].element_data['fields']
                    this.UTIEntry_field_Wmata(get_element_fields, get_default_value);
                  }
                  else {
                    // if default values is empty purpose
                    this.finalArray2 = [];
                  }
                  // switch form automatic color updates

                }
                else if (this.modelFieldsForm[v].element_type == "uti-entry-field-TIMBER") {
                  this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
                }
                else if (this.modelFieldsForm[v].element_type == "date") {
                
                  if (this.modelFieldsForm[v].element_data.default_date_time != "") {
                    if (this.modelFieldsForm[v].element_data.default_date_time == "none" || this.modelFieldsForm[v].element_data.default_date_time == "current") {
                      //   this.modelFieldsForm[v].element_data.default_date_time = this.assignDates(this.modelFieldsForm[v].element_data.default_date_time)
                    } else {
                      this.modelFieldsForm[v].element_data.default_date_time = new Date(this.modelFieldsForm[v].element_data.default_date_time).toISOString();
                    }
                  }
                }
                else if(this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA_WELD"){
                  if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values') && this.modelFieldsForm[v].element_data.default_values != undefined && this.modelFieldsForm[v].element_data.default_values != "") {
                    const copyweldform =_.cloneDeep(this.modelFieldsForm[v]);
                   this.copyweldForm = copyweldform;
                    let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                    const fields = this.modelFieldsForm[v].element_data.fields;
                    this.fieldsWeld = fields; 
                    let weldArray = this.convertUUIDtoNormal(get_default_value);
                    this.splitarray(weldArray);
                  }
                }
                if (this.modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                  this.totalElementQuantity = Number(this.modelFieldsForm[v].element_data.default_value);
                  this.htmlcalculation();
                }

              }
            }
            this.copyOfFormModelfield = this.modelFieldsForm;
          }
        }
      }
      else {
        isForm = true;
      }
      if (isForm == true) {
        console.log('Form new Attached');
        let get_db_data_forms = value;
        if (get_db_data_forms != undefined) {
          this.show = true;
          get_db_data_forms.form_name = this.dataService4.changeSpecialtoKeyFormat(get_db_data_forms.form_name);
          let get_cur_formdata = get_db_data_forms.form_data;
          if (Array.isArray(get_cur_formdata)) {
            if (get_cur_formdata.length > 0) {
              get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
            }
          } else {
            console.log(JSON.stringify(get_cur_formdata));
            get_cur_formdata = JSON.parse(get_cur_formdata);
            if (get_cur_formdata != null && get_cur_formdata.length > 0) {
              get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
            }
          }
          if (get_db_data_forms.is_extend == true) {
            if (get_db_data_forms.hasOwnProperty('ext_form_data')) {
              if (get_db_data_forms.ext_form_data != null) {
                let get_cur_ext_formdata = get_db_data_forms.ext_form_data;
                if (Array.isArray(get_cur_ext_formdata)) {
                  if (get_cur_ext_formdata.length > 0) {
                    get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                  }
                } else {
                  get_cur_ext_formdata = JSON.parse(get_cur_ext_formdata);
                  if (get_cur_ext_formdata.length > 0) {
                    get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                  }
                }
              }
            }
          }
        }
        value = get_db_data_forms;
        this.formId = value.form_id;
        var formelementCount;
        if (Array.isArray(value.form_data) == false) {
          formelementCount = JSON.parse(value.form_data);
        } else {
          formelementCount = value.form_data;
        }
        if (value.form_data == null) {
          formelementCount = [];
        }
        var ext_formelementCount = null;
        if (value.is_extend == true && value.ext_form_data != null) {
          if (Array.isArray(value.ext_form_data) == false) {
            ext_formelementCount = JSON.parse(value.ext_form_data);
          } else {
            ext_formelementCount = value.ext_form_data;
          }
        }

        formelementCount = formelementCount.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
        let formData = {
          annotation_id: this.getId,
          created_by_user_id: this.su.user_id,
          form_data: formelementCount,
          ext_form_data: ext_formelementCount,
          ext_form_element_count: value.ext_form_element_count,
          // form_data: this.modelFieldsForm,
          form_element_count: formelementCount.length,
          form_name: value.form_name,
          // form_id: this.formId,
          form_id: value.form_id,
          isLocalModified: 0,
          is_default_flag: 0,
          is_hidden: 0,
          is_removed: 0,
          is_extend: value.is_extend,
          last_updated_date: new Date().toISOString(),
          project_id: this.projectId,
          version_number: "2",
        };
        console.log(formData);
        //not update to api
        for (let am = 0; am < this.layerDatas.length; am++) {
          let find_annotation = this.layerDatas[am].annotations.findIndex((annot) => annot.annotation_id == this.getId);
          if (find_annotation > -1) {
            const form_mapping = () => {
              this.formCount = this.layerDatas[am].annotations[find_annotation].annotation_forms.length;
              this.show = false;
              this.currentFormId = value.form_id;
              this.currentFormName = value.form_name;
              this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
              this.canclose = value.canClose;
              this.currentFormHiddenStatus = JSON.parse(value.is_hidden);
              
              if (this.currentFormHiddenStatus == false) {
                this.colorvalid = false;
              } else {
                this.colorvalid = true;
              }
              if (value.hasOwnProperty('is_extend')) {
                this.is_extend = value.is_extend;
              } else {
                this.is_extend = false;
              }
              if (this.createDocumentStore.data_allow_condition.includes(this.is_extend)) {
                this.is_extend = false;
              } else {
                this.is_extend = true;
              }
              this.newFormData = formData;
              var newFormDataFelds = null;
              var ext_newFormDataFelds = [];
              if (Array.isArray(value.form_data) == false) {
                newFormDataFelds = JSON.parse(value.form_data)
              } else {
                newFormDataFelds = value.form_data
              }
              if (value.form_data == null) {
                newFormDataFelds = [];
              }
              if (value.ext_form_data != null && value.ext_form_data != undefined) {
                if (Array.isArray(value.ext_form_data) == false) {
                  ext_newFormDataFelds = JSON.parse(value.ext_form_data)
                } else {
                  ext_newFormDataFelds = value.ext_form_data;
                }
              }

              newFormDataFelds = newFormDataFelds.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true" && formdata.is_removed != "1")
              // converting special characters
              let getforms = newFormDataFelds;
              if (getforms != undefined && getforms.length > 0) {
                //start converting
                let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                newFormDataFelds = change_character_res;
              }
              this.modelFieldsForm = newFormDataFelds;

              if(weldformswitch == true){
                let clonenewFormDataFelds = _.cloneDeep(newFormDataFelds);
                let weldform = clonenewFormDataFelds.filter((id) => id.element_type == "uti-entry-field-WMATA_WELD")
                if(weldform.length > 0){
                var welditem = weldform[0];
                }
              }
              if (this.is_extend == true) {
                if (ext_newFormDataFelds != null && ext_newFormDataFelds != undefined) {
                  ext_newFormDataFelds = ext_newFormDataFelds.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                  // converting special characters
                  let getforms = ext_newFormDataFelds;
                  if (getforms != undefined && getforms.length > 0) {
                    //start converting
                    let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                    ext_newFormDataFelds = change_character_res;
                  }
                }
                this.extend_modelFieldsForm = ext_newFormDataFelds;
                if(weldformswitch == true){
                  this.extend_modelFieldsForm.push(welditem);
                }
                let merge_forms = [...newFormDataFelds, ...ext_newFormDataFelds];
                this.usecaseCopyArray = _.cloneDeep(merge_forms)

              } else {
                this.undoDatataForForms = _.cloneDeep(newFormDataFelds);
                this.usecaseCopyArray = _.cloneDeep(newFormDataFelds);
              }
              this.process_use_conditions();
              this.FormulaCalc();
              if (this.modelFieldsForm != null) {
                if (this.modelFieldsForm.length > 0) {
                  for (let v = 0; v < this.modelFieldsForm.length; v++) {
                    if (this.modelFieldsForm[v].element_type == "uti-entry-field") {
                      this.outputArray = []
                      this.finalArray1 = []
                      var fff = this.modelFieldsForm[v].element_data["fields"];
                      for (let k = 0; k < this.modelFieldsForm[v].element_data['fields'].length; k++) {
                        if (this.modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                          for (let j = 0; j < this.modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                            this.outputArray.push({ 'id': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                          }
                        }
                      }
                      this.elementFields = this.modelFieldsForm[v].element_data['fields']
                      if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                        if (this.modelFieldsForm[v].element_data['default_values'] != "") {
                          this.finalArray = this.modelFieldsForm[v].element_data['default_values']
                          this.displayArryChange(this.modelFieldsForm[v].element_data['fields'], this.modelFieldsForm[v].element_data['default_values'])
                        } else {
                          this.finalArray = []
                        }
                      } else {
                        this.finalArray = []
                      }
                    }
                    else if (this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA") {
                      // make default values array of json

                      if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values') && this.modelFieldsForm[v].element_data.default_values != undefined && this.modelFieldsForm[v].element_data.default_values != "") {
                        let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                        let get_element_fields = this.modelFieldsForm[v].element_data['fields']
                        this.UTIEntry_field_Wmata(get_element_fields, get_default_value);
                      }
                      else {
                        // if default values is empty purpose
                        this.finalArray2 = [];
                      }
                    }
                    else if (this.modelFieldsForm[v].element_type == "uti-entry-field-TIMBER") {
                      this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
                    }
                    if (this.modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                      this.totalElementQuantity = Number(this.modelFieldsForm[v].element_data.default_value);
                      this.htmlcalculation();
                    }
                    if (this.modelFieldsForm[v].element_type == "date") {
                
                      if (this.modelFieldsForm[v].element_data.default_date_time != "") {
                        if (this.modelFieldsForm[v].element_data.default_date_time == "none" || this.modelFieldsForm[v].element_data.default_date_time == "current") {
                          //this.modelFieldsForm[v].element_data.default_date_time = this.assignDates(this.modelFieldsForm[v].element_data.default_date_time)
                        } else {
                          //  this.modelFieldsForm[v].element_data.default_date_time = new Date(this.modelFieldsForm[v].element_data.default_date_time).toISOString();
                        }
                      }
                    }
                  }
                }
                this.copyOfFormModelfield = this.modelFieldsForm;
              }
              if (this.extend_modelFieldsForm != null) {
                if (this.extend_modelFieldsForm.length > 0) {
                  for (let v = 0; v < this.extend_modelFieldsForm.length; v++) {
                    if (this.extend_modelFieldsForm[v].element_type == "uti-entry-field") {
                      this.outputArray = [];
                      this.finalArray1 = [];
                      var fff = this.extend_modelFieldsForm[v].element_data["fields"];
                      for (let k = 0; k < this.extend_modelFieldsForm[v].element_data['fields'].length; k++) {
                        if (this.extend_modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                          for (let j = 0; j < this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                            this.outputArray.push({ 'id': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                          }
                        }
                      }
                      this.elementFields = this.extend_modelFieldsForm[v].element_data['fields']
                      if (this.extend_modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                        if (this.extend_modelFieldsForm[v].element_data['default_values'] != "") {
                          this.finalArray = this.extend_modelFieldsForm[v].element_data['default_values']
                          this.displayArryChange(this.extend_modelFieldsForm[v].element_data['fields'], this.extend_modelFieldsForm[v].element_data['default_values'])
                        } else {
                          this.finalArray = []
                        }
                      } else {
                        this.finalArray = []
                      }
                    }
                    if (this.extend_modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                      this.totalElementQuantity = Number(this.extend_modelFieldsForm[v].element_data.default_value);
                      this.htmlcalculation();
                    }
                    if (this.extend_modelFieldsForm[v].element_type == "date") {
                    
                      if (this.extend_modelFieldsForm[v].element_data.default_date_time != "") {
                        if (this.extend_modelFieldsForm[v].element_data.default_date_time == "none" || this.extend_modelFieldsForm[v].element_data.default_date_time == "current") {
                          //  this.extend_modelFieldsForm[v].element_data.default_value = this.assignDates(this.extend_modelFieldsForm[v].element_data.default_date_time)
                        } else {
                          this.extend_modelFieldsForm[v].element_data.default_value = new Date(this.extend_modelFieldsForm[v].element_data.default_date_time).toISOString();
                        }
                      }
                    }
                  }
                }
              }


            }
            if (this.isReadonly == true || this.userrole == 'view') {
              // form mapping calling does not call api when viewonly mode on
              form_mapping();
            }
            else {
              //  call api the form mapping calling when viewonly mode off
              // new form attached in layer data Corresponding annotation
              this.layerDatas[am].annotations[find_annotation].annotation_forms.push(formData);
              let copylayerDatas = _.cloneDeep(this.layerDatas[am].annotations[find_annotation].annotation_forms)
              this.currentSelectedAnnotationData.annotation_forms = copylayerDatas;
              let generateCloneLayer = _.cloneDeep(this.layerDatas);
              this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw, 'form').subscribe((response) => {
                console.log(response);
              

                if (response["response_code"] == 200) {
                  form_mapping();
                  this.checkAlign_usecase();
                }
                else {
                  this.errorMessage();
                }
              });
            }

          }
        }
      }
    }
    else if (this.multipleSelectOn == true) {

      // this.show = true;
      console.log(this.multiselectionList);
      console.log(this.layerDatas);
      this.formId = value.form_id;
      let multipleFormCount = 0;
      for (var i = 0; i < this.multiselectionList.length; i++) {
        // let annotationForms = this.multiselectionList[i].annotation_forms;
        let annotationForms = this.multiselectionList[i].annotation_forms.filter((forms) => this.createDocumentStore.data_allow_condition.includes(forms.is_removed))
        let find_form_index = annotationForms.findIndex((data) => data.form_id == value.form_id);
        if (find_form_index > -1) {
          let find_layer = this.layerDatas.findIndex((layer) => layer.layer_id == this.multiselectionList[i].layer_id);
          if (find_layer > -1) {
            // find annotationIndex
            let annot_index = this.layerDatas[find_layer].annotations.findIndex((annot) => annot.annotation_id == this.multiselectionList[i].annotation_id);
            if (annot_index > -1) {
              if (this.layerDatas[find_layer].annotations[annot_index].annotation_forms.length > 0) {
                let change_form = this.layerDatas[find_layer].annotations[annot_index].annotation_forms;
                change_form.push(change_form.splice(find_form_index, 1)[0]);
                this.layerDatas[find_layer].annotations[annot_index].annotation_forms = change_form;
                multipleFormCount = multipleFormCount + this.layerDatas[find_layer].annotations[annot_index].annotation_forms.length;
              }
            }
          }
          console.log('Form Already Attached');
          isForm = false;
          for (let a = 0; a < annotationForms.length; a++) {
            if (annotationForms[a].form_id == value.form_id) {
              let get_db_data_forms = annotationForms[a];
              if (get_db_data_forms != undefined) {
                get_db_data_forms.form_name = this.dataService4.changeSpecialtoKeyFormat(get_db_data_forms.form_name);
                let get_cur_formdata = get_db_data_forms.form_data;
                if (Array.isArray(get_cur_formdata)) {
                  if (get_cur_formdata.length > 0) {
                    get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
                  }
                } else {
                 
                  if(get_cur_formdata!=undefined){
                  console.log(get_cur_formdata)
                  get_cur_formdata = JSON.parse(get_cur_formdata);
                  
                  if (get_cur_formdata.length > 0) {
                    get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
                  }
                }
                }
                if (get_db_data_forms.is_extend == true) {
                  if (get_db_data_forms.hasOwnProperty('ext_form_data')) {
                    if (get_db_data_forms.ext_form_data != null) {
                      let get_cur_ext_formdata = get_db_data_forms.ext_form_data;
                      if (Array.isArray(get_cur_ext_formdata)) {
                        if (get_cur_ext_formdata.length > 0) {
                          get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                        }
                      } else {
                        get_cur_ext_formdata = JSON.parse(get_cur_ext_formdata);
                        if (get_cur_ext_formdata.length > 0) {
                          get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                        }
                      }
                    }
                  }
                  let get_cur_ext_formdata = get_db_data_forms.ext_form_data == undefined ? [] : get_db_data_forms.ext_form_data;
                  if(value.ext_form_data != undefined && value.ext_form_data.length != 0 && get_cur_ext_formdata.length == 0){
                    get_db_data_forms.ext_form_data = value.ext_form_data
                    get_cur_ext_formdata = value.ext_form_data
                    get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                  }
                }

              }
              annotationForms[a] = get_db_data_forms;


              this.currentFormId = annotationForms[a].form_id;
              let check_form_name = this.formListDefaultValues.filter((f_name) => f_name.form_id == this.currentFormId);
              if (check_form_name.length > 0) {
                this.currentFormName = check_form_name[0].form_name;
              }
              else {
                this.currentFormName = annotationForms[a].form_name;
              }
              if (annotationForms[a].hasOwnProperty('is_extend')) {
                this.is_extend = annotationForms[a].is_extend;
              } else {
                this.is_extend = false;
              }
              // this.currentFormName = annotationForms[a].form_name;
              
              this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
              this.currentFormHiddenStatus = JSON.parse(annotationForms[a].is_hidden);
              if (this.currentFormHiddenStatus == false) {
                this.colorvalid = false;
              } else {
                this.colorvalid = true;
              }
              var newFormDataFelds;
              let ext_newFormDataFelds = [];
              if (Array.isArray(annotationForms[a].form_data) == false) {
               
                if(annotationForms[a].form_data!=undefined){
                console.log(annotationForms[a].form_data)
                newFormDataFelds = JSON.parse(annotationForms[a].form_data)
                }
              } else {
                newFormDataFelds = annotationForms[a].form_data
              }

              if (annotationForms[a].hasOwnProperty('ext_form_data') && annotationForms[a].ext_form_data != null && annotationForms[a].ext_form_data != "") {
                if (Array.isArray(annotationForms[a].ext_form_data) == false) {
                  ext_newFormDataFelds = JSON.parse(annotationForms[a].ext_form_data)
                } else {
                  ext_newFormDataFelds = annotationForms[a].ext_form_data
                }
              }
              let clone_model_fiels = _.cloneDeep(annotationForms[a].form_data)
              if (check_form_name[0].form_data != undefined && check_form_name[0].form_data != null) {
                if (Array.isArray(check_form_name[0].form_data) == false) {
                  check_form_name[0].form_data = JSON.parse(check_form_name[0].form_data)
                } else {
                  check_form_name[0].form_data = check_form_name[0].form_data
                }
              }
              if(weldformswitch == true){
                let clonenewFormDataFelds = _.cloneDeep(clone_model_fiels);
                let weldform = clonenewFormDataFelds.filter((id) => id.element_type == "uti-entry-field-WMATA_WELD")
                if(weldform.length > 0){
                var welditem = weldform[0];
                }
              }
              newFormDataFelds = this.merge_form_process(clone_model_fiels, check_form_name[0].form_data, 'leftside');
              // newFormDataFelds = this.getUpdatedFormdata(annotationForms[a].form_data, check_form_name[0].form_data)
              newFormDataFelds = newFormDataFelds.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
              // converting special characters
              let getforms = newFormDataFelds;
              if (getforms != undefined && getforms.length > 0) {
                //start converting
                let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                newFormDataFelds = change_character_res;
              }

              this.modelFieldsForm = newFormDataFelds//annotationForms[a].form_data;

              if (this.is_extend == true) {
                ext_newFormDataFelds = ext_newFormDataFelds.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                let clone_extend_model_fiels = _.cloneDeep(annotationForms[a].ext_form_data)
                if (check_form_name[0].ext_form_data != undefined && check_form_name[0].ext_form_data != null) {
                  if (Array.isArray(check_form_name[0].ext_form_data) == false) {
                    check_form_name[0].ext_form_data = JSON.parse(check_form_name[0].ext_form_data)
                  } else {
                    check_form_name[0].ext_form_data = check_form_name[0].ext_form_data
                  }
                }
            
                ext_newFormDataFelds = this.merge_form_process(clone_extend_model_fiels, check_form_name[0].ext_form_data, 'rightside')
                // ext_newFormDataFelds = this.getUpdatedFormdata(annotationForms[a].ext_form_data, check_form_name[0].ext_form_data)
                // converting special characters
                let getforms = ext_newFormDataFelds;
                if(weldformswitch == true){
                  let copyextendform = _.cloneDeep(ext_newFormDataFelds);
                    let index = copyextendform.findIndex((type) => type.element_type == "uti-entry-field-WMATA_WELD");
                    if (index == -1) {
                      ext_newFormDataFelds.push(welditem);
                    }
                }
                if (getforms != undefined && getforms.length > 0) {
                  //start converting
                  let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                  ext_newFormDataFelds = change_character_res;
                }

                this.extend_modelFieldsForm = ext_newFormDataFelds//annotationForms[a].ext_form_data;

                let merger_forms = [...this.modelFieldsForm, ...this.extend_modelFieldsForm];
                this.undoDatataForForms = _.cloneDeep(merger_forms);
                this.usecaseCopyArray = _.cloneDeep(merger_forms);
                if(weldformswitch == false){
                  this.extend_modelFieldsForm = this.removeHiddenFields(ext_newFormDataFelds, annotationForms[a].ext_form_data)
                }
                this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")

              } else {
                this.undoDatataForForms = _.cloneDeep(newFormDataFelds);
                this.usecaseCopyArray = _.cloneDeep(newFormDataFelds);
              }
              this.modelFieldsForm = this.removeHiddenFields(newFormDataFelds, annotationForms[a].form_data)
              this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
              this.process_use_conditions();
              this.FormulaCalc();
              if (this.modelFieldsForm.length > 0) {
                for (let v = 0; v < this.modelFieldsForm.length; v++) {
                  if (this.modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                    this.totalElementQuantity = Number(this.modelFieldsForm[v].element_data.default_value);
                    this.htmlcalculation();
                  }
                  if (this.modelFieldsForm[v].element_type == "uti-entry-field") {
                    this.outputArray = []
                    this.finalArray1 = []
                    var fff = this.modelFieldsForm[v].element_data["fields"];
                    for (let k = 0; k < this.modelFieldsForm[v].element_data['fields'].length; k++) {
                      if (this.modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                        for (let j = 0; j < this.modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                          this.outputArray.push({ 'id': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                        }
                      }
                    }
                    this.elementFields = this.modelFieldsForm[v].element_data['fields']
                    if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                      if (this.modelFieldsForm[v].element_data['default_values'] != "") {
                        this.finalArray = this.modelFieldsForm[v].element_data['default_values']
                        this.displayArryChange(this.modelFieldsForm[v].element_data['fields'], this.modelFieldsForm[v].element_data['default_values'])
                      }
                    }
                  }
                  else if (this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA") {
                    // make default values array of json

                    if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values') && this.modelFieldsForm[v].element_data.default_values != undefined && this.modelFieldsForm[v].element_data.default_values != "") {
                      let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                      let get_element_fields = this.modelFieldsForm[v].element_data['fields']
                      this.UTIEntry_field_Wmata(get_element_fields, get_default_value);
                    }
                    else {
                      // if default values is empty purpose
                      this.finalArray2 = [];
                    }
                  }
                  else if (this.modelFieldsForm[v].element_type == "uti-entry-field-TIMBER") {
                    this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
                  }
                  else if(this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA_WELD"){
                    if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values') && this.modelFieldsForm[v].element_data.default_values != undefined && this.modelFieldsForm[v].element_data.default_values != "") {
                      const copyweldform =_.cloneDeep(this.modelFieldsForm[v]);
                     this.copyweldForm = copyweldform;
                      let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                      const fields = this.modelFieldsForm[v].element_data.fields;
                      this.fieldsWeld = fields; 
                      var weldArray = this.convertUUIDtoNormal(get_default_value);
                    }
                  }
  
                  else if (this.modelFieldsForm[v].element_type == "date") {
                    
                    if (this.modelFieldsForm[v].element_data.default_date_time != "") {
                      if (this.modelFieldsForm[v].element_data.default_date_time == "none" || this.modelFieldsForm[v].element_data.default_date_time == "current") {
                        //   this.modelFieldsForm[v].element_data.default_value = this.assignDates(this.modelFieldsForm[v].element_data.default_date_time)
                      } else {
                        this.modelFieldsForm[v].element_data.default_date_time = new Date(this.modelFieldsForm[v].element_data.default_date_time).toISOString();
                      }
                    }
                  }
                  else if (this.modelFieldsForm[v].element_type == "calculation") {
                    let calc = this.modelFieldsForm[v];
                    if (calc.element_data.calculation.includes('√')) {
                      let get_fianl_value = this.dataService4.squareRootCalculation(calc.element_data.calculation);
                      if (get_fianl_value != '√' && get_fianl_value != '') {
                        get_fianl_value = eval(get_fianl_value);
                      }
                      this.modelFieldsForm[v].element_data.calculation = get_fianl_value;
                      this.modelFieldsForm[v].element_data.calculation = this.modelFieldsForm[v].element_data.calculation.toFixed(Number(this.modelFieldsForm[v].element_data.default_value));
                    }
                    //square root function implemented end
                    //power function implemented start
                    else if (calc.element_data.calculation.includes('^')) {
                      let get_fianl_value = this.dataService4.powerOfCalculation(calc.element_data.calculation);
                      if (get_fianl_value != '^' && get_fianl_value != '') {
                        get_fianl_value = eval(get_fianl_value);
                      }
                      this.modelFieldsForm[v].element_data.calculation = get_fianl_value;
                      this.modelFieldsForm[v].element_data.calculation = this.modelFieldsForm[v].element_data.calculation.toFixed(Number(this.modelFieldsForm[v].element_data.default_value));
                    }
                    //power function implemented end
                    else {
                      let check_seperators = ["(", ")", "+", "-", "*", "/"];
                      let get_calculation = calc.element_data.calculation;
                      let get_fist_value = calc.element_data.calculation[0];
                      let get_second_value = calc.element_data.calculation[1];
                      let get_last_value = calc.element_data.calculation[calc.element_data.calculation.length - 1];
                      if (check_seperators.includes(get_fist_value) && check_seperators.includes(get_second_value)) {
                        this.modelFieldsForm[v].element_data.calculation = calc.element_data.calculation
                      }
                      else if (check_seperators.includes(get_last_value)) {
                        this.modelFieldsForm[v].element_data.calculation = calc.element_data.calculation
                      }
                      else if ((get_calculation.includes("(") && !get_calculation.includes(")")) ||
                        (get_calculation.includes(")") && !get_calculation.includes("("))) {
                        this.modelFieldsForm[v].element_data.calculation = calc.element_data.calculation
                      }
                      else {
                        
                        if (calc.element_data.calculation != undefined && calc.element_data.calculation != "" || !calc.element_data.calculation.includes("[")) {
                          var validcalculation = false;
                          try {
                            eval(calc.element_data.calculation);
                            validcalculation = true;
                          } catch (e) {
                            if (e instanceof SyntaxError) {
                              // alert(e.message);
                              validcalculation = false;
                              this.modelFieldsForm[v].element_data.calculation = calc.element_data.calculation;
                            }
                          }
                        }
                        if (validcalculation == true) {
                          
                          
                          this.modelFieldsForm[v].element_data.calculation = eval(calc.element_data.calculation);
                          this.modelFieldsForm[v].element_data.calculation = this.modelFieldsForm[v].element_data.default_value == "" ? this.modelFieldsForm[v].element_data.calculation.toFixed(Number(1)) : this.modelFieldsForm[v].element_data.calculation.toFixed(Number(this.modelFieldsForm[v].element_data.default_value));
                        }
                        // calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
                        let confirmedValue = calc.element_data.calculation;
                        console.log(Math.abs(confirmedValue));
                        let decimalCheck = Math.abs(confirmedValue);
                      }
                      console.log(typeof this.modelFieldsForm[v].element_data.calculation);
                    }
                  }
                }
              }

              if (this.extend_modelFieldsForm != null) {
                if (this.extend_modelFieldsForm.length > 0) {
                  for (let v = 0; v < this.extend_modelFieldsForm.length; v++) {
                    if (this.extend_modelFieldsForm[v].element_type == "uti-entry-field") {
                      this.outputArray = []
                      this.finalArray1 = []
                      var fff = this.extend_modelFieldsForm[v].element_data["fields"];
                      for (let k = 0; k < this.extend_modelFieldsForm[v].element_data['fields'].length; k++) {
                        if (this.extend_modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                          for (let j = 0; j < this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                            this.outputArray.push({ 'id': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                          }
                        }
                      }
                      this.elementFields = this.extend_modelFieldsForm[v].element_data['fields']
                      if (this.extend_modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                        if (this.extend_modelFieldsForm[v].element_data['default_values'] != "") {
                          this.finalArray = this.extend_modelFieldsForm[v].element_data['default_values']
                          this.displayArryChange(this.extend_modelFieldsForm[v].element_data['fields'], this.extend_modelFieldsForm[v].element_data['default_values'])
                        }
                      }
                    }
                    if (this.extend_modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                      this.totalElementQuantity = Number(this.extend_modelFieldsForm[v].element_data.default_value);
                      this.htmlcalculation();
                    }
                    if (this.extend_modelFieldsForm[v].element_type == "date") {
                      
                      if (this.extend_modelFieldsForm[v].element_data.default_date_time != "") {
                        if (this.extend_modelFieldsForm[v].element_data.default_date_time == "none" || this.extend_modelFieldsForm[v].element_data.default_date_time == "current") {
                          //  this.extend_modelFieldsForm[v].element_data.default_value = this.assignDates(this.extend_modelFieldsForm[v].element_data.default_date_time)
                        } else {
                          this.extend_modelFieldsForm[v].element_data.default_date_time = new Date(this.extend_modelFieldsForm[v].element_data.default_date_time).toISOString();
                        }
                      }
                    }
                  }
                }
              }
              this.copyOfFormModelfield = this.modelFieldsForm;

            }
          }
        }
        else {
          isForm = true;
        }
        if (isForm == true) {
          let get_db_data_forms = value;
          if (get_db_data_forms != undefined) {

            get_db_data_forms.form_name = this.dataService4.changeSpecialtoKeyFormat(get_db_data_forms.form_name);
            let get_cur_formdata = get_db_data_forms.form_data;
            if(get_cur_formdata!=null){
              if (Array.isArray(get_cur_formdata)) {
                if (get_cur_formdata.length > 0) {
                  get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
                }
              } else {
                get_cur_formdata = JSON.parse(get_cur_formdata);
                if (get_cur_formdata.length > 0) {
                  get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
                }
              }
            }
            if (get_db_data_forms.is_extend == true) {
              if (get_db_data_forms.hasOwnProperty('ext_form_data')) {
                if (get_db_data_forms.ext_form_data != null) {
                  let get_cur_ext_formdata = get_db_data_forms.ext_form_data;
                  if (Array.isArray(get_cur_ext_formdata)) {
                    if (get_cur_ext_formdata.length > 0) {
                      get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                    }
                  } else {
                    get_cur_ext_formdata = JSON.parse(get_cur_ext_formdata);
                    if (get_cur_ext_formdata.length > 0) {
                      get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                    }
                  }
                }
              }
            }

          }
          value = get_db_data_forms;
          var annotation_id = this.multiselectionList[i].annotation_id;
          // this.toolbarData = value.form_data;
          let temp_extend = value.ext_form_data;

          if (temp_extend != null) {
            if (typeof temp_extend === 'string') {
              temp_extend = JSON.parse(temp_extend);
            }
          }

          let form_data = value.form_data;
          if (typeof form_data === 'string') {
            temp_extend = JSON.parse(form_data);
          }

          let formData = {
            // form_data: (typeof value.form_data === 'string' || value.form_data instanceof String) ? JSON.parse(value.form_data) : value.form_data,
            // form_data: this.modelFieldsForm,
            form_data: form_data,
            form_element_count: this.modelFieldsForm == null ? 0 : this.modelFieldsForm.length,
            form_name: value.form_name,
            // form_id: this.formId,
            form_id: value.form_id,
            ext_form_data: temp_extend,
            ext_form_element_count: value.ext_form_element_count,
            isLocalModified: 0,
            is_default_flag: 0,
            is_hidden: 0,
            is_extend: value.is_extend,
            is_removed: 0,
            last_updated_date: new Date().toISOString(),
            project_id: this.projectId,
            version_number: "2",
            sync_version_uuid: "0",
            created_date: value.created_date,
            created_by_user_id: this.su.user_id,
          };
          if (this.isReadonly != true && this.userrole != 'view') {
            this.layerDatas = Addform(this.layerDatas, formData, annotation_id); // form adding process in layerdatas
            this.multiselectionList[i].annotation_forms.push(formData); // form adding process in multipleselection list
          }
          this.currentFormId = value.form_id;
          this.currentFormName = value.form_name;
          this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
          this.currentFormHiddenStatus = JSON.parse(value.is_hidden);
          if (value.hasOwnProperty('is_extend')) {
            this.is_extend = value.is_extend;
          } else {
            this.is_extend = false;
          }
          if (this.createDocumentStore.data_allow_condition.includes(this.is_extend)) {
            this.is_extend = false;
          } else {
            this.is_extend = true;
          }
          // check form count
          // find layerIndex
          let find_layer = this.layerDatas.findIndex((layer) => layer.layer_id == this.multiselectionList[i].layer_id);
          if (find_layer > -1) {
            // find annotationIndex
            let annot_index = this.layerDatas[find_layer].annotations.findIndex((annot) => annot.annotation_id == annotation_id);
            if (annot_index > -1) {
              multipleFormCount = multipleFormCount + this.layerDatas[find_layer].annotations[annot_index].annotation_forms.length;
            }
          }
          this.needUpdateFormCount = multipleFormCount;
          // this.modelFieldsForm = getFormById(this.layerDatas, annotation_id, value.form_id);
          var newFormDataFelds;
          if (Array.isArray(value.form_data) == false) {
            newFormDataFelds = JSON.parse(value.form_data);
          } else {
            newFormDataFelds = value.form_data;
          }
          this.modelFieldsForm = newFormDataFelds;
          if(weldformswitch == true){
            let clonenewFormDataFelds = _.cloneDeep(newFormDataFelds);
            let weldform = clonenewFormDataFelds.filter((id) => id.element_type == "uti-entry-field-WMATA_WELD")
            if(weldform.length > 0){
            var welditem = weldform[0];
            }
          }
          newFormDataFelds = newFormDataFelds.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
          // converting special characters
          let getforms = newFormDataFelds;
          if (getforms != undefined && getforms.length > 0) {
            //start converting
            let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
            newFormDataFelds = change_character_res;
          }
          if (this.is_extend == true) {
            let ext_newFormDataFelds = [];
            if (value.hasOwnProperty('ext_form_data')) {
              if (value.ext_form_data != null) {
                if (Array.isArray(value.ext_form_data) == false) {
                  ext_newFormDataFelds = JSON.parse(value.ext_form_data)
                } else {
                  ext_newFormDataFelds = value.ext_form_data;
                }
                ext_newFormDataFelds = ext_newFormDataFelds.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true");
                let getforms = ext_newFormDataFelds;
                if (getforms != undefined && getforms.length > 0) {
                  //start converting
                  let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                  ext_newFormDataFelds = change_character_res;
                }
              }
              this.extend_modelFieldsForm = ext_newFormDataFelds;
              this.extend_modelFieldsForm = ext_newFormDataFelds;
                if(weldformswitch == true){
                  this.extend_modelFieldsForm.push(welditem);
                }
              let merge_forms = [...newFormDataFelds, ...ext_newFormDataFelds];
              //taking the current form copy for  undoing and redoing
              this.undoDatataForForms = _.cloneDeep(merge_forms)
              //taking the current form copy for use condition
              this.usecaseCopyArray = _.cloneDeep(merge_forms);
            }
            if (this.extend_modelFieldsForm != null) {
              if (this.extend_modelFieldsForm.length > 0) {
                for (let v = 0; v < this.extend_modelFieldsForm.length; v++) {
                  if (this.extend_modelFieldsForm[v].element_type == "uti-entry-field") {
                    this.outputArray = []
                    this.finalArray1 = []
                    var fff = this.extend_modelFieldsForm[v].element_data["fields"];
                    for (let k = 0; k < this.extend_modelFieldsForm[v].element_data['fields'].length; k++) {
                      if (this.extend_modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                        for (let j = 0; j < this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                          this.outputArray.push({ 'id': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                        }
                      }
                    }
                    this.elementFields = this.extend_modelFieldsForm[v].element_data['fields']
                    if (this.extend_modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                      if (this.extend_modelFieldsForm[v].element_data['default_values'] != "") {
                        this.finalArray = this.extend_modelFieldsForm[v].element_data['default_values']
                        this.displayArryChange(this.extend_modelFieldsForm[v].element_data['fields'], this.extend_modelFieldsForm[v].element_data['default_values'])
                      }
                    }
                  }
                  if (this.extend_modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                    this.totalElementQuantity = Number(this.extend_modelFieldsForm[v].element_data.default_value);
                    this.htmlcalculation();
                  }
                  if (this.extend_modelFieldsForm[v].element_type == "date") {
                   
                    if (this.extend_modelFieldsForm[v].element_data.default_date_time != "") {
                      if (this.extend_modelFieldsForm[v].element_data.default_date_time == "none" || this.extend_modelFieldsForm[v].element_data.default_date_time == "current") {
                        // this.extend_modelFieldsForm[v].element_data.default_value = this.assignDates(this.extend_modelFieldsForm[v].element_data.default_date_time)
                      } else {
                        this.extend_modelFieldsForm[v].element_data.default_date_time = new Date(this.extend_modelFieldsForm[v].element_data.default_date_time).toISOString();
                      }
                    }
                  }
                }
              }
            }
          }
          else {
            this.undoDatataForForms = _.cloneDeep(newFormDataFelds);
            this.usecaseCopyArray = _.cloneDeep(newFormDataFelds);
          }
          this.process_use_conditions();
          this.FormulaCalc();
          if (this.modelFieldsForm.length > 0) {
            for (let v = 0; v < this.modelFieldsForm.length; v++) {
              if (this.modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                this.totalElementQuantity = Number(this.modelFieldsForm[v].element_data.default_value);
                this.htmlcalculation();
              }
              if (this.modelFieldsForm[v].element_type == "uti-entry-field") {
                this.outputArray = []
                this.finalArray1 = []
                var fff = this.modelFieldsForm[v].element_data["fields"];
                for (let k = 0; k < this.modelFieldsForm[v].element_data['fields'].length; k++) {
                  if (this.modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                    for (let j = 0; j < this.modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                      this.outputArray.push({ 'id': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                    }
                  }
                }
                this.elementFields = this.modelFieldsForm[v].element_data['fields']
                if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                  if (this.modelFieldsForm[v].element_data['default_values'] != "") {
                    this.finalArray = this.modelFieldsForm[v].element_data['default_values']
                    this.displayArryChange(this.modelFieldsForm[v].element_data['fields'], this.modelFieldsForm[v].element_data['default_values'])
                  }
                }
              }
              else if (this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA") {
                // make default values array of json

                if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values') && this.modelFieldsForm[v].element_data.default_values != undefined && this.modelFieldsForm[v].element_data.default_values != "") {
                  let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                  let get_element_fields = this.modelFieldsForm[v].element_data['fields']
                  this.UTIEntry_field_Wmata(get_element_fields, get_default_value);
                }
                else {
                  // if default values is empty purpose
                  this.finalArray2 = [];
                }

              }
              else if (this.modelFieldsForm[v].element_type == "uti-entry-field-TIMBER") {
                this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
              }
              else if (this.modelFieldsForm[v].element_type == "date") {
              
                if (this.modelFieldsForm[v].element_data.default_date_time != "") {
                  if (this.modelFieldsForm[v].element_data.default_date_time == "none" || this.modelFieldsForm[v].element_data.default_date_time == "current") {
                    //  this.modelFieldsForm[v].element_data.default_value = this.assignDates(this.modelFieldsForm[v].element_data.default_date_time)
                  } else {
                    this.modelFieldsForm[v].element_data.default_date_time = new Date(this.modelFieldsForm[v].element_data.default_date_time).toISOString();
                  }
                }
              }
              else if (this.modelFieldsForm[v].element_type == "calculation") {
                let calc = this.modelFieldsForm[v];
                if (calc.element_data.calculation.includes('√')) {
                  let get_fianl_value = this.dataService4.squareRootCalculation(calc.element_data.calculation);
                  if (get_fianl_value != '√' && get_fianl_value != '') {
                    get_fianl_value = eval(get_fianl_value);
                  }
                  this.modelFieldsForm[v].element_data.calculation = get_fianl_value;
                  this.modelFieldsForm[v].element_data.calculation = this.modelFieldsForm[v].element_data.calculation.toFixed(Number(this.modelFieldsForm[v].element_data.default_value));
                }
                //square root function implemented end
                //power function implemented start
                else if (calc.element_data.calculation.includes('^')) {
                  let get_fianl_value = this.dataService4.powerOfCalculation(calc.element_data.calculation);
                  if (get_fianl_value != '^' && get_fianl_value != '') {
                    get_fianl_value = eval(get_fianl_value);
                  }
                  this.modelFieldsForm[v].element_data.calculation = get_fianl_value;
                  this.modelFieldsForm[v].element_data.calculation = this.modelFieldsForm[v].element_data.calculation.toFixed(Number(this.modelFieldsForm[v].element_data.default_value));
                }
                //power function implemented end
                else {
                  let check_seperators = ["(", ")", "+", "-", "*", "/"];
                  let get_calculation = calc.element_data.calculation;
                  let get_fist_value = calc.element_data.calculation[0];
                  let get_second_value = calc.element_data.calculation[1];
                  let get_last_value = calc.element_data.calculation[calc.element_data.calculation.length - 1];
                  if (check_seperators.includes(get_fist_value) && check_seperators.includes(get_second_value)) {
                    this.modelFieldsForm[v].element_data.calculation = calc.element_data.calculation
                  }
                  else if (check_seperators.includes(get_last_value)) {
                    this.modelFieldsForm[v].element_data.calculation = calc.element_data.calculation
                  }
                  else if ((get_calculation.includes("(") && !get_calculation.includes(")")) ||
                    (get_calculation.includes(")") && !get_calculation.includes("("))) {
                    this.modelFieldsForm[v].element_data.calculation = calc.element_data.calculation
                  }
                  else {
                    if (calc.element_data.calculation != undefined && calc.element_data.calculation != "" && !calc.element_data.calculation.includes(']')) {
                      var validcalculation = false;
                      try {
                        eval(calc.element_data.calculation);
                        validcalculation = true;
                      } catch (e) {
                        if (e instanceof SyntaxError) {
                          // alert(e.message);
                          validcalculation = false;
                          this.modelFieldsForm[v].element_data.calculation = calc.element_data.calculation;
                        }
                      }
                    }
                    if (validcalculation == true) {
                      this.modelFieldsForm[v].element_data.calculation = eval(calc.element_data.calculation);
                      this.modelFieldsForm[v].element_data.calculation = this.modelFieldsForm[v].element_data.default_value == "" ? this.modelFieldsForm[v].element_data.calculation.toFixed(Number(1)) : this.modelFieldsForm[v].element_data.calculation.toFixed(Number(this.modelFieldsForm[v].element_data.default_value));
                    }
                    // calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
                    let confirmedValue = calc.element_data.calculation;
                    console.log(Math.abs(confirmedValue));
                    let decimalCheck = Math.abs(confirmedValue);
                  }
                  console.log(typeof this.modelFieldsForm[v].element_data.calculation);
                }
              }
            }
          }
          var form_hidden=this.formList.filter(res=>res.form_id==this.formId)
          if(form_hidden.length==0){
            this.colorvalid=true
          }else{
            this.colorvalid=false  
          }
          this.lastAnnotationId = annotation_id;
        }        
      }
      if(weldformswitch == true){
        this.splitarray(weldArray);
      }
      console.log(this.modelFieldsForm);
      console.log(this.extend_modelFieldsForm);
      let generateCloneLayer = _.cloneDeep(this.layerDatas);
      let annotation_ids = this.createDocumentStore.selectedAnnotations;
      let unique_ids = annotation_ids.filter((c, index) => { return annotation_ids.indexOf(c) === index; });
      console.log(unique_ids, this.createDocumentStore.selectedAnnotations);
      this.createDocumentStore.selectedAnnotations = unique_ids;
      console.log(this.multiselectionList);
      if (this.isReadonly != true && this.userrole != 'view') {
      
        let clone_multi_selectionlist = _.cloneDeep(this.multiselectionList);
        this.show = true;
        this.documentService.annotationMultipleUpdate(generateCloneLayer, clone_multi_selectionlist,'form').subscribe((response) => {
          console.log(response);
          if (response["response_code"] == 200) {
            this.show = false;
            // update form count
            console.log(this.formList,this.formId)
          
            this.formCount = multipleFormCount;
            this.checkAlign_usecase();
            this.show = false;
          }
          else {
            this.errorMessage();
          }
        });
       
      }

      // this.documentService.UpdateForm(this.layerDatas).subscribe((response) => {
      //     console.log(response);
      //     console.log(this.layerDatas);
      //     this.copyOfFormModelfield = this.modelFieldsForm;
      //   });
    }
    this.alignmenprocess();
    if(isForm == false){
      this.checkAlign_usecase()
    }
  };

  checkAnnIDfromDOM(cloneGrpAnnList,getGroupAnnList){
    if(cloneGrpAnnList.length > 0){
      let filteredIds = cloneGrpAnnList.filter(id => document.getElementById(id) != null);
      return filteredIds
    }
    return getGroupAnnList
  }

  getUpdatedFormdata(annotation_form, actual_form) {
    
    var actual_form_data;
    if (Array.isArray(actual_form) == false) {
      actual_form_data = JSON.parse(actual_form)
    } else {
      actual_form_data = actual_form
    }
    annotation_form.forEach(element => {
      var FieldFind = actual_form_data.filter(ele => ele['element_uuid'] == element['element_uuid']);
      //Fieldfind ==> overall form fields from form builder
      //element ==> edited form fields for the annotation 
      //ganesh added fieldfind.length>0 if condition seperately
      if (FieldFind.length > 0) {
        if (FieldFind[0].is_removed == true || FieldFind[0].is_removed == "true") {
          annotation_form = actual_form_data.filter(ele => ele['element_uuid'] != FieldFind[0]['element_uuid']);
        }
        // ganesh changed this line FieldFind.length > 0 && FieldFind.is_removed != true && FieldFind.is_removed != "true"
        // added line FieldFind.length > 0 && FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true" for this if condition
        if (FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true") {
          if (FieldFind[0].element_type == 'single_choice' || FieldFind[0].element_type == 'dropdown') {
            this.cdRef.detectChanges();
            FieldFind[0].element_data.options.forEach(element1 => {
              element1.default = false
            });
            var defaultOptionValue: any;
            if (element.element_data.hasOwnProperty('options')) {
              defaultOptionValue = element.element_data.options.filter((ele => ele.default == true))
            }
            if (defaultOptionValue != undefined && defaultOptionValue.length > 0) {
              var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == defaultOptionValue[0].element_uuid))
              currentOption[0].default = true;
            }
          } else if (FieldFind[0].element_type == 'multiple_choice' || FieldFind[0].element_type == 'checkbox') {

            FieldFind[0].element_data.options.forEach(element1 => {
              element1.default = false
            });
            var UCitemDefault: any;
            if (element.element_data.hasOwnProperty('options')) {
              UCitemDefault = element.element_data.options.filter((ele => ele.default == true))
            }
            if (UCitemDefault != undefined) {
              UCitemDefault.forEach(element2 => {
                var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == element2.element_uuid))
                currentOption[0].default = true;
              });
            }
          } else if (FieldFind[0].element_type == 'date') {
            
            if (element.element_data.default_date_time != "" && element.element_data.default_date_time != "none" && element.element_data.default_date_time != "current" && element.element_data.default_date_time != undefined) {
              //  FieldFind[0].element_data.default_value = new Date(element.element_data.default_date_time).toISOString();
              FieldFind[0].element_data.default_date_time = new Date(element.element_data.default_date_time).toISOString();
            }
            else if (FieldFind[0].element_data.default_date_time != "") {
              if (FieldFind[0].element_data.default_date_time == "current") {
                //    FieldFind[0].element_data.default_value = this.assignDates(FieldFind[0].element_data.default_date_time)
              }
              else if (FieldFind[0].element_data.default_date_time == "none" && FieldFind[0].element_data.default_value != "") {
                //  FieldFind[0].element_data.default_value = FieldFind[0].element_data.default_value;
              }
              else {
                //   FieldFind[0].element_data.default_value = new Date(FieldFind[0].element_data.default_date_time).toISOString();
              }


            }
          }
          else if (FieldFind[0].element_type == 'uti-entry-field') {
            FieldFind[0].element_data.default_values = element.element_data['default_values']
          }
          else if (FieldFind[0].element_type == 'uti-entry-field-WMATA') {
            FieldFind[0].element_data.default_values = element.element_data['default_values'];
          }
          else if (FieldFind[0].element_type == 'uti-entry-field-TIMBER') {
            FieldFind[0].element_data.default_values = element.element_data['default_values'];
          }
          else if (FieldFind[0].element_type == 'address') {

            FieldFind[0].element_data.street_address1 = element.element_data.street_address1
            FieldFind[0].element_data.city = element.element_data["city"]
            FieldFind[0].element_data.state = element.element_data["state"]
            FieldFind[0].element_data.zip = element.element_data["zip"]
            FieldFind[0].element_data.street_address2 = element.element_data.street_address2
          }
          else {
            if (element.element_data.default_value != undefined && element.element_data.default_value != "") {
              FieldFind[0].element_data.default_value = element.element_data.default_value
            }
          }
        }
      }
      else {
        console.log(element, FieldFind);
      }
    })

    return actual_form_data
  }

  selectedIndex: number = 0;

  removeHiddenFields(mainForm, annotationForm) {
    mainForm = mainForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
    let finalForm = []
    for (let i = 0; i < annotationForm.length; i++) {
      let filtereddata = mainForm.filter((formdata) => formdata.element_id == annotationForm[i].element_id)
      if (filtereddata.length > 0) {
        finalForm.push(annotationForm[i])
      }
    }
    return finalForm
  }
  get images() {
    return [this.modelFields[this.selectedIndex]];
  }

  previous() {
    this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
  }

  next() {
    this.selectedIndex = Math.min(
      this.selectedIndex + 1,
      this.modelFields.length - 1
    );
  }
  openswitchForm() {
    this.automatic_update_form();
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    let clone_form_list = _.cloneDeep(this.formListDefaultValues);
    clone_form_list = clone_form_list.filter((data) => data.is_hidden != 1);
    
    let dialogRef = this.dialogBox.open(SwitchFormComponent, {
      width: "380px",
      data: {
        callback_formData: this.callBackgetFormData,
        formdata: this.layerDatas,
        annotationId: this.getId,
        multipleSelectOn: this.multipleSelectOn,
        multiselectionList: this.multiselectionList,
        formList: clone_form_list,
        activeLayerId: this.activeLayerIdDraw,
        currentFormId: this.currentFormId,
        canClose: this.canclose,
        isAnnotationDefaultForm: this.isAnnotationDefaultForm,
        switch_form_list: this.createDocumentStore_1.switch_form_list
      },
    });
    dialogRef.afterClosed().subscribe((response) => {
      
    
      if (response != undefined && this.multipleSelectOn == false) {
        
        console.log()
        console.log(response.data.formCount);
        if (response.data.formCount != undefined) {
          this.formCount = response.data.formCount;
        }
        if (response.data.layerData != undefined) {
       
          this.layerDatas = response.data.layerData;
          for (var k = 0; k < this.layerDatas.length; k++) {
            for (var l = 0; l < this.layerDatas[k].annotations.length; l++) {
              if (this.getId == this.layerDatas[k].annotations[l].annotation_id) {
                if (this.layerDatas[k].annotations[l].annotation_forms.length > 0) {
                  let filter_forms = this.layerDatas[k].annotations[l].annotation_forms.filter((forms) => this.createDocumentStore.data_allow_condition.includes(forms.is_removed));
                  this.layerDatas[k].annotations[l].annotation_forms = _.cloneDeep(filter_forms);
                  this.currentSelectedAnnotationData.annotation_forms =  _.cloneDeep(filter_forms);
                  let tempformLength = this.layerDatas[k].annotations[l].annotation_forms.length;
                  if (tempformLength != 0) {

                    this.currentFormId = this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].form_id;
                    var form_hidden = this.formList.filter(res => res.form_id == this.currentFormId)
                    if (form_hidden.length == 0) {
                      this.colorvalid = true
                    } else {
                      this.colorvalid = false
                    }
                    this.currentFormName = this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].form_name;

                    if (this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].hasOwnProperty('is_extend')) {
                      this.is_extend = this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].is_extend;
                    } else {
                      this.is_extend = false;
                    }
                    this.modelFieldsForm = getFormById(this.layerDatas, this.getId, this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].form_id);
                    this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                    if (this.createDocumentStore.data_allow_condition.includes(this.is_extend)) {
                      this.is_extend = false;
                    } else {
                      this.is_extend = true;
                    }
                    if (this.is_extend == true) {
                      this.extend_modelFieldsForm = ext_getFormById(this.layerDatas, this.getId, this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].form_id);
                      console.log(typeof this.extend_modelFieldsForm)
                      this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                    }
                  }
              }
                else {
                  this.modelFieldsForm = [];
                  this.extend_modelFieldsForm = [];
                  this.currentFormName = "";
                  this.currentFormId = "";
                }
              }
            }
          }
        }
           
      }
    
      if (response != undefined && this.multipleSelectOn == true) {
        console.log(response.data.formCount);
        console.log(response.data.layerData);
        if (response.data.formCount != undefined) {
          this.formCount = response.data.formCount;
          this.needUpdateFormCount = response.data.formCount;
        }
        if (response.data.layerData != undefined) {
          this.layerDatas = response.data.layerData;
          for (let ml = 0; ml < this.multiselectionList.length; ml++) {
            for (var k = 0; k < this.layerDatas.length; k++) {
              for (var l = 0; l < this.layerDatas[k].annotations.length; l++) {
                if (this.multiselectionList[ml].annotation_id == this.layerDatas[k].annotations[l].annotation_id) {
                  let filter_forms = this.layerDatas[k].annotations[l].annotation_forms.filter((forms) => this.createDocumentStore.data_allow_condition.includes(forms.is_removed));
                  this.layerDatas[k].annotations[l].annotation_forms = _.cloneDeep(filter_forms);
                  if (this.layerDatas[k].annotations[l].annotation_forms.length > 0) {
                    let tempformLength = this.layerDatas[k].annotations[l].annotation_forms.length;
                    if(tempformLength!=0){
                    this.currentFormId = this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].form_id;
                    var form_hidden_multiselect=this.formList.filter(res=>res.form_id== this.currentFormId)
                    if(form_hidden_multiselect.length==0){
                      this.colorvalid=true
                    }else{
                      this.colorvalid=false
                    }
                    this.currentFormName = this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].form_name;
                   
                    this.modelFieldsForm = getFormById(this.layerDatas, this.layerDatas[k].annotations[l].annotation_id, this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].form_id);
                    if(typeof this.modelFieldsForm=='object'){
                      console.log(this.modelFieldsForm)
                    this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                    }else{
                    
                      console.log(this.modelFieldsForm)
                      if(this.modelFieldsForm!=undefined){
                      let modelfields=JSON.parse(this.modelFieldsForm)
                      this.modelFieldsForm =modelfields.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                      console.log(this.modelFieldsForm)
                      }
                    }
                    if (this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].hasOwnProperty('is_extend')) {
                      this.is_extend = this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].is_extend;
                    } else {
                      this.is_extend = false;
                    }
                    if (this.createDocumentStore.data_allow_condition.includes(this.is_extend)) {
                      this.is_extend = false;
                    } else {
                      this.is_extend = true;
                    }
                    if (this.is_extend == true) {
                      this.extend_modelFieldsForm = ext_getFormById(this.layerDatas, this.layerDatas[k].annotations[l].annotation_id, this.layerDatas[k].annotations[l].annotation_forms[tempformLength - 1].form_id);
                      if(typeof this.extend_modelFieldsForm=="string"){
                        var ext_fields=JSON.parse(this.extend_modelFieldsForm)
                      }else{
                        ext_fields=this.extend_modelFieldsForm
                      }
                      this.extend_modelFieldsForm =  ext_fields.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                    }
                  }
                  }
                  else {
                    this.modelFieldsForm = [];
                    this.extend_modelFieldsForm = [];
                    this.currentFormName = "";
                    this.currentFormId = "";
                  }
                }
              }
            }
          }
        }
      }
    });
  }
  openswitchToolbar() {
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    let dialog_ref = this.dialogBox.open(SwitchToolbarComponent, {
      // callBack1: this.callBackgetData,
      data: {
        selectedToolBar: this.toolbar_id,
        toolbarListData: this.createDocumentStore_1.switch_toolbar_list,
      },
    });
    dialog_ref.afterClosed().subscribe((t_data) => {
      if (t_data) {
        this.switch_toolbar_api(t_data);
      }
    })
  }

  myCallbackFunctionmultiselect(event: StateChange,element_id,url,element_stub_id) {
    switch (event.reason) {
      case 'loading-failed':
          console.log('load failed',element,url);
          this.changeSourcemultiselect(element_stub_id,url);
        break;
    }
  }

  changeSourcemultiselect(element_id,url) {
    //sample hiec --> "https://alexcorvi.github.io/heic2any/demo/1.heic"
    // element.src = "assets/images/projectdetails/P3_ImageIcon_Blue600.png";
    console.log(this.baseUrl+url+this.sKey1+this.sKey2);
    let currentURL = this.baseUrl+url+this.sKey1+this.sKey2;
    let createElement = document.createElement('img');
    createElement.setAttribute('src', "assets/images/spin.gif");
    createElement.setAttribute('id', 'mediaimageheadLoader' + element_id);
    createElement.style.position = "absolute";
    createElement.style.top = "50%";
    createElement.style.left = "50%";
    createElement.style.height = "50px";
    createElement.style.width = "50px";
    createElement.style.marginLeft = "-25px";
    createElement.style.marginTop = "-25px";
    let get_append_parent = document.getElementById('mediaimagehead' + element_id);
    if (get_append_parent != null) {
      get_append_parent.appendChild(createElement);
    }
    fetch(currentURL)
      .then((res) => res.blob())
      .then((blob) => heic2any({
        blob,
        toType: "image/jpeg",
      }).catch((e) => {
        console.log(e);
      }))
      .then((conversionResult: any) => {
        var url = URL.createObjectURL(conversionResult);
        let element: any = document.getElementById("imageviewer" + element_id);
        element.src = url;
        element.setAttribute("lazyLoad",url);
        let getElement_Loader = document.getElementById('mediaimageheadLoader' + element_id);
        if (getElement_Loader != null) {
          getElement_Loader.remove();
        }
        // return url;
      })
      .catch((e) => {
        console.log(e);
      });
  }


  myCallbackFunction(event: StateChange,element_id,url) {
    switch (event.reason) {
      case 'loading-failed':
          console.log('load failed',element_id,url);
          this.changeSource(element_id,url);
        break;
    }
  }

  changeSource(element_id,url) {
    //sample hiec --> "https://alexcorvi.github.io/heic2any/demo/1.heic"
    // element.src = "assets/images/projectdetails/P3_ImageIcon_Blue600.png";
    console.log(this.baseUrl+url+this.sKey1+this.sKey2);
    let currentURL = this.baseUrl+url+this.sKey1+this.sKey2;
    let createElement = document.createElement('img');
    createElement.setAttribute('src', "assets/images/spin.gif");
    createElement.setAttribute('id', 'mediaimageheadLoader' + element_id);
    createElement.style.position = "absolute";
    createElement.style.top = "50%";
    createElement.style.left = "50%";
    createElement.style.height = "50px";
    createElement.style.width = "50px";
    createElement.style.marginLeft = "-25px";
    createElement.style.marginTop = "-25px";
    let get_append_parent = document.getElementById('mediaimagehead' + element_id);
    if (get_append_parent != null) {
      get_append_parent.appendChild(createElement);
    }
    fetch(currentURL)
      .then((res) => res.blob())
      .then((blob) => heic2any({
        blob,
        toType: "image/jpeg",
      }).catch((e) => {
        console.log(e);
      }))
      .then((conversionResult: any) => {
        var url = URL.createObjectURL(conversionResult);
        let element: any = document.getElementById("imageviewer" + element_id);
        element.src = url;
        element.setAttribute("lazyLoad",url);
        let getElement_Loader = document.getElementById('mediaimageheadLoader' + element_id);
        if (getElement_Loader != null) {
          getElement_Loader.remove();
        }
        // return url;
      })
      .catch((e) => {
        console.log(e);
      });
  }

  error_callback(imageurl){
    console.log(imageurl)
    // return this.convert_blob(imageurl);
  }

  convert_blob(imageurl){
    fetch(imageurl).then(response => response.blob()).then(blobValue => {
      let filepath: any = blobValue;
      var file = new Blob([filepath]);
      let fileURL = URL.createObjectURL(file);
      return fileURL;
    })
  }

  // loadImage({ imagePath }: Attributes): Observable<string> {
  //   // Load the image through `HttpClient` and cancel the request if the user change page or the image gets removed
  //   return this.http.get(imagePath, { responseType: 'blob' }).pipe(map(blob => URL.createObjectURL(blob)));
  // }


  callBackgetData = (toolbarId) => {
    this.toolbarElements_view_svg = [];
    if (this.toolbarListData.length > 0) {
      if (toolbarId == null || toolbarId == "") {
        this.toolbarId = this.toolbar_id;
      } else {
        this.toolbarId = toolbarId;
      }
      var istoolbarList = this.toolbarList.filter((data) => data.toolbar_id == this.toolbarId);
      this.toolbarList = istoolbarList;
      if (istoolbarList.length > 0) {
        this.toolbar_name = istoolbarList[0].toolbar_name;
        this.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(this.toolbar_name);
        this.toolbar_id = istoolbarList[0].toolbar_id;
        // set last toolbar appear data
        this.lastseenToolbar_storage();
        this.toolbarData = istoolbarList[0].toolbar_data;
        this.modelFields = JSON.parse(this.toolbarData);
        if (this.updateNewToolbarData != undefined) {
          for (let i = 0; i < this.updateNewToolbarData.length; i++) {
            if (this.updateNewToolbarData[i].toolbarId == this.toolbar_id) {
              this.modelFields = this.updateNewToolbarData[i].convertJsonList;
              console.log(this.modelFields);
            }
          }
        }
        let convertJson_response = this.modelFields;
        if (convertJson_response.length > 0) {
          convertJson_response = this.dataService4.changeSpecialtokeyformatList(convertJson_response, 'toolbarbuilder');
          this.modelFields = convertJson_response;
        }
        //remove Deleted Toolbar Shapes
        let filterToolbarShape = this.modelFields.filter((TData) => TData.is_removed == false ||
          TData.is_removed == "false" || TData.is_removed == 0 || TData.is_removed == "0")
        this.modelFields = filterToolbarShape;
        this.copyOfModelfield = this.modelFields;
        this.tempModelFields = _.cloneDeep(this.modelFields);
        this.toolbarFilter = this.encrptdecrpt.getItem("toolbarFilterItem");
        if (this.modelFields.length > 0) {
          // toolbar svg view
          this.ngForRendred1();
        }
        // The below line is commented for the purpose for ticket number 1168. 
        // this.toolbarFilterMethod();
        console.log(this.tempModelFields);
        // check the enable of copy or move annotation to another document
        let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
        if (get_copy_move_ano_doc != null && get_copy_move_ano_doc.copyandmoveMode == true) {
          let clone_copy_data = _.cloneDeep(get_copy_move_ano_doc.annotations);
          this.enbl_cpy_mv_betweendocument(clone_copy_data, get_copy_move_ano_doc.mode);
        }
        this.getProjectfolderlist(false);
        // this.saveToolBarSwitched()
      } else {
        var start = new Date().getTime();
        console.log('toolbar data' + ' Start time: ' + start);
        this.toolbardesginService.get_toolbar_data(this.toolbarId).subscribe((data) => {
          if (data["response_code"] == 200) {
           
            
            var end = new Date().getTime();
            var time = end - start;
            console.log('toolbar data' + ' end time: ' + end);
            console.log('toolbar data' + ' Execution time: ' + time);
          }
          if (data != null) {
            console.log(data);
            this.toolbar_name = data["response_body"].toolbar_listing[0].toolbar_name;
            this.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(this.toolbar_name);
            this.sub = this.toolbar_name;
            this.toolbar_id = data["response_body"].toolbar_listing[0].toolbar_id;
            let get_toolbar_data = data["response_body"].toolbar_listing[0].toolbar_data;
            // set last toolbar appear data
            this.lastseenToolbar_storage();
            if (get_toolbar_data != null && get_toolbar_data != undefined) {
              let get_response_data = data["response_body"].toolbar_listing[0].toolbar_data;
              let convertJson_response = JSON.parse(get_response_data);
              if (get_toolbar_data.length > 0) {
                this.toolbarData = data["response_body"].toolbar_listing[0].toolbar_data;
                // converting the special characters
                convertJson_response = this.dataService4.changeSpecialtokeyformatList(convertJson_response, 'toolbarbuilder');
                this.modelFields = convertJson_response;
                //remove Deleted Toolbar Shapes
                let filterToolbarShape = this.modelFields.filter((TData) => TData.is_removed == false ||
                  TData.is_removed == "false" || TData.is_removed == 0 || TData.is_removed == "0")

                this.modelFields = filterToolbarShape;
                console.log(this.modelFields);
                this.copyOfModelfield = this.modelFields;
                this.tempModelFields = _.cloneDeep(this.modelFields);
                this.toolbarFilter = this.encrptdecrpt.getItem("toolbarFilterItem");
                this.toolbarFilterMethod();
                if (this.modelFields.length > 0) {
                  // toolbar svg Drawing
                  this.ngForRendred1();
                }
              }
            }
            this.toolbarList.push(data["response_body"].toolbar_listing[0]);
            // check the enable of copy or move annotation to another document
            let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
            if (get_copy_move_ano_doc != null && get_copy_move_ano_doc.copyandmoveMode == true) {
              let clone_copy_data = _.cloneDeep(get_copy_move_ano_doc.annotations);
              this.enbl_cpy_mv_betweendocument(clone_copy_data, get_copy_move_ano_doc.mode);
            }
            this.getProjectfolderlist(false);
            // this.saveToolBarSwitched()
          }
        })
      }
    }
    else {
      // check the enable of copy or move annotation to another document
      let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
      if (get_copy_move_ano_doc != null && get_copy_move_ano_doc.copyandmoveMode == true) {
        let clone_copy_data = _.cloneDeep(get_copy_move_ano_doc.annotations);
        this.enbl_cpy_mv_betweendocument(clone_copy_data, get_copy_move_ano_doc.mode);
      }
      this.getProjectfolderlist(false);
    }


  };




  saveToolBarSwitched() {
    let toolbar_data = _.cloneDeep(this.modelFields);
    // if (typeof this.modelFields === 'string' || this.modelFields instanceof String) {
    //   toolbar_data = JSON.parse(this.modelFields)
    // }else{
    // toolbar_data = this.modelFields
    // }
    let Updatemodel: any = {
      user_id: this.su.user_id,
      toolbar_id: this.toolbarId,
      toolbar_data: toolbar_data,
      toolbar_element_count: toolbar_data.length,
    };
    console.log(Updatemodel);
    this.toolbardesginService
      .update_toolbar_data(Updatemodel).subscribe((data) => {
        console.log(data);
        if (data["response_code"] == 200) {
        }
        else {
        }
      });
  }
  //Footer icon Display
  icon_object = {
    baseurl: "./assets/images/ProjectsScreen/",
    geticon: function (index) {
      //functions 
      return this.baseurl + this.icons[index - 1];
    },
    icons: [
      "P3_Toolbar_CircleIcon.png",
      "P3_Toolbar_OctagonIcon.png",
      "P3_Toolbar_SquareIcon.png",
      "P3_Toolbar_TriangleIcon.png",
      "P3_Toolbar_StarIcon.png",
      "P3_Toolbar_DiamondIcon.png",
      "P3_Toolbar_FlagIcon.png",
      "P3_Toolbar_CameraIcon.png",
      "P3_Toolbar_ArrowIcon.png",
      "P3_Toolbar_CalloutIcon.png",
      "P3_Toolbar_TextIcon_New.png",
      "P3_Toolbar_FreehandLineIcon.png",
      "P3_Toolbar_PolylineArrowIcon.png",
      "P3_Toolbar_PolylineIcon.png",
      "P3_Toolbar_LineIcon.png",
      "P3_Toolbar_LineAxialIcon.png",
      "P3_Toolbar_FreehandAreaIcon.png",
      "P3_Toolbar_PolygonIcon.png",
      "P3_Toolbar_DrawnEllipseIcon.png",
      "P3_Toolbar_DrawnRectangleIcon.png",
    ],
  };

  toolbar_content: any = {
    toolbarItem: this.modelFields,
  };
  //slider
  @Input() public width = 600;
  @Input() public height = 450;

  @ViewChild('pRef', { static: false }) pRef: ElementRef;
  screenWidthValue: any = 0;
  @HostListener('window:resize', ['$event'])
  onResize(event) {
    this.screenWidthValue = event.target.innerWidth;
    console.log(this.screenWidthValue);
  }

  ngAfterViewInit() {
    console.log(this.pRef);
    if (this.arrayUpdated) {
      this.showSlides(this.slideIndex1);
    }
    this.zoomLevels = [0.1, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.5, 3];
    this.currentZoomLevel = 1;
    this.panZoomController = panzoom(document.querySelector('#pdfImg'));
    this.panZoomController.pause();
    this.screenWidthValue = window.innerWidth;
    console.log(this.screenWidthValue);
    this.imageSize();
    // this.dragScrollAction();
    this.createElementChanged = "";
    this.makeResizableDiv();
    // this.makeItSimple();
    this.scrollPage_storage();
    console.log('new class added')
    let get_class = new layerdata_sharing();
    get_class.update_student('ganga',10);
  }


  createElementChanged: any;
  getboundingValue: any;
  bbox: any;
  freehandUpdate: boolean = false;
  stringPathArray: any[] = [];
  public drawCanvasContext: CanvasRenderingContext2D;
  freehand_path_value: string = "";

  

  private captureEvents(element_id) {
    this.createElementChanged = "";
    // this.freehandUpdate=true;
    this.drawFreehandMenu = true;
    var pdfImg = document.getElementById("pdfImg");
    let newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeFreehandAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    pdfImg.appendChild(newcreatedElement);
    // var canvasEl: HTMLCanvasElement = this.createElementChanged;
    this.drawCanvasContext = newcreatedElement.getContext("2d");
    this.drawCanvasContext.lineWidth = this.currentSelectedItems.element_data.line_width;
    this.drawCanvasContext.lineCap = "round";
    var strokeColor = this.currentSelectedItems.element_data.stroke_color;
    this.drawCanvasContext.strokeStyle = this.checkStrokeColor1(strokeColor);
    this.drawCanvasContext.stroke();

    fromEvent(newcreatedElement, "mousedown")
      .pipe(
        switchMap((e) => {
          e.preventDefault();
          console.log(e);
          this.stringPath = "";
          this.a = 0;
          // after a mouse down, we'll record all mouse moves
          return fromEvent(newcreatedElement, "mousemove").pipe(
            // we'll stop (and unsubscribe) once the user releases the mouse
            // this will trigger a 'mouseup' event
            takeUntil(
              fromEvent(newcreatedElement, "mouseup").do(() => {
                if (this.stringPath != "") {
                  this.accessMenuFeatureStop = false;
                  this.stringPathArray.push(this.stringPath);
                  console.log('mouse_up');
                  if (this.toolbarElementId == 17) {
                    var fillColor = this.currentSelectedItems.element_data.fill_color;
                    this.drawCanvasContext.fillStyle = this.checkStrokeColor1(fillColor);
                    this.drawCanvasContext.fill();
                  }
                }
              })
            ),
            // we'll also stop (and unsubscribe) once the mouse leaves the canvas (mouseleave event)
            takeUntil(fromEvent(newcreatedElement, "mouseleave").do(() => {
              if (this.stringPath != "") {
                this.accessMenuFeatureStop = false;
                this.stringPathArray.push(this.stringPath);
                console.log('mouse_up');
                if (this.toolbarElementId == 17) {
                  var fillColor = this.currentSelectedItems.element_data.fill_color;
                  this.drawCanvasContext.fillStyle = this.checkStrokeColor1(fillColor);
                  this.drawCanvasContext.fill();
                }
              }
            })),
            // pairwise lets us get the previous value to draw a line from
            // the previous point to the current point
            pairwise()
          );
        })
      )
      .subscribe((res: [MouseEvent, MouseEvent]) => {
        const rect = newcreatedElement.getBoundingClientRect();
        const prevPos = {
          x: res[0].clientX - rect.left,
          y: res[0].clientY - rect.top,
        };

        const currentPos = {
          x: res[1].clientX - rect.left,
          y: res[1].clientY - rect.top,
        };
        // this method we'll implement soon to do the actual drawing
        this.drawOnCanvas(prevPos, currentPos, element_id);
      });
  }

  addZoom(newcreatedElement) {
    if (this.pngFormat == false && this.pdfScaleValue > 1 && newcreatedElement != null) {
      // let get_pdfannotationhead = document.getElementById('pdfannotationhead');
      let detailed_scale = this.pdfScaleValue;//e.source.viewport.scale
      let increase_width = this.realWidth * this.pdfScaleValue//+(get_width.substring(get_width.length - 2, 0));
      let increase_height = this.realHeight * this.pdfScaleValue
      let width_difference = (increase_width - this.realWidth) / 2;
      let height_difference = (increase_height - this.realHeight) / 2;

      if (this.realHeight < this.realWidth && this.pdfScaleValue < 1) {
        width_difference = 0
      } else if (this.realHeight > this.realWidth && this.pdfScaleValue < 1) {
        height_difference = 0
      }
      // if(height_difference >= 0 && width_difference >= 0){
      newcreatedElement.style.top = height_difference + 'px'
      newcreatedElement.style.left = width_difference + 'px'
      newcreatedElement.style.transform = "matrix(" + detailed_scale + ", 0, 0, " + detailed_scale + ", 0, 0)"
    }
  }

  private captureEventsSVG(element_id) {
    this.createElementChanged = "";
    // this.freehandUpdate=true;
    this.drawFreehandMenu = true;
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeFreehandAttribute", "0.5");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    pdfImg.appendChild(newcreatedElement);
    var create_path: any = "";
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);

    fromEvent(newcreatedElement, "mousedown")
      .pipe(
        switchMap((e) => {
          e.preventDefault();
          if(this.showvisible==false){
            return
          }
          if(this.layerDatas.length==0){
            return
          }
         
          if((this.layerDatas.length!=0)){
    var active=this.layerDatas;
    active=active.filter(res=>res.layer_id==this.activeLayerIdDraw)
         }
         if(this.isReadonly == true){
           return
         }
         if(this.layerDatas.length!=0 && active.length==0){
           return
         }
          console.log(e);
          this.stringPath = "";
          this.freehand_path_value = "";
          this.a = 0;
          create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          create_path.setAttribute("customefreehandattributepath", "1");
          newcreatedElement.appendChild(create_path);
          create_path.setAttribute('stroke', "black");
          create_path.setAttribute('stroke-width', "1");
          create_path.setAttribute('fill', "none");
          // after a mouse down, we'll record all mouse moves
          return fromEvent(newcreatedElement, "mousemove").pipe(
            // we'll stop (and unsubscribe) once the user releases the mouse
            // this will trigger a 'mouseup' event
            takeUntil(
              fromEvent(newcreatedElement, "mouseup").do(() => {
                if (this.stringPath != "") {
                  this.accessMenuFeatureStop = false;
                  this.stringPathArray.push(this.stringPath);
                  console.log('mouse_up');
                  let strokeColor = this.currentSelectedItems.element_data.stroke_color;
                  let get_stroke = this.checkStrokeColor1(strokeColor);
                  create_path.setAttribute('stroke', get_stroke);
                  if (this.toolbarElementId == 17) {
                    let fillColor = this.currentSelectedItems.element_data.fill_color;
                    let get_fill_color = this.checkStrokeColor1(fillColor);
                    create_path.setAttribute('fill', get_fill_color);
                    create_path.setAttribute('d', `${this.freehand_path_value} Z`);
                  }
                }
              })
            ),
            // we'll also stop (and unsubscribe) once the mouse leaves the canvas (mouseleave event)
            takeUntil(fromEvent(newcreatedElement, "mouseleave").do(() => {
              if (this.stringPath != "") {
                this.accessMenuFeatureStop = false;
                this.stringPathArray.push(this.stringPath);
                console.log('mouse_up');
                if (this.toolbarElementId == 17) {
                  let fillColor = this.currentSelectedItems.element_data.fill_color;
                  let get_fill_color = this.checkStrokeColor1(fillColor);
                  create_path.setAttribute('fill', get_fill_color);
                  let strokeColor = this.currentSelectedItems.element_data.stroke_color;
                  let get_stroke = this.checkStrokeColor1(strokeColor);
                  create_path.setAttribute('stroke', get_stroke);
                  create_path.setAttribute('d', `${this.freehand_path_value} Z`);
                }
              }
            })),
            // pairwise lets us get the previous value to draw a line from
            // the previous point to the current point
            pairwise()
          );
        })
      )
      .subscribe((res: [MouseEvent, MouseEvent]) => {
        // const rect = newcreatedElement.getBoundingClientRect();
        const prevPos = {
          x: res[0].offsetX,
          y: res[0].offsetY,
        };

        const currentPos = {
          x: res[1].offsetX,
          y: res[1].offsetY,
        };
        // this method we'll implement soon to do the actual drawing
        this.drawOnCanvasSVG(prevPos, currentPos, create_path);
      });
  }

  private drawOnCanvasSVG(

    prevPos: { x: number; y: number },
    currentPos: { x: number; y: number },
    path,
  ) {
    if (!path) {
      return;
    }
    prevPos.x = prevPos.x;
    prevPos.y = prevPos.y;
    currentPos.x = currentPos.x;
    currentPos.y = currentPos.y;
    prevPos.x = Math.round(prevPos.x);
    prevPos.y = Math.round(prevPos.y);
    currentPos.x = Math.round(currentPos.x);
    currentPos.y = Math.round(currentPos.y);
    console.log(prevPos, currentPos);
    if (prevPos) {
      if (this.a == 0) {
        this.stringPath = this.stringPath + "move" + "-" + prevPos.x + ":" + prevPos.y + " ";
        this.a++;
        // this.drawCanvasContext.moveTo(prevPos.x, prevPos.y); // from
        this.freehand_path_value = this.freehand_path_value == "" ? `M${prevPos.x}  ${prevPos.y} ` : this.freehand_path_value + `M${prevPos.x}  ${prevPos.y} `;
      }
      else {
        // this.drawCanvasContext.lineTo(prevPos.x, prevPos.y); // from
      }

      this.stringPath = this.stringPath + "line-" + currentPos.x + ":" + currentPos.y + " ";
      // this.drawCanvasContext.lineTo(currentPos.x, currentPos.y);
      this.freehand_path_value = this.freehand_path_value == "" ? `L${currentPos.x}  ${currentPos.y} ` : this.freehand_path_value + `L${currentPos.x}  ${currentPos.y} `;
      // console.log(this.freehand_path_value);
      path.setAttribute("d", this.freehand_path_value);
    }
    // previous and current position with the offset
  }

  private drawOnCanvas(
    prevPos: { x: number; y: number },
    currentPos: { x: number; y: number },
    element_id
  ) {
    if (!this.drawCanvasContext) {
      return;
    }
    prevPos.x = prevPos.x / this.scale;
    prevPos.y = prevPos.y / this.scale;
    currentPos.x = currentPos.x / this.scale;
    currentPos.y = currentPos.y / this.scale;
    prevPos.x = Math.round(prevPos.x);
    prevPos.y = Math.round(prevPos.y);
    currentPos.x = Math.round(currentPos.x);
    currentPos.y = Math.round(currentPos.y);
    console.log(prevPos, currentPos);
    if (prevPos) {
      if (this.a == 0) {
        console.log('beginpath', this.scale);
        this.stringPath = this.stringPath + "move" + "-" + prevPos.x + ":" + prevPos.y + " ";
        this.a++;
        this.drawCanvasContext.beginPath();
        this.drawCanvasContext.moveTo(prevPos.x, prevPos.y); // from
      }
      else {
        this.drawCanvasContext.lineTo(prevPos.x, prevPos.y); // from
      }

      this.stringPath = this.stringPath + "line-" + currentPos.x + ":" + currentPos.y + " ";
      this.drawCanvasContext.lineTo(currentPos.x, currentPos.y);
    }
    this.drawCanvasContext.lineWidth = this.currentSelectedItems.element_data.line_width;
    this.drawCanvasContext.lineJoin = 'round';
    var strokeColor = this.currentSelectedItems.element_data.stroke_color;
    this.drawCanvasContext.strokeStyle = this.checkStrokeColor1(strokeColor);
    this.drawCanvasContext.stroke();
    // previous and current position with the offset
  }

  //Draw the Freehand Line End
  annotationsWH: any = [];
  //Update Freehand As one start
  updatefreehandDrawAsOne() {
    this.copytoolhead=false;
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    this.show = true;

    if (this.stringPathArray.length > 0) {
      this.annotationsWH = [];
      var convertAnnotationData = "";
      this.removesvgAttribute("customeFreehandAttribute");
      let close_path_string = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        if (this.toolbarElementId == 17) {
          close_path_string = "";
          let split_value = _.cloneDeep(this.stringPathArray);
          let split_value_remove_space = split_value[i].trim();
          let space_split_value = split_value_remove_space.split(" ");
          let get_first_point = space_split_value[0];
          let split_hyphen = get_first_point.split('-');
          split_hyphen[0] = "line-";
          close_path_string = split_hyphen[0] + split_hyphen[1];
        }
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
        convertAnnotationData = convertAnnotationData.trim();
        convertAnnotationData = convertAnnotationData + " " + close_path_string + " ";
      }
      convertAnnotationData = convertAnnotationData.trim();
      this.annotationUpdateFreehandAsOne(convertAnnotationData);
    }
    // if (this.multipleSelectOn == true) {
    //   // The below two lines are commented for ticket number 1270.
    //   // this.multiselectionList = [];
    //   // this.previousSelectAnnotation = [];
    //   console.log(this.multiselectionList);
    //   if (this.annotationSelected == true) {
    //     if(this.currentSelectedAnnotationData)
    //     if(this.currentSelectedAnnotationData.length!=undefined)
    //     {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //     }
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  getXandYFreehandAsOne(annotationUpdateFreehand) {
    var annotationsXandY = { startx: 0, endx: 0, starty: 0, endy: 0 };
    var xCoordinate = [];
    var yCoordinate = [];
    annotationUpdateFreehand = annotationUpdateFreehand.trim();
    var splitData = annotationUpdateFreehand.split(" ");
    for (var i = 0; i < splitData.length; i++) {
      var hypenSplit = splitData[i].split("-");
      var colonSplit = hypenSplit[1].split(":");
      xCoordinate.push(colonSplit[0]);
      yCoordinate.push(colonSplit[1]);
    }
    annotationsXandY.startx = Math.min.apply(null, xCoordinate);
    annotationsXandY.endx = Math.max.apply(null, xCoordinate);
    annotationsXandY.starty = Math.min.apply(null, yCoordinate);
    annotationsXandY.endy = Math.max.apply(null, yCoordinate);
    this.annotationsWH.push(annotationsXandY);
  }

  updatefreehandDrawAsMany() {
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    this.show = true;
    if (this.stringPathArray.length > 0) {
      let updateAnnotationIds = [];
      let close_path_string = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var trimstring = this.stringPathArray[i].trim();
        if (this.toolbarElementId == 17) {
          let split_value = _.cloneDeep(this.stringPathArray[i]);
          let split_value_remove_space = split_value.trim();
          let space_split_value = split_value_remove_space.split(" ");
          let get_first_point = space_split_value[0];
          let split_hyphen = get_first_point.split('-');
          split_hyphen[0] = "line-";
          close_path_string = split_hyphen[0] + split_hyphen[1];
          trimstring = trimstring + " " + close_path_string;
        }
        let annotationId = this.annotationUpdateFreehandAsMany(trimstring);
        updateAnnotationIds.push(annotationId);
      }
      this.removesvgAttribute('customefreehandattribute');
      this.drawFreehandMenu = false;
      this.accessMenuFeatureStop = false;
      this.toolbarSet = false;
      this.annotationUpdateFreehandAsManyAPI(updateAnnotationIds);
    }
    // if (this.multipleSelectOn == true) {
    //   // The below two lines are commented for ticket number 1270.
    //   // this.multiselectionList = [];
    //   // this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     if(this.currentSelectedAnnotationData.length!=undefined)
    //     {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //     }
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  async annotationUpdateFreehandAsManyAPI(updateAnnotationIds) {
    this.receiveString = "";
    this.freehand_path_value = "";
    this.toolbarBg = -1;
    this.drawFunctionActive = false;
    this.getPositionActive = false;
    this.shapeStringInorNot = false;
    this.drawCanvasContext = null;
    let lastAnnotationData = _.cloneDeep(this.createJson);
    if (this.layerDatas != undefined) {
      for (let a = 0; a < updateAnnotationIds.length; a++) {
        let filter_layer = this.layerDatas.findIndex((layer1) => layer1.layer_id == this.activeLayerIdDraw);
        if (filter_layer > -1) {
          let find_annotation = this.layerDatas[filter_layer].annotations.findIndex((annot1) => annot1.annotation_id == updateAnnotationIds[a]);
          let get_annotation = this.layerDatas[filter_layer].annotations[find_annotation];
          await this.drawUpdatedShapesSVG(get_annotation);
        }
      }
      let layers = this.layerDatas;
      let cloneLayerData = _.cloneDeep(layers);
      // disable drag scroll
      this.createDocumentStore.disable_drag_scroll = false;
      this.documentService.anotupdMulAnnotations_freehand_asmany(cloneLayerData, updateAnnotationIds, this.activeLayerIdDraw, 'newannotation').subscribe((response) => {
        if (response["response_code"] == 200) {
          console.log(response);
          // var tempdetails = response["response_body"]["layer_data"][0]["annotations"];
          // for (let i = 0; i < updateAnnotationIds.length; i++) {
          //   let itemIndex = tempdetails.findIndex(data => data.annotation_id == updateAnnotationIds[i]);
          //   if (itemIndex != -1) {
          //     this.search_displayannotation.push(tempdetails[itemIndex]);
          //   }
          // }
          // this.dataService.search_annotation.emit();
          if (this.layerEnable == true) {
            this.cdRef.detectChanges();
            let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
            let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: this.checkedAnnotationIdsBackup, currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
            console.log(data);

            this.dataService2.layerDatafromnavigation.emit(data);
          }
          
          this.show = false;
          this.getPositionString = "";
          this.stringPathArray = [];
          this.getPositionSetMove = 1;
          this.newplotannotationSelection(this.createJson);
          this.annotationselectEnableDisable('remove');
        }
        else {
          this.annotationselectEnableDisable('remove');
          this.errorMessage();
        }
        if(this.isRapidmode == true && this.rapidmodeData != undefined){
          this.setBgIndex(this.rapidmodeData.index,this.rapidmodeData.itemName,this.rapidmodeData.element_id,this.rapidmodeData.item)
        }
      });
    }
  }



  // when click as many create seperate canvas start
  seperateDrawAsMany(trimstring) {
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.pointerEvents = "none";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    trimstring = trimstring.trim();
    var spaceSplit = trimstring.split(" ");
    console.log(spaceSplit);
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");

      for (var j = 0; j < hypenSplit.length; j++) {
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var colonSplit = hypenSplit[j].split(":");
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var h = parseFloat(colonSplit[2]);
          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            this.canvasElement.moveTo(x, y);
            break;
          case "line":
            this.canvasElement.clearRect(
              0,
              0,
              newcreatedElement.width,
              newcreatedElement.height
            );
            this.canvasElement.lineTo(x, y);
            break;
        }
        if (this.toolbarElementId == 17) {
          this.canvasElement.fillStyle = this.checkStrokeColor1("red");
          this.canvasElement.fill();
        }
        this.canvasElement.lineWidth = 1;
        this.canvasElement.strokeStyle = "rgba(0.999999999885,44.999999991,98.0000000025,1)";
        this.canvasElement.stroke();
      }
    }
  }
  //Update Freehand As one End

  showSlides(n) {
    var i;
    if (n > this.parent.length) {
      this.slideIndex1 = 1;
    }
    if (n < 1) {
      this.slideIndex1 = this.parent.length;
    }
    for (i = 0; i < this.parent.length; i++) {
      this.renderer.setStyle(this.parent[i], "display", "none");
    }
    this.renderer.setStyle(
      this.parent[this.slideIndex1 - 1],
      "display",
      "flex"
    );
    //
  }


  switchPageChangeAction() {
    this.clear_drawing_path();
    let get_page_number = this.slideIndex + 1;
    let find_current_page = this.documentDetails.findIndex((page_data) => page_data.page_number == get_page_number);
    if (find_current_page > -1) {
      let pageNumber = 0;
      let imgurlTemp = this.documentDetails[find_current_page].file_path;
      this.imgUrl = environment.APIBaseUrl + "get_web_singed_file?file=" + imgurlTemp + "&key1=" + this.imgdataService.securityKey1() + "&key2=" + this.imgdataService.securityKey2();
      this.currentPageId = this.documentDetails[find_current_page].page_id;
      this.realWidth = this.documentDetails[find_current_page].width;
      this.realHeight = this.documentDetails[find_current_page].height;
      this.documentService.createDocumentStore_values.document_width = this.realWidth;
      this.documentService.createDocumentStore_values.document_height = this.realHeight;
      console.log("this.realWidth", this.realWidth);
      console.log("this.realHeight", this.realHeight);
      console.log('page_icon_data : ', this.documentDetails[find_current_page].page_icon_data);
      let base_icon_details = this.documentDetails[find_current_page].page_icon_data;
      if (base_icon_details != null) {
        this.iconsize1 = base_icon_details;
        var stringify = JSON.parse(this.iconsize1);
        this.seticonheight = stringify.height;
        this.seticonwidth = stringify.width;
      }
      else {
        this.iconsize1 = null;
        this.seticonheight = 0;
        this.seticonwidth = 0;
      }
      this.pageName = this.documentDetails[find_current_page].page_name;
      pageNumber = this.documentDetails[find_current_page].page_number;
      // this.imageScalingReset();
      this.getActiveLayerIdMain();
      const layer_api_call = new Promise(async resolve => {
        let get_response = await this.getAnnotationForm();
        resolve(get_response);
      });
      Promise.all([layer_api_call]).then(responses => {
        if (responses[0] == 200) {
          this.getGroupAnnotationDatas();
        }
      });
      this.getAnnotationForm();
      this.pagewisemaintainzoom();
      if (this.multipleSelectOn == true) {

        // this.removeCanvasAttribute("customeMultipleAttribute");
        this.createDocumentStore.selectedAnnotations = [];
        this.multiselectionList = [];
        // multiselection svg drawing empty place
        this.multiselectionList_svg_view = [];
        this.selectAnnotationZero();
        // this.captureEventsMultiple();
      }
      // let senddata = { data: this.documentDetails, pageno: pageNumber, pdfPath: this.imgUrl, pngFormat: this.pngFormat };
      // this.dataService.sendPageDatawithNumber.emit(senddata);
      let document_input = {
        pageNumber: pageNumber, document_details: this.documentDetails,
        pngFormat: this.pngFormat, imgUrl: this.imgUrl, currentPageId: this.currentPageId, pageName: this.pageName
      };
      this.document_credential.update_current_documents_data(document_input);

    }
    if (this.getsearchoption) {
      this.encrptdecrpt.setItem(this.projectId + "currentpage", this.currentPageId);//security
      console.log(this.currentPageId);
      this.dataService.searchoption.emit(true);
      this.searchOption = true;
    } else {
      this.searchOption = false;
    }
    var end = new Date().getTime();
    console.log('page function' + ' end time: ' + end);
    // this.checkLayerPagesBasedShowData();
  }

  closeAlignAnn(){
    this.alignAnnEnabled = false;
    let alignAnnDatas = {annotationData: "",type: 'end'}
    this.dataService2.annotationAlignment.emit(alignAnnDatas);
    this.deselectAnnotation();
    if(this.multipleSelectOn == true){
      this.dataService2.imageChangeDocHeader.emit();
    }
    this.alignAnnBaseAnn = [];
  }

  imageScalingReset() {
    let getImageContainer = document.getElementById("Imagecontainer");
    let getImageContainerSize = getImageContainer.getBoundingClientRect();
    if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
      let disableScale = false;
      var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
      console.log(scale_val);
      this.scale = scale_val;
      let currentViewX = this.realWidth * scale_val;
      let currentViewY = this.realHeight * scale_val;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      const x1 = this.realWidth;
      const y1 = this.realHeight;
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: scale_val,
      });
      let viewImageDiv = document.getElementById("pdfImg");

      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      panZoomElement.pause();
    }
    else {
      let centerX = getImageContainerSize.width - this.realWidth;
      let centerY = getImageContainerSize.height - this.realHeight;
      let viewImageDiv = document.getElementById("pdfImg");
      this.scaleValue = 1;
      this.scale = 1;
      this.getAnnotationForm();
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
    }
    // calling Page Zoom maintain function
    this.pagewise_zoom_storage();
  }

  async switchPageChangeActionPdf() {
    this.clear_drawing_path();
    if (this.pdfScaleValue >= 1) {
      // revert back to the zooming styles
      let get_pdfimg = document.getElementById('pdfImg');
      if (get_pdfimg != null) {
        get_pdfimg.style.width = this.realWidth + 'px';
        get_pdfimg.style.height = this.realHeight + 'px';
      }
      let get_annotationhead = document.getElementById('pdfannotationhead');
      if (get_annotationhead != null) {
        get_annotationhead.style.removeProperty('top');
        get_annotationhead.style.removeProperty('left');
        get_annotationhead.style.removeProperty('transform');
      }
    }
    let filter_current_page_details = this.documentDetails.find((find_page) => find_page.page_number == this.currentPageNumber);
    if (typeof filter_current_page_details != undefined) {
      let pageNumber = 0;
      this.realHeight = filter_current_page_details.height;
      this.realWidth = filter_current_page_details.width;
      this.documentService.createDocumentStore_values.document_width = filter_current_page_details.width;
      this.documentService.createDocumentStore_values.document_height = filter_current_page_details.height;
      this.currentPageId = filter_current_page_details.page_id;
      let base_icon_details = filter_current_page_details.page_icon_data;
      if (base_icon_details != null) {
        this.iconsize1 = base_icon_details;
        var stringify = JSON.parse(this.iconsize1);
        this.seticonheight = stringify.height;
        this.seticonwidth = stringify.width;
      }
      else {
        this.iconsize1 = null;
        this.seticonheight = 0;
        this.seticonwidth = 0;
      }
      this.pageName = filter_current_page_details.page_name;
      pageNumber = filter_current_page_details.page_number;
      // await this.pdfPanzoomSync(1);
      this.getActiveLayerIdMain();
      console.log(this.activeLayerIdDraw);
      let get_response = await this.getAnnotationForm();
      // this.pdfPanzoomSample();
      this.pagewisemaintainzoompdf();
      this.getGroupAnnotationDatas();
      if (get_response == 200) {
        console.log('getactivelayer function completed');
        this.show = false;
      }
      // let senddata = { data: this.documentDetails, pageno: pageNumber, pdfPath: this.imgUrl, pngFormat: this.pngFormat };
      // this.dataService.sendPageDatawithNumber.emit(senddata);
      let document_input = {
        pageNumber: pageNumber, document_details: this.documentDetails,
        pngFormat: this.pngFormat, imgUrl: this.imgUrl, currentPageId: this.currentPageId, pageName: this.pageName
      };
      this.document_credential.update_current_documents_data(document_input);
    }
    var end = new Date().getTime();
    console.log('page function' + ' end time: ' + end);
    // for (var i = 0; i < this.documentDetails.length; i++) {
    //   if (this.pdfPageNumber == this.documentDetails[i].page_number) {
    //     let pageNumber = 0;
    //     let getChildCanvas = document.querySelectorAll("svg.documentSVG");
    //     if (getChildCanvas.length > 0) {
    //       for (var a = 0; a < getChildCanvas.length; a++) {
    //         console.log(a + 1);
    //         if (getChildCanvas[a].getAttribute('documentSVG') != null) {
    //           getChildCanvas[a].remove();
    //         }
    //       }
    //     }
    //     let currentPageNumbr3$ = this.documentPage.singlePagenumber.emit(this.pdfPageNumber);

    //     this.realHeight = this.documentDetails[i].height;
    //     this.realWidth = this.documentDetails[i].width;
    //     this.documentService.createDocumentStore_values.document_width = this.documentDetails[i].width;
    //     this.documentService.createDocumentStore_values.document_height = this.documentDetails[i].height;
    //     this.currentPageId = this.documentDetails[i].page_id;
    //     this.documentPage.currentPageId.emit(this.currentPageId);
    //     console.log('current_page_id : ', this.currentPageId);
    //     console.log('page_icon_data : ', this.documentDetails[i].page_icon_data)
    //     let base_icon_details = this.documentDetails[i].page_icon_data;
    //     if (base_icon_details != null) {
    //       this.iconsize1 = base_icon_details;
    //       var stringify = JSON.parse(this.iconsize1);
    //       this.seticonheight = stringify.height;
    //       this.seticonwidth = stringify.width;
    //     }
    //     else {
    //       this.iconsize1 = null;
    //       this.seticonheight = 0;
    //       this.seticonwidth = 0;
    //     }
    //     this.pageName = this.documentDetails[i].page_name;
    //     pageNumber = this.documentDetails[i].page_number;
    //     this.dataService.pageName.emit(this.pageName);
    //     console.log(this.documentDetails[i], this.realWidth, this.realHeight,);
    //     await this.pdfPanzoomSync(1);
    //     this.getActiveLayerIdMain();
    //     console.log(this.activeLayerIdDraw);
    //     this.getAnnotationForm();
    //     let senddata = { data: this.documentDetails, pageno: pageNumber, pdfPath: this.imgUrl, pngFormat: this.pngFormat };
    //     this.dataService.sendPageDatawithNumber.emit(senddata);
    //   }
    // }
  }

  checkLayerPagesBasedShowData() {
    //dummy data
    //  let page_element = this.layerDatas[0].associated_pages.filter(ele => ele.page_id == this.currentPageId)
    if (this.layerDatas != undefined) {
      for(var k=0;k<this.documentDetails.length;k++){
        this.findlayerid = this.layerDatas.filter((document_page) => document_page.layer_id === this.documentDetails[k].active_layer_id)
        if(this.findlayerid.length!=0)
        {
          break;
        }
      }
      if(this.findlayerid!=undefined && this.findlayerid!=null && this.findlayerid.length==0){
        this.findlayerid = this.layerDatas.filter(check => this.createDocumentStore.data_allow_conditionT.includes(check.is_active_flag));
      }
      if (this.findlayerid.length != 0) {
        this.findlayerid.forEach((data) => {
          console.log(data)

          let associated_pages = data.associated_pages
          this.show = false
          let page_element1 = associated_pages.filter(ele => ele.page_id == this.currentPageId)

          if (page_element1.length != 0) {
            if (page_element1[0].is_hidden == true || page_element1[0].is_hidden == "true" || page_element1[0].is_hidden == 1) {
              this.showvisible = false;
              console.log(this.showvisible)

            } else {

              this.showvisible = true;
              console.log(this.showvisible)
            }
            if (page_element1[0].is_lock == true || page_element1[0].is_lock == "true" || page_element1[0].is_lock == 1) {
              this.lockedLayerActive = true;
            }
            else {
              this.lockedLayerActive = false;
            }
          }
        })
      }
    }
  }
  //Panning and Zooming Start

  zoom() {
    const isSmooth = false;
    const scale = this.currentZoomLevel;
    if (scale) {
      const transform = this.panZoomController.getTransform();
      const deltaX = transform.x;
      const deltaY = transform.y;
      const offsetX = scale + deltaX;
      const offsetY = scale + deltaY;

      if (isSmooth && this.drawFunctionActive == false) {
        this.panZoomController.smoothZoom(0, 0, scale);
      } else {
        this.panZoomController.zoomTo(offsetX, offsetY, scale);
      }
    }
  }

  toolbarElementId: number;
  newShapeAddwhenMultiSelect: boolean = false;
  selectAnnotationForms: any[] = [];
  shapeStringInorNot: boolean = false;
  //ToolbarIcon Select icon and setBg Start
  rapidmodeData : any; 
  async setBgIndex(index, itemName, element_id, item) {
    this.formContentleft = [];
    this.formContentright = [];
    this.useCaseEmptycellIds = []
    this.setbgBool = true;
    this.useCaseEmptycellIds = []
    this.encrptdecrpt.setItem("setbgIndexBool",this.setbgBool);
    console.log("setBgIndex",index, itemName, element_id, item)
    if(this.toolbar_name=="Copy mode Enabled" && this.isRapidmode == true){
      console.log(this.propertiesannotationData,this.createDocumentStore.current_copy_annot_data,this.copyAnnotationCreatePageValue,this.drawFunctionActive,this.getPositionActive)
      this.getCurrentCopyData(this.propertiesannotationData,0)
      this.copyAnnotationCreatePageValue = true 
      this.drawFunctionActive = true
      this.getPositionActive = true
      return
    }
    if(this.isRapidmode == true){
      this.rapidmodeData={index, itemName, element_id, item}
    }
    this.dataService2.searchselector.emit(false)
    let filter_current_shape = this.modelFields.find((toolbar) => toolbar.element_uuid == item.element_uuid);
    item = filter_current_shape;
    await this.automatic_update_form();
    if (this.attribute_change == true) {
      await this.attribute_value_changes();
    }
    this.annotationtagsName = '';
    let no_layer = false;
    this.textsize = 13;
    let no_active_layer = false;
    // current page details get from document pages
    let check_current_Page_active = this.documentDetails.filter((page_data_active) => page_data_active.page_id == this.currentPageId);
    if (check_current_Page_active.length > 0) {
      // active layer id based get data from document pages
      this.value = this.layerDatas.filter(layeritem => layeritem.layer_id == check_current_Page_active[0].active_layer_id);
      if(this.value.length==0){ // P2 active layer and lock and visible process
        let find_layer_active_P2 =  this.layerDatas.filter(layeritem => this.createDocumentStore.data_allow_conditionT.includes(layeritem.is_active_flag));
        if(find_layer_active_P2.length>0){
          this.value = find_layer_active_P2;
        }
        else{
          this.value = [];
        }
      }
      if (this.value.length > 0) {
        this.activeLayerIdDraw = check_current_Page_active[0].active_layer_id;
        if(check_current_Page_active[0].active_layer_id == null){
          this.activeLayerIdDraw = this.value[0].layer_id;
        }
        let associated_pages = this.value[0].associated_pages;
        let page_element1 = associated_pages.filter(ele => ele.page_id == this.currentPageId)
        let get_lock = page_element1[0].is_lock;
        let get_visible = page_element1[0].is_hidden;
        if(get_lock == undefined){
          get_lock = JSON.parse(this.value[0].is_locked_flag);
        }
        if(get_visible == undefined){
          get_visible = JSON.parse(this.value[0].is_visible_flag);
          get_visible = !get_visible;
        }
        if (this.createDocumentStore.data_allow_condition.includes(get_lock)) {
          this.lockedLayerActive = false;
        }
        else {
          this.lockedLayerActive = true;
        }
        if (this.createDocumentStore.data_allow_condition.includes(get_visible) && this.lockedLayerActive == false) {
          this.showvisible = true;
        }
        else {
          this.showvisible = false;
        }
      }
      else {
        this.value = [];
        this.lockedLayerActive = false;
        this.showvisible = true;
        no_active_layer = true;
      }
    }

    if (this.layerDatas.length == 0) {
      const dialogRef = this.dialogBox.open(ClayeralertComponent, {
        data: {
          active: false
        }
      });
    }
    else if (this.layerDatas.length > 0) {
      if (this.lockedLayerActive == true && no_layer == false) {
        const dialogRef = this.dialogBox.open(ClayeralertComponent, {
          data: {
            lock: true
          }
        }
        )
      }
      else if (this.showvisible == false && no_layer == false) {
        const dialogRef = this.dialogBox.open(ClayeralertComponent, {
          data: {
            lock: false
          }
        })
      }
      else if (this.lockedLayerActive == false && this.showvisible == true && no_layer == false && no_active_layer == false) {
        this.currentSelectedItems = item;
        // P2 shape does not have below keys show we can map manually emtpy values
        if (this.currentSelectedItems.element_data.shape != undefined && this.currentSelectedItems.element_data.shape.initial_width == undefined) {
          this.currentSelectedItems.element_data.shape.initial_width = 0;
        }
        if (this.currentSelectedItems.element_data.shape != undefined && this.currentSelectedItems.element_data.shape.initial_height == undefined) {
          this.currentSelectedItems.element_data.shape.initial_height = 0;
        }
        if (this.currentSelectedItems.element_data.shape != undefined && this.currentSelectedItems.element_data.shape.annotation_media == undefined) {
          this.currentSelectedItems.element_data.shape.annotation_media = [];
        }
        if (this.currentSelectedItems.element_data.shape != undefined && this.currentSelectedItems.element_data.shape.annotation_links == undefined) {
          this.currentSelectedItems.element_data.shape.annotation_links = [];
        }
        if (this.currentSelectedItems.element_data.shape != undefined && this.currentSelectedItems.element_data.shape.annotation_tags == undefined) {
          this.currentSelectedItems.element_data.shape.annotation_tags = "";
        }
        if (this.currentSelectedItems.element_data.shape != undefined && this.currentSelectedItems.element_data.shape.initial_rotation == undefined) {
          this.currentSelectedItems.element_data.shape.initial_rotation = "0";
        }

        console.log(this.currentSelectedItems);
        this.shapeStringInorNot = false;
        this.toolbarSet = true;
        if (item.element_data.shape != undefined && item.element_data.shape.is_stamp != '0' && item.element_data.shape.is_stamp != 0) {
          this.shapeStringInorNot = true;
        }
        if (this.lockedLayerActive == false && this.shapeStringInorNot == false) {
          // if (this.multipleSelectOn == true) {
          //   this.newShapeAddwhenMultiSelect = true;
          // }
          this.receiveString = "";
          console.log(this.formList, this.modelFieldsForm);
          if (item.element_data.forms_list_data == undefined) {
            this.selectAnnotationForms = [];
            // this.modelFieldsForm = []
          }
          else if (item.element_data.forms_list_data != undefined) {
            var formsToMap = [];
            var custom_form_entervalue_wmata = false;
            var custom_form_defaultvalues_wmata = false;
            var custom_form_inspection_wmata = false;
            var get_first_option_default_values = [];
            var get_fields = [];
            let elementForms = item.element_data.forms_list_data;
            var custom_form_timber_inspection = false;
            // forms count loop
            for (let i = 0; i < elementForms.length; i++) {

              console.log(this.formListDefaultValues)
               //Before without using clonedeep this.formListDefaultValues array is filtered.So any forms values attached with annotation in toolbar are reflected for remaining annotations too. 
               var formListDefaultValuesCopy = _.cloneDeep(this.formListDefaultValues);
               let formidentified = formListDefaultValuesCopy.filter((form) => form.form_id == elementForms[i].form_id);
              // let formidentified =elementForms.filter((form) => form.form_id == this.formList[i].form_id);
              if (formidentified.length > 0) {
                let localForm = formidentified[0];
                if (localForm.hasOwnProperty('is_extend')) {
                  var is_extends = localForm.is_extend;
                  if (this.createDocumentStore.data_allow_condition.includes(is_extends)) {
                    is_extends = false;
                  } else {
                    is_extends = true;
                  }
                } else {
                  this.is_extend = false;
                }
                if (typeof localForm.form_data === 'string' || localForm.form_data instanceof String) {
                  console.log("String Ji");
                  localForm.form_data = JSON.parse(localForm.form_data);
                }
                if (localForm.hasOwnProperty('ext_form_data') && localForm.ext_form_data != null && localForm.ext_form_data.length != 0) {
                  if (typeof localForm.ext_form_data === 'string' || localForm.ext_form_data instanceof String) {
                    localForm.ext_form_data = JSON.parse(localForm.ext_form_data);
                  }
                }
                // forms => form data loop

                let form_data = localForm.form_data;
                for (let j = 0; j < form_data.length; j++) {
                  let element_value = form_data[j];
                  let compare_form_data = elementForms[i].form_data.filter((element_data) => element_data.element_uuid == element_value.element_uuid);
                  if (compare_form_data.length > 0) {
                    let element_data = element_value.element_data;
                    if (element_value.element_type == "single_choice" || element_value.element_type == "multiple_choice" || element_value.element_type == "checkbox" || element_value.element_type == "dropdown") {
                      let options = element_data.options;
                      for (let k = 0; k < options.length; k++) {
                        let compare_options = compare_form_data[0].element_data.options.filter((element_id) => element_id.element_uuid == options[k].element_uuid);
                        if (compare_options.length > 0) {
                          options[k].default = compare_options[0].default
                        }
                        // custom form wmata inspecation true of false find palce
                        if (element_value.element_type == "multiple_choice" && element_value.element_name == "Inspection Completed" && options[0].default == true) {
                          // inspection true
                          custom_form_inspection_wmata = true;
                        }
                        // custom form timber inspection true of false find place
                        if (element_value.element_type == "checkbox" && compare_options[0].attributes == true && compare_options[0].default == true) {
                          custom_form_timber_inspection = true;
                        }
                        else if (element_value.element_type == "checkbox" && compare_options[0].attributes == true && compare_options[0].default == false) {
                          custom_form_timber_inspection = false;
                        }
                      }
                      element_data.options = options;
                    } else if (element_value.element_type == "date") {
                      
                      element_data.default_value = compare_form_data[0].element_data.default_value
                      element_data.default_date_time = compare_form_data[0].element_data.default_date_time
                    }
                    else if (element_value.element_type == "address") {

                      if (compare_form_data[0].element_data.city != '') {
                        element_data.city = compare_form_data[0].element_data.city
                      } else {

                      }
                      if (compare_form_data[0].element_data.street_address1 != '') {
                        element_data.street_address1 = compare_form_data[0].element_data.street_address1
                      } else {

                      }
                      if (compare_form_data[0].element_data.street_address2 != '') {
                        element_data.street_address2 = compare_form_data[0].element_data.street_address2
                      } else {

                      }
                      if (compare_form_data[0].element_data.state != '') {
                        element_data.state = compare_form_data[0].element_data.state
                      } else {

                      }
                      if (compare_form_data[0].element_data.zip != '') {
                        element_data.zip = compare_form_data[0].element_data.zip
                      } else {

                      }
                    }

                    else if (compare_form_data[0].element_type == "uti-entry-field-WMATA") {
                      if (compare_form_data[0].element_data.hasOwnProperty("default_values")) {
                        if (compare_form_data[0].element_data.default_values != undefined && compare_form_data[0].element_data.default_values != "") {
                          element_data["default_values"] = compare_form_data[0].element_data.default_values;
                          // custom form values filled
                          custom_form_entervalue_wmata = true;
                          custom_form_defaultvalues_wmata = true;
                          // first array stored place
                          get_first_option_default_values = element_value.element_data.default_values[0];
                          get_fields = element_value.element_data.fields;
                        }
                      }
                    }
                    else if (compare_form_data[0].element_type == "uti-entry-field-WMATA_WELD") {
                      if (compare_form_data[0].element_data.hasOwnProperty("default_values")) {
                        if (compare_form_data[0].element_data.default_values != undefined && compare_form_data[0].element_data.default_values != "") {
                          element_data["default_values"] = compare_form_data[0].element_data.default_values;
                        }
                      }
                    }
                    else if (compare_form_data[0].element_type == "uti-entry-field-TIMBER") {
                      if (compare_form_data[0].element_data.hasOwnProperty("default_values")) {
                        if (compare_form_data[0].element_data.default_values != undefined && compare_form_data[0].element_data.default_values != "") {
                          // timber form default values store to formlist formdata
                          element_data["default_values"] = compare_form_data[0].element_data.default_values;
                        }
                      }
                    }
                    else {
                      element_data.default_value = compare_form_data[0].element_data.default_value;
                      let find_custom_form = form_data.findIndex((fields_checkup) => fields_checkup.element_type == "uti-entry-field-WMATA");
                      if (find_custom_form > -1 && element_data.default_value != undefined && element_data.default_value != '') {
                        // custom form values filled
                        custom_form_entervalue_wmata = true;
                      }
                    }
                    element_data.last_modified_date = new Date().toISOString();
                    element_value.element_data = element_data;
                    console.log(element_value.element_data);
                  }
                  form_data[j] = element_value;
                }
                if (is_extends == true) {
                  if (localForm.ext_form_data != null && localForm.hasOwnProperty('ext_form_data')) {
                    let ext_form_data = localForm.ext_form_data;
                    for (let j = 0; j < ext_form_data.length; j++) {
                      let element_value = ext_form_data[j]
                      let compare_form_data = elementForms[i].ext_form_data.filter((element_data) => element_data.element_uuid == element_value.element_uuid);
                      if (compare_form_data.length > 0) {
                        let element_data = element_value.element_data;
                        if (element_value.element_type == "address") {

                          if (compare_form_data[0].element_data.city != '') {
                            element_data.city = compare_form_data[0].element_data.city
                          } else {

                          }
                          if (compare_form_data[0].element_data.street_address1 != '') {
                            element_data.street_address1 = compare_form_data[0].element_data.street_address1
                          } else {

                          }
                          if (compare_form_data[0].element_data.street_address2 != '') {
                            element_data.street_address2 = compare_form_data[0].element_data.street_address2
                          } else {

                          }
                          if (compare_form_data[0].element_data.state != '') {
                            element_data.state = compare_form_data[0].element_data.state
                          } else {

                          }

                          if (compare_form_data[0].element_data.zip != '') {
                            element_data.zip = compare_form_data[0].element_data.zip
                          } else {

                          }
                        }
                        if (element_value.element_type == "single_choice" || element_value.element_type == "multiple_choice" || element_value.element_type == "checkbox" || element_value.element_type == "dropdown") {
                          let options = element_data.options
                          for (let k = 0; k < options.length; k++) {
                            let compare_options = compare_form_data[0].element_data.options.filter((element_id) => element_id.element_uuid == options[k].element_uuid);
                            if (compare_options.length > 0) {
                              options[k].default = compare_options[0].default
                            }
                          }
                          element_data.options = options
                        } else if (element_value.element_type == "date") {
                          
                          element_data.default_value = compare_form_data[0].element_data.default_value
                          element_data.default_date_time = compare_form_data[0].element_data.default_date_time
                        } else {
                          element_data.default_value = compare_form_data[0].element_data.default_value
                        }
                        element_data.last_modified_date = new Date().toISOString();
                        element_value.element_data = element_data
                        console.log(element_value.element_data)
                      }
                      ext_form_data[j] = element_value

                    }
                    localForm.ext_form_data = ext_form_data;
                  }
                }
                localForm.form_data = form_data;
                // is_default_flag value replace annotation form value
                localForm.is_default_flag = elementForms[i].is_default_flag;
                formsToMap.push(localForm);
              }
            }
            this.selectAnnotationForms = formsToMap;
          }
          console.log(this.selectAnnotationForms);
          this.drawFunctionActive = true;
          this.getPositionActive = true;
          this.annotationName = item.element_data.element_name == '' ? item.element_data.element_type : item.element_data.element_name;
          this.toolbarBg = index;
          this.deselectAnnotation();
          this.annotationselectEnableDisable('enable');
          //Temporary Layer Plotting annotation on Top
          //Shapes here
          //Circle
          if (element_id == 1) {
            this.toolbarElementId = 1;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.receiveString = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
          }
          //octagon
          else if (element_id == 2) {
            this.toolbarElementId = 2;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            // this.receiveString = "move-15:25 line-18:18 line-25:15 line-32:18 line-35:25 line-32:32 line-25:35 line-18:32 line-15:25 line-18:18";
            this.receiveString = "move-15:25 line-18:18 line-25:15 line-32:18 line-35:25 line-32:32 line-25:35 line-18:32 line-15:25 line-18:18";
          }
          else if (element_id == 3) {
            this.toolbarElementId = 3;
            this.receiveString = "move-15:15 line-35:15 line-35:35 line-15:35 line-15:15 line-35:15";
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
          }
          else if (element_id == 4) {
            this.toolbarElementId = 4;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            this.receiveString =
              "move-25:15 line-35:35 line-15:35 line-25:15 line-35:35";
          }
          else if (element_id == 5) {
            this.toolbarElementId = 5;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            //old string value for star
            // "move-25:12 line-30:22 line-38:22 line-32:30 line-35:40 line-25:34 line-15:40 line-18:30 line-12:22 line-20:22 line-25:12 line-30:22"
            this.receiveString = "move-25:12 line-29.5:22 line-38:22 line-32:29.5 line-35:40 line-25:35 line-15:40 line-18:29.5 line-12:22 line-20.5:22 line-25:12 line-29.5:22";
          }
          else if (element_id == 6) {
            this.toolbarElementId = 6;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            this.receiveString =
              "move-25:15 line-32.5:25 line-25:35 line-17.5:25 line-25:15 line-32.5:25";
          }
          else if (element_id == 7) {
            this.toolbarElementId = 7;
            this.receiveString = "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-17:25 line-17:40 line-15:40 line-15:15"
            // old string  
            // "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-15:25";

            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
          } else if (element_id == 8) {
            this.toolbarElementId = 8;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            // this.receiveString = "ovalIn-21.5:18:7:7 move-10:15 line-17:15 line-17:10 line-33:10 line-33:15 line-40:15 line-40:31 line-10:31 line-10:15 line-17:15 move-34:19 line-35:19";
            this.receiveString = "move-31:22 controlpoint1-31:25.3137 controlpoint2-28.3137:28 endCurve-25:28 controlpoint1-21.6863:28 controlpoint2-19:25.3137 endCurve-19:22 controlpoint1-19:18.6863 controlpoint2-21.6863:16 endCurve-25:16 controlpoint1-28.3137:16 controlpoint2-31:18.6863 endCurve-31:22 move-17.5:15 line-19.5:12.5 line-30.5:12.5 line-32.5:15 line-36:15 controlpoint-38:15 curveEnd-38:17 line-38:29 controlpoint-38:31 curveEnd-36:31 line-14:31 controlpoint-12:31 curveEnd-12:29 line-12:17 controlpoint-12:15 curveEnd-14:15 line-17.5:15 line-19.5:12.5 move-14:19 line-16:19 line-16:20 line-14:20 move-22:22 controlpoint-22:19 curveEnd-25:19 controlpoint-28:19 curveEnd-28:22 controlpoint-28:25 curveEnd-25:25 controlpoint-22:25 curveEnd-22:22";
          } else if (element_id == 9) {
            this.toolbarElementId = 9;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            this.receiveString =
              "move-10:22.5 line-25:22.5 line-25:15 line-40:25 line-25:35 line-25:27.5 line-10:27.5 line-10:22.5 line-25:22.5";
          }
          else if (element_id == 11) {
            this.toolbarElementId = 11;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
          }
          else if (element_id == 12) {
            this.dataService2.moveAccessfn(true);
            this.shape = true;
            this.toolbarElementId = 12;
            this.annotationName = itemName;
            this.drawFreehandMenu = true;
            this.accessMenuFeatureStop = true;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            // this.panZoomController.pause();
            this.captureEventsSVG(element_id);
            // this.freehanddrawing();
          }
          else if (element_id == 13) {
            this.dataService2.moveAccessfn(true);
            this.shape = true;
            this.toolbarElementId = 13;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = true;
            this.drawShapeDoneLineAxial = false;
            this.accessPolylineArrowMenuFeatureStop = true;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            // this.panZoomController.pause();
            this.polylinearrowmethodSVG();
          }
          else if (element_id == 14) {
            this.dataService2.moveAccessfn(true);
            this.shape = true;
            this.toolbarElementId = 14;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolylineArrow = false;
            this.accessPolylineMenuFeatureStop = true;
            this.drawShapeDoneLineAxial = false;
            this.drawShapeDonePolyline = true;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            this.polylinemethodSVG();
          }
          else if (element_id == 15) {
            this.dataService2.moveAccessfn(true);
            this.shape = true;
            this.toolbarElementId = 15;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.accessLineMenuFeatureStop = true;
            this.drawShapeDoneLine = true;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            this.drawLineMethodSVG(0);
          }
          else if (element_id == 16) {
            this.dataService2.moveAccessfn(true);
            this.shape = true;
            this.toolbarElementId = 16;
            this.drawShapeDonePolygon = false;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.accessLineAxialMenuFeatureStop = true;
            this.drawShapeDoneLineAxial = true;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            this.drawLineAxialMethodSVG();
          }
          else if (element_id == 17) {
            this.dataService2.moveAccessfn(true);
            this.shape = true;
            this.toolbarElementId = 17;
            this.drawFreehandMenu = true;
            this.annotationName = itemName;
            this.accessMenuFeatureStop = true;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            this.captureEventsSVG(element_id);
          }
          else if (element_id == 18) {
            this.dataService2.moveAccessfn(true);
            this.shape = true;
            this.toolbarElementId = 18;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = true;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.accessPolygonMenuFeatureStop = true;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = false;
            this.drawEllipseDone = false;
            // this.panZoomController.pause();
            this.polygonmethodSVG();
          }
          else if (element_id == 19) {
              this.dataService2.moveAccessfn(true);
              this.shape = true;
              this.toolbarElementId = 19;
              this.drawShapeDoneLineAxial = false;
              this.drawRectangleDone = false;
              this.drawEllipseDone = true;
              this.drawFreehandMenu = false;
              this.drawShapeDonePolygon = false;
              this.drawShapeDonePolyline = false;
              this.drawShapeDonePolylineArrow = false;
              this.accessPolygonMenuFeatureStop = false;
              this.accessdrawEllipseMenuStop = true;
              // this.drawEllipse();
              this.drawEllipsesvg();
          }
          else if (element_id == 20) {
            this.dataService2.moveAccessfn(true);
            this.shape = true;
            this.toolbarElementId = 20;
            this.drawFreehandMenu = false;
            this.drawShapeDonePolygon = false;
            this.drawShapeDonePolyline = false;
            this.drawShapeDonePolylineArrow = false;
            this.drawShapeDoneLineAxial = false;
            this.drawRectangleDone = true;
            this.drawEllipseDone = false;
            this.accessPolygonMenuFeatureStop = false;
            this.accessRectangleMenuFeatureStop = true;
            // this.panZoomController.pause();
            // this.drawRectangle();
            this.drawRectangleSVG();
          }

          if (this.toolbarElementId > 11) {
            // disable drag scroll
            this.createDocumentStore.disable_drag_scroll = true;
          }

        }
        else if (this.shapeStringInorNot == true) {
          if (item.element_data.forms_list_data == undefined) {
            this.selectAnnotationForms = [];
          }
          else if (item.element_data.forms_list_data != undefined) {
            this.selectAnnotationForms = item.element_data.forms_list_data;
          }
          this.drawFunctionActive = true;
          this.getPositionActive = true;
          this.toolbarBg = index;
          this.annotationName = itemName;
          this.deselectAnnotation();
          this.toolbarElementId = element_id;
          this.receiveString = item.element_data.shape.annotation_data;
          this.drawFreehandMenu = false;
          this.drawShapeDonePolygon = false;
          this.drawShapeDonePolyline = false;
          this.drawShapeDonePolylineArrow = false;
          this.drawShapeDoneLineAxial = false;
          this.drawRectangleDone = false;
          // this.panZoomController.pause();
        }

        // custom form wmata condition wise shape and fill color and stroke color changing point
        if (custom_form_inspection_wmata != undefined && custom_form_inspection_wmata == true) {
          // finalarray2 first option fill value based this condition calculated
          this.receiveString = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
          this.currentSelectedItems.element_data.fill_color = "#98D133";
          this.currentSelectedItems.element_data.stroke_color = "#000000";
          if (custom_form_defaultvalues_wmata != undefined && custom_form_defaultvalues_wmata == true) {
            let get_first_array = get_first_option_default_values;
            console.log(get_first_array);
            let sample_local_object = { "location": "", "decibels": "", "previouscondition": "", "flagforrReview": "", "Condition": "", "Comment": "" };
            for (let key_value in get_first_array) {
              let find_key_name = get_fields.findIndex((field_an) => field_an.element_uuid == key_value);
              if (find_key_name > -1) {
                let get_field_name = get_fields[find_key_name].element_name;
                if (get_field_name == "Location Depth (inches)") {
                  sample_local_object.location = get_first_array[key_value];
                }
                else if (get_field_name == "Decibels") {
                  sample_local_object.decibels = get_first_array[key_value];
                }
                if (get_field_name == "Previous Condition?") {
                  sample_local_object.previouscondition = get_first_array[key_value];
                }
                else if (get_field_name == "Flag for Review?") {
                  sample_local_object.flagforrReview = get_first_array[key_value];
                }
                else if (get_field_name == "Condition") {
                  let get_key = get_first_array[key_value];
                  let get_options_result = get_fields[find_key_name].element_data.options;
                  let get_key_index = get_options_result.findIndex((color_option) => color_option.element_uuid == get_key);
                  sample_local_object.Condition = get_options_result[get_key_index].name;
                }
                else if (get_field_name == "Comment") {
                  sample_local_object.Comment = get_first_array[key_value];
                }
              }
            }

            // stroke color red changes check
            if (sample_local_object.previouscondition == "") {
              this.currentSelectedItems.element_data.stroke_color = "#BC0900";
            }
            else {
              this.currentSelectedItems.element_data.stroke_color = "#000000";
            }
            // shape changes based on form entered values
            if (sample_local_object.flagforrReview == "Yes") {
              // star
              this.receiveString = "move-25:12 line-29.5:22 line-38:22 line-32:29.5 line-35:40 line-25:35 line-15:40 line-18:29.5 line-12:22 line-20.5:22 line-25:12 line-29.5:22";
            }
            if ((sample_local_object.flagforrReview == "" || sample_local_object.flagforrReview == "No") && sample_local_object.Condition != "") {
              // flag
              this.receiveString = "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-17:25 line-17:40 line-15:40 line-15:15";
            }
            // fill color changes
            let blue_color = ['NM - Not measured', 'NA - No access to anchor rod', 'SI - Indicates similar but opposite side; refers to WMATA anchor rod pattern'];
            let red_color = ['FR - Full fracture of anchor rod', 'CR - Strong probability of crack development in anchor rod'];
            let orange_color = ['NT - Anchor rod not tensioned (i.e. the hex nut was loose)', 'PC - Pitting corrosion', 'NO - Notch or thread', 'TN - Strong thread noise', 'TW - Tack weld on anchor rod', 'SP - Anchor rod contains spliced connection', 'UD - Undetermined discontinuity in anchor rod'];
            let OT_color = ['OT - Other'];
            if (sample_local_object.Condition != "") {
              if (blue_color.includes(sample_local_object.Condition)) {
                this.currentSelectedItems.element_data.fill_color = "#002F5F";
              }
              else if (red_color.includes(sample_local_object.Condition)) {
                this.currentSelectedItems.element_data.fill_color = "#BC0900";
              }
              else if (orange_color.includes(sample_local_object.Condition)) {
                this.currentSelectedItems.element_data.fill_color = "#F48F00";
              }
              else if (OT_color.includes(sample_local_object.Condition)) {
                this.currentSelectedItems.element_data.fill_color = "#DF1ED3";
              }
            }
            else {
              this.currentSelectedItems.element_data.fill_color = "#FFFF00";
            }
          }
          else {
            this.currentSelectedItems.element_data.fill_color = "#98D133";
          }
        }
        else if (custom_form_inspection_wmata != undefined && custom_form_inspection_wmata == false) {
          if (custom_form_defaultvalues_wmata != undefined && custom_form_defaultvalues_wmata == true) {
            this.receiveString = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
            this.currentSelectedItems.element_data.fill_color = "#FFFF00";
            this.currentSelectedItems.element_data.stroke_color = "#000000";
          }
          else if (custom_form_defaultvalues_wmata != undefined && custom_form_entervalue_wmata == true) {
            this.receiveString = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
            this.currentSelectedItems.element_data.fill_color = "#FFFF00";
            this.currentSelectedItems.element_data.stroke_color = "#000000";
          }
        }
        else if (custom_form_entervalue_wmata != undefined && custom_form_entervalue_wmata == true) {
          this.receiveString = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
          this.currentSelectedItems.element_data.fill_color = "#FFFF00";
          this.currentSelectedItems.element_data.stroke_color = "#000000";
        }

        // if(custom_form_timber_inspection != undefined && custom_form_timber_inspection == true){
        //   this.currentSelectedItems.element_data.fill_color = "#98D133";
        // }
        // else if(custom_form_timber_inspection != undefined && custom_form_timber_inspection == false){
        //   this.currentSelectedItems.element_data.fill_color = "#BC0900";
        // }
      }
      else {
        const dialogRef = this.dialogBox.open(ClayeralertComponent, {
          data: {
            active: true
          }
        });
      }
    }
   
  }
  annotationselectEnableDisable(enable) {
    var allCanvasInDocument: any = document.querySelectorAll("svg.documentSVG");
    if (enable == 'enable') {
      for (var i = 0; i < allCanvasInDocument.length; i++) {
        allCanvasInDocument[i].style.pointerEvents = 'none';
      }
    }
    else if (enable == 'remove') {
      for (var i = 0; i < allCanvasInDocument.length; i++) {
        allCanvasInDocument[i].style.pointerEvents = 'none';
      }
    }

  }

  //ToolbarIcon Select icon and setBg End
  getPositionString: string = "";
  getPositionSetMove: number = 1;
  copyAnnotationCreatePageValue: boolean = false;
  showcopyAnnotationOption: boolean = false;
  //Over an Image click print Shapes get Position Start

  //new commented item
  // && this.lockedLayerActive == false
  getPosition(e) {
    console.log("FORMSSSSSSSSSS", this.modelFieldsForm)
    this.createDocumentStore.isSingleClick = true;
    setTimeout(() => {
      if (this.createDocumentStore.isSingleClick) {

        //
        // added disable method for freehand drawing getPosition and annotation_selection events Unnecessarily trigger
        if (this.drawFreehandMenu == true || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolyline == true ||
          this.drawShapeDoneLine == true || this.drawShapeDoneLineAxial == true || this.drawShapeDonePolygon == true
          || this.drawEllipseDone == true || this.drawRectangleDone == true || this.isReadonly == true) {
          return;
        }
        if (this.isReadonly == true && this.isRapidmode == true) {
          return
        }
        console.log('plot shape');
        if ((this.toolbarSet == true && this.toolbarElementId < 11) || (this.toolbarSet == true && this.shapeStringInorNot == true)) {
          this.show = true;
          this.toolbarSet = false;
        }
        if (
          this.getPositionActive == true &&
          this.singleCopyAnnotation == false &&
          this.rapidShotModeOn == false && this.copyAnnotationCreatePageValue == false && this.shapeStringInorNot == false
        ) {
          if (this.toolbarElementId > -1 && this.toolbarElementId < 10) {
            if (this.drawFunctionActive == true) {
              this.generateAnnotation(e);
            }
          }
          else if (this.toolbarElementId == 11) {
            const dialogConfig = new MatDialogConfig();
            dialogConfig.disableClose = true;
            dialogConfig.autoFocus = true;
            let dialogrefText = this.dialogBox.open(TextAnnotationComponent, {
              width: "380px",
            });
            dialogrefText.afterClosed().subscribe((res) => {
              console.log(res);
              if (res.access == true) {
                this.show = true;
                this.toolbarSet = false;
                this.textShapeDrawing(res, e);
              }
              else {
                this.toolbarBg = -1;
                this.drawFunctionActive = false;
                this.getPositionActive = false;
                this.shapeStringInorNot = false;
              }
            });
          }
        } else if ((this.rapidShotModeOn == true || this.copyAnnotationCreatePageValue == true) && this.lockedLayerActive == false) {
          if (this.getPositionActive == true) {
            if (this.toolbarElementId <= 9 && this.rapidShotModeOn == true) {
              if (this.drawFunctionActive == true) {
                this.coordinateX = e.offsetX;
                this.coordinateY = e.offsetY;
                var initialRotationRapidShot;
                var getdate = new Date();
                var annontationidDate = new Date().getTime();
                var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
                this.layerid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
                var MyDateString = new Date().toISOString();
                console.log(MyDateString);
                if (
                  this.propertiesannotationData["initial_rotation"] == undefined ||
                  this.propertiesannotationData["initial_rotation"] == ""
                ) {
                  initialRotationRapidShot = 0;
                } else {
                  initialRotationRapidShot = this.propertiesannotationData["initial_rotation"];
                }

                this.createJson = {
                  annotation_data: this.propertiesannotationData["annotation_data"],
                  annotation_forms: this.propertiesannotationData["annotation_forms"],
                  annotation_id: uuid,
                  annotation_label: this.propertiesannotationData["annotation_label"],
                  annotation_links: this.propertiesannotationData["annotation_links"],
                  annotation_media: this.propertiesannotationData["annotation_media"],
                  annotation_name: this.propertiesannotationData["annotation_name"],
                  annotation_stubs: this.propertiesannotationData["annotation_stubs"],
                  annotation_tags: this.propertiesannotationData["annotation_tags"],
                  annotation_url: this.propertiesannotationData["annotation_url"],
                  created_by_user_id: this.su.user_id,
                  created_date: MyDateString,
                  document_id: this.propertiesannotationData["document_id"],
                  element_size: 1,
                  fill_color: this.propertiesannotationData["fill_color"],
                  initial_height: this.propertiesannotationData["initial_height"],
                  initial_rotation: initialRotationRapidShot,
                  initial_position_x: this.coordinateX,
                  initial_position_y: this.coordinateY,
                  initial_width: this.propertiesannotationData["initial_width"],
                  is_removed: this.propertiesannotationData["is_removed"],
                  last_updated_date: MyDateString,
                  layer_id: this.activeLayerIdDraw,
                  line_width: this.propertiesannotationData["line_width"],
                  opacity: this.propertiesannotationData["opacity"],
                  page_id: this.currentPageId,
                  project_id: this.projectId,
                  stroke_color: this.propertiesannotationData["stroke_color"],
                  toolbar_element_id: this.propertiesannotationData["toolbar_element_id"],
                  version_number: 1,
                  text_font_size: this.propertiesannotationData["text_font_size"]
                };
                this.shapeDrawingrapidShotMode();
                // else if(this.copyAnnotationCreatePage==true){
                //   this.copyAnnotationCreatePageAction();
                // }
                // } 
                // this.ellipseDraw();
                // this.annotationUpdate();
              }
            }
            else if (this.copyMultiAnn == true) {

              // copy annotation JSON create and drawing start 
              console.log('copycreatePage');
              const cloneCopyAnnts = _.cloneDeep(this.copyAnnotationDatas);
              var length = (cloneCopyAnnts.length) - 1;
              for (let zx = 0; zx < cloneCopyAnnts.length; zx++) {
                if (zx == length && this.isRapidmode != true) {
                  this.copyMultiAnn = false
                }
                this.propertiesannotationData = this.copyAnnotationDatas[zx];
                if (this.drawFunctionActive == true) {
                  this.coordinateX = e.offsetX;
                  this.coordinateY = e.offsetY;
                  var initialRotationRapidShot;
                  var getdate = new Date();
                  var annontationidDate = new Date().getTime();
                  // annotation media include move annotation to another document implementation
                  var media_values = [];
                  var link_values = [];
                  var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
                  // annotation media should be empty normal copy with and copywithout data
                  media_values = [];
                  // annotation links include new id generate process
                  link_values = _.cloneDeep(this.propertiesannotationData["annotation_links"]);
                  if (link_values != undefined && link_values != null && link_values.length > 0) {
                    for (let la = 0; la < link_values.length; la++) {
                      // new annotation id assign process
                      link_values[la].annotation_id = uuid;
                      let annot_link_id = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime();
                      link_values[la].annotation_link_id = annot_link_id;
                      link_values[la].last_updated_date = new Date().toISOString();
                    }
                  }
                  var MyDateString = new Date().toISOString();
                  console.log(MyDateString);
                  if (
                    this.propertiesannotationData["initial_rotation"] == undefined ||
                    this.propertiesannotationData["initial_rotation"] == ""
                  ) {
                    initialRotationRapidShot = 0;
                  } else {
                    initialRotationRapidShot = this.propertiesannotationData["initial_rotation"];
                  }
                  if (this.toolbarElementId > 11 && this.toolbarElementId <= 18) {
                    // var getOldAnnotationData: any = this.propertiesannotationData["annotation_data"];
                    var getNewAnnotationData: any = "";
                    // getOldAnnotationData = getOldAnnotationData.trim();
                    // let splitedData = getOldAnnotationData.split(" ");
                    // console.log(splitedData);
                    // for (let i = 0; i < splitedData.length; i++) {
                    //   let getcolorsplit = splitedData[i].split("-");
                    //   let getName = getcolorsplit[0];
                    //   let getData = getcolorsplit[1];
                    //   let splitGetData: any = getData.split(":");
                    //   var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
                    //   let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                    //   let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                    //   splitGetData[0] = this.coordinateX + parseInt(calculateAddWidth);
                    //   splitGetData[1] = this.coordinateY + parseInt(calculateAddHeight);
                    //   if(isNaN(splitGetData[0]) || isNaN(splitGetData[1])){
                    //   
                    //   }
                    //   console.log(calculateAddWidth, calculateAddHeight);
                    //   getNewAnnotationData = getNewAnnotationData + getName + "-" + splitGetData[0] + ":" + splitGetData[1] + " ";
                    // }
                    let x_y = { x: this.coordinateX, y: this.coordinateY };
                    let get_New_AnnotationData = this.documentPage.generate_copy_annotation(this.propertiesannotationData, x_y)
                    getNewAnnotationData = get_New_AnnotationData;
                  }
                  else if (this.toolbarElementId <= 11) {
                    var getNewAnnotationData: any = this.propertiesannotationData["annotation_data"];
                    // Resize and Properties shape changed width and height include method.
                    if (this.propertiesannotationData.initial_width != 0 && this.propertiesannotationData.initial_height != 0) {
                      let checkShapeDiffX = Number(this.propertiesannotationData.initial_width) / 2;
                      let checkShapeDiffY = Number(this.propertiesannotationData.initial_height) / 2;
                      this.coordinateX = this.coordinateX - checkShapeDiffX;
                      this.coordinateY = this.coordinateY - checkShapeDiffY;
                      this.coordinateX = this.coordinateX < 0 ? 0 : this.coordinateX;
                      this.coordinateY = this.coordinateY < 0 ? 0 : this.coordinateY;
                    }
                  }
                  else if (this.toolbarElementId == 19 || this.toolbarElementId == 20) {
                    var getOldAnnotationData: any = this.propertiesannotationData["annotation_data"];

                    if (getOldAnnotationData.includes('move')) {
                      // var getOldAnnotationData: any = this.propertiesannotationData["annotation_data"];
                      var getNewAnnotationData: any = "";
                      // getOldAnnotationData = getOldAnnotationData.trim();
                      // let splitedData = getOldAnnotationData.split(" ");
                      // console.log(splitedData);
                      // for (let i = 0; i < splitedData.length; i++) {
                      //   let getcolorsplit = splitedData[i].split("-");
                      //   let getName = getcolorsplit[0];
                      //   let getData = getcolorsplit[1];
                      //   let splitGetData: any = getData.split(":");
                      //   var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
                      //   let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                      //   let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                      //   splitGetData[0] = this.coordinateX + parseInt(calculateAddWidth);
                      //   splitGetData[1] = this.coordinateY + parseInt(calculateAddHeight);
                      //   console.log(calculateAddWidth, calculateAddHeight);
                      //   getNewAnnotationData = getNewAnnotationData + getName + "-" + splitGetData[0] + ":" + splitGetData[1] + " ";
                      // }
                      // getNewAnnotationData = getNewAnnotationData.trim();
                      let x_y = { x: this.coordinateX, y: this.coordinateY };
                      let get_New_AnnotationData = this.documentPage.generate_copy_annotation(this.propertiesannotationData, x_y)
                      getNewAnnotationData = get_New_AnnotationData;
                    }
                    else {
                      var getNewAnnotationData: any = "";
                      getOldAnnotationData = getOldAnnotationData.trim();
                      let splitedData = getOldAnnotationData.split(" ");
                      console.log(splitedData);
                      for (let i = 0; i < splitedData.length; i++) {
                        let splitString = splitedData[i].replaceAll('--', '-n');
                        splitString = splitString.replaceAll(':-', ':n');
                        let hypenSplit = splitString.split("-");
                        if (hypenSplit != '') {
                          let getName = hypenSplit[0];
                          var colonSplit = hypenSplit[1].replaceAll('n', '-').split(":"); // this line we will get four values 
                          // let getcolorsplit = splitedData[i].split("-");
                          // let getData = hypenSplit[1];
                          // let splitGetData: any = getData.split(":");
                          // var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
                          // let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                          // let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                          // first and second value only we changed like x and y position only. no need to change width and height value.
                          colonSplit[0] = this.coordinateX;
                          colonSplit[1] = this.coordinateY;
                          getNewAnnotationData = getNewAnnotationData + getName + "-" + colonSplit[0] + ":" + colonSplit[1] + ":" + colonSplit[2] + ":" + colonSplit[3];
                        }
                      }
                      getNewAnnotationData = getNewAnnotationData.trim();
                    }
                  }
                  // annotation_media and annotation_stubs empty array passing ticket P31-278 revert 10.03.2022
                  // text annotation annotation_url key extra input adding when annotation is resized annotation 22.04.2022
                  if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11 &&
                    Number(this.propertiesannotationData["initial_width"]) != 0 && Number(this.propertiesannotationData["initial_height"]) != 0) {
                    this.propertiesannotationData["annotation_url"] = { "text_resize": "true" };
                  }
                  console.log(this.propertiesannotationData["orginal_property"])
                  console.log(this.propertiesannotationData)
                  console.log(this.arrNewPosition);

                  var copyarrNewPosition = _.cloneDeep(this.arrNewPosition);
                  let index = copyarrNewPosition.findIndex((data) =>
                    data.ann_id == this.propertiesannotationData["annotation_id"])

                  if (index != -1) {
                    let freehandShape = false;
                    if (copyarrNewPosition[index].toolbar_id > 11) {
                      freehandShape = true;
                    }
                    let x = copyarrNewPosition[index].positionX;
                    let y = copyarrNewPosition[index].positionY;
                    if (x > 0) {
                      console.log("commm", copyarrNewPosition[index], 1)
                      this.coordinateX = this.coordinateX - x;
                      if (freehandShape == true) {
                        //- line width
                        this.coordinateX = this.coordinateX + (35) - 5;
                      }
                    }
                    else {
                      x = x * -1;
                      console.log("commm", copyarrNewPosition[index], 2)
                      this.coordinateX = this.coordinateX + x;
                      if (freehandShape == true) {
                        if (copyarrNewPosition[index].positionX < 0) {
                          //+ line width
                          this.coordinateX = this.coordinateX + (35 / 2);
                        } else {
                          //- line width
                          this.coordinateX = this.coordinateX + (35) - 5;
                        }
                      }
                    }
                    if (y > 0) {
                      console.log("commm", copyarrNewPosition[index], 3)
                      this.coordinateY = this.coordinateY - y;
                      if (freehandShape == true) {
                        //- line width
                        this.coordinateY = this.coordinateY + (35);
                      }
                    }
                    else {
                      y = y * -1;
                      console.log("commm", copyarrNewPosition[index], 4)
                      this.coordinateY = this.coordinateY + y;
                      if (freehandShape == true) {
                        if (copyarrNewPosition[index].positionX < 0) {
                          console.log("commm", 6)
                          //+ line width
                          this.coordinateY = this.coordinateY + (35) - 5;
                        } else {
                          console.log("commm", 5)
                          //- line width
                          this.coordinateY = this.coordinateY + (35);
                        }

                      }
                    }
                  }

                  let annId = this.propertiesannotationData["annotation_id"];
                  let fileredElement = this.cpyMultiAnnPos.filter((id) => id.ann_id == annId);
                  console.log(this.cpyMultiAnnPos);
                  let annElement = this.propertiesannotationData["annotation_id"];

                  let get_points = this.checkBoundaryforMultiCopy(fileredElement[0], this.coordinateX, this.coordinateY);
                  this.coordinateX = get_points.newPointX;
                  this.coordinateY = get_points.newPointY;
                  let annontationidDate1 = new Date().getTime();
                  let uuid1 = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate1;
                  this.createJson = {
                    annotation_data: getNewAnnotationData,
                    annotation_forms: this.propertiesannotationData["annotation_forms"],
                    annotation_id: uuid1,
                    annotation_label: this.propertiesannotationData["annotation_label"],
                    annotation_links: link_values,
                    annotation_media: media_values,
                    annotation_name: this.propertiesannotationData["annotation_name"],
                    annotation_stubs: [],
                    annotation_tags: this.propertiesannotationData["annotation_tags"],
                    annotation_url: this.propertiesannotationData["annotation_url"],
                    created_by_user_id: this.su.user_id,
                    created_date: MyDateString,
                    document_id: this.folderId,
                    element_size: 1,
                    fill_color: this.propertiesannotationData["fill_color"],
                    initial_height: this.propertiesannotationData["initial_height"],
                    initial_rotation: initialRotationRapidShot,
                    initial_position_x: this.coordinateX,
                    initial_position_y: this.coordinateY,
                    initial_width: this.propertiesannotationData["initial_width"],
                    is_removed: this.propertiesannotationData["is_removed"],
                    last_updated_date: MyDateString,
                    layer_id: this.activeLayerIdDraw,
                    line_width: this.propertiesannotationData["line_width"],
                    opacity: this.propertiesannotationData["opacity"],
                    original_property: this.propertiesannotationData["original_property"],
                    page_id: this.currentPageId,
                    project_id: this.projectId,
                    stroke_color: this.propertiesannotationData["stroke_color"],
                    toolbar_element_id: this.propertiesannotationData["toolbar_element_id"],
                    version_number: 1,
                    text_font_size: this.propertiesannotationData["text_font_size"]
                  };

                  console.log(this.createJson)
                  let isnegativeCoordinates = false;
                  if (this.coordinateX < 0 && this.coordinateY < 0) {
                    this.coordinateX = -this.coordinateX;
                    this.coordinateY = -this.coordinateY;
                    isnegativeCoordinates = true;
                    console.log(this.coordinateX, this.coordinateY);
                  }
                  //svg purpose commented 04.12.2021
                  // this.getshapeDrawing(this.createJson, isnegativeCoordinates);
                  if (this.copyAnnotationCreatePageValue == true) {
                    this.showcopyAnnotationOption = true;
                    if (this.createJson["toolbar_element_id"] < 12) {
                      let x = this.createJson["initial_position_x"];
                      let lessBoxWidth = x - 36;
                      this.optionPositionX = lessBoxWidth;
                      console.log(lessBoxWidth);
                      let y = this.createJson["initial_position_y"];
                      console.log(y);
                      let lessBoxHeight = y - 52;
                      this.optionPositionY = lessBoxHeight;
                      console.log(lessBoxHeight);
                    }
                    else if (this.createJson["toolbar_element_id"] > 11) {
                      let x = this.createJson["initial_position_x"];
                      let lessBoxWidth = x - 36;
                      let addWidth = lessBoxWidth + this.createJson["initial_width"] / 2;
                      this.optionPositionX = addWidth;
                      this.optionPositionY = this.createJson["initial_position_y"];
                      let y = this.createJson["initial_position_y"];
                      let lessBoxHeight = y - 42;
                      this.optionPositionY = lessBoxHeight;
                    }
                    this.annotationSelected = true;
                    //this.formsheaderCanvas("headerCanvasForms", this.propertiesannotationData, 'annotationLabelForms');
                  }
                  this.copyAnnotationCreatePageSave(zx);
                  // else if(this.copyAnnotationCreatePage==true){
                  //   this.copyAnnotationCreatePageAction();
                  // }
                  // this.ellipseDraw();
                  // this.annotationUpdate();
                }
              }
            }
            else {
              // copy annotation JSON create and drawing start 
              console.log('copycreatePage');
              if (this.drawFunctionActive == true) {
                this.drawFunctionActive = false;
                this.coordinateX = e.offsetX;
                this.coordinateY = e.offsetY;
                var initialRotationRapidShot;
                var getdate = new Date();
                var annontationidDate = new Date().getTime();
                // annotation media include move annotation to another document implementation
                var media_values = [];
                var link_values = [];
                let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
                if (get_copy_move_ano_doc != null) {
                  if ((get_copy_move_ano_doc.mode == "move_with_data" || get_copy_move_ano_doc.mode == "move_without_data") && this.folderId == this.propertiesannotationData["document_id"]) {
                    var uuid: string = this.propertiesannotationData["annotation_id"];
                    // annotation media should be old values not changing anything
                    media_values = _.cloneDeep(this.propertiesannotationData["annotation_media"]);
                    link_values = _.cloneDeep(this.propertiesannotationData["annotation_links"]);
                    let find_current_annotation_data = this.createDocumentStore.view_annotation_array.findIndex((id) => id.annotation_id == this.propertiesannotationData["annotation_id"]);
                    if (find_current_annotation_data > -1) {
                      let annotationClear = document.getElementById(this.createDocumentStore.current_copy_annot_data['annotation_id']);
                      if (annotationClear != null) {
                        annotationClear.remove();
                      }
                      let annotationLabelClear = document.getElementById('label' + this.createDocumentStore.current_copy_annot_data['annotation_id']);
                      if (annotationLabelClear != null) {
                        annotationLabelClear.remove();
                      }
                      this.createDocumentStore.view_annotation_array.splice(find_current_annotation_data, 1);
                    }
                    // remove  old annotation data from layer data
                    let clone_layer_datas = _.cloneDeep(this.layerDatas);
                    if (clone_layer_datas != undefined && clone_layer_datas != null && clone_layer_datas.length > 0) {
                      let find_layer = clone_layer_datas.findIndex((l_data) => l_data.layer_id == this.propertiesannotationData["layer_id"]);
                      if (find_layer > -1) {
                        let find_annot = clone_layer_datas[find_layer].annotations.findIndex((a_data) => a_data.annotation_id == this.propertiesannotationData["annotation_id"]);
                        if (find_annot > -1) {
                          clone_layer_datas[find_layer].annotations.splice(find_annot, 1);
                          this.layerDatas = clone_layer_datas;
                        }
                      }
                    }
                  }
                  else {
                    var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
                    // annotation media include move annotation to another document implementation
                    media_values = _.cloneDeep(this.propertiesannotationData["annotation_media"]);
                    if (media_values != undefined && media_values != null && media_values.length > 0) {
                      for (let ga = 0; ga < media_values.length; ga++) {
                        // new annotation id assign process
                        media_values[ga].annotation_id = uuid;
                        let annot_med_id = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime();
                        media_values[ga].annotation_media_id = annot_med_id;
                        media_values[ga].last_updated_date = new Date().toISOString();
                      }
                    }
                    else {
                      // annotation media should be empty normal copy with and copywithout data
                      media_values = [];
                    }
                    // annotation links include new id generate process
                    link_values = _.cloneDeep(this.propertiesannotationData["annotation_links"]);
                    if (link_values != undefined && link_values != null && link_values.length > 0) {
                      for (let la = 0; la < link_values.length; la++) {
                        // new annotation id assign process
                        link_values[la].annotation_id = uuid;
                        let annot_link_id = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime();
                        link_values[la].annotation_link_id = annot_link_id;
                        link_values[la].last_updated_date = new Date().toISOString();
                      }
                    }
                    else {
                      // annotation media should be empty normal copy with and copywithout data
                      link_values = [];
                    }
                  }

                }
                else {
                  var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
                  // annotation media should be empty normal copy with and copywithout data
                  media_values = [];
                  // annotation links include new id generate process
                  link_values = _.cloneDeep(this.propertiesannotationData["annotation_links"]);
                  if (link_values != undefined && link_values != null && link_values.length > 0) {
                    for (let la = 0; la < link_values.length; la++) {
                      // new annotation id assign process
                      link_values[la].annotation_id = uuid;
                      let annot_link_id = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime();
                      link_values[la].annotation_link_id = annot_link_id;
                      link_values[la].last_updated_date = new Date().toISOString();
                    }
                  }
                }


                var MyDateString = new Date().toISOString();
                console.log(MyDateString);
                if (
                  this.propertiesannotationData["initial_rotation"] == undefined ||
                  this.propertiesannotationData["initial_rotation"] == ""
                ) {
                  initialRotationRapidShot = 0;
                } else {
                  initialRotationRapidShot = this.propertiesannotationData["initial_rotation"];
                }
                if (this.toolbarElementId > 11 && this.toolbarElementId <= 18) {
                  // var getOldAnnotationData: any = this.propertiesannotationData["annotation_data"];
                  var getNewAnnotationData: any = "";
                  // getOldAnnotationData = getOldAnnotationData.trim();
                  // let splitedData = getOldAnnotationData.split(" ");
                  // console.log(splitedData);
                  // for (let i = 0; i < splitedData.length; i++) {
                  //   let getcolorsplit = splitedData[i].split("-");
                  //   let getName = getcolorsplit[0];
                  //   let getData = getcolorsplit[1];
                  //   let splitGetData: any = getData.split(":");
                  //   var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
                  //   let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                  //   let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                  //   splitGetData[0] = this.coordinateX + parseInt(calculateAddWidth);
                  //   splitGetData[1] = this.coordinateY + parseInt(calculateAddHeight);
                  //   if(isNaN(splitGetData[0]) || isNaN(splitGetData[1])){
                  //   
                  //   }
                  //   console.log(calculateAddWidth, calculateAddHeight);
                  //   getNewAnnotationData = getNewAnnotationData + getName + "-" + splitGetData[0] + ":" + splitGetData[1] + " ";
                  // }
                  let x_y = { x: this.coordinateX, y: this.coordinateY };
                  let get_New_AnnotationData = this.documentPage.generate_copy_annotation(this.propertiesannotationData, x_y)
                  getNewAnnotationData = get_New_AnnotationData;
                }
                else if (this.toolbarElementId <= 11) {
                  var getNewAnnotationData: any = this.propertiesannotationData["annotation_data"];
                  // Resize and Properties shape changed width and height include method.
                  if (this.propertiesannotationData.initial_width != 0 && this.propertiesannotationData.initial_height != 0) {
                    let checkShapeDiffX = Number(this.propertiesannotationData.initial_width) / 2;
                    let checkShapeDiffY = Number(this.propertiesannotationData.initial_height) / 2;
                    this.coordinateX = this.coordinateX - checkShapeDiffX;
                    this.coordinateY = this.coordinateY - checkShapeDiffY;
                    this.coordinateX = this.coordinateX < 0 ? 0 : this.coordinateX;
                    this.coordinateY = this.coordinateY < 0 ? 0 : this.coordinateY;
                  }
                }
                else if (this.toolbarElementId == 19 || this.toolbarElementId == 20) {
                  var getOldAnnotationData: any = this.propertiesannotationData["annotation_data"];

                  if (getOldAnnotationData.includes('move')) {
                    // var getOldAnnotationData: any = this.propertiesannotationData["annotation_data"];
                    var getNewAnnotationData: any = "";
                    // getOldAnnotationData = getOldAnnotationData.trim();
                    // let splitedData = getOldAnnotationData.split(" ");
                    // console.log(splitedData);
                    // for (let i = 0; i < splitedData.length; i++) {
                    //   let getcolorsplit = splitedData[i].split("-");
                    //   let getName = getcolorsplit[0];
                    //   let getData = getcolorsplit[1];
                    //   let splitGetData: any = getData.split(":");
                    //   var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
                    //   let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                    //   let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                    //   splitGetData[0] = this.coordinateX + parseInt(calculateAddWidth);
                    //   splitGetData[1] = this.coordinateY + parseInt(calculateAddHeight);
                    //   console.log(calculateAddWidth, calculateAddHeight);
                    //   getNewAnnotationData = getNewAnnotationData + getName + "-" + splitGetData[0] + ":" + splitGetData[1] + " ";
                    // }
                    // getNewAnnotationData = getNewAnnotationData.trim();
                    let x_y = { x: this.coordinateX, y: this.coordinateY };
                    let get_New_AnnotationData = this.documentPage.generate_copy_annotation(this.propertiesannotationData, x_y)
                    getNewAnnotationData = get_New_AnnotationData;
                  }
                  else {
                    var getNewAnnotationData: any = "";
                    getOldAnnotationData = getOldAnnotationData.trim();
                    let splitedData = getOldAnnotationData.split(" ");
                    console.log(splitedData);
                    for (let i = 0; i < splitedData.length; i++) {
                      let splitString = splitedData[i].replaceAll('--', '-n');
                      splitString = splitString.replaceAll(':-', ':n');
                      let hypenSplit = splitString.split("-");
                      if (hypenSplit != '') {
                        let getName = hypenSplit[0];
                        var colonSplit = hypenSplit[1].replaceAll('n', '-').split(":"); // this line we will get four values 
                        // let getcolorsplit = splitedData[i].split("-");
                        // let getData = hypenSplit[1];
                        // let splitGetData: any = getData.split(":");
                        // var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
                        // let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                        // let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                        // first and second value only we changed like x and y position only. no need to change width and height value.
                        colonSplit[0] = this.coordinateX;
                        colonSplit[1] = this.coordinateY;
                        getNewAnnotationData = getNewAnnotationData + getName + "-" + colonSplit[0] + ":" + colonSplit[1] + ":" + colonSplit[2] + ":" + colonSplit[3];
                      }
                    }
                    getNewAnnotationData = getNewAnnotationData.trim();
                  }
                }
                // annotation_media and annotation_stubs empty array passing ticket P31-278 revert 10.03.2022
                // text annotation annotation_url key extra input adding when annotation is resized annotation 22.04.2022
                if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11 &&
                  Number(this.propertiesannotationData["initial_width"]) != 0 && Number(this.propertiesannotationData["initial_height"]) != 0) {
                  this.propertiesannotationData["annotation_url"] = { "text_resize": "true" };
                }
                console.log(this.propertiesannotationData["orginal_property"])
                console.log(this.propertiesannotationData)
                this.createJson = {
                  annotation_data: getNewAnnotationData,
                  annotation_forms: this.propertiesannotationData["annotation_forms"],
                  annotation_id: uuid,
                  annotation_label: this.propertiesannotationData["annotation_label"],
                  annotation_links: link_values,
                  annotation_media: media_values,
                  annotation_name: this.propertiesannotationData["annotation_name"],
                  annotation_stubs: [],
                  annotation_tags: this.propertiesannotationData["annotation_tags"],
                  annotation_url: this.propertiesannotationData["annotation_url"],
                  created_by_user_id: this.su.user_id,
                  created_date: MyDateString,
                  document_id: this.folderId,
                  element_size: 1,
                  fill_color: this.propertiesannotationData["fill_color"],
                  initial_height: this.propertiesannotationData["initial_height"],
                  initial_rotation: initialRotationRapidShot,
                  initial_position_x: this.coordinateX,
                  initial_position_y: this.coordinateY,
                  initial_width: this.propertiesannotationData["initial_width"],
                  is_removed: this.propertiesannotationData["is_removed"],
                  last_updated_date: MyDateString,
                  layer_id: this.activeLayerIdDraw,
                  line_width: this.propertiesannotationData["line_width"],
                  opacity: this.propertiesannotationData["opacity"],
                  original_property: this.propertiesannotationData["original_property"],
                  page_id: this.currentPageId,
                  project_id: this.projectId,
                  stroke_color: this.propertiesannotationData["stroke_color"],
                  toolbar_element_id: this.propertiesannotationData["toolbar_element_id"],
                  version_number: 1,
                  text_font_size: this.propertiesannotationData["text_font_size"]
                };

                console.log(this.createJson)
                let isnegativeCoordinates = false;
                if (this.coordinateX < 0 && this.coordinateY < 0) {
                  this.coordinateX = -this.coordinateX;
                  this.coordinateY = -this.coordinateY;
                  isnegativeCoordinates = true;
                  console.log(this.coordinateX, this.coordinateY);
                }
                //svg purpose commented 04.12.2021
                // this.getshapeDrawing(this.createJson, isnegativeCoordinates);
                if (this.copyAnnotationCreatePageValue == true) {
                  this.showcopyAnnotationOption = true;
                  if (this.createJson["toolbar_element_id"] < 12) {
                    let x = this.createJson["initial_position_x"];
                    let lessBoxWidth = x - 36;
                    this.optionPositionX = lessBoxWidth;
                    console.log(lessBoxWidth);
                    let y = this.createJson["initial_position_y"];
                    console.log(y);
                    let lessBoxHeight = y - 52;
                    this.optionPositionY = lessBoxHeight;
                    console.log(lessBoxHeight);
                  }
                  else if (this.createJson["toolbar_element_id"] > 11) {
                    let x = this.createJson["initial_position_x"];
                    let lessBoxWidth = x - 36;
                    let addWidth = lessBoxWidth + this.createJson["initial_width"] / 2;
                    this.optionPositionX = addWidth;
                    this.optionPositionY = this.createJson["initial_position_y"];
                    let y = this.createJson["initial_position_y"];
                    let lessBoxHeight = y - 42;
                    this.optionPositionY = lessBoxHeight;
                  }
                  this.annotationSelected = true;
                  //this.formsheaderCanvas("headerCanvasForms", this.propertiesannotationData, 'annotationLabelForms');
                }
                this.copyAnnotationCreatePageSave();
                // else if(this.copyAnnotationCreatePage==true){
                //   this.copyAnnotationCreatePageAction();
                // }
                // this.ellipseDraw();
                // this.annotationUpdate();
              }
            }
          }
        } else if (this.lockedLayerActive == false && this.shapeStringInorNot == false) {
          if (
            this.getPositionActive == true &&
            this.newShapeAddwhenMultiSelect == false
          ) {
            if (
              this.toolbarElementId != 12 &&
              this.toolbarElementId != 17 &&
              this.toolbarElementId != 18 &&
              this.toolbarElementId != 14 &&
              this.toolbarElementId != 13 &&
              this.toolbarElementId != 15
            ) {
              if (this.drawFunctionActive == true) {
                this.coordinateX = e.offsetX;
                this.coordinateY = e.offsetY;
                var getdate = new Date();
                var annontationidDate = new Date().getTime();
                var initialRotationofCopy;
                var uuid =
                  this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
                var MyDateString = new Date().toISOString();
                console.log(MyDateString);
                if (
                  this.copyAnnotationData.initial_rotation == undefined ||
                  this.copyAnnotationData.initial_rotation == ""
                ) {
                  initialRotationofCopy = 0;
                } else {
                  initialRotationofCopy = this.copyAnnotationData.initial_rotation;
                }
                this.createJson = {
                  annotation_data: this.copyAnnotationData.annotation_data,
                  annotation_forms: this.copyAnnotationData.annotation_forms,
                  annotation_id: uuid,
                  annotation_label: this.copyAnnotationData.annotation_label,
                  annotation_links: this.copyAnnotationData.annotation_links,
                  annotation_media: this.copyAnnotationData.annotation_media,
                  annotation_name: this.copyAnnotationData.annotation_name,
                  annotation_stubs: this.copyAnnotationData.annotation_stubs,
                  annotation_tags: this.copyAnnotationData.annotation_tags,
                  annotation_url: this.copyAnnotationData.annotation_url,
                  created_by_user_id: this.su.user_id,
                  created_date: MyDateString,
                  document_id: this.folderId,

                  element_size: 1,
                  fill_color: this.copyAnnotationData.fill_color,
                  initial_height: this.copyAnnotationData.initial_height,
                  initial_rotation: initialRotationofCopy,
                  initial_position_x: this.coordinateX,
                  initial_position_y: this.coordinateY,
                  initial_width: this.copyAnnotationData.initial_width,
                  is_removed: false,
                  last_updated_date: MyDateString,
                  layer_id: this.activeLayerIdDraw,
                  line_width: this.copyAnnotationData.line_width,
                  opacity: this.copyAnnotationData.opacity,
                  page_id: this.currentPageId,
                  project_id: this.projectId,
                  stroke_color: this.copyAnnotationData.stroke_color,
                  toolbar_element_id: this.toolbarElementId,
                  version_number: 1,
                };
                console.log(this.createJson);
                if (this.toolbarElementId != 19) {
                  this.shapeDrawingcopyAnnotation();
                } else if (this.toolbarElementId == 19) {
                  this.ellipseDraw();
                }
                // if(this.showMultiSelectFooter==false){
                // }
              }
            } else if (this.toolbarElementId == 12 || this.toolbarElementId == 17) {
              this.captureEventsSVG(this.annotationName);
              this.drawShapeDonePolygon = true;
            } else if (this.toolbarElementId == 18) {
              this.polygonmethodSVG();
            } else if (this.toolbarElementId == 14) {
              this.polylinemethodSVG();
            } else if (this.toolbarElementId == 13) {
              this.polylinearrowmethodSVG();
            } else if (this.toolbarElementId == 15) {
              this.drawLineMethodSVG(1);
            }
          }
        } else if (this.shapeStringInorNot == true) {
          if (this.getPositionActive == true && this.drawFunctionActive == true) {
            // getElement Position of custome shapes plotting
            let local_scale = 1;
            if (this.pngFormat == true) {
              // no need of scaling image formats so will assign 1 value 10/1 = 10 same value;
              local_scale = 1;
            }
            else {
              local_scale = this.pdfScaleValue >= 1 ? this.pdfScaleValue : 1;
            }
            // scaling calculation divide the click x and y position
            this.coordinateX = e.offsetX;
            this.coordinateY = e.offsetY;
            var getdate = new Date();
            var annontationidDate = new Date().getTime();
            var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
            var MyDateString = new Date().toISOString();
            console.log(MyDateString);
            if (this.toolbarElementId > 11 && this.toolbarElementId <= 18) {
              var getOldAnnotationData: any = this.receiveString;
              var getNewAnnotationData: any = "";
              getOldAnnotationData = getOldAnnotationData.trim();
              let splitedData = getOldAnnotationData.split(" ");
              console.log(splitedData);
              for (let i = 0; i < splitedData.length; i++) {
                var splitString = splitedData[i].replaceAll('--', '-n');
                splitString = splitString.replaceAll(':-', ':n');
                // var hypenSplit = splitString.split("-");
                let getcolorsplit = splitString.split("-");
                let getName = getcolorsplit[0];
                let getData = getcolorsplit[1];
                let splitGetData: any = getData.replaceAll('n', '-').split(":");
                var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.currentSelectedItems.element_data.shape);
                let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                splitGetData[0] = this.coordinateX + parseInt(calculateAddWidth);
                splitGetData[1] = this.coordinateY + parseInt(calculateAddHeight);
                console.log(calculateAddWidth, calculateAddHeight);
                getNewAnnotationData = getNewAnnotationData + getName + "-" + splitGetData[0] + ":" + splitGetData[1] + " ";
              }
              getNewAnnotationData = getNewAnnotationData.trim();
            }
            else if (this.toolbarElementId <= 11) {
              var getOldAnnotationData: any = this.receiveString;
              if (getOldAnnotationData.includes('move')) {
                var getOldAnnotationData: any = this.receiveString;
                var getNewAnnotationData: any = "";
                getOldAnnotationData = getOldAnnotationData.trim();
                let splitedData = getOldAnnotationData.split(" ");
                console.log(splitedData);
                for (let i = 0; i < splitedData.length; i++) {
                  var splitString = splitedData[i].replaceAll('--', '-n');
                  splitString = splitString.replaceAll(':-', ':n');
                  let getcolorsplit = splitString.split("-");
                  console.log(typeof splitedData[i])
                  var splitGetData: any[] = []
                  var getName;
                  // The below if condition is added to calculate height and width while exponent (e) is 
                  // present in shape string
                  if (getcolorsplit.length > 2) {
                    if (getcolorsplit != null) {
                      getName = getcolorsplit[0];
                      let new1 = getcolorsplit.slice(1, getcolorsplit.length);
                      let combine = new1.join("-");
                      let splitGetData1 = combine.replaceAll('n', '-');
                      let sp = splitGetData1.split(":")
                      for (let k = 0; k < sp.length; k++) {
                        if (sp[k].includes('e')) {
                          let expNumber = JSON.parse(sp[k]);
                          // let fff = parseFloat(nnn);
                          const convertedNumber = (expNumber).toFixed(20);
                          splitGetData[k] = convertedNumber;
                        }
                        else {
                          const n = sp[k];
                          splitGetData[k] = n;
                        }
                      }
                    }
                  }
                  else {
                    console.log(typeof getcolorsplit)
                    getName = getcolorsplit[0];
                    let getData = getcolorsplit[1];
                    console.log(typeof getData);
                    splitGetData = getData.replaceAll('n', '-').split(":");
                  }
                  var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.currentSelectedItems.element_data.shape);
                  let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                  let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                  splitGetData[0] = this.coordinateX + parseFloat(calculateAddWidth);
                  splitGetData[1] = this.coordinateY + parseFloat(calculateAddHeight);
                  console.log(calculateAddWidth, calculateAddHeight);
                  getNewAnnotationData = getNewAnnotationData + getName + "-" + splitGetData[0] + ":" + splitGetData[1] + " ";
                }
                getNewAnnotationData = getNewAnnotationData.trim();
              }
              // Resize and Properties shape changed width and height include method.

              if (this.currentSelectedItems.element_data.shape.initial_width != 0 && this.currentSelectedItems.element_data.shape.initial_height != 0) {
                let checkShapeDiffX = Number(this.currentSelectedItems.element_data.shape.initial_width) / 2;
                let checkShapeDiffY = Number(this.currentSelectedItems.element_data.shape.initial_height) / 2;
                this.coordinateX = this.coordinateX - checkShapeDiffX + 17.5;
                this.coordinateY = this.coordinateY - checkShapeDiffY + 17.5;
                this.coordinateX = this.coordinateX < 0 ? 0 : this.coordinateX;
                this.coordinateY = this.coordinateY < 0 ? 0 : this.coordinateY;
                console.log(checkShapeDiffX, checkShapeDiffY, this.coordinateX, this.coordinateY);
                console.log(checkShapeDiffX, checkShapeDiffY, this.coordinateX - checkShapeDiffX, this.coordinateY - checkShapeDiffY);
              }
            }
            else if (this.toolbarElementId == 19 || this.toolbarElementId == 20) {
              var getOldAnnotationData: any = this.receiveString;
              if (getOldAnnotationData.includes('move')) {
                var getOldAnnotationData: any = this.receiveString;
                var getNewAnnotationData: any = "";
                getOldAnnotationData = getOldAnnotationData.trim();
                let splitedData = getOldAnnotationData.split(" ");
                console.log(splitedData);
                for (let i = 0; i < splitedData.length; i++) {
                  var splitString = splitedData[i].replaceAll('--', '-n');
                  splitString = splitString.replaceAll(':-', ':n');
                  // var hypenSplit = splitString.split("-");
                  let getcolorsplit = splitString.split("-");
                  let getName = getcolorsplit[0];
                  let getData = getcolorsplit[1];
                  let splitGetData: any = getData.replaceAll('n', '-').split(":");
                  var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.currentSelectedItems.element_data.shape);
                  let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                  let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                  splitGetData[0] = this.coordinateX + parseInt(calculateAddWidth);
                  splitGetData[1] = this.coordinateY + parseInt(calculateAddHeight);
                  console.log(calculateAddWidth, calculateAddHeight);
                  getNewAnnotationData = getNewAnnotationData + getName + "-" + splitGetData[0] + ":" + splitGetData[1] + " ";
                }
                getNewAnnotationData = getNewAnnotationData.trim();
              }
              else {
                var getNewAnnotationData: any = "";
                getOldAnnotationData = getOldAnnotationData.trim();
                let splitedData = getOldAnnotationData.split(" ");
                console.log(splitedData);
                for (let i = 0; i < splitedData.length; i++) {
                  var splitString = splitedData[i].replaceAll('--', '-n');
                  splitString = splitString.replaceAll(':-', ':n');
                  // var hypenSplit = splitString.split("-");
                  let getcolorsplit = splitString.split("-");
                  let getName = getcolorsplit[0];
                  let getData = getcolorsplit[1];
                  let splitGetData: any = getData.replaceAll('n', '-').split(":");
                  var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(this.currentSelectedItems.element_data.shape);
                  let calculateAddWidth: any = parseFloat(splitGetData[0]) - shapeStringValueTemp.left;
                  let calculateAddHeight: any = parseFloat(splitGetData[1]) - shapeStringValueTemp.top;
                  splitGetData[0] = this.coordinateX;
                  splitGetData[1] = this.coordinateY;
                  getNewAnnotationData = getNewAnnotationData + getName + "-" + splitGetData[0] + ":" + splitGetData[1] + ":" + splitGetData[2] + ":" + splitGetData[3];
                }
                getNewAnnotationData = getNewAnnotationData.trim();
              }

            }

            this.createJson = {
              annotation_data: getNewAnnotationData,
              annotation_forms: this.selectAnnotationForms,
              annotation_id: uuid,
              annotation_label: this.currentSelectedItems.element_data.shape.annotation_label,
              annotation_links: this.currentSelectedItems.element_data.shape.annotation_links,
              annotation_media: this.currentSelectedItems.element_data.shape.annotation_media,
              annotation_name: this.annotationName,
              annotation_stubs: [],
              annotation_tags: this.currentSelectedItems.element_data.shape.annotation_tags,
              annotation_url: "",
              created_by_user_id: this.su.user_id,
              created_date: MyDateString,
              document_id: this.folderId,
              element_size: 1,
              fill_color: this.currentSelectedItems.element_data.fill_color,
              initial_height: this.currentSelectedItems.element_data.shape.initial_height,
              initial_position_x: this.coordinateX,
              initial_position_y: this.coordinateY,
              initial_width: this.currentSelectedItems.element_data.shape.initial_width,
              initial_rotation: this.currentSelectedItems.element_data.shape.initial_rotation,
              is_removed: false,
              last_updated_date: MyDateString,
              layer_id: this.activeLayerIdDraw,
              line_width: this.currentSelectedItems.element_data.line_width,
              opacity: this.currentSelectedItems.element_data.opacity,
              original_property: "",
              page_id: this.currentPageId,
              project_id: this.projectId,
              stroke_color: this.currentSelectedItems.element_data.stroke_color,
              toolbar_element_id: this.toolbarElementId,
              version_number: 1,
            };
            // let getCopyData = this.createJson;
            // console.log(getCopyData);
            // let isnegativeCoordinates = false;
            // if (this.coordinateX < 0 && this.coordinateY < 0) {
            //   this.coordinateX = -this.coordinateX;
            //   this.coordinateY = -this.coordinateY;
            //   isnegativeCoordinates = true;
            // }
            // this.getshapeDrawing(getCopyData, isnegativeCoordinates);
            this.annotationUpdate();
          }
        }
        //
      }
    }, 250)
  }

  //Over an Image click print Shapes get Position End

  ellipseDraw() {
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("id", this.createJson["annotation_id"]);
    console.log(this.createJson["annotation_id"]);
    newcreatedElement.addEventListener("click", (e: any) => {
      this.canvasClick(e);
    });
    newcreatedElement.setAttribute("width", "50");
    newcreatedElement.setAttribute("height", "50");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = this.coordinateY + "px";
    newcreatedElement.style.left = this.coordinateX + "px";
    newcreatedElement.style.marginLeft = "-25px";
    newcreatedElement.style.marginTop = "-25px";
    newcreatedElement.style.zIndex = "99";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    this.receiveString = this.receiveString.trim();
    var spaceSplit = this.receiveString.split(" ");

    var hypenSplit = spaceSplit[0].split("-");

    var colonSplit = hypenSplit[1].split(":");

    var x = parseFloat(colonSplit[0]);
    var y = parseFloat(colonSplit[1]);
    var w = parseFloat(colonSplit[2]);
    var h = parseFloat(colonSplit[3]);

    switch (hypenSplit[0]) {
      case "ovalIn":
        this.canvasElement.moveTo(x, y - h / 2); // A1

        this.canvasElement.bezierCurveTo(
          x + w / 2,
          y - h / 2, // C1
          x + w / 2,
          y + h / 2, // C2
          x,
          y + h / 2
        ); // A2

        this.canvasElement.bezierCurveTo(
          x - w / 2,
          y + h / 2, // C3
          x - w / 2,
          y - h / 2, // C4
          x,
          y - h / 2
        ); // A1
        // this.canvasElement.ellipse(x,y,w,h,Math.PI / 4, 0, 2 * Math.PI);

        this.canvasElement.fillStyle = "rgba(0.999999999885,44.999999991,98.0000000025,1)";
        this.canvasElement.fill();
        console.log(this.canvasElement.fillStyle);
        this.canvasElement.lineWidth = 1;
        this.canvasElement.strokeStyle = "rgba(0.999999999885,44.999999991,98.0000000025,1)";
        this.canvasElement.stroke();
    }
  }
  //getLayerList start


  // getAnnotationFormoriginal(action?: string) {
  //   console.log(this.projectId, this.folderId);
  //   this.layerDatas$ = this.documentService.getAnnotationFormlist(this.projectId, this.folderId, this.currentPageId)
  //     .subscribe((response) => {
  //       console.log(response);
  //       this.userdetail = response["response_body"]["user_list"];
  //       let responsevalue = response;
  //       console.log('layerresponse', responsevalue);
  //       if (this.layerDatas != undefined) {
  //         this.findlayerid = this.layerDatas.filter((document_page) => document_page.layer_id === this.documentDetails[0].active_layer_id)
  //         this.findlayerid.forEach((data) => {
  //           console.log(data)
  //           let associated_pages = data.associated_pages;
  //           let page_element1 = associated_pages.filter(ele => ele.page_id == this.currentPageId);
  //           
  //           if (page_element1[0].is_hidden == true || page_element1[0].is_hidden == "true" || page_element1[0].is_hidden == 1) {
  //             this.showvisible = false;
  //           } else {
  //             this.showvisible = true;
  //           }
  //           if (page_element1[0].is_lock == true || page_element1[0].is_lock == "true" || page_element1[0].is_lock == 1) {
  //             this.lockedLayerActive = true;
  //           }
  //           else {
  //             this.lockedLayerActive = false;
  //           }
  //         });
  //       }
  //       this.callBackgetData(this.toolbar_id);
  //       this.layerDatas = [];
  //       let layer_data = response["response_body"]["layer_data"];
  //       if (layer_data != null && layer_data != undefined) {
  //         response["response_body"]["layer_data"] = this.dataService4.changeSpecialtokeyformatList(layer_data, 'layerdata')
  //       }
  //       localStorage.setItem(
  //         "userdetail",
  //         JSON.stringify(response["response_body"]["user_list"])
  //       );
  //       console.log(this.encrptdecrpt.getItem("userdetail"))
  //       let originalLayerData = response["response_body"]["layer_data"];

  //       // latest comment
  //       // this.show = false;

  //       if (layer_data != undefined) {
  //         var layerRemovedFilter = layer_data.filter((data) => data.is_removed == false || data.is_removed == "false");
  //         let filter_pagewise_Layer_data = [];
  //         for (let page_check = 0; page_check < layerRemovedFilter.length; page_check++) {
  //           let get_associate_page = layerRemovedFilter[page_check].associated_pages;
  //           let filter_page = get_associate_page.find((pages_find) => pages_find.page_id == this.currentPageId);
  //           if (filter_page != undefined && (filter_page.is_removed == 'false' || filter_page.is_removed == false || filter_page.is_removed == '0')) {
  //             console.log(layerRemovedFilter[page_check]);
  //             filter_pagewise_Layer_data.push(layerRemovedFilter[page_check]);
  //           }
  //         }
  //         layerRemovedFilter = filter_pagewise_Layer_data;
  //         this.layerDatas = layerRemovedFilter;
  //         var annotations = [];
  //         for (var i = 0; i < layerRemovedFilter.length; i++) {
  //           annotations = [];
  //           for (var j = 0; j < layerRemovedFilter[i].annotations.length; j++) {
  //             if (layerRemovedFilter[i].annotations[j].is_removed == false || layerRemovedFilter[i].annotations[j].is_removed == "false") {
  //               if (action != undefined) {
  //                 if (action == "rotateresizeend" && this.createDocumentStore.rotate_previous_value_backup != null) {
  //                   if (this.createDocumentStore.rotate_previous_value_backup['annotation_id'] == layerRemovedFilter[i].annotations[j].annotation_id) {
  //                     layerRemovedFilter[i].annotations[j].annotation_forms = this.createDocumentStore.rotate_previous_value_backup["annotation_forms"];
  //                     layerRemovedFilter[i].annotations[j].annotation_media = this.createDocumentStore.rotate_previous_value_backup["annotation_media"];
  //                     layerRemovedFilter[i].annotations[j].annotation_links = this.createDocumentStore.rotate_previous_value_backup["annotation_links"];
  //                     layerRemovedFilter[i].annotations[j].annotation_tags = this.createDocumentStore.rotate_previous_value_backup["annotation_tags"];
  //                     this.createDocumentStore.rotate_previous_value_backup = null;
  //                   }
  //                 }
  //               }
  //               annotations.push(layerRemovedFilter[i].annotations[j]);
  //               //check if this is a scale annotation. 
  //               if (layerRemovedFilter[i].annotations[j].annotation_id.indexOf("scale") >= 0) {
  //                 console.log("scale anntoation in")
  //                 let scaleValue = layerRemovedFilter[i].annotations[j].annotation_url['scaleValue'];
  //                 let scalewidth = layerRemovedFilter[i].annotations[j].annotation_url.scaleAgainst.width
  //                 let scaleheight = layerRemovedFilter[i].annotations[j].annotation_url.scaleAgainst.height
  //                 let scaleTo = scalewidth == 0 ? scaleheight : scalewidth
  //                 this.scaleFactor = scaleValue / scaleTo
  //                 console.log(scalewidth + "-----------" + scaleheight + "----" + scaleheight + "--" + this.scaleFactor)
  //               }
  //             }
  //           }
  //           layerRemovedFilter[i].annotations = annotations;
  //           if (i == 2) {
  //             console.log("layer annotations", annotations);
  //           }
  //         }
  //         this.layerDatas = layerRemovedFilter;
  //         if (this.lockedLayerActive === undefined) {
  //           let activeLayer = this.layerDatas.filter((layer) => (layer.is_active_flag == true || layer.is_active_flag == "true") && (layer.is_locked_flag == "false" || layer.is_locked_flag == false))
  //           if (activeLayer.length > 0) {
  //             this.lockedLayerActive = false
  //           }
  //         }
  //         console.log(this.layerDatas);
  //         this.dataService.searchLayerDatas.emit(this.layerDatas);
  //         // this.dataService.navgiationSendData.emit(this.layerDatas);
  //         // latest comment code
  //         let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
  //         let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: [], currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
  //         console.log(data);

  //         this.dataService2.layerDatafromnavigation.emit(data);
  //         this.dataService.sendMessageLayerDatas(this.layerDatas);
  //         this.documentService.layerDatas = this.layerDatas;
  //         this.getActiveLayerId();
  //       }
  //     });
  //   // return new Promise<void>((resolve, reject) => {
  //   //   resolve();
  //   // });
  // }

  getAnnotationForm(action?: string, callbackfun?: any) {
    return new Promise((resolve) => {
      var start = new Date().getTime();
      console.log('getAnnotation api' + ' Start time: ' + start);
      this.layerDatas$ = this.documentService.getAnnotationFormlist(this.projectId, this.folderId, this.currentPageId)
        .subscribe(async (response) => {
          console.log(_.cloneDeep(response));
          if (response["response_code"] == 200) {
            var end = new Date().getTime();
            var time = end - start;
            console.log('getAnnotation api' + ' end time: ' + end);
            console.log('getAnnotation api' + ' Execution time: ' + time);
          }
          var start_1 = new Date().getTime();
          console.log('drawing started' + ' Start time: ' + start_1);
          this.userdetail = response["response_body"]["user_list"];
          let layer_data = response["response_body"]["layer_data"];
          if (layer_data != null && layer_data != undefined && layer_data.length > 0) {
            // convert special characters
            response["response_body"]["layer_data"] = this.dataService4.changeSpecialtokeyformatList(layer_data, 'layerdata')
            // user details
            this.encrptdecrpt.setItem("userdetail", response["response_body"]["user_list"]);//security
            // conversion layer data
            let originalLayerData = response["response_body"]["layer_data"];
            if (originalLayerData != undefined) {
              // remove deleted layers
              var layerRemovedFilter = originalLayerData.filter((data) => this.createDocumentStore.data_allow_condition.includes(data.is_removed));
              // remove page wise deleted layers 
              let filter_pagewise_Layer_data = [];
              for (let page_check = 0; page_check < layerRemovedFilter.length; page_check++) {
                // getAssociated pages on layer
                let get_associate_page = layerRemovedFilter[page_check].associated_pages;
                // getAssociated pages on layer check page remove or not
                let filter_page = get_associate_page.find((pages_find) => pages_find.page_id == this.currentPageId);
                if (filter_page != undefined && this.createDocumentStore.data_allow_condition.includes(filter_page.is_removed)) {
                  console.log(layerRemovedFilter[page_check]);
                  // push to non-deleted layers to filter_pagewise_Layer_data array
                  filter_pagewise_Layer_data.push(layerRemovedFilter[page_check]);
                }
              }
              let final_layer = filter_pagewise_Layer_data;
              for (let layer_Index = 0; layer_Index < final_layer.length; layer_Index++) {
                // deleted annotation check
                let annotations_loop = final_layer[layer_Index].annotations.filter((annot_data) => this.createDocumentStore.data_allow_condition.includes(annot_data.is_removed));
                // rotate and resize backup
                if (action != undefined) {
                  this.previousRoute = "/index";
                  let filter_rotate_annot_index = annotations_loop.findIndex((rotate) => rotate.annotation_id == this.createDocumentStore.rotate_previous_value_backup['annotation_id']);
                  if (filter_rotate_annot_index > -1 && action == "rotateresizeend" && this.createDocumentStore.rotate_previous_value_backup != null) {
                    annotations_loop[filter_rotate_annot_index].annotation_forms = this.createDocumentStore.rotate_previous_value_backup["annotation_forms"];
                    annotations_loop[filter_rotate_annot_index].annotation_media = this.createDocumentStore.rotate_previous_value_backup["annotation_media"];
                    annotations_loop[filter_rotate_annot_index].annotation_links = this.createDocumentStore.rotate_previous_value_backup["annotation_links"];
                    annotations_loop[filter_rotate_annot_index].annotation_tags = this.createDocumentStore.rotate_previous_value_backup["annotation_tags"];
                    this.createDocumentStore.rotate_previous_value_backup = [];
                  }
                }
                //check if this is a scale annotation. 
                let find_scale_index = annotations_loop.findIndex((annotation_scale) => annotation_scale.annotation_id.includes("scale"));
                if (find_scale_index > -1) {
                  console.log("scale anntoation in");
                  let scaleValue = annotations_loop[find_scale_index].annotation_url['scaleValue'];
                  let scalewidth = annotations_loop[find_scale_index].annotation_url.scaleAgainst.width;
                  let scaleheight = annotations_loop[find_scale_index].annotation_url.scaleAgainst.height;
                  // let scaleTo = scalewidth == 0 ? scaleheight : scalewidth;
                  let scaleTo = scalewidth < scaleheight ? scaleheight : scalewidth;
                  this.scaleFactor = scaleValue / scaleTo;
                }
                // filtered annotation values stored to the layer annotation array - final
                final_layer[layer_Index].annotations = annotations_loop;
              }

              // layer details - delete layer and delete annotation all condition covered in final_layer
              this.layerDatas = final_layer;
              // check the lock and visible and active is enable or not start
              // check current page id document details
              let find_document_page_index = this.documentDetails.findIndex((document) => document.page_id == this.currentPageId);
              // find active layer id from document
              if (find_document_page_index > -1) {
                // else part P2 condition handle
                this.findlayerid = layer_data.filter((layerdetails) => layerdetails.layer_id === this.documentDetails[find_document_page_index].active_layer_id);
                if (this.findlayerid.length > 0) {
                  let associated_pages = this.findlayerid[0].associated_pages;
                  let page_element1 = associated_pages.filter(ele => ele.page_id == this.currentPageId);
                  if (page_element1.length > 0) {
                    if (this.createDocumentStore.data_allow_conditionT.includes(page_element1[0].is_hidden)) {
                      this.showvisible = false;
                    } else {
                      this.showvisible = true;
                    }
                    if (this.createDocumentStore.data_allow_conditionT.includes(page_element1[0].is_lock)) {
                      this.lockedLayerActive = true;
                    }
                    else {
                      this.lockedLayerActive = false;
                    }
                  }
                }
                else {
                  let activeLayer = layer_data.filter((layer) => (!this.createDocumentStore.data_allow_condition.includes(layer.is_active_flag)) && (this.createDocumentStore.data_allow_condition.includes(layer.is_locked_flag)));
                  if (activeLayer.length > 0) {
                    this.lockedLayerActive = false;
                    // if(activeLayer[0].is_visible_flag=="false"){
                    //   let currentPageIndex=activeLayer[0].associated_pages.findIndex(item=>item.page_id==this.currentPageId);
                    //   if(currentPageIndex!=-1){
                    //     // activeLayer[0].associated_pages[currentPageIndex].is_hidden=true;
                    //     delete activeLayer[0].associated_pages[currentPageIndex]['is_hidden'];
                    //     console.log(activeLayer);
                    //   }
                    // }
                    // else if(activeLayer[0].is_visible_flag=="true"){
                    //   let currentPageIndex=activeLayer[0].associated_pages.findIndex(item=>item.page_id==this.currentPageId);
                    //   if(currentPageIndex!=-1){
                    //     delete activeLayer[0].associated_pages[currentPageIndex]['is_hidden'];
                    //     console.log(activeLayer);
                    //     // activeLayer[0].associated_pages[currentPageIndex].is_hidden=false;
                    //   }
                    // }
                  }
                }
              }
              console.log(this.layerDatas);
              this.dataService.searchLayerDatas.emit(this.layerDatas);
              // this.dataService.navgiationSendData.emit(this.layerDatas);
              // latest comment code
              let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
              let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: [], currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
              console.log(_.cloneDeep(data));
              this.dataService2.layerDatafromnavigation.emit(data);
              this.documentService.layerDatas = this.layerDatas;
              let get_value = await this.getActiveLayerId();
              console.log('activelayerid function');
              if (callbackfun != undefined) {
                callbackfun('complete_get_data');
              }
              if (get_value == 200) {
                var end_1 = new Date().getTime();
                var time_1 = end_1 - start_1;
                this.checkCurrentActiveLayerProperties();
                resolve(200);
              }
            }
          }
          else{
            resolve(200);
          }
          // this.callBackgetData(this.toolbar_id); //skip the toolbar view data
        });
    });
  }

  repoint_AnnotationStoreFunction(id) {

    if (this.repoint_AnnotationStore != undefined && this.repoint_AnnotationStore != null && this.repoint_AnnotationStore.length > 0) {
      if (!this.repoint_AnnotationStore.includes(id)) {
        this.repoint_AnnotationStore.push(id);
        this.repoint_AnnotationStore_Id.push(id.annotation_id);
      }
    }
    else {
      this.repoint_AnnotationStore.push(id);
      this.repoint_AnnotationStore_Id.push(id.annotation_id);
    }
  }

  getActiveLayerId() {
    return new Promise((resolve) => {
      var syncActivated = 'disable';
      // this.visibleLayerIds = [];
      let scalingAnnotations = [];
      let displayAnnotations = [];
      if (this.layerDatas != undefined) {
        // check visible annotations
        for (let k = 0; k < this.layerDatas.length; k++) {
          // get associated page of current layer
          let get_current_layer = this.layerDatas[k].associated_pages;
          // filter current page of  associated pages
          let filter_current_page = get_current_layer.filter((page) => page.page_id == this.currentPageId);
          //autocad filter based on current layer and current page
          if (this.autocad_import != undefined) {
            if (this.autocad_import.length != 0) {
              console.log(get_current_layer)
              this.autocad_import = this.autocad_import.filter(res => res.page_id == filter_current_page[0].page_id)
              this.autocad_import = this.autocad_import.filter(res => res.layer_id == filter_current_page[0].layer_id)
              this.autocad_import = this.autocad_import.filter(res => res.is_removed == false)
            } else {

            }
          }

          // check visible layer condition
          if (filter_current_page.length > 0) {
            // if P3 annotation else is P2 annotations
            if (filter_current_page[0].hasOwnProperty('is_hidden')) {
              if (this.createDocumentStore.data_allow_condition.includes(filter_current_page[0].is_hidden)) {
                // merge all annotations in to one array
                if (this.autocad_import != undefined) {
                  if (this.autocad_import.length != 0) {
                    let ids = this.layerDatas[k].annotations.map(c => c.annotation_id);
                    this.layerDatas[k].annotations = this.layerDatas[k].annotations.concat(this.autocad_import.filter(({ annotation_id }) => !ids.includes(annotation_id)))
                    console.log(this.layerDatas[k].annotations);

                  }

                }
                displayAnnotations = [...displayAnnotations, ...this.layerDatas[k].annotations];

              }

              else {
                // select annotaion and hide layers check box and selected annotation should empty using mutiselect
                if (this.multipleSelectOn == true) {
                  console.log(this.multiselectionList)
                  if (this.multiselectionList.length > 0) {
                    console.log(this.createDocumentStore.selectedAnnotations);
                    let temp_holder = [];
                    for (let t = 0; t < this.multiselectionList.length; t++) {
                      if (this.multiselectionList[t].page_id == filter_current_page[0].page_id) {
                        let itemIndex = this.multiselectionList.indexOf(this.multiselectionList[t]);
                        if (itemIndex != -1) {
                          temp_holder.push(this.multiselectionList[t]);
                        }
                        let temp_id = this.createDocumentStore.selectedAnnotations.indexOf(this.multiselectionList[t].annotation_id);
                        if (temp_id != -1) {
                          this.createDocumentStore.selectedAnnotations.splice(temp_id, 1);
                        }
                      }
                    }
                    for (let i = 0; i < temp_holder.length; i++) {
                      let item = this.multiselectionList.indexOf(temp_holder[i]);
                      this.multiselectionList.splice(item, 1);
                    }
                  }
                  this.selectedAnnotationLength = this.multiselectionList.length;
                }
              }
            }
            else {
              if (this.createDocumentStore.data_allow_conditionT.includes(this.layerDatas[k].is_visible_flag)) {
                if (this.autocad_import != undefined) {
                  if (this.autocad_import.length != 0) {
                    let ids = this.layerDatas[k].annotations.map(c => c.annotation_id);
                    this.layerDatas[k].annotations = this.layerDatas[k].annotations.concat(this.autocad_import.filter(({ annotation_id }) => !ids.includes(annotation_id)))
                    console.log(this.layerDatas[k].annotations);



                  }
                }
                displayAnnotations = [...displayAnnotations, ...this.layerDatas[k].annotations];
              }
            }
            // check scaling annotations
            let check_scale_annot = displayAnnotations.filter((annotation_package) => annotation_package.annotation_id.includes('scale'));
            if (check_scale_annot.length > 0) {
              scalingAnnotations = check_scale_annot;
            }
          }
        }
        let filter_removed_annotation = displayAnnotations.filter((data) => this.createDocumentStore.data_allow_condition.includes(data.is_removed));
        displayAnnotations = _.cloneDeep(filter_removed_annotation);
        this.showAllAnnotations = displayAnnotations;
        this.search_displayannotation = displayAnnotations;
        // if (this.searchOption == true) {
        //   setTimeout(() => {
        //     this.dataService.search_annotation.emit();
        //   }, 1000);
        // }
        // remove annotation labels
        let getannotationLabelElement = document.querySelectorAll("p[annotationLabel]");
        if (getannotationLabelElement.length > 0) {
          for (var al = 0; al < getannotationLabelElement.length; al++) {
            getannotationLabelElement[al].remove();
          }
        }
        if (this.copyAnnotationStart == false && this.newShapeAddwhenMultiSelect == false) {
          console.log('normal draw');
          if (displayAnnotations.length > 0) {
            // empty the svg array
            this.createDocumentStore.view_annotation_array = [];
            this.createDocumentStore.single_select_annotation = [];
            displayAnnotations = displayAnnotations.filter((rem_scale_annot) => !rem_scale_annot.annotation_id.includes('scale'));
            for (var i = 0; i < displayAnnotations.length; i++) {
              let cloneDisplayAnnotation = _.cloneDeep(displayAnnotations[i]);
              // if (cloneDisplayAnnotation.page_id == this.currentPageId) {
              if (!cloneDisplayAnnotation.annotation_id.includes('-scale')) {
                // special character changing view annotation label and annotation name
                cloneDisplayAnnotation.annotation_label = this.dataService4.changeSpecialtoKeyFormat(cloneDisplayAnnotation.annotation_label);
                cloneDisplayAnnotation.annotation_name = this.dataService4.changeSpecialtoKeyFormat(cloneDisplayAnnotation.annotation_name);
                // changing annotation data to svg path
                let clone_change_svg_path = _.cloneDeep(cloneDisplayAnnotation);
                if (clone_change_svg_path.annotation_data != "") {
                  let getsvg_path = this.documentPage.changesvgpath(clone_change_svg_path, 'document', this.pngFormat);
                  this.createDocumentStore.view_annotation_array.push(getsvg_path);
                  console.log(this.createDocumentStore.view_annotation_array);
                }
              }

              // }
            }
            if (scalingAnnotations.length > 0) { // draw scale annotations
              var find_Recent_Annot = [];
              if (scalingAnnotations.length > 1) {
                let filter_Scale_Annot = scalingAnnotations.sort((a, b) => new Date(b.created_date).getTime() - new Date(a.created_date).getTime());
                find_Recent_Annot = filter_Scale_Annot[scalingAnnotations.length - 1];
                // The below line is commented. When we give set scale for all pages, in the next pages the set scale values are not updated 
                // find_Recent_Annot = filter_Scale_Annot[0];
              }
              else if (scalingAnnotations.length == 1) {
                find_Recent_Annot = scalingAnnotations[0];
              }
              let clone_scale_anot = _.cloneDeep(find_Recent_Annot);
              let scaleValue = clone_scale_anot["annotation_url"]['scaleValue'];
              let scalewidth = clone_scale_anot["annotation_url"]["scaleAgainst"].width
              let scaleheight = clone_scale_anot["annotation_url"]["scaleAgainst"].height
              // let scaleTo = scalewidth == 0 ? scaleheight : scalewidth
              let scaleTo = scalewidth < scaleheight ? scaleheight : scalewidth;
              this.scaleFactor = scaleValue / scaleTo;
              let checkScaleValue = clone_scale_anot["annotation_url"];
              let getScaleValue = checkScaleValue.scaleAgainst;
              if (getScaleValue.width < getScaleValue.height) {
                this.scaleVertical = true;
                this.scaleHorizontal = false;
                this.scaleHeight = getScaleValue.height.toString();
                this.scaleBoxHeight = (getScaleValue.height + 60).toString();
                this.scalefeetValue = checkScaleValue.scaleValue;
              }
              else {
                this.scaleHorizontal = true;
                this.scaleVertical = false;
                this.scaleWidth = getScaleValue.width.toString();
                this.scaleBoxWidth = (getScaleValue.width + 80).toString();
                this.scalefeetValue = checkScaleValue.scaleValue;
              }
            }
          }
          else {
            // empty the svg array
            this.createDocumentStore.view_annotation_array = [];
            this.deselectAnnotation();
          }
        }
        if(this.select_autocad==true){
          this.show=false;
        }
        this.checkLayerPagesBasedShowData();
        if (this.synAction == true) {
          syncActivated = 'active';
          this.synAction = false;
          this.dataService.synActionCompleteNew.emit(false);
          console.log(this.oldScaleValue, 'scale value activated');
          if (this.pngFormat == false) {
            // this.pdfPanzoomSync(this.oldScaleValue);
          }
        }
        if (this.pngFormat == false && syncActivated == 'disable') {
          // commented by 17.12.2021 check the pdf quality purpose but below code is needed.
          // this.pdfPanzoomSample();
        }
      }
      resolve(200);
    });
  }

  checkPageSwitchrequired() {
    if (this.getOpenLinkWindow == true || this.getOpenLinkWindow == "true") {
      this.pageSwitchedForlink = true
      let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.pageId)
      this.currentPageNumber = page_data[0].page_number
      this.slideIndex = this.currentPageNumber - 1;
      // this.pdfPageNumber = data;
      this.scaleHorizontal = false;
      this.scaleVertical = false;
      // previous page annotation selection removed.
      this.previousSelectAnnotation = [];
      if (this.pngFormat == true) {
        this.show = true;
        this.switchPageChangeAction();
      }
      else {
        this.show = true;
        this.switchPageChangeActionPdf();
      }
    }
  }

  getCanvaswidthandHeight(getData) {
    console.log(getData);
    let convertAnnotationWH = getData.annotation_data;
    let xCoordinate = [];
    let yCoordinate = [];
    let startx;
    let starty;
    let endx;
    let endy;
    convertAnnotationWH = convertAnnotationWH.trim();
    let splitData = convertAnnotationWH.split(" ");
    for (var i = 0; i < splitData.length; i++) {
      let hypenSplit = splitData[i].split("-");
      let colonSplit = hypenSplit[1].split(":");
      xCoordinate.push(colonSplit[0]);
      yCoordinate.push(colonSplit[1]);
    }
    startx = Math.min.apply(null, xCoordinate);
    endx = Math.max.apply(null, xCoordinate);
    starty = Math.min.apply(null, yCoordinate);
    endy = Math.max.apply(null, yCoordinate);
    let getDrawWidthandHeight = this.calculateRectPos(
      startx,
      starty,
      endx,
      endy
    );
    return getDrawWidthandHeight;
  }
  //Shape showing ActivateId get and displayShapes Store End

  //blurry remove canvas function
  canvasBlurryRemove(canvasEle, contextEle) {
    devicePixelRatio = 72;
    this.canvasElement = canvasEle.getContext("2d");
    let rect = canvasEle.getBoundingClientRect();
    // increase the actual size of our canvas
    canvasEle.width = rect.width * devicePixelRatio;
    canvasEle.height = rect.height * devicePixelRatio;

    // ensure all drawing operations are scaled
    this.canvasElement.scale(devicePixelRatio, devicePixelRatio);

    // scale everything down using CSS
    canvasEle.style.width = rect.width + 'px';
    canvasEle.style.height = rect.height + 'px';
  }

  //Database Shapes drawing method Start
  getshapeDrawing(getData, isnegativeCoordinates) {
    if (getData.annotation_id != this.propertiesannotationData.annotation_id && this.isforResize) {
      return;
    }
    var elementId = Number(getData.toolbar_element_id);
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("documentSVG", "1");
    newcreatedElement.className = 'annot_canvas';
    // newcreatedElement.classList.add("disabled");
    getData.initial_height = Number(getData.initial_height);
    getData.initial_width = Number(getData.initial_width);
    var getHeight;
    var getWidth;
    let linewidthCount = 0;
    if (elementId > 11) {
      linewidthCount = Math.round(Number(getData.line_width) / 2);
    }
    else {
      linewidthCount = Math.round(Number(getData.line_width) / 6);
    }
    var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(getData);
    if (getData.initial_width <= 0 && getData.initial_height <= 0 && elementId >= 12 && elementId <= 18) {
      let getDrawWidthandHeight = this.shapeService1.getCanvaswidthandHeight(getData);
      if (Number(getData.initial_position_x) != 0) {
        let getChangedString = this.changeStringValue(getData);
        getData.annotation_data = getChangedString;
        getData.initial_position_x = Number(getData.initial_position_x);
        getData.initial_position_y = Number(getData.initial_position_y);
        this.coordinateX = getData.initial_position_x < 0 ? -(getData.initial_position_x) : getData.initial_position_x;
        this.coordinateY = getData.initial_position_y < 0 ? -(getData.initial_position_y) : getData.initial_position_y;
      }
      else {
        this.coordinateX = getDrawWidthandHeight.left;
        this.coordinateY = getDrawWidthandHeight.top;
      }

      if (shapeStringValueTemp.width < 2 || shapeStringValueTemp.height < 2) {
        if (getData.line_width > 20) {
          getWidth = getDrawWidthandHeight.width + (Number(getData.line_width) * 4);
          getHeight = getDrawWidthandHeight.height + (Number(getData.line_width) * 4);
        }
        else {
          getWidth = getDrawWidthandHeight.width + (Number(getData.line_width));
          getHeight = getDrawWidthandHeight.height + (Number(getData.line_width));
        }
      }
      else {
        if (getData.line_width > 20) {
          getWidth = getDrawWidthandHeight.width + (Number(getData.line_width) * 4);
          getHeight = getDrawWidthandHeight.height + (Number(getData.line_width) * 4);
        }
        else {
          getWidth = getDrawWidthandHeight.width + (Number(getData.line_width));
          getHeight = getDrawWidthandHeight.height + (Number(getData.line_width));
        }
      }
    }
    else if (getData.initial_width != 0 && getData.initial_height != 0 && elementId >= 12 && elementId <= 18) {

      console.log(getData.initial_width, getData.initial_height);
      if (getData.line_width > 20) {
        getHeight = getData.initial_height + (Number(getData.line_width) * 4);
        getWidth = getData.initial_width + (Number(getData.line_width) * 4);
      }
      else {
        getHeight = getData.initial_height + Number(getData.line_width);
        getWidth = getData.initial_width + Number(getData.line_width);
      }
    }
    else if (elementId <= 11 && getData.initial_height != 0 && getData.initial_width != 0) {
      this.coordinateX = getData.initial_position_x;
      this.coordinateY = getData.initial_position_y;
      getWidth = Number(getData.initial_width) + (Number(getData.line_width) / (6) * 4);
      getHeight = Number(getData.initial_height) + (Number(getData.line_width) / (6) * 4);
      if (elementId == 5 || elementId == 9) {
        getWidth = Number(getData.initial_width) + (Number(getData.line_width) / (6) * 4);
        getHeight = Number(getData.initial_height) + (Number(getData.line_width) / (6) * 4);
      }
    }
    else if (elementId < 11) {
      console.log(this.seticonwidth, this.seticonheight)
      if ((this.seticonwidth == undefined || this.seticonwidth == 0) && (this.seticonheight == undefined || this.seticonheight == 0)) {
        getWidth = 35 + linewidthCount;
        getHeight = 35 + linewidthCount;
        if (elementId == 5 || elementId == 9) {
          getWidth = 35 + (linewidthCount * 2);
          getHeight = 35 + (linewidthCount * 2);
        }
      }
      else {
        getWidth = this.seticonwidth + (linewidthCount * 2);
        getHeight = this.seticonheight + (linewidthCount * 2);
      }


    }
    else if (elementId == 19 || elementId == 20) {
      if (getData.annotation_data.includes('move') && getData.initial_width != 0 && getData.initial_height != 0) {
        let getDrawWidthandHeight = this.shapeService1.getCanvaswidthandHeight(getData);
        getWidth = getDrawWidthandHeight.width + (Number(getData.line_width) / 2);
        getHeight = getDrawWidthandHeight.height + (Number(getData.line_width) / 2);
        this.coordinateX = Number(getData.initial_position_x) - 35 - ((Number(getData.line_width) / 2) / 2);
        this.coordinateY = Number(getData.initial_position_y) - 35 - ((Number(getData.line_width) / 2) / 2);
      }
      else if (getData.annotation_data.includes('move') && getData.initial_position_x != 0 && getData.initial_position_y != 0) {
        let getDrawWidthandHeight = this.shapeService1.getCanvaswidthandHeight(getData);
        getWidth = getDrawWidthandHeight.width + (Number(getData.line_width));
        getHeight = getDrawWidthandHeight.height + (Number(getData.line_width));
        this.coordinateX = Number(getData.initial_position_x) - ((Number(getData.line_width) / 2));
        this.coordinateY = Number(getData.initial_position_y) - ((Number(getData.line_width) / 2));
      }
      else {
        // changing code
        if (getData.annotation_data.includes('move')) {
          let repoint_shape = this.shapeService1.getCanvaswidthandHeight(getData);
          getWidth = repoint_shape.width + 20 + (Number(getData.line_width));
          getHeight = repoint_shape.height + 20 + (Number(getData.line_width));
          this.coordinateX = Number(repoint_shape.left) - 10;
          this.coordinateY = Number(repoint_shape.top) - 10;
        }
        else {
          let stringValue = getData.annotation_data;
          let splitString = stringValue.replaceAll('--', '-n');
          splitString = splitString.replaceAll(':-', ':n');
          let hypenSplitCD = splitString.split("-");
          let colonSplitCD = hypenSplitCD[1].replaceAll('n', '-').split(":");
          // add negative value reduce the x and y in normal shapes
          colonSplitCD[0] = Number(colonSplitCD[2]) < 0 ? Number(colonSplitCD[0]) + Number(colonSplitCD[2]) : Number(colonSplitCD[0]);
          colonSplitCD[1] = Number(colonSplitCD[3]) < 0 ? Number(colonSplitCD[1]) + Number(colonSplitCD[3]) : Number(colonSplitCD[1]);

          colonSplitCD[0] = Number(colonSplitCD[0]) < 0 ? - (Number(colonSplitCD[0])) : Number(colonSplitCD[0]);
          colonSplitCD[1] = Number(colonSplitCD[1]) < 0 ? - (Number(colonSplitCD[1])) : Number(colonSplitCD[1]);
          // let negativeElipseRectX = colonSplitCD[2] < 0 ? true : false;
          // let negativeElipseRectY = colonSplitCD[3] < 0 ? true : false;  
          colonSplitCD[2] = Number(colonSplitCD[2]) < 0 ? - (Number(colonSplitCD[2])) : Number(colonSplitCD[2]);
          colonSplitCD[3] = Number(colonSplitCD[3]) < 0 ? - (Number(colonSplitCD[3])) : Number(colonSplitCD[3]);

          if (elementId == 19) {
            getWidth = parseInt(colonSplitCD[2]) + 4 + Number(getData.line_width) / (2);
            getHeight = parseInt(colonSplitCD[3]) + 4 + Number(getData.line_width) / (2);
          }
          else {
            getWidth = parseInt(colonSplitCD[2]) + 20 + Number(getData.line_width) / (2);
            getHeight = parseInt(colonSplitCD[3]) + 20 + Number(getData.line_width) / (2);
          }
          if (Number(getData.initial_width) != 0 && Number(getData.initial_height) != 0) {
            this.coordinateX = Number(getData.initial_position_x);
            this.coordinateY = Number(getData.initial_position_y);
            this.coordinateY = this.coordinateY - (35 / 2) - ((Number(getData.line_width) / 2) / 2);
            this.coordinateX = this.coordinateX - (35 / 2) - ((Number(getData.line_width) / 2) / 2);
            // commented by ganesh at 04.06.2021 purpose of rectange position change after move
            // getData.initial_width = 0;
            // getData.initial_height = 0;
            // getData.initial_position_x = 0;
            // getData.initial_position_y = 0;
          }
          else if (Number(getData.initial_position_x) != 0 && Number(getData.initial_position_y) != 0) {
            this.coordinateX = Number(getData.initial_position_x);
            this.coordinateY = Number(getData.initial_position_y);
            this.coordinateY = this.coordinateY - (getHeight / 2);
            this.coordinateX = this.coordinateX - (getWidth / 2);
          }
          else {
            // if(negativeElipseRectX){
            //   
            //   this.coordinateX = -(colonSplitCD[2]) < 0 ? -(colonSplitCD[0]) + colonSplitCD[2] - ((Number(getData.line_width) / 2) / 2) : colonSplitCD[0] - ((Number(getData.line_width) / 2) / 2);
            // }
            // if(negativeElipseRectY){
            //   this.coordinateY = -(colonSplitCD[3]) < 0 ? -(colonSplitCD[1]) + colonSplitCD[3] - ((Number(getData.line_width) / 2) / 2) : colonSplitCD[1] - ((Number(getData.line_width) / 2) / 2);
            // }
            // if(!negativeElipseRectX && !negativeElipseRectY){
            //Jose Added condition to include line width alone for eclipes alone
            if (elementId == 19) {
              this.coordinateX = colonSplitCD[0] - ((Number(getData.line_width) / 2));
              this.coordinateY = colonSplitCD[1] - ((Number(getData.line_width) / 2));
            } else {
              this.coordinateX = colonSplitCD[0] - 10 - ((Number(getData.line_width) / 2) / 2);
              this.coordinateY = colonSplitCD[1] - 10 - ((Number(getData.line_width) / 2) / 2);
            }
          }
          console.log(getWidth, getHeight);
        }

      }
    }
    newcreatedElement.style.position = "absolute";
    this.transparentBorder(newcreatedElement);
    newcreatedElement.style.zIndex = "1";
    if (
      elementId == 12 ||
      elementId == 17 ||
      elementId == 18 ||
      elementId == 14 ||
      elementId == 13 ||
      elementId == 19 ||
      elementId == 20 ||
      elementId == 15 ||
      elementId == 16
    ) {
      newcreatedElement.setAttribute("id", getData.annotation_id);
      var complexElementWidth = 0;
      var complexElementHeight = 0;
      if ((elementId == 13 || elementId == 14) && getData.initial_height == 0) {
        newcreatedElement.setAttribute("width", getWidth + 20);
        newcreatedElement.setAttribute("height", getHeight + 20);
        complexElementWidth = getWidth + 20;
        complexElementHeight = getHeight + 20;
      }
      else if (elementId != 19 && elementId != 20 && getData.initial_height == 0) {
        newcreatedElement.setAttribute("width", getWidth + 20);
        newcreatedElement.setAttribute("height", getHeight + 20);
        complexElementWidth = getWidth + 20;
        complexElementHeight = getHeight + 20;
      }
      else {
        newcreatedElement.setAttribute("width", getWidth);
        newcreatedElement.setAttribute("height", getHeight);
        complexElementWidth = getWidth;
        complexElementHeight = getHeight;
      }

      if (getData.initial_width != 0 && getData.initial_height != 0 && (elementId >= 12 && elementId <= 18)) {
        let topResizeSimple = 0;
        let leftResizeSimple = 0;
        if (shapeStringValueTemp.width < 2 || shapeStringValueTemp.height < 2) {
          newcreatedElement.style.top = Number(this.coordinateY) - (35 / 2) - ((Number(getData.line_width) / 2) / 2) + 'px';
          newcreatedElement.style.left = Number(this.coordinateX) - (35 / 2) - ((Number(getData.line_width) / 2) / 2) + 'px';
          topResizeSimple = this.coordinateY - (35 / 2) - ((Number(getData.line_width) / 2) / 2);
          leftResizeSimple = this.coordinateX - (35 / 2) - ((Number(getData.line_width) / 2) / 2);
          if (getData.line_width > 20) {
            let cloneLineWidthChange = _.cloneDeep(getData);
            let getStringMethod = this.shapeService1.resizeFunctionLineWidth(cloneLineWidthChange, false, newcreatedElement.width, newcreatedElement.height);
            getData.annotation_data = getStringMethod.shapeString;
            newcreatedElement.style.top = Number(this.coordinateY) - (35 / 2) - ((Number(getData.line_width) / 2) / 2) - getStringMethod.yDifference + "px";
            newcreatedElement.style.left = Number(this.coordinateX) - (35 / 2) - ((Number(getData.line_width) / 2) / 2) - getStringMethod.xDifference + "px";
            topResizeSimple = Number(this.coordinateY) - (35 / 2) - ((Number(getData.line_width) / 2) / 2) - getStringMethod.yDifference;
            leftResizeSimple = Number(this.coordinateX) - (35 / 2) - ((Number(getData.line_width) / 2) / 2) - getStringMethod.xDifference;
          }
          if (getData.annotation_label.trim() != "") {
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, complexElementWidth, complexElementHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
        else {
          newcreatedElement.style.top = Number(this.coordinateY) - (35 / 2) - ((Number(getData.line_width) / 2)) + 'px';
          newcreatedElement.style.left = Number(this.coordinateX) - (35 / 2) - ((Number(getData.line_width) / 2)) + 'px';
          topResizeSimple = Number(this.coordinateY) - (35 / 2) - ((Number(getData.line_width) / 2));
          leftResizeSimple = Number(this.coordinateX) - (35 / 2) - ((Number(getData.line_width) / 2));
          if (getData.line_width > 20) {
            let cloneLineWidthChange = _.cloneDeep(getData);
            let getStringMethod = this.shapeService1.resizeFunctionLineWidth(cloneLineWidthChange, false, newcreatedElement.width, newcreatedElement.height);
            getData.annotation_data = getStringMethod.shapeString;
            newcreatedElement.style.top = Number(this.coordinateY) - (35 / 2) - ((Number(getData.line_width) / 2)) - getStringMethod.yDifference + "px";
            newcreatedElement.style.left = Number(this.coordinateX) - (35 / 2) - ((Number(getData.line_width) / 2)) - getStringMethod.xDifference + "px";
            topResizeSimple = Number(this.coordinateY) - (35 / 2) - ((Number(getData.line_width) / 2)) - getStringMethod.yDifference;
            leftResizeSimple = Number(this.coordinateX) - (35 / 2) - ((Number(getData.line_width) / 2)) - getStringMethod.xDifference;
          }
          if (getData.annotation_label.trim() != "") {
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, complexElementWidth, complexElementHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
      }
      else if (getData.initial_position_x != 0 && getData.initial_position_y != 0 && (elementId >= 12 && elementId <= 18)) {
        let topResizeSimple = 0;
        let leftResizeSimple = 0;
        if (shapeStringValueTemp.width < 2 || shapeStringValueTemp.height < 2) {
          newcreatedElement.style.top = Number(this.coordinateY) - (newcreatedElement.height / 2) + 'px';
          newcreatedElement.style.left = Number(this.coordinateX) - (newcreatedElement.width / 2) + 'px';
          topResizeSimple = Number(this.coordinateY) - (newcreatedElement.height / 2);
          leftResizeSimple = Number(this.coordinateX) - (newcreatedElement.width / 2);
          if (getData.line_width > 20) {
            let cloneLineWidthChange = _.cloneDeep(getData);
            let getStringMethod = this.shapeService1.resizeFunctionLineWidth(cloneLineWidthChange, false, newcreatedElement.width, newcreatedElement.height);
            getData.annotation_data = getStringMethod.shapeString;
            newcreatedElement.style.top = Number(this.coordinateY) - (newcreatedElement.height / 2) + "px";
            newcreatedElement.style.left = Number(this.coordinateX) - (newcreatedElement.width / 2) + "px";
          }
          if (getData.annotation_label.trim() != "") {
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, complexElementWidth, complexElementHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
        else {
          newcreatedElement.style.top = Number(this.coordinateY) - (newcreatedElement.height / 2) + 'px';
          newcreatedElement.style.left = Number(this.coordinateX) - (newcreatedElement.width / 2) + 'px';
          topResizeSimple = Number(this.coordinateY) - (newcreatedElement.height / 2);
          leftResizeSimple = Number(this.coordinateX) - (newcreatedElement.width / 2);
          if (getData.line_width > 20) {
            let cloneLineWidthChange = _.cloneDeep(getData);
            let getStringMethod = this.shapeService1.resizeFunctionLineWidth(cloneLineWidthChange, false, newcreatedElement.width, newcreatedElement.height);
            getData.annotation_data = getStringMethod.shapeString;
            newcreatedElement.style.top = Number(this.coordinateY) - (newcreatedElement.height / 2) + "px";
            newcreatedElement.style.left = Number(this.coordinateX) - (newcreatedElement.width / 2) + "px";
          }
          if (getData.annotation_label.trim() != "") {
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, complexElementWidth, complexElementHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
      }
      else if (elementId == 19 || elementId == 20) {

        if (getData.annotation_data.includes('move') && elementId == 19 && getData.initial_height != 0) {
          newcreatedElement.style.top = Number(getData.initial_position_y) - (17.5) - ((Number(getData.line_width) / 2)) + "px";
          newcreatedElement.style.left = Number(getData.initial_position_x) - (17.5) - ((Number(getData.line_width) / 2)) + "px";
          if (getData.annotation_label.trim() != "") {
            let topResizeSimple = Number(getData.initial_position_y) - (35) + 10;
            let leftResizeSimple = Number(getData.initial_position_x) - (35) + 10;
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, getWidth, getHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
        else if (getData.annotation_data.includes('move') && elementId == 20 && getData.initial_height != 0) {
          newcreatedElement.style.top = Number(getData.initial_position_y) - (17.5) + "px";
          newcreatedElement.style.left = Number(getData.initial_position_x) - (17.5) + "px";
          if (getData.annotation_label.trim() != "") {
            let topResizeSimple = Number(getData.initial_position_y) - (17.5);
            let leftResizeSimple = Number(getData.initial_position_x) - (17.5);
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, getWidth, getHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
        else if (getData.annotation_data.includes('move') && elementId == 19 && getData.initial_position_x != 0) {
          newcreatedElement.style.top = Number(this.coordinateY) - (35) + 10 + "px";
          newcreatedElement.style.left = Number(this.coordinateX) - (35) + 10 + "px";
          if (getData.annotation_label.trim() != "") {
            let topResizeSimple = Number(this.coordinateY) - (35) + 10;
            let leftResizeSimple = Number(this.coordinateX) - (35) + 10;
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, getWidth, getHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
        else if (getData.annotation_data.includes('move') && elementId == 20 && getData.initial_position_x != 0) {
          newcreatedElement.style.top = Number(this.coordinateY) - (17.5) + "px";
          newcreatedElement.style.left = Number(this.coordinateX) - (17.5) + "px";
          if (getData.annotation_label.trim() != "") {
            let topResizeSimple = Number(this.coordinateY) - (17.5);
            let leftResizeSimple = Number(this.coordinateX) - (17.5);
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, getWidth, getHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
        else if (getData.annotation_data.includes('move') && (elementId == 20 || elementId == 19)) {
          newcreatedElement.style.top = Number(this.coordinateY) + "px";
          newcreatedElement.style.left = Number(this.coordinateX) + "px";
          // changing code 26.10.2021 reason ticket no:391 repoint and resize ellipse when hit resizeincrease button moving left and top position issue 
          // newcreatedElement.style.top = Number(this.coordinateY) - ((Number(getData.line_width) / 2)) + "px";
          // newcreatedElement.style.left = Number(this.coordinateX) - ((Number(getData.line_width) / 2)) + "px";
          if (getData.annotation_label.trim() != "") {
            let topResizeSimple = Number(this.coordinateY) - ((Number(getData.line_width) / 2));
            let leftResizeSimple = Number(this.coordinateX) - ((Number(getData.line_width) / 2));
            this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, getWidth, getHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
        else {
          newcreatedElement.style.top = this.coordinateY + "px";
          newcreatedElement.style.left = this.coordinateX + "px";
          if (getData.annotation_label.trim() != "") {
            this.shapeService1.mainDrawingLabel(getData, pdfImg, this.coordinateX, this.coordinateY, complexElementWidth, complexElementHeight);
            this.getMultipleMovingLabelElement(getData.annotation_id);
          }
        }
      }
      else {
        let topResizeSimple = 0;
        let leftResizeSimple = 0;
        newcreatedElement.style.top = this.coordinateY - (Number(getData.line_width) / 2) + "px";
        newcreatedElement.style.left = this.coordinateX - (Number(getData.line_width) / 2) + "px";
        newcreatedElement.style.marginTop = - 10 + "px";
        newcreatedElement.style.marginLeft = - 10 + "px";
        topResizeSimple = Number(this.coordinateY) - (Number(getData.line_width) / 2);
        leftResizeSimple = Number(this.coordinateX) - (Number(getData.line_width) / 2);
        if (getData.line_width > 20) {
          let cloneLineWidthChange = _.cloneDeep(getData);
          let getStringMethod = this.shapeService1.resizeFunctionLineWidth(cloneLineWidthChange, false, newcreatedElement.width, newcreatedElement.height);
          getData.annotation_data = getStringMethod.shapeString;
          newcreatedElement.style.top = this.coordinateY - (Number(getData.line_width) / 2) - getStringMethod.yDifference + "px";
          newcreatedElement.style.left = this.coordinateX - (Number(getData.line_width) / 2) - getStringMethod.xDifference + "px";
          topResizeSimple = Number(this.coordinateY) - (Number(getData.line_width) / 2) - getStringMethod.yDifference;
          leftResizeSimple = Number(this.coordinateX) - (Number(getData.line_width) / 2) - getStringMethod.xDifference;
        }
        if (getData.annotation_label.trim() != "") {
          this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, complexElementWidth, complexElementHeight, false, -10, -10);
        }
      }
      // else if(getData.initial_height == 0&&getData.initial_position_x==0&&getData.initial_position_y==0) {
      //   newcreatedElement.style.marginTop = - 10 + "px";
      //   newcreatedElement.style.marginLeft = - 10 + "px";
      // }
    }
    else if (
      elementId == 15 ||
      elementId == 16
    ) {
      newcreatedElement.setAttribute("id", getData.annotation_id);
      newcreatedElement.setAttribute("width", getWidth + getData.line_width + getData.line_width + 10);
      newcreatedElement.setAttribute("height", getHeight + getData.line_width + getData.line_width + 10);
      newcreatedElement.style.top = this.coordinateY - getData.line_width - getData.line_width + "px";
      newcreatedElement.style.left = this.coordinateX - getData.line_width - getData.line_width + "px";
      newcreatedElement.style.marginTop = -getData.line_width - 2.5 + "px";
      newcreatedElement.style.marginLeft = -getData.line_width - 2.5 + "px";
    }
    else if (elementId == 11) {
      let staticValue = "move-0:10 line-20:10 line-20:5 controlpoint-20:0 curveEnd-25:0 line-44:0 controlpoint-49:0 curveEnd-49:5 line-49:15 controlpoint-49:20 curveEnd-44:20 line-25:20 controlpoint-20:20 curveEnd-20:15 line-20:10";
      var getText = getData.annotation_data.split('text-');
      console.log(getText);
      let textheight = 20;
      console.log(typeof getText[1]);
      if (typeof getText[1] != undefined) {
        if (getData.hasOwnProperty("annotation_label") && getData.annotation_label.trim() != '') {
          let textvalue = getData.annotation_label.trim();
          getText.push(textvalue);
        }
        else {
          let textvalue = "     ";
          getText.push(textvalue);
        }
      }
      getText[1] = getText[1].replaceAll("`~", " ");
      getText[1] = getText[1].replaceAll("~`", "-");
      getText[1] = getText[1].replaceAll("~~~", ":");
      newcreatedElement.setAttribute("id", getData.annotation_id);

      let textCount = 20;
      console.log(getText[1].length);
      if (getText[1].length < 5) {
        textCount = 27;
      }
      else if (getText[1].length > 12) {
        textCount = 12;
      }

      if (Number(getData.initial_width) == 0) {
        let canvas12 = document.createElement("canvas");
        canvas12.style.width = "200px";
        let context = canvas12.getContext("2d");
        let fontSizeget = getText[1].length > 15 ? 9 : getText[1].length <= 6 ? 10 : 7;
        context.font = "14px times new roman";
        context.fillText(getText[1], 0, 0);
        let widthget = context.measureText(getText[1]).width;
        console.log(widthget);
        var formattedWidth = Math.ceil(widthget);
        formattedWidth = formattedWidth;

        canvas12.innerHTML = getText[1];
        canvas12.style.fontWeight = "500";
        canvas12.style.fontSize = "14px";
        var textWidth = formattedWidth;
        let currentAnnotationData = "move-0:10 line-20:10 line-20:5 controlpoint-20:0 curveEnd-25:0 line-" + Number(textWidth) + ":0 controlpoint-" + Number(textWidth + 5) + ":0 curveEnd-" + Number(textWidth + 5) + ":5 line-" + Number(textWidth + 5) + ":15 controlpoint-" + Number(textWidth + 5) + ":20 curveEnd-" + Number(textWidth) + ":20 line-25:20 controlpoint-20:20 curveEnd-20:15 line-20:10 text-" + getText[1] + "";
        let widththerom = "move-0:10 line-20:10 line-20:5 controlpoint-20:0 curveEnd-25:0 line-" + Number(textWidth) + ":0 controlpoint-" + Number(textWidth + 5) + ":0 curveEnd-" + Number(textWidth + 5) + ":5 line-" + Number(textWidth + 5) + ":15 controlpoint-" + Number(textWidth + 5) + ":20 curveEnd-" + Number(textWidth) + ":20 line-25:20 controlpoint-20:20 curveEnd-20:15 line-20:10";
        let x1Coordinate = [];
        let y1Coordinate = [];
        let cloneGetData = _.cloneDeep(getData);
        /* widththerom = widththerom.trim();
        let splitData123 = widththerom.split(" ");
        for (var im = 0; im < splitData123.length; im++) {
          console.log(splitData123[im]);
          let hypenSplit = splitData123[im].split("-");
          let colonSplit = hypenSplit[1].split(":");
          x1Coordinate.push(colonSplit[0]);
          y1Coordinate.push(colonSplit[1]);
        }
        let startx = Math.min.apply(null, x1Coordinate);
        let endx = Math.max.apply(null, x1Coordinate);
        let starty = Math.min.apply(null, y1Coordinate);
        let endy = Math.max.apply(null, y1Coordinate); */
        let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(cloneGetData);
        var textshapewidth = getShapeStringWidth.width;
        var textshapeheight = getShapeStringWidth.height;

        // getData.annotation_data = currentAnnotationData;
        console.log(textshapewidth, textshapeheight);
        console.log(currentAnnotationData);
        var newOne = textshapewidth + 25;
        let text_shape_height = 50;
        let numberOfLineBreaks = (getData.annotation_label.match(/\n/g) || []).length;
        if (numberOfLineBreaks > 0) {
          numberOfLineBreaks = numberOfLineBreaks + 1;
          text_shape_height = numberOfLineBreaks * 25;
        }
        else {
          text_shape_height = 50;
        }
        console.log(newOne);
        newcreatedElement.setAttribute("width", newOne.toString());
        newcreatedElement.setAttribute("height", ((Number(getData.line_width) / 2) + text_shape_height).toString());
        var textShapexyWidth = (newOne - textshapewidth) / 2;
        textShapexyWidth = textShapexyWidth < 0 ? -(textShapexyWidth) : textShapexyWidth;
        var textShapexyHeight = (text_shape_height - textshapeheight) / 2;
        textShapexyWidth = textShapexyWidth;
        console.log(textShapexyWidth, textShapexyHeight);
        let textshapetop = Number(this.coordinateY) - (newcreatedElement.height / 2);
        let textshapeleft = Number(this.coordinateX) - (newcreatedElement.width / 2);
        textshapetop = textshapetop < 0 ? 0 : textshapetop;
        textshapeleft = textshapeleft < 0 ? 0 : textshapeleft;
        let canvasRightSideCheck = newOne + textshapeleft;
        if (this.realWidth < canvasRightSideCheck) {
          var checkDifference = canvasRightSideCheck - this.realWidth;
          console.log(checkDifference);
          textshapeleft = textshapeleft - checkDifference;
          console.log(textshapeleft);
        }
        newcreatedElement.style.top = textshapetop + "px";
        newcreatedElement.style.left = textshapeleft + "px";
      }
      else if (Number(getData.initial_width) != 0) {
        let cloneGetData = _.cloneDeep(getData);
        cloneGetData.annotation_data = getText[0];
        let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(cloneGetData);
        var textWidth = Number(getData.initial_width);
        let textHeight = Number(getData.initial_height) + (Number(getData.line_width) / 6);

        var textshapewidth = getShapeStringWidth.width;
        var textshapeheight = getShapeStringWidth.height;

        var newOne = textshapewidth + 25;

        let text_shape_height = getShapeStringWidth.height;
        let numberOfLineBreaks = (getData.annotation_label.match(/\n/g) || []).length;
        if (numberOfLineBreaks > 0) {
          numberOfLineBreaks = numberOfLineBreaks + 1;
          text_shape_height = numberOfLineBreaks * 25;
        }
        else {
          text_shape_height = 50;
        }

        newcreatedElement.setAttribute("width", (textWidth).toString());
        newcreatedElement.setAttribute("height", (textHeight).toString());

        var textShapexyWidth = (newOne - textshapewidth) / 2;
        textShapexyWidth = textShapexyWidth < 0 ? -(textShapexyWidth) : textShapexyWidth;
        var textShapexyHeight = (text_shape_height - textshapeheight) / 2;
        textShapexyWidth = textShapexyWidth;

        /* let subtractX = this.dbxposition - 17.5 -  (linewidthCount/2);
        let subtractY = this.dbyposition - 17.5 - (linewidthCount/2); */
        let subtractX = this.dbxposition - 17.5 - (newcreatedElement.width / 2);
        let subtractY = this.dbyposition - 17.5 - (newcreatedElement.height / 2);
        subtractX = subtractX < 0 ? 0 : subtractX;
        subtractY = subtractY < 0 ? 0 : subtractY;
        let canvasRightSideCheck = newOne + subtractX;
        if (this.realWidth < canvasRightSideCheck) {
          var checkDifference = canvasRightSideCheck - this.realWidth;
          console.log(checkDifference);
          subtractX = subtractX - checkDifference;
          console.log(subtractX);
        }
        newcreatedElement.style.top = Number(subtractY) + "px";
        newcreatedElement.style.left = Number(subtractX) + "px";
      }
      //label view commend 15.09. because canvas fill text using canvas
      if (false) {
        var labelElement = document.createElement("p");
        // pdfImg.appendChild(labelElement);
        labelElement.setAttribute("annotationLabel", "1");
        labelElement.setAttribute("id", "label" + getData.annotation_id);
        labelElement.style.color = this.checkStrokeColor1(getData.stroke_color);
        let fontSizeget = getText[1].length > 15 ? 9 : getText[1].length <= 6 ? 10 : 7;
        var fontSizeBaseHeight = (shapeStringValueTemp.height / 2);
        labelElement.style.fontSize = fontSizeBaseHeight + 'px';
        labelElement.style.fontWeight = "500";
        labelElement.style.position = "absolute";
        labelElement.style.top = "0px";
        labelElement.style.left = "0px";
        labelElement.innerHTML = getData.annotation_label;
        labelElement.style.lineHeight = "1";
        labelElement.style.textAlign = "center";
        labelElement.style.pointerEvents = "none";
        labelElement.style.zIndex = "9";
        // labelElement.style.whiteSpace = "pre-wrap";
        // var numberOfLineBreaks = (getData.annotation_label.match(/\n/g) || []).length;
        // console.log(numberOfLineBreaks);
        // if (numberOfLineBreaks != 0) {
        //   labelElement.style.whiteSpace = "pre-wrap";
        // }
        console.log(getData.annotation_label);
        let measurement = (labelElement.clientHeight);
        let measurement1 = (labelElement.clientWidth);
        console.log(measurement, measurement1);
        if (Number(getData.initial_height) != 0 && Number(getData.initial_width) != 0) {

          let findDifferencex = newcreatedElement.width - measurement1;
          let findDifferencey = newcreatedElement.height - measurement;
          let subtractX = this.dbxposition - 17.5 - (linewidthCount / 2);
          let subtractY = this.dbyposition - 17.5 - (linewidthCount / 2);
          labelElement.style.top = Number(subtractY) + (findDifferencey / 2) + "px";
          labelElement.style.left = Number(subtractX) + (findDifferencex / 2) + "px";
        }
        else {
          labelElement.style.top = Number(this.coordinateY) - (measurement / 2) + "px";
          labelElement.style.left = Number(this.coordinateX) - (measurement1 / 2) + 8 + "px";
        }
        labelElement.style.wordBreak = "break-word";
        // if (getData.initial_rotation != undefined && getData.initial_rotation != 0) {
        //   
        //   let dx = getData.initial_rotation > 0 ? (labelElement.clientWidth / 2) : (-15);
        //   let dy = getData.initial_rotation > 0 ? (-15) : labelElement.clientHeight / 2;
        //   labelElement.style.transform = 'matrix(' + Math.cos(getData.initial_rotation) + ',' + Math.sin(getData.initial_rotation) + ',' + -(Math.sin(getData.initial_rotation)) + ',' + Math.cos(getData.initial_rotation) + ',' + 0 + ',' + 0 + ')';
        //   console.log('matrix(' + Math.cos(getData.initial_rotation), Math.sin(getData.initial_rotation), -(Math.sin(getData.initial_rotation)), Math.cos(getData.initial_rotation), dx, dy + ')');
        //   // console.log(this.canvasElement.getTransform());
        //   // this.canvasElement.restore();
        // }
      }

    }
    else {
      // if (this.multipleSelectOn == false) {
      //   //recent command color border remove like 01.07.2021
      //   if (getData.annotation_id == this.getId) {
      //     this.colorBorder(newcreatedElement);
      //   }
      // }
      console.log(getWidth, getHeight);
      var getStringWidth = this.shapeService1.getCanvaswidthandHeight(getData);
      newcreatedElement.setAttribute("id", getData.annotation_id);
      newcreatedElement.setAttribute("width", getWidth);
      newcreatedElement.setAttribute("height", getHeight);
      if (Number(getData.initial_height) != 0 && Number(getData.initial_width) != 0) {

        let subtractX = this.dbxposition - 17.5;
        let subtractY = this.dbyposition - 17.5;
        newcreatedElement.style.top = subtractY - ((Number(getData.line_width) / 6) * 2) + "px";
        newcreatedElement.style.left = subtractX - ((Number(getData.line_width) / 6) * 2) + "px";
        if (getData.annotation_label.trim() != "") {
          let topResizeSimple = subtractY - ((Number(getData.line_width) / 6) * 2);
          let leftResizeSimple = subtractX - ((Number(getData.line_width) / 6) * 2);
          this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, getWidth, getHeight);
        }
      }
      else {
        newcreatedElement.style.top = Number(this.coordinateY) + "px";
        newcreatedElement.style.left = Number(this.coordinateX) + "px";
        newcreatedElement.style.marginLeft = -getWidth / 2 + "px";
        newcreatedElement.style.marginTop = -getHeight / 2 + "px";
        let margin_values_left = -(getWidth / 2);
        let margin_values_top = -(getHeight / 2);
        if (getData.annotation_label.trim() != "") {
          let topResizeSimple = Number(this.coordinateY);
          let leftResizeSimple = Number(this.coordinateX);

          this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, getWidth, getHeight, false, 0, 0);
        }
      }
    }

    if (this.searchannotationIdsBackup.length > 0) {
      for (let z = 0; z < this.searchannotationIdsBackup.length; z++) {
        if (getData.annotation_id == this.searchannotationIdsBackup[z]) {
          this.colorBorderSVG(newcreatedElement);
        }
      }
    }
    // newcreatedElement.addEventListener("click", (e: any) => {
    //   this.canvasClick(e);
    // });
    newcreatedElement.addEventListener("contextmenu", (e: any) => {
      debugger
      this.canvasRightClick(e);
      console.log(e);
      
    });
    // if(getData.annotation_label.trim()!=""){
    //   this.shapeService1.mainDrawingLabel(getData,pdfImg,newcreatedElement.style.top,newcreatedElement.style.left);
    // }
    console.log(typeof newcreatedElement);
    pdfImg.appendChild(newcreatedElement);
    if (this.multipleSelectOn == true) {
      for (var n = 0; n < this.multiselectionList.length; n++) {
        if (getData.annotation_id == this.multiselectionList[n].annotation_id) {
          this.colorBorder(newcreatedElement);
        }
      }
    }
    else if (this.multipleSelectOn == false) {
      //recent command color border remove like 01.07.2021 multiselect when we deselect single annotation selection is there issue happend 
      // if (getData.annotation_id == this.getId) {
      //   this.colorBorder(newcreatedElement);
      // }
      // else if(getData.annotation_id == this.getId && this.rotateandresize==false){
      //  
      //   this.canvasClick(getData.annotation_id);
      // }
    }
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    // this.canvasBlurryRemove(newcreatedElement,this.canvasElement);
    if (elementId >= 1 && elementId <= 10 && (Number(getData.initial_width) < 35) && (Number(getData.initial_height) < 35) &&
      (Number(getData.initial_width) != 0) && (Number(getData.initial_height) != 0)) {

      let actualCanvasWH = this.shapeService1.getCanvaswidthandHeight(getData);
      let currentDBgetW = Number(getData.initial_width) //- (4.5 * 2);
      let currentDBgetH = Number(getData.initial_height) //- (4.5 * 2);
      let actualratio = actualCanvasWH.width / actualCanvasWH.height;
      let fixedratio = Number(currentDBgetW) / Number(currentDBgetH);
      var scaleFactor1 = 1;
      if (actualratio > fixedratio) {
        scaleFactor1 = Number(currentDBgetW) / actualCanvasWH.width;
      }
      else {
        scaleFactor1 = Number(currentDBgetH) / actualCanvasWH.height;
      }
      if (scaleFactor1 > 0) {
        // changed HUD project purpose scale 1;
        // before value scaleFactor1;
        scaleFactor1 = 1;
        this.canvasElement.setTransform(scaleFactor1, 0, 0, scaleFactor1, 0, 0);
      }
    } else if (elementId >= 12 && elementId <= 18 && Number(getData.initial_width) != 0 && Number(getData.initial_height) != 0) {

      let actualCanvasWH = this.shapeService1.getCanvaswidthandHeight(getData);
      let currentDBgetW = Number(getData.initial_width);
      let currentDBgetH = Number(getData.initial_height);
      let actualratio = actualCanvasWH.width / actualCanvasWH.height;
      let fixedratio = Number(currentDBgetW) / Number(currentDBgetH);
      var scaleFactor1 = 1;
      if (actualratio > fixedratio) {
        scaleFactor1 = Number(currentDBgetW) / actualCanvasWH.width;
      }
      else {
        scaleFactor1 = Number(currentDBgetH) / actualCanvasWH.height;
      }
      if (scaleFactor1 > 0) {
        this.canvasElement.setTransform(scaleFactor1, 0, 0, scaleFactor1, 0, 0);
      }
    }
    else if ((elementId == 19) && getData.annotation_data.includes('move') && Number(getData.initial_height) != 0) {

      let actualCanvasWH = this.shapeService1.getCanvaswidthandHeight(getData);
      let currentDBgetW = Number(getData.initial_width) + 17.5;
      let currentDBgetH = Number(getData.initial_height) + 17.5;
      let actualratio = actualCanvasWH.width / actualCanvasWH.height;
      let fixedratio = Number(currentDBgetW) / Number(currentDBgetH);
      var scaleFactor1 = 1;
      if (actualratio > fixedratio) {
        scaleFactor1 = Number(currentDBgetW) / actualCanvasWH.width;
      }
      else {
        scaleFactor1 = Number(currentDBgetH) / actualCanvasWH.height;
      }
      if (scaleFactor1 > 0) {
        this.canvasElement.setTransform(scaleFactor1, 0, 0, scaleFactor1, 0, 0);
      }
    }
    else if (elementId == 20 && getData.annotation_data.includes('move')) {
      let actualCanvasWH = this.shapeService1.getCanvaswidthandHeight(getData);
      let currentDBgetW = Number(getData.initial_width);
      let currentDBgetH = Number(getData.initial_height);
      let actualratio = (actualCanvasWH.width + 35) / (actualCanvasWH.height + 35);
      let fixedratio = Number(currentDBgetW) / Number(currentDBgetH);
      var scaleFactor1 = 1;
      if (actualratio > fixedratio) {
        scaleFactor1 = Number(currentDBgetW) / actualCanvasWH.width;
      }
      else {
        scaleFactor1 = Number(currentDBgetH) / actualCanvasWH.height;
      }
      if (scaleFactor1 > 0) {
        this.canvasElement.setTransform(scaleFactor1, 0, 0, scaleFactor1, 0, 0);
      }
    }
    else if (elementId == 11 && Number(getData.initial_height) == 0) {
      let actualCanvasWH = this.shapeService1.getCanvaswidthandHeight(getData);
      let currentDBgetW = newcreatedElement.width;
      let currentDBgetH = newcreatedElement.height;
      let actualratio = (actualCanvasWH.width) / (actualCanvasWH.height);
      let fixedratio = Number(currentDBgetW) / Number(currentDBgetH);
      var scaleFactor1 = 1;
      if (actualratio > fixedratio) {
        scaleFactor1 = Number(currentDBgetW) / (actualCanvasWH.width);
      }
      else {
        scaleFactor1 = Number(currentDBgetH) / actualCanvasWH.height;
      }
      if (scaleFactor1 > 0) {
        this.canvasElement.setTransform(scaleFactor1, 0, 0, scaleFactor1, 0, 0);
      }
    }
    else if (elementId == 11 && Number(getData.initial_height) != 0) {
      let actualCanvasWH = this.shapeService1.getCanvaswidthandHeight(getData);
      console.log(actualCanvasWH);

      let currentDBgetW = actualCanvasWH.width;
      let currentDBgetH = actualCanvasWH.height;
      let actualratio = (newcreatedElement.width) / (newcreatedElement.height);
      let fixedratio = Number(currentDBgetW) / Number(currentDBgetH);
      var scaleFactor1 = 1;
      if (actualratio > fixedratio) {
        scaleFactor1 = Number(currentDBgetW) / (actualCanvasWH.width);
      }
      else {
        scaleFactor1 = Number(currentDBgetH) / actualCanvasWH.height;
      }
      if (scaleFactor1 > 0) {
        this.canvasElement.setTransform(scaleFactor1, 0, 0, scaleFactor1, 0, 0);
      }
    }
    else if (elementId < 11 && Number(getData.initial_height) != 0 && Number(getData.initial_position_x) != 0) {
      let actualCanvasWH = this.shapeService1.getCanvaswidthandHeight(getData);
      let currentDBgetWJSON = Number(getData.initial_width);
      let currentDBgetHJSON = Number(getData.initial_height);
      let currentDBgetW = currentDBgetWJSON;
      let currentDBgetH = currentDBgetHJSON;
      if (currentDBgetWJSON != currentDBgetHJSON) {
        if (currentDBgetWJSON < currentDBgetHJSON) {
          currentDBgetW = currentDBgetHJSON;
          currentDBgetH = currentDBgetHJSON;
        }
        else {
          currentDBgetW = currentDBgetWJSON;
          currentDBgetH = currentDBgetWJSON;
        }
      }
      let actualratio = (actualCanvasWH.width) / (actualCanvasWH.height);
      //Jose modified this for resize
      // let fixedratio = Number(currentDBgetW) / Number(currentDBgetH);
      let fixedratio = Number(currentDBgetWJSON) / Number(currentDBgetHJSON);
      var scaleFactor1 = 1;
      if (actualCanvasWH.width != getData.initial_width && actualCanvasWH.height != getData.initial_height) {
        if (actualratio > fixedratio) {
          scaleFactor1 = Number(currentDBgetW) / (actualCanvasWH.width);
        }
        else {
          scaleFactor1 = Number(currentDBgetH) / (actualCanvasWH.height);
        }
        if (currentDBgetWJSON <= 50 || currentDBgetHJSON <= 50) {
          scaleFactor1 = scaleFactor1 == 1 ? 0.96 : scaleFactor1;
        } else {
          //for ipad resized shapes
          // scaleFactor1 = scaleFactor1 > 1 && scaleFactor1 < 1.1 ? 1 : scaleFactor1;
        }
      }
      if (scaleFactor1 > 0) {
        this.canvasElement.setTransform(scaleFactor1, 0, 0, scaleFactor1, 0, 0);
      }
    }
    // To Repoint the drawn shape inside the canvas center.
    // --------------
    console.log(getStringWidth);


    if (getStringWidth != undefined && getData.initial_height == 0) {
      let translateWidth = getStringWidth.width - newcreatedElement.width;
      let translateHeight = getStringWidth.height - newcreatedElement.height;
      let translateX = (translateWidth / 2) + getStringWidth.left;
      let translateY = (translateHeight / 2) + getStringWidth.top;
      this.canvasElement.translate(-translateX, -translateY);
      this.canvasElement.restore();
    } else if (getStringWidth != undefined && getData.toolbar_element_id < 12) {
      //Jose Added for resize fixed shapes
      let translateWidth = getStringWidth.width - newcreatedElement.width;
      let translateHeight = getStringWidth.height - newcreatedElement.height;
      let translateX = (translateWidth / 2) + getStringWidth.left;
      let translateY = (translateHeight / 2) + getStringWidth.top;
      let check_width_same = Math.round(getStringWidth.width);
      let check_height_same = Math.round(getStringWidth.height);
      let check_width_same_json = Math.round(getData.initial_width);
      let check_height_same_json = Math.round(getData.initial_height);
      console.log(getStringWidth.width, getData.initial_width);
      if (check_width_same != check_width_same_json || check_height_same != check_height_same_json) {
        let getnew_one = this.shapeService1.getCanvaswidthandHeight(getData);
        console.log(getData.annotation_data, getnew_one);
      }
      if (getStringWidth.left < 0 || getStringWidth.top < 0) {
        // translateX = getStringWidth.left < 0 ? getStringWidth.left : getStringWidth.top;
        // translateX = translateX < 0 ? translateX : (translateWidth / 2) + getStringWidth.left;
        // translateY = translateX < 0 ? translateX : (translateHeight / 2) + getStringWidth.top;
        // translateY = getStringWidth.top < 0 ? getStringWidth.top : (translateHeight/2);
        this.canvasElement.translate(-translateX, -translateY);
      }
      else if (check_width_same == check_width_same_json || check_height_same == check_height_same_json) {
        console.log('same Width');
      }
      else if (newcreatedElement.width > getStringWidth.width && newcreatedElement.height > getStringWidth.height) {
        translateX = (translateWidth / 2) - translateX;
        translateY = (translateHeight / 2) - translateY;
        //Jose added this below line for position
        // if (elementId < 11 && getStringWidth.height != getStringWidth.width) {
        //   if (translateX > translateY) {
        //     translateY = translateY - ((translateY / scaleFactor1) / 4) //- (getStringWidth.height/scaleFactor1)
        //   } else {
        //     if (elementId == 7) {
        //       translateX = translateX - ((translateX / scaleFactor1) / 2)// - (getStringWidth.width/scaleFactor1)
        //     } else {
        //       translateX = translateX - ((translateX / scaleFactor1) / 4)// - (getStringWidth.width/scaleFactor1)
        //     }

        //   }
        // }
        ///////
        //HUD project purpose changed value translate / 2 and negative ah change pannirkom translate ah
        // before value translate / 2 not be there and positive translate is there
        translateX = translateX / 2;
        translateY = translateY / 2;
        // translateX = (newcreatedElement.width - Number(getData.initial_width)) / 2;
        // translateY = (newcreatedElement.height - Number(getData.initial_height)) / 2;
        this.canvasElement.translate(translateX, translateY);
      }
      else if (getStringWidth.width < 40 && getStringWidth.height < 40) {
        translateX = translateWidth / 2;
        translateY = translateHeight / 2;
        if (translateX > 0 && translateY > 0) {
          this.canvasElement.translate(translateX, translateY);
        } else {
          // commented by ganesh 11.09.2021 change shape in setting page translate issues solved
          // this.canvasElement.translate(-translateX, -translateY);
        }
      }
      //  else if(elementId < 11 && (this.canvasElement.canvas.width - this.canvasElement.canvas.height) > 100){
      //   this.canvasElement.translate(-((getStringWidth.left-(getStringWidth.width/2))/2), -getStringWidth.top);
      // } else if(elementId < 11 && (this.canvasElement.canvas.height - this.canvasElement.canvas.width) > 100){
      //   this.canvasElement.translate(-getStringWidth.left, -((getStringWidth.top-(getStringWidth.height/2))/2));
      // }
      else {
        this.canvasElement.translate(-translateX, -translateY);
      }
      this.canvasElement.restore();
    }
    // else if (getStringWidth != undefined && getData.toolbar_element_id < 12 ) {
    //   //Jose Added for resize fixed shapes
    //   let translateWidth = getStringWidth.width - newcreatedElement.width;
    //   let translateHeight = getStringWidth.height - newcreatedElement.height;
    //   let translateX = (translateWidth / 2) + getStringWidth.left;
    //   let translateY = (translateHeight / 2) + getStringWidth.top;
    //   this.canvasElement.translate(-translateX, -translateY);
    //   this.canvasElement.restore();
    // }
    // if (elementId>=12&&getData.initial_position_x != 0&&getData.initial_position_y != 0) {
    //   let getDrawWidthandHeight = this.shapeService1.getCanvaswidthandHeight(getData); 
    //   let translateWidth = getDrawWidthandHeight.width - newcreatedElement.width;
    //   let translateHeight = getDrawWidthandHeight.height - newcreatedElement.height;
    //   let translateX = (translateWidth / 2) + getDrawWidthandHeight.left;
    //   let translateY = (translateHeight / 2) + getStringWidth.top;
    //   this.canvasElement.translate(-translateX, -translateY);
    //   this.canvasElement.restore();
    // }
    // ---------------

    //Rotate shape drawing setup start
    if (getData.initial_rotation != undefined && getData.initial_rotation != 0 && (elementId < 11 || elementId >= 19)) {
      let dx = getData.initial_rotation > 0 ? (getWidth / 2) : (-15);
      let dy = getData.initial_rotation > 0 ? (-15) : getHeight / 2;
      newcreatedElement.style.transform = 'matrix(' + Math.cos(getData.initial_rotation) + ',' + Math.sin(getData.initial_rotation) + ',' + -(Math.sin(getData.initial_rotation)) + ',' + Math.cos(getData.initial_rotation) + ',' + 0 + ',' + 0 + ')';
      console.log('matrix(' + Math.cos(getData.initial_rotation), Math.sin(getData.initial_rotation), -(Math.sin(getData.initial_rotation)), Math.cos(getData.initial_rotation), dx, dy + ')');
      // console.log(this.canvasElement.getTransform());
      // this.canvasElement.restore();
    }
    //Rotate shape drawing setup end

    // newcreatedElement = this.shapeService1.createHIDPIcanvs(getWidth,getHeight,7,newcreatedElement);
    // let ratio = 2;
    // newcreatedElement.width = newcreatedElement.clientWidth * ratio;
    // newcreatedElement.height = newcreatedElement.clientHeight * ratio;
    // this.canvasElement.scale(ratio,ratio);
    // newcreatedElement.style.width = getWidth + "px";
    // newcreatedElement.style.height = getHeight + "px";

    // newcreatedElement.width = getWidth * 2;
    // newcreatedElement.height = getHeight * 2; 
    if (elementId == 11) {

      if (Number(getData.initial_width) == 0) {
        newcreatedElement.setAttribute("width", (newOne + (Number(getData.line_width) / 6)).toString());
        let textshapetop = Number(this.coordinateY) - (newcreatedElement.height / 2);
        let textshapeleft = Number(this.coordinateX) - (newcreatedElement.width / 2);
        textshapetop = textshapetop < 0 ? 0 : textshapetop;
        textshapeleft = textshapeleft < 0 ? 0 : textshapeleft;
        let canvasRightSideCheck = newOne + textshapeleft;
        if (this.realWidth < canvasRightSideCheck) {
          var checkDifference = canvasRightSideCheck - this.realWidth;
          console.log(checkDifference);
          textshapeleft = textshapeleft - checkDifference;
          console.log(textshapeleft);
        }
        newcreatedElement.style.top = textshapetop + "px";
        newcreatedElement.style.left = textshapeleft + "px";
        textShapexyWidth = (newcreatedElement.width - textshapewidth) / 2;
        textShapexyWidth = textShapexyWidth < 0 ? -(textShapexyWidth) : textShapexyWidth;
        textShapexyHeight = (newcreatedElement.height - textshapeheight) / 2;
      }
      else if (Number(getData.initial_width) != 0) {
        var textWidth = Number(getData.initial_width) + (Number(getData.line_width) / 2);
        let textHeight = Number(getData.initial_height) + (Number(getData.line_width) / 2);
        newcreatedElement.setAttribute("width", (textWidth).toString());
        newcreatedElement.setAttribute("height", (textHeight).toString());
        /* let subtractX = this.dbxposition - 17.5 -  (linewidthCount/2);
        let subtractY = this.dbyposition - 17.5 - (linewidthCount/2); */
        let subtractX = this.dbxposition - 17.5 - ((Number(getData.line_width) / 2) / 2);
        let subtractY = this.dbyposition - 17.5 - ((Number(getData.line_width) / 2) / 2);
        subtractX = subtractX < 0 ? 0 : subtractX;
        subtractY = subtractY < 0 ? 0 : subtractY;
        let canvasRightSideCheck = newOne + subtractX;
        if (this.realWidth < canvasRightSideCheck) {
          var checkDifference = canvasRightSideCheck - this.realWidth;
          console.log(checkDifference);
          subtractX = subtractX - checkDifference;
          console.log(subtractX);
        }
        newcreatedElement.style.top = Number(subtractY) + "px";
        newcreatedElement.style.left = Number(subtractX) + "px";
        let subtractX1 = this.dbxposition - 35 - ((Number(getData.line_width) / 2) / 2);
        let subtractY1 = this.dbyposition - 35 - ((Number(getData.line_width) / 2) / 2);
        // let measurement = (labelElement.clientHeight);
        // let measurement1 = (labelElement.clientWidth);
        // let findDifferencex = newcreatedElement.width - measurement1;
        // let findDifferencey = newcreatedElement.height - measurement;
        // labelElement.style.top = Number(subtractY1) + (findDifferencey / 2) + "px";
        // labelElement.style.left = Number(subtractX1) + (findDifferencex / 2) + 12 + "px";

      }

      if (getData.initial_rotation != undefined && getData.initial_rotation != 0 && elementId < 12) {
        let dx = getData.initial_rotation > 0 ? (newcreatedElement.width / 2) : (-15);
        let dy = getData.initial_rotation > 0 ? (-15) : newcreatedElement.height / 2;
        newcreatedElement.style.transform = 'matrix(' + Math.cos(getData.initial_rotation) + ',' + Math.sin(getData.initial_rotation) + ',' + -(Math.sin(getData.initial_rotation)) + ',' + Math.cos(getData.initial_rotation) + ',' + 0 + ',' + 0 + ')';
        console.log('matrix(' + Math.cos(getData.initial_rotation), Math.sin(getData.initial_rotation), -(Math.sin(getData.initial_rotation)), Math.cos(getData.initial_rotation), dx, dy + ')');
        // console.log(this.canvasElement.getTransform());
        // this.canvasElement.restore();
      }
    }
    this.canvasElement.imageSmoothingQuality = "high";
    this.canvasElement.imageSmoothingEnabled = true;
    this.canvasElement.globalAlpha = getData.opacity;
    getData.annotation_data = getData.annotation_data.trim();
    var spaceSplit = getData.annotation_data.split(" ");

    var previous = { x: 0, y: 0 };
    var current = { x: 0, y: 0 };
    var a = 0;
    var last_mousex = this.coordinateX;
    var last_mousey = this.coordinateY;
    var mousex = 0;
    var mousey = 0;
    var cpx = 0;
    var cpy = 0;
    let cp1x = 0;
    let cp1y = 0;
    let cp2x = 0;
    let cp2y = 0;
    let cx = 0;
    let cy = 0;
    for (var i = 0; i < spaceSplit.length; i++) {
      var splitString = spaceSplit[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      var hypenSplit = splitString.split("-");
      for (var j = 0; j < hypenSplit.length; j++) {
        if (hypenSplit.length > 2) {
          let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
          hypenSplit = [hypenSplit[0], localString1];
        }
        if (hypenSplit != '') {
          var colonSplit = hypenSplit[j].replaceAll('n', '-').split(":");
          colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
          colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));
        }
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint" &&
          hypenSplit[0] != "drawRect" &&
          hypenSplit[0] != "controlpoint1" &&
          hypenSplit[0] != "controlpoint2" &&
          hypenSplit[0] != "endCurve"
        ) {
          //Ellipse negative value is coming convert positive from ipad
          var x = Math.round(parseFloat(colonSplit[0]));
          var y = Math.round(parseFloat(colonSplit[1]));
          var w = Math.round(parseFloat(colonSplit[2]));
          var h = Math.round(parseFloat(colonSplit[3]));

          switch (hypenSplit[0]) {
            case "move":
              if (
                getData.toolbar_element_id >= 12 && (Number(getData.initial_position_y) != 0 && Number(getData.initial_height) == 0) &&
                getData.toolbar_element_id <= 20 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16) {
                this.canvasElement.moveTo(
                  x - this.coordinateX + 10 + ((Number(getData.line_width) / 2) / 2),
                  y - this.coordinateY + 10 + ((Number(getData.line_width) / 2) / 2)
                );
              }
              else if (
                getData.toolbar_element_id >= 12 && Number(getData.initial_height) == 0 &&
                getData.toolbar_element_id <= 18 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16
              ) {
                //Freehand shapes except ellipse and rectangle
                this.canvasElement.moveTo(
                  x - this.coordinateX + 10 + (Number(getData.line_width) / 2),
                  y - this.coordinateY + 10 + (Number(getData.line_width) / 2)
                );
              }
              else if ((getData.toolbar_element_id == 19 || getData.toolbar_element_id == 20) && Number(getData.initial_height) == 0) {
                this.canvasElement.moveTo(
                  x - this.coordinateX + ((Number(getData.line_width) / 2)),
                  y - this.coordinateY + ((Number(getData.line_width) / 2))
                );
              }
              else if (
                getData.toolbar_element_id >= 12 && Number(getData.initial_height) != 0 &&
                getData.toolbar_element_id <= 20 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16) {
                this.canvasElement.moveTo(
                  x + ((Number(getData.line_width) / 2) / 2),
                  y + ((Number(getData.line_width) / 2) / 2)
                );
              }
              else if ((getData.toolbar_element_id == 15 || getData.toolbar_element_id == 16) && (Number(getData.initial_position_y) != 0)) {
                //Line and line axial shape
                this.canvasElement.moveTo(
                  x - this.coordinateX + 10 + ((Number(getData.line_width) / 2) / 2),
                  y - this.coordinateY + 10 + ((Number(getData.line_width) / 2) / 2)
                );
              }
              else if (getData.toolbar_element_id == 15 || getData.toolbar_element_id == 16) {
                //Line and line axial shape
                this.canvasElement.moveTo(
                  x - this.coordinateX + 10 + (Number(getData.line_width) / 2),
                  y - this.coordinateY + 10 + (Number(getData.line_width) / 2)
                );
              }
              else {
                //Simple shapes initial
                if (elementId == 11) {
                  if (Number(getData.initial_height) != 0 && Number(getData.initial_width) != 0) {
                    this.canvasElement.moveTo(x + ((linewidthCount / 2)), y + ((linewidthCount / 2)));
                  }
                  else {
                    this.canvasElement.moveTo(x + textShapexyWidth, y + textShapexyHeight);
                  }
                }
                else {
                  this.canvasElement.moveTo(x, y);
                }
              }
              if (elementId == 13 && j == 1) {
                previous.x = x - this.coordinateX + 10;
                previous.y = y - this.coordinateY + 10;
                a++;
              }
              break;
            case "line":
              this.canvasElement.clearRect(
                0,
                0,
                newcreatedElement.width,
                newcreatedElement.height
              );
              if (
                getData.toolbar_element_id >= 12 && (Number(getData.initial_position_y) != 0 && Number(getData.initial_height) == 0) &&
                getData.toolbar_element_id <= 20 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16) {
                this.canvasElement.lineTo(
                  x - this.coordinateX + 10 + ((Number(getData.line_width) / 2) / 2),
                  y - this.coordinateY + 10 + ((Number(getData.line_width) / 2) / 2)
                );
              }
              else if (
                getData.toolbar_element_id >= 12 && Number(getData.initial_height) == 0 &&
                getData.toolbar_element_id <= 18 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16
              ) {
                this.canvasElement.lineTo(
                  x - this.coordinateX + 10 + (Number(getData.line_width) / 2),
                  y - this.coordinateY + 10 + (Number(getData.line_width) / 2)
                );
              }
              else if ((getData.toolbar_element_id == 19 || getData.toolbar_element_id == 20) && Number(getData.initial_height) == 0) {
                this.canvasElement.lineTo(
                  x - this.coordinateX + ((Number(getData.line_width) / 2)),
                  y - this.coordinateY + ((Number(getData.line_width) / 2))
                );
              }
              else if (
                getData.toolbar_element_id >= 12 && Number(getData.initial_height) != 0 &&
                getData.toolbar_element_id <= 20 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16) {
                this.canvasElement.lineTo(
                  x + ((Number(getData.line_width) / 2) / 2),
                  y + ((Number(getData.line_width) / 2) / 2)
                );
              }
              else if ((getData.toolbar_element_id == 15 || getData.toolbar_element_id == 16) && (Number(getData.initial_position_y) != 0)) {
                //Line and line axial shape
                this.canvasElement.lineTo(
                  x - this.coordinateX + 10 + ((Number(getData.line_width) / 2) / 2),
                  y - this.coordinateY + 10 + ((Number(getData.line_width) / 2) / 2)
                );
              }
              else if (getData.toolbar_element_id == 15 || getData.toolbar_element_id == 16) {
                //Line and line axial shape
                this.canvasElement.lineTo(
                  x - this.coordinateX + 10 + (Number(getData.line_width) / 2),
                  y - this.coordinateY + 10 + (Number(getData.line_width) / 2)
                );
              }
              else {
                if (elementId == 11) {
                  if (Number(getData.initial_height) != 0 && Number(getData.initial_width) != 0) {
                    if (i == 1) {
                      var x_value_text = x;
                    }
                    this.canvasElement.lineTo(x + ((linewidthCount / 2)), y + ((linewidthCount / 2)));
                  }
                  else {
                    if (i == 1) {
                      var x_value_text = x;
                    }
                    this.canvasElement.lineTo(x + textShapexyWidth, y + textShapexyHeight);
                  }
                }
                else {
                  this.canvasElement.lineTo(x, y);
                }
              }
              break;
            case "ovalIn":
              if (elementId == 1 || elementId == 8) {
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.arc(
                  newcreatedElement.clientWidth / 2,
                  newcreatedElement.clientHeight / 2.3, r, 0, 2 * Math.PI
                );
              } else if (elementId == 19) {
                w = w < 0 ? -(w) : w;
                h = h < 0 ? -(h) : h;
                w = w;
                h = h;
                console.log(w, h);
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.ellipse((w / 2) + 2 + ((Number(getData.line_width) / 2) / 2), (h / 2) + 2 + ((Number(getData.line_width) / 2) / 2), w / 2, h / 2, Math.PI * 1, 0, 2 * Math.PI);
              }
              break;
          }
        }
        else if ((hypenSplit[0] == "controlpoint" || hypenSplit[0] == "curveEnd") && j == 1) {
          if (hypenSplit[0] == "controlpoint") {
            cpx = parseFloat(colonSplit[0]);
            cpy = parseFloat(colonSplit[1]);
          }
          if (hypenSplit[0] == "curveEnd") {
            var ex = parseFloat(colonSplit[0]);
            var ey = parseFloat(colonSplit[1]);
            if (elementId == 11) {
              if (Number(getData.initial_height) != 0 && Number(getData.initial_width) != 0) {
                this.canvasElement.quadraticCurveTo(cpx + ((linewidthCount / 2)), cpy + ((linewidthCount / 2)), ex + ((linewidthCount / 2)), ey + ((linewidthCount / 2)));
              }
              else {
                this.canvasElement.quadraticCurveTo(cpx + textShapexyWidth, cpy + textShapexyHeight, ex + textShapexyWidth, ey + textShapexyHeight);
              }
            }
            else {
              this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
            }
          }
        }
        else if ((hypenSplit[0] == "controlpoint1" || hypenSplit[0] == "controlpoint2" || hypenSplit[0] == "endCurve") && j == 1) {
          if (hypenSplit[0] == "controlpoint1") {
            cp1x = parseFloat(colonSplit[0]);
            cp1y = parseFloat(colonSplit[1]);
          }
          else if (hypenSplit[0] == "controlpoint2") {
            cp2x = parseFloat(colonSplit[0]);
            cp2y = parseFloat(colonSplit[1]);
          }
          else if (hypenSplit[0] == "endCurve") {
            cx = parseFloat(colonSplit[0]);
            cy = parseFloat(colonSplit[1]);
            // this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);
            if (getData.toolbar_element_id >= 12 && Number(getData.initial_height) != 0 && getData.toolbar_element_id <= 20 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16) {
              this.canvasElement.bezierCurveTo(cp1x + ((Number(getData.line_width) / 2) / 2), cp1y + ((Number(getData.line_width) / 2) / 2), cp2x + ((Number(getData.line_width) / 2) / 2), cp2y + ((Number(getData.line_width) / 2) / 2), cx + ((Number(getData.line_width) / 2) / 2), cy + ((Number(getData.line_width) / 2) / 2));
            }
            else if ((getData.toolbar_element_id == 19 || getData.toolbar_element_id == 20) && Number(getData.initial_height) == 0) {
              this.canvasElement.bezierCurveTo(cp1x - this.coordinateX + ((Number(getData.line_width) / 2)), cp1y - this.coordinateY + ((Number(getData.line_width) / 2)), cp2x - this.coordinateX + ((Number(getData.line_width) / 2)), cp2y - this.coordinateY + ((Number(getData.line_width) / 2)), cx - this.coordinateX + ((Number(getData.line_width) / 2)), cy - this.coordinateY + ((Number(getData.line_width) / 2)));
            }
            else {
              console.log(cp1x, cp1y, cp2x, cp2y, cx, cy);
              cp1x = Math.round(parseFloat(cp1x.toString()));
              cp1y = Math.round(parseFloat(cp1y.toString()));
              cp2x = Math.round(parseFloat(cp2x.toString()));
              cp2y = Math.round(parseFloat(cp2y.toString()));
              cx = Math.round(parseFloat(cx.toString()));
              cy = Math.round(parseFloat(cy.toString()));
              this.canvasElement.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, cx, cy);
            }
          }
        }
        else if (hypenSplit[0] == "drawRect" && j == 1) {
          // let colonSplit = hypenSplit[j].split(":");
          colonSplit[0] = Number(colonSplit[0]);
          colonSplit[1] = Number(colonSplit[1]);
          colonSplit[2] = Number(colonSplit[2]);
          colonSplit[3] = Number(colonSplit[3]);
          colonSplit[0] = colonSplit[0] < 0 ? -(colonSplit[0]) : colonSplit[0];
          colonSplit[1] = colonSplit[1] < 0 ? -(colonSplit[1]) : colonSplit[1];
          colonSplit[2] = colonSplit[2] < 0 ? -(colonSplit[2]) : colonSplit[2];
          colonSplit[3] = colonSplit[3] < 0 ? -(colonSplit[3]) : colonSplit[3];
          let rectX = parseFloat(colonSplit[0]);
          let rectY = parseFloat(colonSplit[1]);
          let rectWidth = parseFloat(colonSplit[2]);
          let rectHeight = parseFloat(colonSplit[3]);
          console.log(rectWidth, rectHeight);
          this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);
          let rectlineWidth = this.globalLineWidth(getData.line_width);
          let convertMinuspointX = shapeStringValueTemp.width < 0 ? -(shapeStringValueTemp.width) : shapeStringValueTemp.width;
          let convertMinuspointY = shapeStringValueTemp.height < 0 ? -(shapeStringValueTemp.height) : shapeStringValueTemp.height;
          let getLeftPosistion = (newcreatedElement.width - convertMinuspointX) / 2;
          let getTopPosistion = (newcreatedElement.height - convertMinuspointY) / 2;
          // newcreatedElement.style.left =  
          console.log(getLeftPosistion, getTopPosistion, rectWidth, rectHeight);
          this.canvasElement.rect(getLeftPosistion, getTopPosistion, rectWidth, rectHeight);
        }
      }
    }
    if (
      elementId != 12 &&
      elementId != 14 &&
      elementId != 13 &&
      elementId != 15
    ) {
      var checkFill = getData.fill_color;
      this.canvasElement.fillStyle = this.checkStrokeColor1(checkFill);
      this.canvasElement.fill();
    }
    if (elementId == 17 || elementId == 18 || elementId == 1) {
      console.log(elementId);
      this.canvasElement.closePath();
    }
    // this.canvasElement.drawImage(newcreatedElement,0,0,50,50,0,0,10,50);
    // latest
    // if (getData.line_width / 5 < 1) {
    //   this.canvasElement.lineWidth = 1;
    // }
    // else {
    //   this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width);
    // }
    // if ((elementId == 15 || elementId == 16 || elementId == 12 || elementId == 13 || elementId == 14) && getData.line_width != 0) {
    //   this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width) + 1;
    // }
    if (elementId <= 11) {
      this.canvasElement.lineWidth = Math.round(Number(getData.line_width) / (6));
    }
    else if (elementId > 11) {
      this.canvasElement.lineWidth = Number(getData.line_width) / (2);
    }
    // if ((elementId >= 12 && elementId <= 16) || getData.stroke_color.toLowerCase() != getData.fill_color.toLowerCase()) {
    //   this.canvasElement.strokeStyle = this.checkStrokeColor1(getData.stroke_color);
    //   this.canvasElement.stroke();
    // }
    this.canvasElement.strokeStyle = this.checkStrokeColor1(getData.stroke_color);
    this.canvasElement.stroke();
    newcreatedElement.style.overflow = "visible";
    newcreatedElement.style.display = "block";
    if (elementId == 11) {
      // newcreatedElement.appendChild(labelElement);
      // labelElement.style.top = '0px';
      // labelElement.style.left = '0px';
      console.log(x_value_text);
      // check width difference between canvas and inside shape string = check_different
      let check_different = 0;
      let get_min_width = newcreatedElement.width;

      if (shapeStringValueTemp.width >= newcreatedElement.width) {
        get_min_width = newcreatedElement.width;
        check_different = shapeStringValueTemp.width - newcreatedElement.width;
      }
      else {
        get_min_width = shapeStringValueTemp.width;
        check_different = newcreatedElement.width - shapeStringValueTemp.width;
      }

      let numberOfLineBreaks = (getData.annotation_label.match(/\n/g) || []).length;
      console.log(numberOfLineBreaks);
      let fontSizeBaseHeight = (shapeStringValueTemp.height / numberOfLineBreaks);
      if (numberOfLineBreaks > 0) {
        numberOfLineBreaks = numberOfLineBreaks + 1;
        let check = getText[1].split('\n');
        let check_larger_value = 0;
        for (let check_larger = 0; check_larger < check.length; check_larger++) {
          if (check_larger_value < check[check_larger].length) {
            check_larger_value = check[check_larger].length;
          }
        }
        // fontSizeBaseHeight = (shapeStringValueTemp.height / numberOfLineBreaks);
        // check width difference between canvas and inside shape string 


        if (Number(getData.initial_width) != 0) {
          formattedWidth = Number(get_min_width) - (x_value_text);
        }
        else {
          formattedWidth = Number(get_min_width) - (x_value_text);
        }
        console.log(getText[1].length, (formattedWidth / check_larger_value));
        fontSizeBaseHeight = Math.round(formattedWidth / check_larger_value) * 2;
        fontSizeBaseHeight = fontSizeBaseHeight - 1.5;
        if (fontSizeBaseHeight < 8) {
          fontSizeBaseHeight = 12;
        }
      }
      else {
        formattedWidth = Number(get_min_width) - (x_value_text) - (check_different / 2);
        // fontSizeBaseHeight = (shapeStringValueTemp.height / 2);
        fontSizeBaseHeight = Math.round(formattedWidth / getText[1].length) * 2;
        fontSizeBaseHeight = fontSizeBaseHeight;
        if (getData.annotation_label.length == 1) {
          fontSizeBaseHeight = 12;
        }
      }

      this.canvasElement.font = '500 ' + fontSizeBaseHeight + 'px Roboto, "Helvetica Neue", sans-serif';
      this.canvasElement.textAlign = 'left';
      this.canvasElement.textBaseline = 'top';
      this.canvasElement.fillStyle = this.checkStrokeColor1(getData.stroke_color);
      let getStringSplit = getData.annotation_data.split(' ');
      let secondLineget = getStringSplit[1].split('-');
      let colonsplitsecond = secondLineget[1].split(':');
      let ypositionCalc = -5;
      let xpositionCalc = x_value_text + (check_different / 2) + 1;
      if (numberOfLineBreaks > 0) {
        // check height difference between canvas and inside shape string
        let get_large_height = newcreatedElement.height;
        if (shapeStringValueTemp.height <= newcreatedElement.height) {
          get_large_height = newcreatedElement.height;
        }
        else {
          get_large_height = shapeStringValueTemp.height;
        }
        //y position normal resize text shapes
        let ypositionCalc = (get_large_height) - (numberOfLineBreaks * fontSizeBaseHeight);
        ypositionCalc = (ypositionCalc / 2);
        console.log(ypositionCalc);
        var words = getData.annotation_label.split('\n');
        var line = '';
        let lineHeight = fontSizeBaseHeight;
        console.log(words);
        for (var n = 0; n < words.length; n++) {
          this.canvasElement.fillText(words[n] + '', xpositionCalc, ypositionCalc);
          ypositionCalc += lineHeight;
        }
        // this.canvasElement.fillText(line, xpositionCalc + 4, ypositionCalc);
      }
      else {
        let get_large_height = newcreatedElement.height;
        let check_height_difference_normal = 0;
        if (shapeStringValueTemp.height <= newcreatedElement.height) {
          get_large_height = newcreatedElement.height;
          check_height_difference_normal = newcreatedElement.height - shapeStringValueTemp.height;
        }
        else {
          get_large_height = shapeStringValueTemp.height;
          check_height_difference_normal = shapeStringValueTemp.height - newcreatedElement.height;
        }
        //y position normal text shapes
        ypositionCalc = (get_large_height) - (1 * fontSizeBaseHeight) - (check_height_difference_normal / 2) - 2;
        if (getData.initial_width > 0 && getData.initial_height > 0) {
          ypositionCalc = (newcreatedElement.height - fontSizeBaseHeight) / 2;
        }
        this.canvasElement.fillText(getData.annotation_label, xpositionCalc, ypositionCalc);
      }

    }

    // this.canvasElement.lineCap = "square";
    // this.canvasElement.lineJoin = "miter";
    // if (elementId >= 12 && elementId <= 18 && getData.initial_height != 0 && getData.initial_width != 0) {
    //   newcreatedElement.style.top = Number(this.coordinateY) - (35 / 2) - ((Number(getData.line_width)/2)/2) + 'px';
    //   newcreatedElement.style.left = Number(this.coordinateX) - (35 / 2) - ((Number(getData.line_width)/2)/2) + 'px';
    // }
    // let getimagedata = this.canvasElement.getImageData(0,0,newcreatedElement.width,newcreatedElement.height);
    // console.log(getimagedata)
    // let imagedata = getimagedata.data;
    // for (var i = 0; i < imagedata.length; i+= 4) {
    //   imagedata[i] = imagedata[i] ^ 255; // Invert Red
    //   imagedata[i+1] = imagedata[i+1] ^ 255; // Invert Green
    //   imagedata[i+2] = imagedata[i+2] ^ 255; // Invert Blue
    // }
    // this.canvasElement.putImageData(getimagedata,0,0);
  }

  getshapeDrawingP2P3(getDataP2P3) {
    let getData = _.cloneDeep(getDataP2P3);
    getData.initial_position_x = getData.initial_position_x < 0 ? -(Number(getData.initial_position_x)) : Number(getData.initial_position_x);
    getData.initial_position_y = getData.initial_position_y < 0 ? -(Number(getData.initial_position_y)) : Number(getData.initial_position_y);
    var elementId = Number(getData.toolbar_element_id);
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("documentSVG", "1");
    newcreatedElement.className = 'annot_canvas';
    getData.initial_height = Number(getData.initial_height);
    getData.initial_width = Number(getData.initial_width);
    var getHeight;
    var getWidth;
    let linewidthCount = 0;
    if (elementId > 11) {
      linewidthCount = Math.round(Number(getData.line_width) / 2);
    }
    else {
      linewidthCount = Math.round(Number(getData.line_width) / 6);
    }
    var shapeStringValueTemp = this.shapeService1.getCanvaswidthandHeight(getData);
    getWidth = shapeStringValueTemp.width + 10;
    getHeight = shapeStringValueTemp.height + 10;
    newcreatedElement.style.position = "absolute";
    this.transparentBorder(newcreatedElement);
    newcreatedElement.style.zIndex = "1";

    if (true) {
      if (this.multipleSelectOn == false) {
        if (getData.annotation_id == this.getId) {
          this.colorBorder(newcreatedElement);
        }
      }
      var getStringWidth = this.shapeService1.getCanvaswidthandHeight(getData);
      newcreatedElement.setAttribute("id", getData.annotation_id);
      newcreatedElement.setAttribute("width", getWidth);
      newcreatedElement.setAttribute("height", getHeight);
      var getStringWidth = this.shapeService1.getCanvaswidthandHeight(getData);
      newcreatedElement.style.top = Number(this.coordinateY) - 5 + "px";
      newcreatedElement.style.left = Number(this.coordinateX) - 5 + "px";
      // if (getData.annotation_label.trim() != "") {
      //   let topResizeSimple = Number(this.coordinateY);
      //   let leftResizeSimple = Number(this.coordinateX);
      //   this.shapeService1.mainDrawingLabel(getData, pdfImg, leftResizeSimple, topResizeSimple, getWidth, getHeight);
      // }
    }
    if (this.multipleSelectOn == true) {
      for (var n = 0; n < this.multiselectionList.length; n++) {
        if (getData.annotation_id == this.multiselectionList[n].annotation_id) {
          this.colorBorder(newcreatedElement);
        }
      }
    }
    if (this.searchannotationIdsBackup.length > 0) {
      for (let z = 0; z < this.searchannotationIdsBackup.length; z++) {
        if (getData.annotation_id == this.searchannotationIdsBackup[z]) {
          this.colorBorder(newcreatedElement);
        }
      }
    }
    newcreatedElement.addEventListener("click", (e: any) => {
      this.canvasClick(e);
    });
    newcreatedElement.addEventListener("contextmenu", (e: any) => {
         debugger
      this.canvasRightClick(e);
    });
    // if(getData.annotation_label.trim()!=""){
    //   this.shapeService1.mainDrawingLabel(getData,pdfImg,newcreatedElement.style.top,newcreatedElement.style.left);
    // }

    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    this.canvasElement.globalAlpha = getData.opacity;
    // this.canvasBlurryRemove(newcreatedElement,this.canvasElement);

    if (getStringWidth != undefined) {
      let translateWidth = getStringWidth.width - newcreatedElement.width;
      let translateHeight = getStringWidth.height - newcreatedElement.height;
      let translateX = (translateWidth / 2) + getStringWidth.left;
      let translateY = (translateHeight / 2) + getStringWidth.top;
      let shapeLeft = translateX;
      let shapeTop = translateY;
      newcreatedElement.style.top = shapeTop + "px";
      newcreatedElement.style.left = shapeLeft + "px";

      this.canvasElement.translate(-translateX - 0.5, -translateY - 0.8);
      this.canvasElement.restore();
      if (getData.annotation_label.trim() != "") {
        this.shapeService1.mainDrawingLabel(getData, pdfImg, shapeLeft, shapeTop, getWidth, getHeight, true);
      }
    }

    getData.annotation_data = getData.annotation_data.trim();
    var spaceSplit = getData.annotation_data.split(" ");

    var previous = { x: 0, y: 0 };
    var current = { x: 0, y: 0 };
    var a = 0;
    var last_mousex = this.coordinateX;
    var last_mousey = this.coordinateY;
    var mousex = 0;
    var mousey = 0;
    var cpx = 0;
    var cpy = 0;
    let cp1x = 0;
    let cp1y = 0;
    let cp2x = 0;
    let cp2y = 0;
    let cx = 0;
    let cy = 0;
    let xposition = Number(this.coordinateX);
    let yposition = Number(this.coordinateY);

    for (var i = 0; i < spaceSplit.length; i++) {
      var splitString = spaceSplit[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      var hypenSplit = splitString.split("-");
      for (var j = 0; j < hypenSplit.length; j++) {
        var colonSplit = hypenSplit[j].replaceAll('n', '-').split(":");
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint" &&
          hypenSplit[0] != "drawRect" &&
          hypenSplit[0] != "controlpoint1" &&
          hypenSplit[0] != "controlpoint2" &&
          hypenSplit[0] != "endCurve"
        ) {
          //Ellipse negative value is coming convert positive from ipad
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var w = parseFloat(colonSplit[2]);
          var h = parseFloat(colonSplit[3]);

          switch (hypenSplit[0]) {
            case "move":
              let actmovex = x;
              let actmovey = y;
              // actmovex = actmovex < 0 ? -(actmovex) : actmovex;
              // actmovey = actmovey < 0 ? -(actmovey) : actmovey;
              this.canvasElement.moveTo(actmovex, actmovey);
              break;
            case "line":
              let actlinex = x;
              let actliney = y;
              // actlinex = actlinex < 0 ? -(actlinex) : actlinex;
              // actliney = actliney < 0 ? -(actliney) : actliney;
              this.canvasElement.lineTo(actlinex, actliney);
              break;
            case "ovalIn":
              if (elementId == 1 || elementId == 8) {
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.arc(
                  newcreatedElement.clientWidth / 2,
                  newcreatedElement.clientHeight / 2.3, r, 0, 2 * Math.PI
                );
              } else if (elementId == 19) {
                w = w < 0 ? -(w) : w;
                h = h < 0 ? -(h) : h;
                w = w;
                h = h;
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.ellipse((w / 2) + 2 + ((Number(getData.line_width) / 2) / 2), (h / 2) + 2 + ((Number(getData.line_width) / 2) / 2), w / 2, h / 2, Math.PI * 1, 0, 2 * Math.PI);
              }
              break;
          }
        }
        else if ((hypenSplit[0] == "controlpoint" || hypenSplit[0] == "curveEnd") && j == 1) {
          if (hypenSplit[0] == "controlpoint") {
            cpx = parseFloat(colonSplit[0]);
            cpy = parseFloat(colonSplit[1]);
          }
          if (hypenSplit[0] == "curveEnd") {
            var ex = parseFloat(colonSplit[0]);
            var ey = parseFloat(colonSplit[1]);
            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
          }
        }
        else if ((hypenSplit[0] == "controlpoint1" || hypenSplit[0] == "controlpoint2" || hypenSplit[0] == "endCurve") && j == 1) {
          if (hypenSplit[0] == "controlpoint1") {
            cp1x = parseFloat(colonSplit[0]);
            cp1y = parseFloat(colonSplit[1]);
          }
          else if (hypenSplit[0] == "controlpoint2") {
            cp2x = parseFloat(colonSplit[0]);
            cp2y = parseFloat(colonSplit[1]);
          }
          else if (hypenSplit[0] == "endCurve") {
            cx = parseFloat(colonSplit[0]);
            cy = parseFloat(colonSplit[1]);
            let cp1linex = cp1x;
            let cp1liney = cp1y;
            let cp2linex = cp2x;
            let cp2liney = cp2y;
            let cxlinex = cx;
            let cxliney = cy;
            // cp1linex = cp1linex < 0 ? -(cp1linex) : cp1linex;
            // cp1liney = cp1liney < 0 ? -(cp1liney) : cp1liney;
            // cp2linex = cp2linex < 0 ? -(cp2linex) : cp2linex;
            // cp2liney = cp2liney < 0 ? -(cp2liney) : cp2liney;
            // cxlinex = cxlinex < 0 ? -(cxlinex) : cxlinex;
            // cxliney = cxliney < 0 ? -(cxliney) : cxliney;
            this.canvasElement.bezierCurveTo(cp1linex, cp1liney, cp2linex, cp2liney, cxlinex, cxliney);
          }
        }
        else if (hypenSplit[0] == "drawRect" && j == 1) {
          // let colonSplit = hypenSplit[j].split(":");
          colonSplit[0] = Number(colonSplit[0]);
          colonSplit[1] = Number(colonSplit[1]);
          colonSplit[2] = Number(colonSplit[2]);
          colonSplit[3] = Number(colonSplit[3]);
          colonSplit[2] = colonSplit[2] < 0 ? -(colonSplit[2]) : colonSplit[2];
          colonSplit[3] = colonSplit[3] < 0 ? -(colonSplit[3]) : colonSplit[3];
          let rectX = parseFloat(colonSplit[0]);
          let rectY = parseFloat(colonSplit[1]);
          let rectWidth = parseFloat(colonSplit[2]);
          let rectHeight = parseFloat(colonSplit[3]);
          console.log(rectWidth, rectHeight);
          this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);
          let rectlineWidth = this.globalLineWidth(getData.line_width);
          // newcreatedElement.setAttribute('width',(newcreatedElement.width + rectlineWidth).toString());
          // newcreatedElement.setAttribute('height',(newcreatedElement.height + rectlineWidth).toString());
          // newcreatedElement.style.top = this.coordinateY - (rectlineWidth/2) + 'px';
          // newcreatedElement.style.left = this.coordinateX - (rectlineWidth/2) + 'px';
          this.canvasElement.rect(
            ((Number(getData.line_width) / 2) / 2) + 1,
            ((Number(getData.line_width) / 2) / 2) + 1,
            rectWidth,
            rectHeight);
        }
      }
    }
    if (
      elementId != 12 &&
      elementId != 14 &&
      elementId != 13 &&
      elementId != 15
    ) {
      var checkFill = getData.fill_color;
      this.canvasElement.fillStyle = this.checkStrokeColor1(checkFill);
      this.canvasElement.fill();
    }
    if (elementId == 17 || elementId == 18) {
      console.log(elementId);
      this.canvasElement.closePath();
    }

    if (elementId <= 11) {
      this.canvasElement.lineWidth = Math.round(Number(getData.line_width) / (6));
    }
    else if (elementId > 11) {
      this.canvasElement.lineWidth = Number(getData.line_width) / (2);
    }
    this.canvasElement.strokeStyle = this.checkStrokeColor1(getData.stroke_color);
    this.canvasElement.stroke();
    if (getData.annotation_id == "1-DC078F91-83FA-43D0-93A9-8B90E1C2F966-16267884284981") {

      newcreatedElement.style.background = "red";
    }
  }

  //Database Shapes drawing method End
  canvasRightClick(e:any , id?: string) {
    debugger
    // e.preventDefault();
    e.preventDefault();
    console.log(e);
    
    console.log(this.createDocumentStore.single_select_annotation)
    this.formContentleft = [];  
    this.formContentright = [];
    this.useCaseEmptycellIds = []
    console.log('right click');
    if(this.alignAnnEnabled == true || this.grpAnntsEnbled == true){
      return
    }
    // this.automatic_update_form();
    //select1 boolean is added in order to prevent from continuous right click events from user.
    if (this.multiclickdisabled == false && this.toolbarSet == false) {
      let annot_id = "";
      let anot_layr_id = "";
      let anot_page_id = "";
      if (typeof e == 'object') {
        e.stopPropagation();
        annot_id = id;
      }
      else {
        annot_id = e;
      }
      if(this.alignAnnBaseAnn != undefined && this.alignAnnBaseAnn.annotation_id == annot_id){
        this.show = false;
         return
      }
      this.show = true;
      this.multiclickdisabled = true;
      let is_locked_flag_value;
      for (let i = 0; i < this.layerDatas.length; i++) {
        let annotations = this.layerDatas[i]["annotations"].filter(annotation => annotation.annotation_id == annot_id)
        if (annotations.length > 0) {
          let associated_pages = this.layerDatas[i].associated_pages;
          let page_element = associated_pages.filter(ele => ele.page_id == this.currentPageId);
          // this.activeLayerIdDraw = page_element[0].layer_id;
          is_locked_flag_value = page_element.length > 0 ? page_element[0].is_lock : "false";
          // mapping new changes for the getannotation api
          anot_layr_id = annotations[0].layer_id;
          anot_page_id = annotations[0].page_id;
          break;
        }
      }
      console.log(is_locked_flag_value)
      if (is_locked_flag_value == "true" || is_locked_flag_value == true || is_locked_flag_value == "1") {
        
        this.show=false
        this.multiclickdisabled = false;
        return;
      }
      console.log(is_locked_flag_value);
      // this.getId = $(e.target).attr("id");
      this.getId = annot_id;
      const annot_detail = { annot_id: this.getId, layer_id: anot_layr_id, page_id: anot_page_id }
      debugger
      this.canvasRightClickBox(e,annot_detail);
    }
  }

  canvasRightClickBox(e ,get_annot_input) {
    debugger
    e.preventDefault()

    if (this.userrole == 'view' || this.isReadonly == true) {
      this.multiclickdisabled = true;
      this.show = false;
      return;
    }
    this.documentService.getSingleAnnotation(get_annot_input).subscribe((res) => {
      console.log(res);
      
      if (res["response_code"] == 200) {  
        console.log(this.createDocumentStore.view_annotation_array);
        // convert special characters
        let get_db_data = res["response_body"][0];
        res["response_body"][0] = this.document_credential.convert_special_char_annot(get_db_data);
        let singleDataReceived = res["response_body"][0];
        this.singleDataReceived = res["response_body"][0];
        if (singleDataReceived.annotation_data != undefined) {
          this.singleDataReceived = this.annotation_data_change(singleDataReceived);
          singleDataReceived = this.annotation_data_change(singleDataReceived);
        }
        for (var k = 0; k < this.layerDatas.length; k++) {
          let itemIndex = this.layerDatas[k].annotations.findIndex(item => item.annotation_id == singleDataReceived.annotation_id);
          if (itemIndex != -1) {
            this.layerDatas[k].annotations.splice(itemIndex, 1, singleDataReceived);
            console.log(this.layerDatas[k].annotations[itemIndex]);
            this.layerDatas[k].annotations[itemIndex].annotation_tags = singleDataReceived.annotation_tags.toString();
            this.propertiesannotationData = singleDataReceived;
            this.currentSelectedAnnotationData = singleDataReceived;
            this.degree = this.propertiesannotationData["initial_rotation"];
            this.annotNameAnnotation = this.propertiesannotationData["annotation_name"];
            this.propertiesannotationDataString = this.propertiesannotationData["annotation_data"];
            // this.toolbarElementId = parseInt(this.propertiesannotationData["toolbar_element_id"]);
            this.get_disable_setting(this.toolbarElementId);
            // this.propertiesShapeDraw(this.propertiesannotationDataString);
          }
        }
        let findCurGroupIndex = this.findGroupindex(this.getId);
        var groupOptionDisplay = false;
        if(findCurGroupIndex != -1){
          groupOptionDisplay = true;
        }
        
        this.show = false;
        const dialogConfig = new MatDialogConfig();
        console.log(this.annotationstring)
        dialogConfig.disableClose = true;
        dialogConfig.autoFocus = true;
        e.preventDefault()
        debugger
        let annotationmenudialogBox = this.dialogBox.open(
          AnnotationMenuComponent,
          {
            width: "380px",
            data: {
              pagenumber: this.currentPageNumber,
              annotation_id: this.getId,
              layerData: this.layerDatas,
              activateIdDraw: this.activeLayerIdDraw,
              annotationstring: this.annotationstring,
              elementHandW: this.elementHandW,
              multipleSelectOn: this.multipleSelectOn,
              toolbarElementId: this.toolbarElementId,
              toolbarListData: this.toolbar_detail,
              selectAnnotationData: this.propertiesannotationData,
              formlist: this.formList,
              defaultForms: this.formListDefaultValues,
              multiselectionList1: this.multiselectionList,
              singleDataReceived: this.singleDataReceived,
              rotateandresize1: this.rotateandresize,
              copyenable: this.copytoolhead,
              searchoption: this.searchOption,
              currentPage: this.currentPageId,
              rapidShotMode: this.isRapidmode,
              groupOption: groupOptionDisplay
            },
          }
        );
        annotationmenudialogBox.afterClosed().subscribe(async (res) => {
          this.multiclickdisabled = false;
          if (res != undefined) {
            if (res.name == "rapidShot") {
              this.rapidShotModeOn = true;
              this.receiveString = "";
              this.drawFunctionActive = true;
              this.getPositionActive = true;
              // this.toolbarBg = index;
              this.annotationName = this.annotNameAnnotation;
              this.receiveString = this.propertiesannotationDataString;
              console.log(
                this.rapidShotModeOn,
                this.drawFunctionActive,
                this.getPositionActive,
                this.annotationName,
                this.receiveString
              );
            }
            else if (res.name == "moveLayer") {
              console.log(res.data);
              let newId = res.newID;
              this.layerDatas = res.data;
              this.previousSelectAnnotation = [];
              this.getId = "";
              this.dataService.imageChangeDocHeader.emit();
              let groupAnntsArr = this.createDocumentStore.view_annotation_array.filter(id => id.hasOwnProperty("grouping_border_id"));
              console.log(groupAnntsArr)
              console.log(this.createDocumentStore.view_annotation_array);
              this.getAnnotationForm1(this.layerDatas);
              let oldId = get_annot_input.annot_id;
              let groupIndex = this.findGroupindex(oldId);
              if(groupIndex != -1){
                this.groupingFunctionality(groupIndex,oldId,newId);
              }
              console.log(this.createDocumentStore.view_annotation_array);
              // if(groupAnntsArr.length > 0){
              //   groupAnntsArr.forEach(data => {
              //     this.createDocumentStore.view_annotation_array.push(data)
              //   })
              // }
            }
            else if (res.name == "btw_doc_copy_move") {
              //  annotation copy or move annotation to different document
              let selected_annot = this.multipleSelectOn == false ? [this.propertiesannotationData] : this.multiselectionList;
              for (let re = 0; re < selected_annot.length; re++) {
                if (res.type == "copy_without_data") {
                  selected_annot[re].annotation_links = [];
                  selected_annot[re].annotation_media = [];
                  selected_annot[re].annotation_tags = "";
                  // forms reset
                  const myArray = this.formList;
                  const myClonedArray = [];
                  myArray.forEach(val => myClonedArray.push(Object.assign({}, val)));
                  console.log(myClonedArray);
                  for (let j = 0; j < selected_annot[re]["annotation_forms"].length; j++) {
                    for (let k = 0; k < myClonedArray.length; k++) {
                      if (selected_annot[re]["annotation_forms"][j].form_id == myClonedArray[k].form_id) {
                        if (Array.isArray(myClonedArray[k].form_data) == false) {
                          myClonedArray[k].form_data = JSON.parse(myClonedArray[k].form_data);
                        } else {
                          myClonedArray[k].form_data = (myClonedArray[k].form_data);
                        }
                        selected_annot[re]["annotation_forms"][j] = myClonedArray[k];
                      }
                    }
                  }
                }
                // else{
                //   selected_annot[re].annotation_media = [];
                // }
              }
              // if the copy or move option same type we can merge the annotations \
              let get_already_local_value = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
              if (get_already_local_value != null) {
                if (res.type.includes("move") && get_already_local_value.mode.includes("move")) {
                  let get_current_annotations = get_already_local_value.annotations;
                  for (let da = 0; da < selected_annot.length; da++) {
                    let find_annot = get_current_annotations.findIndex((a_data) => a_data.annotation_id == selected_annot[da].annotation_id);
                    if (find_annot > -1) {
                      get_current_annotations.splice(find_annot, 1);// already selected annotations removed 
                    }
                  }
                  selected_annot = [...get_current_annotations, ...selected_annot];
                }
                else if (res.type.includes("copy") && get_already_local_value.mode.includes("copy")) {
                  let get_current_annotations = get_already_local_value.annotations;
                  for (let da = 0; da < selected_annot.length; da++) {
                    let find_annot = get_current_annotations.findIndex((a_data) => a_data.annotation_id == selected_annot[da].annotation_id);
                    if (find_annot > -1) {
                      get_current_annotations.splice(find_annot, 1);// already selected annotations removed 
                    }
                  }
                  selected_annot = [...get_current_annotations, ...selected_annot];
                }
              }
              // annotation layers inject to the local value
              let annotation_layers_only = layer_mapping_copy_btw_doc(this.layerDatas, selected_annot);
              let copy_move_mode_option = { copyandmoveMode: true, annotations: selected_annot, projectId: this.projectId, mode: res.type, layerdata_btw: annotation_layers_only };
              this.encrptdecrpt.setItem("cpy_mve_btw_doc", copy_move_mode_option);// set localstorage selected annotation
              let clone_copy_data = _.cloneDeep(selected_annot);
              this.enbl_cpy_mv_betweendocument(clone_copy_data, res.type);
              // disable multiselection function
              this.dataService2.imageChangeDocHeader.emit();
            }
          }

        });
        // when multiselect on rightclick option annotation details mapping dont want.
        if (this.multipleSelectOn == false) {
          this.newplotannotationSelection(singleDataReceived);
        }
      }
    });

  }

  groupingFunctionality(index,oldId,newId) {
    let MyDateString = new Date().toISOString();
    let annotationIds = this.createJSON_grpAnnts.group_data[index].annotation_ids;
    let cloneGrpAnnList = _.cloneDeep(annotationIds);
    let filterlist = this.checkAnnIDfromDOM(cloneGrpAnnList, annotationIds);
    let pathBox = this.calcMinandMaxforGrpAnnts_getAnns(filterlist);
    let annIndex = annotationIds.findIndex(id => id == oldId);
    if(annIndex != -1){
      this.createJSON_grpAnnts.group_data[index].annotation_ids.splice(annIndex,1);
      this.createJSON_grpAnnts.group_data[index].annotation_ids.push(newId);
      let color_index = this.createJSON_grpAnnts.group_data[index].color_details.filter(id => id.annotation_id == oldId);
      if(color_index.length > 0){
        let clone_colorDetails = _.cloneDeep(color_index[0]);
        clone_colorDetails.annotation_id = newId;
        clone_colorDetails.last_updated_date = MyDateString;
        this.createJSON_grpAnnts.group_data[index].color_details.push(clone_colorDetails);
        color_index[0].is_removed = true;
        color_index[0].last_updated_date = MyDateString;
      }
    }
    let curGroup = this.createJSON_grpAnnts.group_data[index];
    console.log(annotationIds);
    console.log(pathBox);
    let getBorderBoxWidthandHeight: any = this.getAnnotationWidthandHeightAction(pathBox);
    let groupColorCode = curGroup.group_state;
    let groupId = curGroup.group_annotation_id;
    let groupStateColor = this.findColor(groupColorCode)
    let getsvgpath_borderBox = {
      annotation_id: groupId + "-borderbox",
      grouping_border_id: groupId,
      annotation_type: "groupingBox",
      annotation_data: pathBox,
      groupingEnable: true,
      opacity: 1,
      width: (getBorderBoxWidthandHeight.width),
      height: (getBorderBoxWidthandHeight.height),
      left: getBorderBoxWidthandHeight.left,
      top: getBorderBoxWidthandHeight.top,
      fill_color: "transparent",
      stroke_color: groupStateColor
    }
    curGroup.last_updated_date = MyDateString;
    // let filter_colorDetails = curGroup.color_details.filter(id => id.is_removed == false);
    // filter_colorDetails.forEach(data => {
    //   let filterAnn = this.createDocumentStore.view_annotation_array.filter(id => id.annotation_id == data.annotation_id);
    //   if (filterAnn.length > 0) {
    //     let findAnnColor = this.findColor(data.color_state)
    //     filterAnn[0].opacity = 0.5;
    //     filterAnn[0].fill_color = findAnnColor;
    //     filterAnn[0].stroke_color = findAnnColor;
    //   }
    // })
    // this.createDocumentStore.view_annotation_array.push(getsvgpath_borderBox);
    var ids = {
      proj_id: this.projectId,
      folder_id: this.folderId,
      user_id: this.su.user_id,
    }
    this.documentService.updatingGroupAnntsService(ids, this.createJSON_grpAnnts).subscribe((response) => {
      console.log(response);
      this.getGroupAnnotationDatas()
    })
  }

  annotation_data_change(data: any) {
    let singleDataReceived = Object.assign({}, data);
    this.annotationstring = this.singleDataReceived.annotation_data;
    if ((singleDataReceived.toolbar_element_id < 19 || singleDataReceived.annotation_data.includes('move'))) {
      if (Number(singleDataReceived.initial_height) != 0 && Number(singleDataReceived.initial_width) != 0) {
        let getresizeShapeString = this.shapeService1.resizeFunctionNew(singleDataReceived, false);
        singleDataReceived.annotation_data = getresizeShapeString.shapeString;
      }
      else if ((singleDataReceived.toolbar_element_id == 13 || singleDataReceived.toolbar_element_id == 14) && singleDataReceived.initial_position_x != 0) {
        let getresizeShapeString = this.shapeService1.resizeFunctionNew(singleDataReceived, false);
        singleDataReceived.annotation_data = getresizeShapeString.shapeString;
      }
    }
    return singleDataReceived;
  }

  //Shapes drawed Update Database Start
  async annotationUpdate() {
    if(this.isRapidmode == false && this.copyMultiAnn == false){
      this.receiveString = "";
      this.toolbarBg = -1;
      this.drawFunctionActive = false;
      this.getPositionActive = false;
      this.shapeStringInorNot = false;
    }
    // this.receiveString = "";
    // this.toolbarBg = -1;
    // this.drawFunctionActive = false;
    // this.getPositionActive = false;
    // this.shapeStringInorNot = false;
    let layers = [];
    let updateAnnotationId = "";
    let newShapeAnnotationData = "";
    if (this.layerDatas != undefined) {
      this.layerDatas.forEach((data) => {
       
        if (data.layer_id === this.activeLayerIdDraw) {
          
          console.log(this.createJson)
          data.annotations.push(this.createJson);
          newShapeAnnotationData = _.cloneDeep(this.createJson);
          updateAnnotationId = this.createJson["annotation_id"];
          layers.push(data);
        } else {
          layers.push(data);
        }
      });
      let cloneLayerData = _.cloneDeep(layers);
      let annotationsIds = [];
      annotationsIds.push(this.createJson["annotation_id"]);
      // await this.replacecurrentChangeInSVG
      await this.drawUpdatedShapesSVG(newShapeAnnotationData);
      // disable drag scroll
      this.createDocumentStore.disable_drag_scroll = false;
      let st = this.functionstarttime('update api');
        this.documentService.annotationUpdateForm1(cloneLayerData, updateAnnotationId, this.activeLayerIdDraw, 'newannotation').subscribe((response) => {
          console.log(response);
      
          if (response["response_code"] == 200) {
            this.arrNewPosition = []
            this.functionendtime('update api',st);
  
            this.get_disable_setting(this.toolbarElementId)         
            
            if (this.createDocumentStore.copy_move_btw_doc == false) {
  
              this.show = false;
            }
            this.getPositionString = "";
            this.search_displayannotation.push(this.createJson);
            if (this.searchOption == true) {
              this.dataService.search_annotation.emit();
            }
            this.stringPathArray = [];
            this.getPositionSetMove = 1;
            console.log(updateAnnotationId);
            if (this.multipleSelectOn == false) {
              this.createDocumentStore.single_select_annotation = [];
              this.createDocumentStore.single_select_annotation.push(updateAnnotationId);
            }
            if (this.layerEnable == true) {
              this.cdRef.detectChanges();
              let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
              let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: this.checkedAnnotationIdsBackup, currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
              console.log(data);
              this.dataService2.layerDatafromnavigation.emit(data);
            }
            this.newplotannotationSelection(newShapeAnnotationData);
            this.annotationselectEnableDisable('remove');
            // remove the annotation move annotation  to another document option logic below
            this.removeoldAnnotation();

          }
          else {
            this.annotationselectEnableDisable('remove');
            this.errorMessage();
          }
          if(this.isRapidmode == true && this.rapidmodeData != undefined){
            this.setBgIndex(this.rapidmodeData.index,this.rapidmodeData.itemName,this.rapidmodeData.element_id,this.rapidmodeData.item)
          }else if(this.isRapidmode == true &&this.propertiesannotationData != undefined){
            this.getCurrentCopyData(this.propertiesannotationData,0)
            this.copyAnnotationCreatePageValue = true 
            this.drawFunctionActive = true
            this.getPositionActive = true
          }
        });
    }
    if(this.copymultiannenabled == true){
        this.closeCopyFooter()
        this.displayCopyMultiMessage("disabled");
    }
    
  }

  async annotationUpdate_multiplecopy(length) {
    if(this.isRapidmode == false && this.copyMultiAnn == false){
      this.receiveString = "";
      this.toolbarBg = -1;
      this.drawFunctionActive = false;
      this.getPositionActive = false;
      this.shapeStringInorNot = false;
    }
    let layers = [];
    let updateAnnotationId = "";
    let newShapeAnnotationData = "";
    if (this.layerDatas != undefined) {
      this.layerDatas.forEach((data) => {
       
        if (data.layer_id === this.activeLayerIdDraw) {
          
          console.log(this.createJson)
          data.annotations.push(this.createJson);
          this.newcopyAnnotations.push(this.createJson);
          newShapeAnnotationData = _.cloneDeep(this.createJson);
          updateAnnotationId = this.createJson["annotation_id"];
          layers.push(data);
        } else {
          layers.push(data);
        }
      });
      var cloneLayerData = _.cloneDeep(layers);
      
      // await this.replacecurrentChangeInSVG
      let shapes = await this.drawUpdatedShapesSVG(newShapeAnnotationData);
    }
      // disable drag scroll
      this.createDocumentStore.disable_drag_scroll = false;
      let st = this.functionstarttime('update api');
      const check = length + 1;
      if(check == this.copyMultiselectionList.length || this.isRapidmode == true){
        console.log(this.newcopyAnnotations);
        this.documentService.annotationUpdate_multipleCopy(cloneLayerData, this.newcopyAnnotations, this.activeLayerIdDraw, 'newannotation').subscribe((response) => {
          console.log(response);
      
          if (response["response_code"] == 200) {
            console.log(response)
          }
          else {
            this.annotationselectEnableDisable('remove');
            this.errorMessage();
          }
          if (this.copymultiannenabled == true && this.isRapidmode != true) {
            this.closeCopyFooter()
            this.displayCopyMultiMessage("disabled");
          }
          if(this.isRapidmode == true){
            this.copyAnnotationCreatePageValue = true 
            this.drawFunctionActive = true
            this.getPositionActive = true;
            this.toolbarSet = true;
          }
          if(this.isRapidmode == true && check == this.copyMultiselectionList.length){
            this.show = false;
          }
        });
      }  
  }

  removeoldAnnotation() {
    if (this.createDocumentStore.copy_move_btw_doc == true) {
      let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
      if (get_copy_move_ano_doc != null) {
        if ((get_copy_move_ano_doc.mode == "move_with_data" || get_copy_move_ano_doc.mode == "move_without_data")) {
          if (this.copyAnnotation_svg_view.length > 0) {
            let find_annot = this.copyAnnotation_svg_view.findIndex((cpy_annot) => cpy_annot.annotation_id == this.createDocumentStore.current_copy_annot_data['annotation_id']);
            if (find_annot > -1) {
              this.copyAnnotation_svg_view.splice(find_annot, 1);
              // remove the annotation from copyannotations key
              let find_annot_original = this.copyAnnotationDatas.findIndex((cpy_annot) => cpy_annot.annotation_id == this.createDocumentStore.current_copy_annot_data['annotation_id']);
              if (find_annot_original > -1) {
                this.copyAnnotationDatas.splice(find_annot_original, 1);
              }
              // remove the element in view
              // let annotationClear = document.getElementById(this.createDocumentStore.current_copy_annot_data['annotation_id']);
              // if (annotationClear != null) {
              //   annotationClear.remove();
              // }
              // let annotationLabelClear = document.getElementById('label' + this.createDocumentStore.current_copy_annot_data['annotation_id']);
              // if (annotationLabelClear != null) {
              //   annotationLabelClear.remove();
              // }
              // layerdatas value changes the old annotation is_removed 1
              let get_local_via_layer = get_copy_move_ano_doc.layerdata_btw;
              let find_layer = get_local_via_layer.find(({ layer_id }) => layer_id == this.createDocumentStore.current_copy_annot_data['layer_id']);
              if (find_layer != undefined) {
                let delete_annot_layer = [find_layer];
                let get_del_annot = delete_annot_layer[0].annotations.find(({ annotation_id }) => annotation_id == this.createDocumentStore.current_copy_annot_data['annotation_id']);
                if (get_del_annot != undefined) {
                  get_del_annot.is_removed = true;
                }
                // call api different document
                if (this.folderId != this.createDocumentStore.current_copy_annot_data['document_id']) {
                  let cloneDeleteData = _.cloneDeep(delete_annot_layer);
                  this.documentService.annotationUpdateForm1(cloneDeleteData, get_del_annot.annotation_id, get_del_annot.layer_id).subscribe((response) => {
                    console.log(response);
                   
                    if (response["response_code"] == 200) {
                      this.show = false;
                      if (this.copyAnnotation_svg_view.length == 0) {
                        this.closeCopyFooter();
                      }
                      else {
                        // remove from layerdata_btw key
                        let remove_deleted_one = get_local_via_layer.findIndex((layer_loc) => layer_loc.layer_id == get_del_annot.layer_id);
                        if (remove_deleted_one > -1) {
                          let find_remove_anot = get_local_via_layer[remove_deleted_one].annotations.findIndex((re_annot) => re_annot.annotation_id == get_del_annot.annotation_id);
                          if (find_remove_anot > -1) {
                            get_local_via_layer[remove_deleted_one].annotations.splice(find_remove_anot, 1);
                            get_copy_move_ano_doc.layerdata_btw = get_local_via_layer;
                          }
                          // remove from annotations key
                          let find_select_annot_key = get_copy_move_ano_doc.annotations.findIndex((s_anot) => s_anot.annotation_id == get_del_annot.annotation_id);
                          if (find_select_annot_key > -1) {
                            get_copy_move_ano_doc.annotations.splice(find_select_annot_key, 1);
                          }
                          // reasign the cpy_mve_btw_doc value
                          this.encrptdecrpt.setItem("cpy_mve_btw_doc", get_copy_move_ano_doc);// set localstorage selected annotation
                        }
                      }
                    }
                  });
                }
                // without call api same document 
                else if (this.folderId == this.createDocumentStore.current_copy_annot_data['document_id']) {
                  this.show = false;
                  if (this.copyAnnotation_svg_view.length == 0) {
                    this.closeCopyFooter();
                  }
                  else {
                    // remove from layerdata_btw key
                    let remove_deleted_one = get_local_via_layer.findIndex((layer_loc) => layer_loc.layer_id == get_del_annot.layer_id);
                    if (remove_deleted_one > -1) {
                      let find_remove_anot = get_local_via_layer[remove_deleted_one].annotations.findIndex((re_annot) => re_annot.annotation_id == get_del_annot.annotation_id);
                      if (find_remove_anot > -1) {
                        get_local_via_layer[remove_deleted_one].annotations.splice(find_remove_anot, 1);
                        get_copy_move_ano_doc.layerdata_btw = get_local_via_layer;
                      }
                      // remove from annotations key
                      let find_select_annot_key = get_copy_move_ano_doc.annotations.findIndex((s_anot) => s_anot.annotation_id == get_del_annot.annotation_id);
                      if (find_select_annot_key > -1) {
                        get_copy_move_ano_doc.annotations.splice(find_select_annot_key, 1);
                      }
                      // reasign the cpy_mve_btw_doc value
                      this.encrptdecrpt.setItem("cpy_mve_btw_doc", get_copy_move_ano_doc);// set localstorage selected annotation
                    }
                  }
                }
              }
            }
          }
        }
        else {
          this.show = false;
        }
      }
    }
  }
  // Annotation Data Info
  form = true;
  media = false;
  links = false;
  tags = false;
  properties = false;
  metadata = false;

  doubleClick() {
    this.showFiller = !this.showFiller;
  }
  formiconClick() {
    if (this.showFiller == false) {
      this.showFiller = true;
    }
    this.form = true;
    this.media = false;
    this.links = false;
    this.tags = false;
    this.properties = false;
    this.metadata = false;
    this.formShow = false;
  }

  mediaIconClick() {
    this.formShow = false;
    this.automatic_update_form();
    this.media = true;
    this.form = false;
    this.links = false;
    this.tags = false;
    this.properties = false;
    this.metadata = false;
    // if (this.multipleSelectOn == true) {
    //   // this.drawMediaAnnotations();
    //   let count = 1;
    //   this.mediaAnnotations.changes.subscribe((data) => {
    //     if (count == 1) {
    //       count = 2;
    //       this.drawMediaAnnotations();
    //     }
    //   });
    // }

  }

  linkIconClick() {
    this.automatic_update_form();
    this.media = false;
    this.form = false;
    this.links = true;
    this.tags = false;
    this.properties = false;
    this.metadata = false;
    this.formShow = false;
    if (this.showFiller == false) {
      this.showFiller = true;
    }
    if (this.multipleSelectOn == false) {
      this.annotationLinks = [];
      this.annotationlinkGet(this.getId);
      console.log(this.annotationLinks);
    }
    else {
      if (this.multiselectionList_svg_view.length > 0) {
        // multiple selection location value assigning
        for (let k = 0; k < this.multiselectionList_svg_view.length; k++) {
          if (Array.isArray(this.multiselectionList_svg_view[k].annotation_links)) {
            for (let l = 0; l < this.multiselectionList_svg_view[k].annotation_links.length; l++) {
              this.multiselectionList_svg_view[k].annotation_links[l]["location"] = this.getLocation(this.multiselectionList_svg_view[k].annotation_links[l]);
            }
          }
        }
      }
    }

  }

  openurl(url) {
    window.open(url);
  }

  propertyIconClick() {
    this.formShow = false;
    if (this.showFiller == false) {
      this.showFiller = true;
    }
    this.automatic_update_form();
    this.media = false;
    this.form = false;
    this.links = false;
    this.tags = false;
    this.properties = true;
    this.metadata = false;
    if (this.multipleSelectOn == true) {
      this.propertiesannotationData = this.multiselectionList[this.multiselectionList.length - 1];

      console.log(this.propertiesannotationData)
      this.textsize = this.propertiesannotationData.text_font_size;
      this.updateduserid = (this.propertiesannotationData.updated_by_user_id);
      this.createduserid = (this.propertiesannotationData.created_by_user_id);
      this.userdetail = this.encrptdecrpt.getItem("userdetail")
      this.list = this.userdetail;
      this.list2 = this.userdetail;
      this.list2 = this.list2.filter(ele => ele.user_id == this.createduserid)
      console.log(this.createduserid, this.updateduserid)
      if (this.list2.length != 0) {

        console.log(this.list2)
        this.firstname = this.list2[0].first_name
        this.lastname = this.list2[0].last_name
        this.firstname = this.dataService4.changeSpecialtoKeyFormat(this.firstname);
        this.lastname = this.dataService4.changeSpecialtoKeyFormat(this.lastname);
      }
      this.list = this.list.filter(ele => ele.user_id == this.updateduserid)
      if (this.list.length != 0) {
        console.log(this.list)

        this.firstname1 = this.list[0].first_name;
        this.lastname1 = this.list[0].last_name;
        this.firstname1 = this.dataService4.changeSpecialtoKeyFormat(this.firstname1);
        this.lastname1 = this.dataService4.changeSpecialtoKeyFormat(this.lastname1);
      }
      else {
        this.firstname1 = this.firstname;
        this.lastname1 = this.lastname;
        this.firstname1 = this.dataService4.changeSpecialtoKeyFormat(this.firstname1);
        this.lastname1 = this.dataService4.changeSpecialtoKeyFormat(this.lastname1);
      }

    }

    this.annotNameAnnotation = this.propertiesannotationData["annotation_name"];
    this.annotShapeAnnotation = this.ShapeNameGet(this.propertiesannotationData["toolbar_element_id"]);
    this.annotLabelAnnotation = this.propertiesannotationData["annotation_label"];
    // this.lineWidth = this.propertiesannotationData["line_width"];
    console.log(this.propertiesannotationData["line_width"])
    this.propertiesannotationData["line_width"] = Number(this.propertiesannotationData["line_width"]).toFixed(2);
    this.lineWidth = Number(this.propertiesannotationData["line_width"]).toFixed(2);
    console.log(this.lineWidth)

    this.opacityValue = this.propertiesannotationData["opacity"];
    this.backupLinewidth = _.cloneDeep(this.propertiesannotationData["line_width"]);
    let createdDates = this.propertiesannotationData["created_date"];
    this.createdDate = this.datePipe.transform(createdDates, "MM/dd/yyyy");
    this.createdtime = this.datePipe.transform(createdDates, "hh:mm aa");
    let modifiedDates = this.propertiesannotationData["last_updated_date"];
    this.modifiedDate = this.datePipe.transform(modifiedDates, "MM/dd/yyyy");
    this.modifytime = this.datePipe.transform(modifiedDates, "hh:mm aa");
    console.log(typeof this.propertiesannotationData["line_width"], typeof this.lineWidth);
    var currentAnnottion = [];
    var filterDataIn = [];


    for (let i = 0; i < this.layerDatas.length; i++) {

      if (this.multipleSelectOn == false) {
        filterDataIn = this.layerDatas[i].annotations.filter((data) => data.annotation_id == this.getId);
      }
      else if (this.multipleSelectOn == true) {
        filterDataIn = this.layerDatas[i].annotations.filter((data) => data.annotation_id == this.multiselectionList[this.multiselectionList.length - 1].annotation_id);
      }
      if (filterDataIn.length > 0) {
        currentAnnottion = filterDataIn;
        this.propertiesannotationData = currentAnnottion[0];
        this.propertiesannotationDataCopy = _.cloneDeep(currentAnnottion[0]);
        console.log(this.propertiesannotationDataCopy);
      }
    }
    // this.propertiesannotationDataCopy = _.cloneDeep(this.propertiesannotationData);
    // var annot_initial_width = this.propertiesannotationData["initial_width"];
    // var annot_initial_height = this.propertiesannotationData["initial_height"];
    var annot_element_id = this.propertiesannotationData["toolbar_element_id"];


    let getStringTopLeft = this.shapeService1.getSetScaleWidthandHeight(currentAnnottion[0]);
    console.log("calculated")
    console.log(getStringTopLeft)
    var annot_initial_width = 50
    var annot_initial_height = 50

    if (annot_element_id <= 10) {
      let d_initialHeight = currentAnnottion[0]["initial_height"];
      let d_initialWidth = currentAnnottion[0]["initial_width"];
      if ((d_initialWidth == 0 || d_initialWidth == "") && (d_initialHeight == 0 || d_initialHeight == "")) {
        annot_initial_width = 50
        annot_initial_height = 50
      } else {
        annot_initial_width = Number(d_initialWidth)
        annot_initial_height = Number(d_initialHeight)
      }

    }
    else if (annot_element_id == 17 || annot_element_id == 19 || annot_element_id == 20) {
      let shape_width_height = this.shapeService1.getCanvaswidthandHeight(currentAnnottion[0]);
      console.log("original")
      console.log(shape_width_height)
      annot_initial_width = getStringTopLeft.width
      annot_initial_height = getStringTopLeft.height

      var org_annot_width = shape_width_height.width;
      var org_annot_height = shape_width_height.height;

      var positiveLvalue = (org_annot_width + annot_initial_width) * this.scaleFactor
      positiveLvalue = positiveLvalue > 0 ? positiveLvalue : (org_annot_width) * this.scaleFactor

      var positiveHvalue = (shape_width_height.height + getStringTopLeft.height) * this.scaleFactor
      positiveHvalue = positiveHvalue > 0 ? positiveHvalue : (shape_width_height.height) * this.scaleFactor

      annot_initial_width = annot_initial_width < 0 ? positiveLvalue : (org_annot_width) * this.scaleFactor

      annot_initial_height = getStringTopLeft.height < 0 ? positiveHvalue : (shape_width_height.height) * this.scaleFactor
    }
    else {
      annot_initial_width = getStringTopLeft.width
      annot_initial_height = getStringTopLeft.height
    }
    console.log(annot_initial_width + "==================" + annot_initial_height)
    console.log(getStringTopLeft)

    // let scaleValue = 100
    // let scalewidth = 122.56267409470776
    // let scaleheight = 0
    // let scaleTo = scalewidth == 0 ? scaleheight : scalewidth
    // let scaleFactor = scaleValue / scaleTo
    if (this.scaleFactor != "" && Number(this.scaleFactor > 0)) {
      this.annotMetadata = this.shapeService1.process_set_scale(annot_element_id, annot_initial_width, annot_initial_height, this.scaleFactor)
      let splitData = this.annotMetadata.split("==")
      this.annotMetadataLength = splitData[0];
      this.annotMetadataArea = splitData[1];
      this.annotMetadataHeight = splitData[2];
    }
    else {
      this.annotMetadataLength = "N/A"
      this.annotMetadataArea = "N/A"
      this.annotMetadataHeight = "N/A"
    }
    // preview svg drawing
    this.single_view_Preview_svg_drawing(this.propertiesannotationData);

    // after redrawing label moveattribute get removed so append it for moving purpose. move => multiselect flow
    if (this.propertiesannotationData["annotation_label"] != null || this.propertiesannotationData["annotation_label"] != "" || this.propertiesannotationData["annotation_label"] != undefined) {
      this.getMultipleMovingLabelElement(this.propertiesannotationData["annotation_id"]);
    }
  }



  tagIconClick() {
    this.formShow = false;
    if (this.showFiller == false) {
      this.showFiller = true;
    }
    this.automatic_update_form();
    this.media = false;
    this.form = false;
    this.links = false;
    this.tags = true;
    this.properties = false;
    this.metadata = false;
    this.annotationTags = [];
    this.annotationtagsName = "";
    this.tagCount = 0;

    if (this.multipleSelectOn == false) {
      this.multipleSelectOnTags = false;
      this.annotationTagGet(this.getId);
    } else if (this.multipleSelectOn == true) {
      this.tempTagLayerDatas = _.cloneDeep(this.layerDatas);
      this.multipleSelectTags();
    }
  }

  //stub data
  callBackgetStubData = (filterStub) => {
    this.show = true;
    let annotationMediaImages = [];
    console.log(MyDateString)
    if (this.multipleSelectOn == false) {
      this.url = "";
      var MyDateString = new Date().toISOString();
      for (i = 0; i < filterStub.length; i++) {
        this.filepath = filterStub[i].name;

        let imageData = {
          stub_id: this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime(),
          media_url: this.url,
          is_removed: false,
          media_name: this.filepath,
          media_type: "image",
          from_medium: "stub",
          created_date: MyDateString,
          annotation_id: this.getId,
          media_comment: "",
          version_number: 0,
          last_updated_date: MyDateString,
          created_by_user_id: this.su.user_id,
          annotation_media_id: this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime(),
          media_tags: "",
          is_changed: true
        };

        annotationMediaImages.push(imageData);
        console.log(annotationMediaImages)
        // stubdata.push(imageData);
      }
      let layers = [];
      if (this.layerDatas != undefined) {
        var dummyMedia = _.cloneDeep(annotationMediaImages)
        for (var i = 0; i < this.layerDatas.length; i++) {
          var annotationDAta = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
          if (annotationDAta.length > 0) {
            var undoData = _.cloneDeep(annotationDAta)
            for (var t = 0; t < filterStub.length; t++) {
              annotationDAta[0].annotation_media.push(annotationMediaImages[t])
            }
            for (var a = 0; a < dummyMedia.length; a++) {
              dummyMedia[a].is_removed = true
              undoData[0].annotation_media.push(dummyMedia[a])
            }
            //this.sampleFormObject = ttt[0].annotation_media
            this.globalMediaCount(annotationDAta[0].annotation_media, 'media')
            this.udoArrayChange(undoData[0])
          }
        }
      }
      //this.layerDatas = layers;
      let generateCloneLayer = _.cloneDeep(this.layerDatas);
      this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw, 'media').subscribe((response) => {
        console.log(response);
       
        if (response["response_code"] == 200) {
          this.show = false;
        }
        else {
          this.errorMessage();
        }
      });
    } else if (this.multipleSelectOn == true) {
      let stubMedia = [];

      for (var stub = 0; stub < this.multiselectionList.length; stub++) {
        stubMedia = [];
        this.url = "";
        for (i = 0; i < filterStub.length; i++) {
          this.filepath = filterStub[i].name;
          var MyDateString = new Date().toISOString();
          var imageData = {
            stub_id: this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime(),
            media_url: this.url,
            is_removed: false,
            media_name: this.filepath,
            media_type: "image",
            from_medium: "stub",
            created_date: MyDateString,
            annotation_id: this.multiselectionList[stub].annotation_id,
            media_comment: "",
            version_number: 0,
            last_updated_date: MyDateString,
            created_by_user_id: this.su.user_id,
            annotation_media_id: this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime(),
            media_tags: "",
            is_changed: true
          };
          // this.sampleFormObject.push(imageData);
          stubMedia.push(imageData);
          this.multiselectionList[stub].annotation_media.push(imageData);
          let filter_svg_view_index = this.multiselectionList_svg_view.findIndex((svg_view_media) => svg_view_media.annotation_id == this.multiselectionList[stub].annotation_id);
          if (filter_svg_view_index > -1) {
            this.multiselectionList_svg_view[filter_svg_view_index].annotation_media.push(imageData);
          }
        }
        let cloneLayer = _.cloneDeep(this.layerDatas);
        this.layerDatas = cloneLayer;
        if (this.layerDatas != undefined) {
          for (var i = 0; i < this.layerDatas.length; i++) {
            let annotationValue = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.multiselectionList[stub].annotation_id));
            if (annotationValue.length > 0) {
              for (var t = 0; t < stubMedia.length; t++) {
                annotationValue[0].annotation_media.push(stubMedia[t]);
              }
            }
          }
        }
      }
      this.globalMediaCount(this.multiselectionList, 'media');
      // let generateCloneLayer = _.cloneDeep(this.layerDatas);

      this.documentService.annotationMultipleUpdate(this.layerDatas, this.multiselectionList,'media').subscribe((response) => {
        if (response["response_code"] == 200) {
          this.show = false;
        }
        else {
          this.errorMessage();
        }
      });
    }
  };
  //image section
  openswtchmedia: boolean = false;
  sampleFormObject: Array<any> = [];
  setPrefix: any = "IMG_";
  setNumber: any = "0001";

  stubNumberArray: any[] = [];

  AddStubPhotos() {
    var numbersPart = [];
    let imageHere = 0;
    let tempsampleObject = this.sampleFormObject.filter((data) => {
      if (data.media_url == "") {
        return data;
      }
    });
    if (tempsampleObject.length > 0) {
      let getLastIndex = tempsampleObject[tempsampleObject.length - 1];
      let storeNumber = [];
      var checkchar1 = getLastIndex.media_name;
      var checkchar = checkchar1.replace(".jpg", "")


      for (let k = checkchar.length - 1; k >= 0; k--) {

        if (Number(checkchar[k]) >= 0 && Number(checkchar[k]) <= 9) {
          storeNumber.push(checkchar[k]);
        }
        else {
          break;
        }
        console.log(storeNumber);
      }
      if (storeNumber.length > 0) {
        let getLastNumber = "";
        for (let a = 0; a < storeNumber.length; a++) {
          getLastNumber = storeNumber[a] + getLastNumber;
        }
        console.log(getLastNumber);
        let numberLength = getLastNumber.length;
        let addIncrement = Number(getLastNumber) + 1;
        this.setNumber = addIncrement.toString().padStart(numberLength, "0");
      }
    }
    else {
      this.setNumber = "-Infinity";
    }

    console.log(this.setNumber);
    this.openswtchmedia = true;
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    let dialogref = this.dialogBox.open(StubphotosComponent, {
      width: "900px",
      data: {
        callback_StubData: this.callBackgetStubData,
        annotationData: this.getId,
        setNumber: this.setNumber,
        sampleFormObject: this.sampleFormObject,
        projectID: this.projectId,
      },
    });
  }

  selectedFile: ImageSnippet;

  onSelectFile() {
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    this.dialogBox.open(AddMultipleImagesComponent, {
      data: {
        annotationData: this.getId,
        userId: this.su.user_id,
        stubIdData: "",
        heading: "Images",
        filename: "",
        multipleSelectOn: this.multipleSelectOn,
        multiselectionList: this.multiselectionList,
        layerDatas: this.layerDatas
      }
    }).beforeClosed().subscribe((res) => {
      if (this.multipleSelectOn == false) {
        let layers = [];
        let annotationMediaImages = [];
        if (res['data'].length > 0) {
          this.show = true;
          for (var k = 0; k < res['data'].length; k++) {
            if (res['data'][k].mediaUrl != "") {
              let imageData = {
                stub_id: res['data'][k].stubId,
                media_url: res['data'][k].mediaUrl,
                is_removed: false,
                media_name: res['data'][k].filename,
                media_type: "image",
                from_medium: res['data'][k].media_type,
                created_date: new Date().toISOString(),
                annotation_id: res['data'][k].annotationId,
                media_comment: "",
                version_number: 0,
                last_updated_date: new Date().toISOString(),
                created_by_user_id: this.su.user_id,
                annotation_media_id: res['data'][k].mediaId,
                media_tags: "",
                is_changed: true
              };
              var final_name = this.duplicateCheck(imageData.media_name, this.getId,annotationMediaImages);
              imageData.media_name = final_name;
              annotationMediaImages.push(imageData);
            }
          }
          var dummyMedia = _.cloneDeep(annotationMediaImages)
          for (var i = 0; i < this.layerDatas.length; i++) {
            var annotationDAta = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
            this.udoArrayChange(_.cloneDeep(annotationDAta[0]));
            if (annotationDAta.length > 0) {
              for (var t = 0; t < res['data'].length; t++) {
                annotationDAta[0].annotation_media.push(annotationMediaImages[t])
              }
              this.globalMediaCount(annotationDAta[0].annotation_media, 'media')
              var undoData = _.cloneDeep(annotationDAta)
              // for (var t = 0; t < res['data'].length; t++) {
              //   annotationDAta[0].annotation_media.push(annotationMediaImages[t])
              // }
              for (var a = 0; a < dummyMedia.length; a++) {
                dummyMedia[a].is_removed = true
                if (undoData.length > 0) {
                  undoData[0].annotation_media.push(dummyMedia[a])
                }
              }
              //this.sampleFormObject = ttt[0].annotation_media
              this.globalMediaCount(annotationDAta[0].annotation_media, 'media')
              this.udoArrayChange(undoData[0]);
              break;
            }
          }
          let generateCloneLayer = _.cloneDeep(this.layerDatas);
          this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw, 'media').subscribe((response) => {
            console.log(response);
           
            if (response["response_code"] == 200) {
              this.show = false;
            }
            else {
              this.errorMessage();
            }
          });
        }
      }
      else {
        console.log(this.multiselectionList, res['data']);
        let annotationMediaImages = [];
        if (res['data'].length > 0) {
          this.show = true;
          for (let mi = 0; mi < this.multiselectionList.length; mi++) {
            annotationMediaImages = [];
            let filter_res_media = res['data'].filter((MData) => MData.annotationId == this.multiselectionList[mi].annotation_id);
            //handle multiple images same annotation pushed
            if (filter_res_media.length > 0) {
              for (let multi_media = 0; multi_media < filter_res_media.length; multi_media++) {
                let imageData = {
                  stub_id: filter_res_media[multi_media].stubId,
                  media_url: filter_res_media[multi_media].mediaUrl,
                  is_removed: false,
                  media_name: filter_res_media[multi_media].filename,
                  media_type: "image",
                  from_medium: filter_res_media[multi_media].media_type,
                  created_date: new Date().toISOString(),
                  annotation_id: this.multiselectionList[mi].annotation_id,
                  media_comment: "",
                  version_number: 0,
                  last_updated_date: new Date().toISOString(),
                  created_by_user_id: this.su.user_id,
                  annotation_media_id: filter_res_media[multi_media].mediaId,
                  media_tags: "",
                };
                let final_name = this.duplicateCheck(imageData.media_name, this.multiselectionList[mi].annotation_id);
                imageData.media_name = final_name;
                this.multiselectionList[mi].annotation_media.push(imageData);
                // It should be push to multiple_view_svg array also
                let filter_svg_view_index = this.multiselectionList_svg_view.findIndex((svg_view_image) => svg_view_image.annotation_id == this.multiselectionList[mi].annotation_id);
                if (filter_svg_view_index > -1) {
                  this.multiselectionList_svg_view[filter_svg_view_index].annotation_media.push(imageData);
                }
              }
            }
            if (this.layerDatas != undefined) {
              for (var i = 0; i < this.layerDatas.length; i++) {
                let annotationValue = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.multiselectionList[mi].annotation_id));
                if (annotationValue.length > 0) {
                  annotationValue[0].annotation_media = this.multiselectionList[mi].annotation_media;
                }
              }
            }
          }
          // for (let dl = 0; dl < res['data'].length; dl++) {
          //   let filterMediaIndex = res['data'].findIndex((AData) => AData.annotationId == this.multiselectionList[mi].annotation_id);
          //   if (filterMediaIndex != -1) {
          //     let imageData = {
          //       stub_id: this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + new Date().getTime(),
          //       media_url: res['data'][dl][filterMediaIndex].path,
          //       is_removed: false,
          //       media_name: res['data'][dl].filename,
          //       media_type: "image",
          //       from_medium: "image",
          //       created_date: new Date().toISOString(),
          //       annotation_id: this.multiselectionList[mi].annotation_id,
          //       media_comment: "",
          //       version_number: 0,
          //       last_updated_date: new Date().toISOString(),
          //       created_by_user_id: this.su.user_id,
          //       annotation_media_id: res['data'][dl][filterMediaIndex].media_id,
          //       media_tags: "",
          //     };
          //     this.multiselectionList[mi].annotation_media.push(imageData);
          //   }
          // }
          this.globalMediaCount(this.multiselectionList, 'media');
          let generateCloneLayer = _.cloneDeep(this.layerDatas);
          this.documentService.annotationMultipleUpdate(generateCloneLayer, this.multiselectionList,'media').subscribe((response) => {
            if (response["response_code"] == 200) {
              this.show = false;
            }
            else {
              this.errorMessage();
            }
          });
        }
      }
    });
  }
  duplicateCheck(name, change_annotation_id,annotationMediaImages?) {
    var count = 0;
    var duplicatename = name;
    var tempName = name;
    for (var i = 0; i < this.layerDatas.length; i++) {
      var annotationDAta = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == change_annotation_id));
      if (annotationDAta.length > 0 && annotationDAta[0].annotation_media != null && annotationDAta[0].annotation_media.length != 0) {
        for (let k = 0; k < annotationDAta[0].annotation_media.length; k++) {
            if(this.createDocumentStore.data_allow_condition.includes(annotationDAta[0].annotation_media[k].is_removed)){
              let letters = annotationDAta[0].annotation_media[k].media_name.split("(", 1);
              let removeBracket=name.split("(", 1);
              if (letters[0].trim() === removeBracket[0].trim()) {
              count++;
              }
            }
        }
      }
    }
    if(annotationMediaImages!=undefined && annotationMediaImages.length>0 && count>0){
      for(let j=0;j<annotationMediaImages.length;j++){
        let remBracket=name.split("(", 1);
        let remBracketCheck=annotationMediaImages[j].media_name.split("(", 1);
        if(remBracket[0].trim() === remBracketCheck[0].trim()){
          count++;
        }
      }
    }
    if (count > 0) {
      tempName=tempName.split("(", 1);
      duplicatename = tempName + " (" + count + ")";
    }
    return duplicatename;
  }

  annotationTagGet(annotationId) {
    console.log(this.userrole);
    this.tagCount = 0;
    for (var i = 0; i < this.layerDatas.length; i++) {
      for (var j = 0; j < this.layerDatas[i].annotations.length; j++) {
        if (annotationId == this.layerDatas[i].annotations[j].annotation_id && this.layerDatas[i].annotations[j].annotation_tags.length != 0) {
          console.log(this.layerDatas[i].annotations[j].annotation_tags);
          let convertString = this.layerDatas[i].annotations[j].annotation_tags.toString();
          this.annotationTags = convertString.split(",");
          this.tagCount = this.annotationTags.length;
          console.log(this.annotationTags);
        }
      }
    }
    console.log(this.tagCount);
  }

  checkTempList: any = [];

  multipleSelectTags() {
    let temptagCount = 0;
    this.checkTempList = [];

    for (var i = 0; i < this.multiselectionList.length; i++) {
      if (this.multiselectionList[i].annotation_tags != "") {
        let tempTags = this.multiselectionList[i].annotation_tags;
        let converString = tempTags.toString();
        let converttempTags = converString.split(",");
        this.checkTempList = [...this.checkTempList, ...converttempTags];
        temptagCount = temptagCount + converttempTags.length;
        if (this.checkTempList.includes('â'))
          this.checkTempList = this.checkTempList.split('â').join("\\");
      }
      if (this.checkTempList.includes('ô')) {
        this.checkTempList = this.checkTempList.split('ô').join('"');
      }
      if (this.checkTempList.includes("ê")) {
        this.checkTempList = this.checkTempList.split("ê").join("'");;
      }
      if (this.checkTempList.includes('Ê')) {
        this.checkTempList = this.checkTempList.split("Ê").join("'");
      }
      if (this.checkTempList.includes('Ô')) {
        this.checkTempList = this.checkTempList.split('Ô').join('"');
      }

      if (this.multiselectionList[i].annotation_tags == "" || this.multiselectionList[i].annotation_tags.length == 0) {
        temptagCount = temptagCount + 0;
      }
    }
    let tempTags = this.checkTempList;
    let removeDuplicate = new Set(tempTags);
    this.checkTempList = [...removeDuplicate];


    this.tagCount = temptagCount;


    if (this.checkTempList.length == 0) {
      // for (let mc = 0; mc < this.checkTempList.length; mc++) {
      // this.tagCount = this.tagCount + this.checkTempList[mc].annotation_tags.length;
      this.tagCount = 0;
      // }
    }
    console.log(this.checkTempList);
  }
  //getTagAnnotation area End
  annotationLinks: any[];
  //getAnnotationDocument Link area start
  annotationlinkGet(annotationId) {

    if (this.multipleSelectOn == false) {
      for (var i = 0; i < this.layerDatas.length; i++) {
        var currentAnnotationLnkedData = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
        console.log(currentAnnotationLnkedData);
        if (currentAnnotationLnkedData.length > 0) {
          this.globalMediaCount(currentAnnotationLnkedData[0].annotation_links, 'links');
        }
      }
    } else if (this.multipleSelectOn == true) {
      let templinkCount = 0;
      for (let ml = 0; ml < this.multiselectionList.length; ml++) {
        if (this.multiselectionList[ml].annotation_links != undefined && this.multiselectionList[ml].annotation_links != null) {
          let linkCount = this.multiselectionList[ml].annotation_links.filter((LData) => {
            return LData.is_removed == "false" || LData.is_removed == 0
          });
          templinkCount = templinkCount + linkCount.length;
        }
      }
      this.linkCount = templinkCount;
    }
  }
  //getAnnotationDocument Link area End
  //Update Freehand Draw Shape Start
  annotationUpdateFreehandAsOne(annotationUpdateFreehand) {
    this.freehand_path_value = "";
    this.drawFreehandMenu = false;
    this.accessMenuFeatureStop = false;
    this.drawCanvasContext = null;
    this.toolbarSet = false;
    var annontationidDate = new Date().getTime();
    var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
    var MyDateString = new Date().toISOString();
    let label_string = "";
    label_string = this.annotationLabelTemplate();
    this.createJson = {
      annotation_data: annotationUpdateFreehand,
      annotation_forms: this.selectAnnotationForms,
      annotation_id: uuid,
      annotation_label: label_string,
      annotation_links: [],
      annotation_media: [],
      annotation_name: this.annotationName,
      annotation_stubs: [],
      annotation_tags: "",
      annotation_url: "",
      created_by_user_id: this.su.user_id,
      created_date: MyDateString,
      document_id: this.folderId,
      element_size: 1,
      fill_color: this.currentSelectedItems.element_data.fill_color,
      initial_height: 0,
      initial_rotation: 0,
      initial_position_x: 0,
      initial_position_y: 0,
      initial_width: 0,
      is_removed: false,
      last_updated_date: MyDateString,
      layer_id: this.activeLayerIdDraw,
      line_width: this.currentSelectedItems.element_data.line_width,
      opacity: 1,
      original_property: "",
      page_id: this.currentPageId,
      project_id: this.projectId,
      stroke_color: this.currentSelectedItems.element_data.stroke_color,
      toolbar_element_id: this.toolbarElementId,
      updated_by_user_id: this.su.user_id,
      version_number: 1,
    };
    this.annotationUpdate();
  }
  //Update Freehand Draw Shape End

  //Update As Many draw in freehand line start
  annotationUpdateFreehandAsMany(annotationUpdateFreehand) {

    var annontationidDate = new Date().getTime();
    var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
    var MyDateString = new Date().toISOString();
    let label_string = "";
    label_string = this.annotationLabelTemplate();
    this.createJson = {
      annotation_data: annotationUpdateFreehand,
      annotation_forms: this.selectAnnotationForms,
      annotation_id: uuid,
      annotation_label: label_string,
      annotation_links: [],
      annotation_media: [],
      annotation_name: this.annotationName,
      annotation_stubs: [],
      annotation_tags: "",
      annotation_url: "",
      created_by_user_id: this.su.user_id,
      created_date: MyDateString,
      document_id: this.folderId,
      element_size: 1,
      fill_color: this.currentSelectedItems.element_data.fill_color,
      initial_height: 0,
      initial_rotation: 0,
      initial_position_x: 0,
      initial_position_y: 0,
      initial_width: 0,
      is_removed: false,
      last_updated_date: MyDateString,
      layer_id: this.activeLayerIdDraw,
      line_width: this.currentSelectedItems.element_data.line_width,
      opacity: 1,
      original_property: "",
      page_id: this.currentPageId,
      project_id: this.projectId,
      stroke_color: this.currentSelectedItems.element_data.stroke_color,
      toolbar_element_id: this.toolbarElementId,
      updated_by_user_id: this.su.user_id,
      version_number: 1,
    };
    if (this.layerDatas != undefined) {
      let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.activeLayerIdDraw);
      if (findLayerIndex != -1) {
        this.layerDatas[findLayerIndex].annotations.push(this.createJson);
      }
    }
    return uuid;
  }
  //Update As Many draw in freehand line End
  //As many API update area start
  // updateFreehandlineAsManyAPI() {
  //   this.drawFreehandMenu = false;
  //   this.documentService.annotationUpdateAUC(this.layerDatas).subscribe((response) => {
  //       console.log(response);
  //       this.show = false;
  //     });
  // }
  //As many API update area end
  //LongPress Functionlity implemented Area Start
  clickAction: boolean = false;
  getId: string;
  idss: string;
  oneTimeValid: number = 1;
  displayfooter: boolean = false;
  opacityValue: any = 0;
  backupOpacity: any = 0;
  lineWidth: any = 1;
  backupLinewidth: any = 1;
  elementHandW: any;
  mousdownEventRemove: any;
  mousupEventRemove: any;
  mousleaveEventRemove: any;
  annotationSelected: boolean = false;
  currentFormId: string = "";
  isAnnotationDefaultForm: boolean = true;
  currentFormName: string = "";
  hideSelectForm: boolean = false;
  currentSelectedAnnotationData: any = {};
  showDataTime: boolean = false;
  previousSelectAnnotation: string[] = [];

  checkformdate = function (formdate) {

    if (formdate == 'current') {
      let curDate = new Date();
      return curDate;
    }
    else
      return formdate;

  }

  getCanvasElementTemp(event) {
    console.log(event, event.offsetX, event.offsetY);
    console.log(event.target.id);
    console.log(event.target.getBoundingClientRect());
  }

  currentSelectedCanvas(e,toolbar_id) {
    let pdfImg = document.getElementById("pdfImg");
    let type_e = typeof e;
    let current_Id:any
    if(type_e == "string"){
      current_Id = toolbar_id != undefined && toolbar_id != 0 ? toolbar_id :  this.propertiesannotationData.toolbar_element_id;
    }
    else{
      current_Id = e.toolbar_element_id;
    }
    let borderid = "media"+this.getId;
    let getElementSelect = document.getElementById(this.getId);
    if (this.previousSelectAnnotation.length == 0) {
      this.previousSelectAnnotation.push(this.getId);
      // this.colorBorder(getElementSelect);
      if(current_Id != 15){
        getElementSelect.classList.add('svg-block');
      }
      else{
        let getBorderElement = document.getElementById(borderid);
        // this.colorBorder(getBorderElement);
        // getBorderElement.classList.add('line-border');
        let ann_dat = e.annotation_data != undefined ? e.annotation_data : this.propertiesannotationData.annotation_data;
        let annotationProp = e.annotation_data != undefined ? e: this.propertiesannotationData;
        let path = this.drawBorderLineForLines(ann_dat,annotationProp);
        if(path == "normalBorder"){
          getElementSelect.classList.add('svg-block');
        }
        else{
          getBorderElement.setAttribute("d", path);
        } 
        
      }
    }
    else if (this.previousSelectAnnotation[0] != this.getId) {
      console.log(this.previousSelectAnnotation);
      let getPreviousElement = document.getElementById(this.previousSelectAnnotation[0]);
      // getPreviousElement.style.pointerEvents = "auto";
      if (getPreviousElement != null) {
        // this.transparentBorder(getPreviousElement);
        this.getMultipleMovingLabelElementRemove(this.previousSelectAnnotation[0]);
        getPreviousElement.classList.remove('svg-block');
        // let borderid_prev = "media"+this.previousSelectAnnotation[0];
        // let getBorderElement = document.getElementById(borderid_prev);
        // if(getBorderElement != undefined){
        //   getBorderElement.setAttribute("d","");
        // }
        const components = Array.prototype.filter.call(
          document.querySelectorAll('*'),
          e => e.id.toLowerCase().startsWith('media')
        )
        components.forEach((data) => {
          data.setAttribute("d", "");
        });  
        
        //add remove svg for line -- Jose
      }
      this.previousSelectAnnotation = [];
      this.previousSelectAnnotation.push(this.getId);
      // this.colorBorder(getElementSelect);
      if(current_Id != 15){
        getElementSelect.classList.add('svg-block');
      }
      else{
        let getBorderElement = document.getElementById(borderid);
        let ann_dat = e.annotation_data != undefined ? e.annotation_data : this.propertiesannotationData.annotation_data
        let annotationProp = e.annotation_data != undefined ? e: this.propertiesannotationData;
        let path = this.drawBorderLineForLines(ann_dat,annotationProp);
        if(path == "normalBorder"){
          getElementSelect.classList.add('svg-block');
        }
        else{
          getBorderElement.setAttribute("d", path);
        }
      }
    }
    else if (this.previousSelectAnnotation[0] == this.getId) {
      // this.colorBorder(getElementSelect);
      if(current_Id != 15){
        getElementSelect.classList.add('svg-block');
      }
      else{
        let getBorderElement = document.getElementById(borderid);
        let ann_dat = e.annotation_data != undefined ? e.annotation_data : this.propertiesannotationData.annotation_data
        let annotationProp = e.annotation_data != undefined ? e: this.propertiesannotationData;
        let path = this.drawBorderLineForLines(ann_dat,annotationProp);
        if(path == "normalBorder"){
          getElementSelect.classList.add('svg-block');
        }
        else{
          getBorderElement.setAttribute("d", path);
        }
      }
    }
    this.checkedAnnotationIdsBackup = this.previousSelectAnnotation;

    if (this.layerEnable == true) {
      let layerCheckDatas = { option: this.multipleSelectOn, id: this.getId, action: 'add' };
      this.dataService.layerCheckBoxClick.emit(layerCheckDatas);
    }
  }
  
  drawBorderLineForLines(annotationData: any,data) {
    let start_cords = {x:0,y:0};
    let end_cords = {x:0,y:0};
    let split_shape = annotationData.split(" ")
    for (var i = 0; i < split_shape.length; i++) {
      let splitshape = split_shape[i].replaceAll('--', '-n');
      splitshape = split_shape[i].replaceAll(':-', ':n');
      var hypenSplit = split_shape[i].split("-");
      console.log("hypenSplit",hypenSplit)
      if(hypenSplit[0] == "move"){
        let shape_cords = hypenSplit[1].replaceAll('n', '-');
        start_cords.x = parseFloat(shape_cords.split(":")[0]) 
        start_cords.y = parseFloat(shape_cords.split(":")[1])
      }else if(hypenSplit[0] == "line"){
        let shape_cords = hypenSplit[1].replaceAll('n', '-');
        end_cords.x = parseFloat(shape_cords.split(":")[0])
        end_cords.y = parseFloat(shape_cords.split(":")[1])
      }
    }
    let shapeStringValue = this.shapeService1.getCanvaswidthandHeight(data);
    let w =shapeStringValue.width;
    let h = shapeStringValue.height;
    console.log(shapeStringValue)
    if(w < 35 || h < 35){
      return "normalBorder";
    }
    let generateannotation = this.calculateCornerpoints(start_cords,end_cords);
    return generateannotation
  }
   
  canvasClick(e) {
    debugger
    console.log(this.annotationName);
    console.log(this.createDocumentStore.single_select_annotation);
    //shape drop down\
    this.changeShapeEnable = false;
    this.annotationtagsName = '';
    let is_locked_flag_value;
    let annot_id;
    let anot_layr_id = "";
    let anot_page_id = "";
    let toolbar_element_id = 0
    this.formContentleft = [];
    this.formContentright = [];
    this.useCaseEmptycellIds = []
    if (typeof e == 'object') {
      annot_id = $(e.target).attr("id");
      let previewBack = { status: false, id: annot_id, location: null };
      // localStorage.setItem("preSelectAnnotationId", JSON.stringify(previewBack));
      this.encrptdecrpt.setItem("preSelectAnnotationId", previewBack);//security
      e.stopPropagation();
    }
    else {
      annot_id = e;
    }

    for (let i = 0; i < this.layerDatas.length; i++) {
      let annotations = this.layerDatas[i]["annotations"].filter(annotation => annotation.annotation_id == annot_id)
      if (annotations.length > 0) {
        let associated_pages = this.layerDatas[i].associated_pages
        let page_element = associated_pages.filter(ele => ele.page_id == this.currentPageId)
        // this.activeLayerIdDraw = page_element[0].layer_id;
        is_locked_flag_value = page_element.length > 0 ? page_element[0].is_lock : "false"
        // check annotation already having response data or not when rotate and resize
        if (this.rotateandresize == true) {
          if (Array.isArray(annotations[0].annotation_forms)) {
            let clone_data = _.cloneDeep(annotations[0]);
            this.newplotannotationSelection(clone_data);
            this.repointvalidcheck();
            // The moveAnnotationsStore variable is used to store the size of multiple annotations locally.
            this.backup_annot_storage(clone_data);
            return;
          }
        }
        // mapping new changes for the getannotation api
        anot_layr_id = annotations[0].layer_id;
        anot_page_id = annotations[0].page_id;
        toolbar_element_id = annotations[0].toolbar_element_id;
        this.propertiesannotationData = annotations[0]
        this.textsize = parseInt(annotations[0].text_font_size);
        break;
      }
    }
    console.log(is_locked_flag_value)
    if (is_locked_flag_value == "true" || is_locked_flag_value == true || is_locked_flag_value == "1") {
      if (this.multipleSelectOn == false) {
        if (this.createDocumentStore.single_select_annotation.indexOf(annot_id) != -1) {
          this.createDocumentStore.single_select_annotation = [];
        }
      }
      return;
    }
    console.log("canvas  click", e);
    this.show = true;
    this.annotationSelectEvent = true;
    if (typeof e == 'object') {
      this.getId = $(e.target).attr("id");
      let previewBack = { status: false, id: this.getId, location: null };
      // localStorage.setItem("preSelectAnnotationId", JSON.stringify(previewBack));
      this.encrptdecrpt.setItem("preSelectAnnotationId", previewBack);//security
      e.stopPropagation();
    }
    else {
      this.getId = e;
    }
    let multiUnselect: boolean = false;
    var getElementSelect = document.getElementById(this.getId);
    var heightC: any = getElementSelect.getAttribute("height");
    var widthC: any = getElementSelect.getAttribute("width");
    this.currentSelectedCanvas(e,toolbar_element_id);
    console.log(this.createDocumentStore.single_select_annotation);
    if (this.showcopyAnnotationOption == false && multiUnselect == false) {
      console.log(this.getId);
      // get the single annotation data from server API
      var start_time = new Date().getTime();
      console.log('single annottaion', start_time);
      const annot_detail = { annot_id: this.getId, layer_id: anot_layr_id, page_id: anot_page_id }
      this.documentService.getSingleAnnotation(annot_detail).subscribe((res) => {
        // this.documentService.getSingleAnnotation(this.getId).subscribe((res) => {
        // console.log(JSON.parse(res["response_body"][0]["annotation_forms"][0].form_data));
        if (res["response_code"] == 200) {
          var end = new Date().getTime();
          var time = end - start_time;
          console.log('single annottaion' + ' end time: ' + end);
          console.log('single annottaion ' + ' Execution time: ' + time);

          // convert special characters
          let get_db_data = res["response_body"][0];
          res["response_body"][0] = this.document_credential.convert_special_char_annot(get_db_data);
          //For label font size
          if(res["response_body"][0].text_font_size == null){
             this.textsize =13;
          }
          // get_db_data.annotation_name = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_name);
          // get_db_data.annotation_label = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_label);
          // get_db_data.annotation_tags = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_tags);
          // get_db_data.annotation_data = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_data);
          // console.log(typeof get_db_data.original_property, get_db_data.original_property);
          // if(get_db_data.original_property!=""){
          //   get_db_data.original_property = typeof get_db_data.original_property == 'string' ? JSON.parse(get_db_data.original_property) : get_db_data.original_property; 
          // }
          // if ((typeof get_db_data.original_property) == 'object') {
          //   if (get_db_data.original_property.hasOwnProperty('annotation_data')) {
          //     get_db_data.original_property.annotation_data = this.dataService4.changeSpecialtoKeyFormat(get_db_data.original_property.annotation_data);
          //   }
          // }
          // if (get_db_data.annotation_forms.length > 0) {
          //   for (let fi = 0; fi < get_db_data.annotation_forms.length; fi++) {
          //     get_db_data.annotation_forms[fi].form_name = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_forms[fi].form_name);
          //     let get_cur_formdata = get_db_data.annotation_forms[fi].form_data;
          //     get_cur_formdata = this.documentService.convertJSON(get_cur_formdata);              
          //     if (get_cur_formdata.length > 0) {
          //       get_db_data.annotation_forms[fi].form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
          //     }
          //     else{
          //       get_db_data.annotation_forms[fi].form_data = get_cur_formdata;
          //     }
          //     if (get_db_data.annotation_forms[fi].is_extend == true) {
          //       if (get_db_data.annotation_forms[fi].hasOwnProperty('ext_form_data')) {
          //         if (get_db_data.annotation_forms[fi].ext_form_data != null) {
          //           let get_cur_ext_formdata = get_db_data.annotation_forms[fi].ext_form_data;
          //           get_cur_ext_formdata = this.documentService.convertJSON(get_cur_ext_formdata);
          //           if (get_cur_ext_formdata.length > 0) {
          //             get_db_data.annotation_forms[fi].ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
          //           }
          //           else{
          //             get_db_data.annotation_forms[fi].ext_form_data = get_cur_ext_formdata;
          //           }
          //         }
          //       }
          //     }
          //   }
          // }
          // if (get_db_data.annotation_links.length > 0) {
          //   if (Array.isArray(get_db_data.annotation_links)) {
          //     for (let li = 0; li < get_db_data.annotation_links.length; li++) {
          //       get_db_data.annotation_links[li].link_type = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_links[li].link_type);
          //       get_db_data.annotation_links[li].link_path = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_links[li].link_path);
          //       if (get_db_data.annotation_links[li].hasOwnProperty('location')) {
          //         if (get_db_data.annotation_links[li].location != undefined) {
          //           get_db_data.annotation_links[li].location = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_links[li].location);
          //         }
          //       }
          //     }
          //   }
          // }
          // if (get_db_data.annotation_media.length > 0) {
          //   if (Array.isArray(get_db_data.annotation_media)) {
          //     for (let li = 0; li < get_db_data.annotation_media.length; li++) {
          //       get_db_data.annotation_media[li].media_name = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_media[li].media_name);
          //       get_db_data.annotation_media[li].media_comment = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_media[li].media_comment);
          //       if (get_db_data.annotation_media[li].hasOwnProperty("media_tags")) {
          //         get_db_data.annotation_media[li].media_tags = this.dataService4.changeSpecialtoKeyFormat(get_db_data.annotation_media[li].media_tags);
          //       }
          //     }
          //   }
          // }
          // res["response_body"][0] = get_db_data;
        }
        if (this.searchOption == true) {
          this.idss = res["response_body"][0].annotation_id;
          this.dataService.getannotationid.emit(this.idss);
        }
        //this.undoArray.push([]);
        if (res["response_code"] == 200) {
          this.cdRef.detectChanges();
          this.show = false;
          var singleDataReceived;
          this.annotationSelected = true;
          console.log(res["response_body"]);
          singleDataReceived = res["response_body"][0];
          console.log(singleDataReceived)
          this.annotationName=singleDataReceived.annotation_name
          if (this.moveElementValue == false) {
            this.optionClick = false;
            this.hideSelectForm = true;
            this.sampleFormObject = [];
            this.modelFieldsForm = [];
            this.extend_modelFieldsForm = [];
            
          }
          else{
            // The moveAnnotationsStore variable is used to store the size of multiple annotations locally.
            this.backup_annot_storage(singleDataReceived);
          }
          // let clone_original_annotationdata = _.cloneDeep(singleDataReceived);
          for (var k = 0; k < this.layerDatas.length; k++) {
            let itemIndex = this.layerDatas[k].annotations.findIndex(item => item.annotation_id == singleDataReceived.annotation_id);
            //this.layerDatas[k].annotations[itemIndex] = singleDataReceived;
            if (itemIndex != -1) {
            var APIFormsList = singleDataReceived.annotation_forms;
            let curnt_slcted_form_index;
            var APIFormsData = [];
            if(APIFormsList.length == 0){
              let curnt_slcted_form_Id = this.selectLastUpdatedForm(this.formListDefaultValues);
              this.currentFormId = curnt_slcted_form_Id;
            }
            else{
               curnt_slcted_form_index = this.select_primary_form(APIFormsList);
               APIFormsData = APIFormsList[curnt_slcted_form_index].form_data;
               this.modelFieldsForm = APIFormsData;
               if(this.createDocumentStore.data_allow_conditionT.includes(APIFormsList[curnt_slcted_form_index].is_extend)){
                   this.is_extend = true;
                   this.extend_modelFieldsForm = APIFormsList[curnt_slcted_form_index].ext_form_data;
                }
                else{
                  this.is_extend = false;
                }
                this.currentFormId = APIFormsList[curnt_slcted_form_index].form_id;
                
            }
            this.createDocumentStore.backupFormData = _.cloneDeep(this.modelFieldsForm);
            this.createDocumentStore.backupExtendFormData = _.cloneDeep(this.extend_modelFieldsForm);
            var editedForm1 = this.formListDefaultValues.filter((ele => ele.form_id == this.currentFormId))
            var editedForm = _.cloneDeep(editedForm1);
            var newFormDataFelds;
            var ext_newFormDataFelds;
            if (Array.isArray(editedForm[0].form_data) == false) {
              newFormDataFelds = JSON.parse(editedForm[0].form_data);
            } else {
              newFormDataFelds = editedForm[0].form_data
            }
            console.log(APIFormsData.length);
            let newFormDataFelds1;
            if(APIFormsData.length != 0){
              newFormDataFelds1 = this.merge_form_process(APIFormsData, newFormDataFelds, 'leftside');
              singleDataReceived.annotation_forms[curnt_slcted_form_index].form_data = newFormDataFelds1;
            }
            else{
              newFormDataFelds1 = newFormDataFelds;
            }
           
              this.layerDatas[k].annotations.splice(itemIndex, 1, singleDataReceived);
              this.currentSelectedAnnotationData = singleDataReceived;
              if (this.multipleSelectOn == true) {
                this.multiselectionList.push(this.layerDatas[k].annotations[itemIndex]);
                let getSelectedElement = document.getElementById(this.layerDatas[k].annotations[itemIndex].annotation_id);
                getSelectedElement.setAttribute('multimoving', this.layerDatas[k].annotations[itemIndex].toolbar_element_id);

                this.multipleAnnotationCall(singleDataReceived);
              }
              else {
                //   for (var l = 0; l < this.layerDatas[k].annotations.length; l++) {
                //     if (this.getId == this.layerDatas[k].annotations[l].annotation_id) {
                let currentData: any = singleDataReceived;
                // checking the annotation id 
                var checkId = singleDataReceived.annotation_id;
                // if (this.repoint_AnnotationStore_Id != null && this.repoint_AnnotationStore_Id != undefined) {
                //   if (this.repoint_AnnotationStore_Id.includes(checkId)) {
                //     var id = this.repoint_AnnotationStore_Id.filter((data) => data == checkId);
                //     var data_filter = this.repoint_AnnotationStore.filter((data) => data.annotation_id == id[0]);
                //     this.single_view_svg_drawing(data_filter[0]);
                //     currentData = data_filter[0];
                //   }
                //   else {
                //     this.single_view_svg_drawing(singleDataReceived);
                //   }
                // }
                // else {
                //   this.single_view_svg_drawing(singleDataReceived);
                // }
                this.currentSelectedAnnotationData = singleDataReceived;
                this.cdRef.detectChanges();
                this.coordinateX = Number(singleDataReceived.initial_position_x);
                this.coordinateY = Number(singleDataReceived.initial_position_y);
                this.get_disable_setting(singleDataReceived.toolbar_element_id);
                // header svg drawing
                this.single_view_svg_drawing(singleDataReceived);

                this.propertiesannotationData = currentData;
                this.propertiesannotationDataCopy = _.cloneDeep(currentData);
                // this.toolbarElementId = singleDataReceived.toolbar_element_id;

                //rotate and resize option enable should be check repoint option annotation based disable enable
                if (this.rotateandresize == true) {
                  this.repointvalidcheck();
                  // The resizeAnnotationsStore variable is used to store the size of multiple annotations locally.
                  this.backup_annot_storage(singleDataReceived);
                }
                if (singleDataReceived.annotation_media.length > 0) {
                  //this.sampleFormObject = singleDataReceived.annotation_media;
                  this.globalMediaCount(singleDataReceived.annotation_media, 'media');
                }
                else if (singleDataReceived.annotation_media.length == 0) {
                  this.sampleFormObject = [];
                }

                singleDataReceived.annotation_forms = singleDataReceived.annotation_forms.filter((ele => ele.is_removed == 0 || ele.is_removed == "0" || ele.is_removed == false))

                //Jose Comment the below if condition
                // if (singleDataReceived.annotation_forms.length > 0) {

                //taking the current form details from api
                let formlength = singleDataReceived.annotation_forms.length;
                let formslist_local = this.formList;
                console.log(formslist_local)
                formslist_local = formslist_local.sort((a, b) => new Date(a.last_updated_date).getTime() - new Date(b.last_updated_date).getTime())
                let sortedForms = singleDataReceived.annotation_forms.length == 0 ? formslist_local : singleDataReceived.annotation_forms//singleDataReceived.annotation_forms.sort((a,b) => a.form_name.localeCompare(b.form_name));
                this.isAnnotationDefaultForm = singleDataReceived.annotation_forms.length == 0 ? false : true
                if (sortedForms != null && sortedForms != undefined && sortedForms.length > 0) {
                  let curnt_slcted_form_index = this.select_primary_form(sortedForms); // primary form selection function
                  this.currentFormId = sortedForms[curnt_slcted_form_index].form_id;
                  let check_form_name = this.formListDefaultValues.filter((f_name) => f_name.form_id == this.currentFormId);
                  if (check_form_name.length > 0 || check_form_name != null) {
                    this.currentFormName = check_form_name[0].form_name;
                  }
                  else {
                    this.currentFormName = sortedForms[curnt_slcted_form_index].form_name;
                  }
                  this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
                  this.currentFormHiddenStatus = JSON.parse(sortedForms[curnt_slcted_form_index].is_hidden);
                  if (sortedForms[curnt_slcted_form_index].hasOwnProperty('is_extend')) {
                    this.is_extend = sortedForms[curnt_slcted_form_index].is_extend;
                  } else {
                    this.is_extend = false;
                  }
                  if (this.createDocumentStore.data_allow_condition.includes(this.is_extend)) {
                    this.is_extend = false;
                  } else {
                    this.is_extend = true;
                  }
                  if (sortedForms[curnt_slcted_form_index].form_data != null && typeof sortedForms[curnt_slcted_form_index].form_data == 'string') {
                    this.modelFieldsForm = JSON.parse(sortedForms[curnt_slcted_form_index].form_data);
                  }
                  else if (sortedForms[curnt_slcted_form_index].form_data != null && typeof sortedForms[curnt_slcted_form_index].form_data != 'string') {
                    this.modelFieldsForm = sortedForms[curnt_slcted_form_index].form_data;
                  }
                  if (this.is_extend == true) {
                    if (sortedForms[curnt_slcted_form_index].hasOwnProperty('ext_form_data') &&
                      sortedForms[curnt_slcted_form_index].ext_form_data != null &&
                      typeof sortedForms[curnt_slcted_form_index].ext_form_data == 'string') {
                      if (sortedForms[curnt_slcted_form_index].ext_form_data != null && sortedForms[curnt_slcted_form_index].ext_form_data != undefined) {
                        this.extend_modelFieldsForm = JSON.parse(sortedForms[curnt_slcted_form_index].ext_form_data);
                      }
                    }
                    else if (sortedForms[curnt_slcted_form_index].hasOwnProperty('ext_form_data') &&
                      sortedForms[curnt_slcted_form_index].ext_form_data != null &&
                      typeof sortedForms[curnt_slcted_form_index].ext_form_data != 'string') {
                      this.extend_modelFieldsForm = sortedForms[curnt_slcted_form_index].ext_form_data;
                    }
                    // if (this.extend_modelFieldsForm != null) {
                    //   if (typeof this.extend_modelFieldsForm === 'string') {
                    //     this.extend_modelFieldsForm = JSON.parse(this.extend_modelFieldsForm);
                    //   }
                    //   this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                    // }
                  }
                  if (this.modelFieldsForm.length > 0) {
                    this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => this.createDocumentStore.data_allow_condition.includes(formdata.is_removed));
                  }
                  if (this.extend_modelFieldsForm.length > 0) {
                    this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => this.createDocumentStore.data_allow_condition.includes(formdata.is_removed));
                  }
                  //taking the defult form details from Form builder for the current form
                  var editedForm1 = this.formListDefaultValues.filter((ele => ele.form_id == this.currentFormId))
                  var editedForm = _.cloneDeep(editedForm1);
                  if (editedForm.length > 0) {

                    let filterCurrentForm = this.formListDefaultValues.filter((ele123 => ele123.form_id == this.currentFormId));
                    this.colorvalid = false;
                    if (filterCurrentForm.length > 0) {
                      let formvalue1 = filterCurrentForm[0];
                      if (formvalue1.is_hidden == 1 || formvalue1.is_hidden == "true" || formvalue1.is_hidden == "1") {
                        this.colorvalid = true;
                      } else {
                        this.colorvalid = false;
                      }
                    }
                    this.formList = this.formList.sort((a, b) => a.form_name.localeCompare(b.form_name))
                    if (editedForm1.length > 0) {
                      
                      console.log(this.formList)
                      console.log(editedForm)
                      editedForm[0].is_hidden = sortedForms[curnt_slcted_form_index].is_hidden
                      editedForm[0].is_removed = sortedForms[curnt_slcted_form_index].is_removed
                      editedForm[0].is_default_flag = sortedForms[curnt_slcted_form_index].is_default_flag
                      if (Array.isArray(editedForm[0].form_data) == false) {
                        newFormDataFelds = JSON.parse(editedForm[0].form_data)
                      } else {
                        newFormDataFelds = editedForm[0].form_data
                      }
                      if (editedForm[0].hasOwnProperty('ext_form_data') && editedForm[0].ext_form_data != null) {
                        if (Array.isArray(editedForm[0].ext_form_data) == false) {
                          ext_newFormDataFelds = JSON.parse(editedForm[0].ext_form_data)
                        } else {
                          ext_newFormDataFelds = editedForm[0].ext_form_data
                        }
                      }
                    }
                    //var formjsonStringyfy = JSON.stringify(editedForm[0].form_data)
                    //checking the form builder form and current form for any new fields are added to that purticular form
                    //if any attach that field to the current form

                    this.createDocumentStore.backupFormData = _.cloneDeep(this.modelFieldsForm);
                    this.createDocumentStore.backupExtendFormData = _.cloneDeep(this.extend_modelFieldsForm);
                    // remove deleted fields
                    if (newFormDataFelds != null && newFormDataFelds.length > 0) {
                      newFormDataFelds = newFormDataFelds.filter((remove_deleted) => this.createDocumentStore.data_allow_condition.includes(remove_deleted.is_removed));
                    }
                    if (ext_newFormDataFelds != null && ext_newFormDataFelds.length > 0) {
                      ext_newFormDataFelds = ext_newFormDataFelds.filter((remove_deleted) => this.createDocumentStore.data_allow_condition.includes(remove_deleted.is_removed));
                    }
                    let clone_model_fields = this.modelFieldsForm;

                    newFormDataFelds = this.merge_form_process(clone_model_fields, newFormDataFelds, 'leftside');
                    let clonenewFormDataFelds = _.cloneDeep(newFormDataFelds);
                    let weldform1 = clonenewFormDataFelds.filter((id) => id.element_type == "uti-entry-field-WMATA_WELD")
                    if (weldform1.length > 0) {
                      weldform = true;
                      var welditem1 = weldform1[0];
                    }
                    let index = this.createDocumentStore.view_annotation_array.findIndex(item => item.annotation_id == singleDataReceived.annotation_id)
                    if (index != -1) {
                      if (this.createDocumentStore.view_annotation_array[index].annotation_label != "") {
                        if (this.createDocumentStore.view_annotation_array[index].toolbar_element_id == 11) {
                          this.textsize = this.createDocumentStore.view_annotation_array[index].textfontSize;
                          let x = this.createDocumentStore.view_annotation_array[index].textshapetextx;
                          let y = this.createDocumentStore.view_annotation_array[index].textshapetexty;
                          this.backUpTextProperties = { 'size': this.textsize, 'xPosition': x, 'yPosition': y }
                        }
                        else {
                          let getannotationLabelElement = document.querySelectorAll("p[annotationLabel]");
                          if (getannotationLabelElement.length > 0) {
                            let currentAttributeElement = document.getElementById("label" + this.propertiesannotationDataCopy.annotation_id);
                            let fontSizeString = currentAttributeElement.style.fontSize;
                            this.textsize = this.stringToNumberConversion(fontSizeString);
                            let fontLeftString = currentAttributeElement.style.left;
                            let fontLeftShapes = this.stringToNumberConversion(fontLeftString);
                            let fontTopString = currentAttributeElement.style.top;
                            let fontTopShapes = this.stringToNumberConversion(fontTopString);
                            this.backUpTextProperties = { 'size': this.textsize, 'xPosition': fontLeftShapes, 'yPosition': fontTopShapes }
                          }
                        }
                      }
                    }
                    //   this.createDocumentStore.view_annotation_array[index].textfontSize=this.textsize;
                    // this.modelFieldsForm.forEach(element => {
                    //   var FieldFind = newFormDataFelds.filter(ele => ele['element_uuid'] == element['element_uuid']);
                    //   // var find_model_field = ext_newFormDataFelds.filter((ele) => ele['element_uuid'] == element['element_uuid']);
                    //   //Fieldfind ==> overall form fields from form builder
                    //   //element ==> edited form fields for the annotation 
                    //   // if (FieldFind.length == 0 && find_model_field.length > 0) {
                    //   //   FieldFind = find_model_field;
                    //   // }
                    //   if (FieldFind.length > 0) {
                    //     if (FieldFind[0].is_removed == true || FieldFind[0].is_removed == "true") {
                    //       newFormDataFelds = newFormDataFelds.filter(ele => ele['element_uuid'] != FieldFind[0]['element_uuid']);
                    //     }
                    //     // ganesh changed this line FieldFind.length > 0 && FieldFind.is_removed != true && FieldFind.is_removed != "true"
                    //     // added line FieldFind.length > 0 && FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true" for this if condition
                    //     if (FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true") {
                    //       if (FieldFind[0].element_type == 'single_choice' || FieldFind[0].element_type == 'dropdown') {
                    //         this.cdRef.detectChanges();
                    //         FieldFind[0].element_data.options.forEach(element1 => {
                    //           element1.default = false
                    //         });
                    //         var defaultOptionValue:any;
                    //         if(element.element_data.hasOwnProperty('options'))
                    //             {
                    //                defaultOptionValue = element.element_data.options.filter((ele => ele.default == true))
                    //             }
                    //         if (defaultOptionValue!=undefined && defaultOptionValue.length > 0) {
                    //           var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == defaultOptionValue[0].element_uuid))
                    //           currentOption[0].default = true;
                    //         }
                    //       } else if (FieldFind[0].element_type == 'multiple_choice' || FieldFind[0].element_type == 'checkbox') {

                    //         FieldFind[0].element_data.options.forEach(element1 => {
                    //           element1.default = false
                    //         });
                    //         var UCitemDefault:any;
                    //         if(element.element_data.hasOwnProperty('options'))
                    //          {
                    //              UCitemDefault = element.element_data.options.filter((ele => ele.default == true))
                    //          }
                    //          if(UCitemDefault!=undefined){
                    //           UCitemDefault.forEach(element2 => {
                    //             var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == element2.element_uuid))
                    //             currentOption[0].default = true;
                    //           });
                    //         }
                    //       }
                    //       else if (FieldFind[0].element_type == 'date') {
                    //         if (element.element_data.default_date_time != "" && element.element_data.default_date_time != "none" && element.element_data.default_date_time != "current" && element.element_data.default_date_time != undefined) {
                    //           //  FieldFind[0].element_data.default_value = new Date(element.element_data.default_date_time).toISOString();
                    //           FieldFind[0].element_data.default_date_time = new Date(element.element_data.default_date_time).toISOString();
                    //         }
                    //         else if (element.element_data.default_date_time != "") {
                    //           if (element.element_data.default_date_time == "current") {
                    //             FieldFind[0].element_data.default_date_time = element.element_data.default_date_time
                    //           }
                    //           else if (element.element_data.default_date_time == "none" || element.element_data.default_date_time == "") {
                    //             FieldFind[0].element_data.default_date_time = element.element_data.default_date_time;
                    //           }
                    //         }
                    //       }
                    //       else if (FieldFind[0].element_type == 'uti-entry-field') {
                    //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
                    //       }
                    //       else if (FieldFind[0].element_type == "uti-entry-field-WMATA") {
                    //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
                    //       }
                    //       else if(FieldFind[0].element_type == "uti-entry-field-TIMBER"){
                    //         // element_data replacing changes new 16.02.2022
                    //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
                    //       }
                    //       else if (FieldFind[0].element_type == 'address') {

                    //         FieldFind[0].element_data.street_address1 = element.element_data.street_address1
                    //         FieldFind[0].element_data.city = element.element_data["city"]
                    //         FieldFind[0].element_data.state = element.element_data["state"]
                    //         FieldFind[0].element_data.zip = element.element_data["zip"]
                    //         FieldFind[0].element_data.street_address2 = element.element_data.street_address2
                    //       } else {
                    //         if (element.element_data.default_value != undefined && element.element_data.default_value != "") {
                    //           FieldFind[0].element_data.default_value = element.element_data.default_value
                    //         }
                    //       }
                    //     }
                    //   }
                    // })
                    if (this.is_extend == true) {
                        let clone_extend_model_fields = this.extend_modelFieldsForm;
                        let find_number_field = clone_extend_model_fields.filter((number_fi) => number_fi.element_type == 'number');
                        console.log(find_number_field);

                        ext_newFormDataFelds = this.merge_form_process(clone_extend_model_fields, ext_newFormDataFelds, 'rightside');
                       
                        editedForm[0].ext_form_data = ext_newFormDataFelds;
                        let getforms = editedForm[0].ext_form_data;
                        if (getforms != undefined && getforms.length > 0) {
                          //start converting
                          let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                          editedForm[0].ext_form_data = change_character_res;
                        }
                        this.extend_modelFieldsForm = editedForm[0].ext_form_data;
                        if(weldform == true){
                          let index = this.extend_modelFieldsForm.findIndex((id) => id.element_type == "uti-entry-field-WMATA_WELD");
                          if(index == -1){
                            this.extend_modelFieldsForm.push(welditem1);
                          }
                       }
                        this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                      
                    }
                    //after assigning the chnges new form data add to the current form
                    editedForm[0].form_data = newFormDataFelds
                    //ganesh added this logic
                    // if (newFormDataFelds != null && newFormDataFelds.length > 0) {
                    //   let remove_items_filter = newFormDataFelds.filter((r_data) => {
                    //     if (this.createDocumentStore.data_allow_condition.includes(r_data.is_removed)) {
                    //       return true;
                    //     }
                    //     else {
                    //       return false;
                    //     }
                    //   })
                    //   console.log(remove_items_filter);
                    // }
                    var formfieldIndex = singleDataReceived.annotation_forms.findIndex((ele => ele.form_id == this.currentFormId))
                    //removed for 2913 ticket starting
                    // singleDataReceived.annotation_forms.splice(formfieldIndex, 1, editedForm[0]);
                    //ending
                    // let generateCloneLayer = _.cloneDeep(this.layerDatas);
                    // this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw).subscribe((response) => {
                    //   console.log(response);
                    // });

                    let getforms = editedForm[0].form_data;
                    if (getforms != undefined && getforms.length > 0) {
                      //start converting
                      let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                      editedForm[0].form_data = change_character_res;
                    }
                    editedForm[0].form_data = editedForm[0].form_data == null ? [] : editedForm[0].form_data;
                    this.modelFieldsForm = editedForm[0].form_data
                    this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                    if (this.is_extend == true) {
                      let merge_forms = [...this.modelFieldsForm, ...this.extend_modelFieldsForm];
                      //taking the current form copy for  undoing and redoing
                      this.undoDatataForForms = _.cloneDeep(merge_forms)
                      //taking the current form copy for use condition
                      this.usecaseCopyArray = _.cloneDeep(merge_forms);
                    }
                    else {
                      //taking the current form copy for  undoing and redoing
                      this.undoDatataForForms = _.cloneDeep(this.modelFieldsForm)
                      //taking the current form copy for use condition
                      this.usecaseCopyArray = _.cloneDeep(this.modelFieldsForm);
                    }
                    //function call for use condition
                    this.process_use_conditions();
                    //function call for calculation
                    this.FormulaCalc();
                    var weldform = false;
                    //default data setting by clickin the annotation for forms
                    if (this.modelFieldsForm.length > 0) {
                      for (let v = 0; v < this.modelFieldsForm.length; v++) {
                        // if it is a html form  need to set the out put array
                        if (this.modelFieldsForm[v].element_type == "uti-entry-field") {
                          this.outputArray = []
                          this.finalArray1 = []
                          var fff = this.modelFieldsForm[v].element_data["fields"];
                          for (let k = 0; k < this.modelFieldsForm[v].element_data['fields'].length; k++) {
                            //making the calculation array for displaying the  output array field
                            if (this.modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                              for (let j = 0; j < this.modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                                this.outputArray.push({ 'id': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                              }
                            }
                          }
                          this.elementFields = this.modelFieldsForm[v].element_data['fields']

                          //if the pay load containg a default values in the html form retriving and assigning for calculation
                          if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                            if (this.modelFieldsForm[v].element_data['default_values'] != "" && this.modelFieldsForm[v].element_data['default_values'] != undefined) {
                              this.finalArray = this.modelFieldsForm[v].element_data['default_values']
                              this.displayArryChange(this.modelFieldsForm[v].element_data['fields'], this.modelFieldsForm[v].element_data['default_values'])
                            }
                          }
                        }
                        else if (this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA") {
                          // make default values array of json

                          if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values') && this.modelFieldsForm[v].element_data.default_values != undefined && this.modelFieldsForm[v].element_data.default_values != "") {
                            let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                            let get_element_fields = this.modelFieldsForm[v].element_data['fields'];
                            this.UTIEntry_field_Wmata(get_element_fields, get_default_value);
                          }
                          else {
                            // if default values is empty purpose
                            this.finalArray2 = [];
                          }
                        }
                        else if (this.modelFieldsForm[v].element_type == "uti-entry-field-TIMBER") {
                          // make default values array of json
                          this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
                        }
                        
                        else if(this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA_WELD"){
                          if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                            weldform = true;
                            if(this.modelFieldsForm[v].element_data.default_values != undefined && 
                              this.modelFieldsForm[v].element_data.default_values != ""){
                                 const copyweldform = _.cloneDeep(this.modelFieldsForm[v]);
                            this.copyweldForm = copyweldform;
                            let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                            const fields = this.modelFieldsForm[v].element_data.fields;
                            this.fieldsWeld = fields;
                            let weldArray = this.convertUUIDtoNormal(get_default_value);
                            this.splitarray(weldArray);
                            }
                          }
                        }
                        //retriving the value from Total elemnat quantity and checking for calculation
                        if (this.modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                          this.totalElementQuantity = Number(this.modelFieldsForm[v].element_data.default_value);
                          this.htmlcalculation();
                        }
                        //according to the form builder value date is assigning to the  annotation forms
                        if (this.modelFieldsForm[v].element_type == "date") {

                          if (this.modelFieldsForm[v].element_data.default_date_time != "") {
                            if (this.modelFieldsForm[v].element_data.default_date_time == "none" || this.modelFieldsForm[v].element_data.default_date_time == "current") {
                              this.modelFieldsForm[v].element_data.default_value = this.assignDates(this.modelFieldsForm[v].element_data.default_date_time)
                            } else {
                              this.modelFieldsForm[v].element_data.default_value = new Date(this.modelFieldsForm[v].element_data.default_date_time).toISOString();
                            }
                          }
                        }
                      }
                      // sorting formdatas based on the element order
                      let tempcopyforms = this.modelFieldsForm;
                      this.modelFieldsForm = tempcopyforms.sort((a, b) => (a.element_order > b.element_order) ? 1 : -1);
                      console.log(this.modelFieldsForm);
                    }
                    //default data setting by clickin the annotation for forms
                    if (this.extend_modelFieldsForm != null) {
                      if (this.extend_modelFieldsForm.length > 0) {
                        for (let v = 0; v < this.extend_modelFieldsForm.length; v++) {
                          // if it is a html form  need to set the out put array
                          if (this.extend_modelFieldsForm[v].element_type == "uti-entry-field") {
                            this.outputArray = []
                            this.finalArray1 = []
                            var fff = this.extend_modelFieldsForm[v].element_data["fields"];
                            for (let k = 0; k < this.extend_modelFieldsForm[v].element_data['fields'].length; k++) {
                              //making the calculation array for displaying the  output array field
                              if (this.extend_modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                                for (let j = 0; j < this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                                  this.outputArray.push({ 'id': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                                }
                              }
                            }
                            this.elementFields = this.extend_modelFieldsForm[v].element_data['fields']
                            //if the pay load containg a default values in the html form retriving and assigning for calculation

                            if (this.extend_modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                              if (this.extend_modelFieldsForm[v].element_data['default_values'] != "" && this.extend_modelFieldsForm[v].element_data['default_values'] != undefined) {
                                this.finalArray = this.extend_modelFieldsForm[v].element_data['default_values']
                                this.displayArryChange(this.extend_modelFieldsForm[v].element_data['fields'], this.extend_modelFieldsForm[v].element_data['default_values'])
                              }
                            }
                          }
                          //retriving the value from Total elemnat quantity and checking for calculation
                          if (this.extend_modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                            this.totalElementQuantity = Number(this.extend_modelFieldsForm[v].element_data.default_value);
                            this.htmlcalculation();
                          }
                          console.log(this.outputArray);
                          //according to the form builder value date is assigning to the  annotation forms
                          if (this.extend_modelFieldsForm[v].element_type == "date") {
                            if (this.extend_modelFieldsForm[v].element_data.default_date_time != "") {
                              if (this.extend_modelFieldsForm[v].element_data.default_date_time == "none" || this.extend_modelFieldsForm[v].element_data.default_date_time == "current") {
                                //  this.extend_modelFieldsForm[v].element_data.default_date_time = this.assignDates(this.extend_modelFieldsForm[v].element_data.default_date_time)
                              } else {
                                this.extend_modelFieldsForm[v].element_data.default_date_time = new Date(this.extend_modelFieldsForm[v].element_data.default_date_time).toISOString();
                              }
                            }
                          }
                          else if(this.extend_modelFieldsForm[v].element_type == "uti-entry-field-TIMBER") {
                            // make default values array of json
                            this.createDocumentStore.custom_form_datas = this.extend_modelFieldsForm;
                          }
                        }
                        if(weldform == true){
                          let copyextendform = _.cloneDeep(this.extend_modelFieldsForm);
                          let index = copyextendform.findIndex((type)=>type.element_type == "uti-entry-field-WMATA_WELD");
                          if(index == -1){
                            this.extend_modelFieldsForm.push(this.copyweldForm);
                          }
                        }
                        // sorting formdatas based on the element order
                        let tempcopyforms = this.extend_modelFieldsForm;
                        this.extend_modelFieldsForm = tempcopyforms.sort((a, b) => (a.element_order > b.element_order) ? 1 : -1);
                        console.log(this.extend_modelFieldsForm);
                      }
                    }
                    this.currentFormName = editedForm[0].form_name
                    this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
                    this.cdRef.detectChanges();
                  }
                }
                else {
                  // empty forms logic
                  this.modelFieldsForm = [];
                  this.extend_modelFieldsForm = [];
                }
                // modelform field hard coded
                // let get_object = new timber_form();
                // this.modelFieldsForm = [get_object];
                // form validation end
                if (formlength == 0) {
                  this.formCount = 0;
                }
                else {
                  this.formCount = singleDataReceived.annotation_forms.length;
                }
                if (this.annotationstring == undefined) {
                  this.annotationstring = this.propertiesannotationData.annotation_data

                }
                this.globalMediaCount(singleDataReceived.annotation_media, 'media')
                this.globalMediaCount(singleDataReceived.annotation_links, 'links')
                if (singleDataReceived.annotation_tags.toString() != "") {
                  let tempAnnotationtags = singleDataReceived.annotation_tags.toString();
                  this.tagCount = tempAnnotationtags.split(",").length;
                  console.log(this.tagCount);
                }
                else if (singleDataReceived.annotation_tags.toString() == "") {
                  this.tagCount = 0;
                }
                this.annotNameAnnotation = this.propertiesannotationData["annotation_name"];
                this.propertiesannotationDataString = this.propertiesannotationData["annotation_data"];
                this.annotLabelAnnotation = this.propertiesannotationData["annotation_label"];
                this.degree = singleDataReceived.initial_rotation;
                this.opacityValue = this.propertiesannotationData["opacity"];
                this.backupOpacity = _.cloneDeep(this.propertiesannotationData["opacity"]);
                this.annotShapeAnnotation = this.ShapeNameGet(this.propertiesannotationData["toolbar_element_id"]);
                this.lineWidth = Number(this.propertiesannotationData["Line_width"]).toFixed(2);
                this.backupLinewidth = _.cloneDeep(this.propertiesannotationData["line_width"]);
                let elementId = parseInt(this.propertiesannotationData["toolbar_element_id"]);
                if (elementId < 12) {
                  let x = parseFloat(this.propertiesannotationData["initial_position_x"]);
                  let lessBoxWidth = x - 119;
                  this.optionPositionX = lessBoxWidth;
                  console.log(lessBoxWidth);
                  let y = parseFloat(this.propertiesannotationData["initial_position_y"]);
                  let lessBoxHeight = y - 52;
                  this.optionPositionY = lessBoxHeight;
                  console.log(lessBoxHeight);
                }
                else if (elementId > 11) {
                  let x = parseFloat(this.propertiesannotationData["initial_position_x"]);
                  let lessBoxWidth: any = x - 119;
                  let addWidth = lessBoxWidth + widthC / 2;
                  this.optionPositionX = addWidth;
                  this.optionPositionY = parseFloat(this.propertiesannotationData["initial_position_y"]);
                  let y = parseFloat(this.propertiesannotationData["initial_position_y"]);
                  let lessBoxHeight = y - 42;
                  this.optionPositionY = lessBoxHeight;
                }
                // initial height for area
                this.initialHeight = this.propertiesannotationData["initial_height"];
                if (this.initialHeight == "" || this.initialHeight == 0) {
                  this.initialHeight = 50;
                }
                //initial width for length
                this.initialWidth = this.propertiesannotationData["initial_width"];
                if (this.initialWidth == "" || this.initialWidth == 0) {
                  this.initialWidth = 50;
                }
                var checkActiveorNot = 0;
                if (this.getScaleValue != undefined && this.getScaleValue.length > 0) {
                  for (var i = 0; i < this.getScaleValue.length; i++) {
                    if (
                      this.currentPageId == this.getScaleValue[i].page_id
                    ) {
                      this.initialWidth =
                        (this.getScaleValue[i].scaleValue * 10) /
                        this.initialWidth;
                      this.initialHeight =
                        (this.getScaleValue[i].scaleValue * 10) /
                        this.initialHeight;
                      this.areaValue = this.checkShapes(
                        this.propertiesannotationData["toolbar_element_id"],
                        this.initialWidth,
                        this.initialHeight
                      );
                      this.areaValue = parseInt(this.areaValue);
                      checkActiveorNot = 1;
                    }
                  }
                }
                if (checkActiveorNot != 1) {
                  this.initialHeight = this.propertiesannotationData[
                    "initial_height"
                  ];
                  if (this.initialHeight == "" || this.initialHeight == 0) {
                    this.initialHeight = 50;
                  }
                  //initial width for length
                  this.initialWidth = this.propertiesannotationData[
                    "initial_width"
                  ];
                  if (this.initialWidth == "" || this.initialWidth == 0) {
                    this.initialWidth = 50;
                  }
                  this.areaValue = this.checkShapes(
                    this.propertiesannotationData["toolbar_element_id"],
                    this.initialWidth,
                    this.initialHeight
                  );
                  this.areaValue = parseInt(this.areaValue);
                }
                if (this.media == true) {
                  this.mediaIconClick();
                }
                else if (this.links == true) {
                  this.linkIconClick();
                }
                else if (this.tags == true) {
                  this.tagIconClick();
                }
                else if (this.properties == true) {
                  this.propertyIconClick();
                }
              }
            }
          }

          this.updateduserid = (res["response_body"][0].updated_by_user_id);
          this.createduserid = (res["response_body"][0].created_by_user_id);
          this.userdetail = this.encrptdecrpt.getItem("userdetail")
          this.list = this.userdetail;
          this.list2 = this.userdetail;
          this.list2 = this.list2.filter(ele => ele.user_id == this.createduserid)
          console.log(this.createduserid, this.updateduserid)
          if (this.list2.length != 0) {

            console.log(this.list2)
            this.firstname = this.list2[0].first_name
            this.lastname = this.list2[0].last_name
            this.firstname = this.dataService4.changeSpecialtoKeyFormat(this.firstname);
            this.lastname = this.dataService4.changeSpecialtoKeyFormat(this.lastname);
          }
          this.list = this.list.filter(ele => ele.user_id == this.updateduserid)
          if (this.list.length != 0) {
            console.log(this.list)

            this.firstname1 = this.list[0].first_name;
            this.lastname1 = this.list[0].last_name;
            this.firstname1 = this.dataService4.changeSpecialtoKeyFormat(this.firstname1);
            this.lastname1 = this.dataService4.changeSpecialtoKeyFormat(this.lastname1);
          }
          else {
            this.firstname1 = this.firstname;
            this.lastname1 = this.lastname;
            this.firstname1 = this.dataService4.changeSpecialtoKeyFormat(this.firstname1);
            this.lastname1 = this.dataService4.changeSpecialtoKeyFormat(this.lastname1);
          }
        }
        else {
          this.errorMessage();
          this.previousSelectAnnotation = [];
          // getElementSelect.style.pointerEvents = "auto";
          this.transparentBorder(getElementSelect);
        }
        this.checkAlign_usecase()
      });
    }
  }

  multipleAnnotationCall(e?: any) {
    this.useCaseEmptycellIds = []
    if (this.layerEnable == true) {
      let layerCheckDatas = { option: this.multipleSelectOn, id: this.getId, action: 'add' };
      this.dataService.layerCheckBoxClick.emit(layerCheckDatas);
    }
    this.selectedAnnotationLength = this.multiselectionList.length;

    this.getCounts();
    if (this.form == true) {
      this.formiconClick();
    }
    else if (this.media == true) {
      this.mediaIconClick();
    }
    else if (this.links == true) {
      this.linkIconClick();
    }
    else if (this.tags == true) {
      this.tagIconClick();
    }
    else if (this.properties == true) {
      this.propertyIconClick();
    }
  }

  canvasClickPreSelect(id) {

    for (var k = 0; k < this.layerDatas.length; k++) {
      let itemIndex = this.layerDatas[k].annotations.findIndex(item => item.annotation_id == this.getId);
      if (itemIndex == -1) {
        this.annotationSelected = false;
        this.hideSelectForm = false;
        this.formCount = 0;
        this.tagCount = 0;
        this.mediaCount = 0
        this.linkCount = 0
      } else {
        let previewBack = { state: false, id: this.getId, location: null };
        // localStorage.setItem("preSelectAnnotationId", JSON.stringify(previewBack));
        this.encrptdecrpt.setItem("preSelectAnnotationId", previewBack);//security
        var getElementSelect = document.getElementById(this.getId);
        var heightC: any = getElementSelect.getAttribute("height");
        var widthC: any = getElementSelect.getAttribute("width");
        if (this.previousSelectAnnotation.length == 0) {
          this.previousSelectAnnotation.push(this.getId);
          this.colorBorder(getElementSelect);
        }
        else if (this.previousSelectAnnotation[0] != this.getId) {
          let getPreviousElement = document.getElementById(this.getId);
          this.transparentBorder(getPreviousElement);
          this.previousSelectAnnotation = [];
          this.previousSelectAnnotation.push(this.getId);
          this.colorBorder(getElementSelect);
        }
        else if (this.previousSelectAnnotation[0] == this.getId) {
          this.colorBorder(getElementSelect);
        }
        console.log(this.clickAction);
        if (this.copyAnnotationCreatePageValue == false && this.showcopyAnnotationOption == false) {
          this.annotationSelected = true;
          this.optionClick = false;
          this.hideSelectForm = true;
          this.sampleFormObject = [];
          this.modelFieldsForm = [];
          this.extend_modelFieldsForm = [];
          var singleDataReceived;
          this.documentService.getSingleAnnotation(this.getId).subscribe((res) => {
            console.log(res);
            singleDataReceived = res["response_body"][0];

            for (var k = 0; k < this.layerDatas.length; k++) {
              if (this.activeLayerIdDraw == this.layerDatas[k].layer_id) {
                let itemIndex = this.layerDatas[k].annotations.findIndex(item => item.annotation_id == singleDataReceived.annotation_id);
                this.layerDatas[k].annotations.splice(itemIndex, 1, singleDataReceived);
                console.log(this.layerDatas[k].annotations[itemIndex]);
                console.log(this.layerDatas);
                let currentData: any = singleDataReceived;
                this.currentSelectedAnnotationData = singleDataReceived;
                this.cdRef.detectChanges();
                this.formsheaderCanvas("headerCanvasForms", singleDataReceived, 'annotationLabelForms');
                if (this.properties == true) {
                  this.formsheaderCanvas("propertyCanvasPreview", singleDataReceived, 'annotationLabelPreview');
                }
                this.propertiesannotationData = currentData;
                this.propertiesannotationDataCopy = _.cloneDeep(currentData);
                // this.toolbarElementId = singleDataReceived.toolbar_element_id;
                console.log(singleDataReceived.annotation_media)
                if (singleDataReceived.annotation_media.length > 0) {
                  //this.sampleFormObject = singleDataReceived.annotation_media;
                  this.globalMediaCount(singleDataReceived.annotation_media, 'media');
                }
                else if (singleDataReceived.annotation_media.length == 0) {
                  this.sampleFormObject = [];
                }
                if (singleDataReceived.annotation_forms.length > 0) {
                  let formlength = singleDataReceived.annotation_forms.length;
                  let sortedForms = singleDataReceived.annotation_forms.sort((a, b) => (a.last_updated_date != undefined ? a.last_updated_date : a.created_date).localeCompare(
                    b.last_updated_date != undefined ? b.last_updated_date : b.created_date));
                  this.currentFormId = sortedForms[sortedForms.length - 1].form_id;
                  this.currentFormName = sortedForms[sortedForms.length - 1].form_name;
                  this.currentFormHiddenStatus = JSON.parse(sortedForms[sortedForms.length - 1].is_hidden);
                  this.modelFieldsForm = getFormById(this.layerDatas, singleDataReceived.annotation_id, sortedForms[sortedForms.length - 1].form_id);
                  this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                  var editedForm1 = this.formList.filter((ele => ele.form_id == this.currentFormId))
                  var editedForm = _.cloneDeep(editedForm1);
                  //var formjsonStringyfy = JSON.stringify(editedForm[0].form_data)
                  var newFormDataFelds;
                  if (Array.isArray(editedForm[0].form_data) == false) {
                    newFormDataFelds = JSON.parse(editedForm[0].form_data)
                  } else {
                    newFormDataFelds = editedForm[0].form_data
                  }
                  this.modelFieldsForm.forEach(element => {
                    var FieldFind = newFormDataFelds.filter(ele => ele['element_uuid'] == element['element_uuid']);
                    if (FieldFind.length > 0) {
                      if (FieldFind[0].element_type == 'single_choice' || FieldFind[0].element_type == 'dropdown') {
                        this.cdRef.detectChanges()
                        FieldFind[0].element_data.options.forEach(element1 => {
                          element1.default = false
                        });
                        var defaultOptionValue: any;
                        if (element.element_data.hasOwnProperty('options')) {
                          defaultOptionValue = element.element_data.options.filter((ele => ele.default == true))
                        }
                        if (defaultOptionValue != undefined && defaultOptionValue.length > 0) {
                          var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == defaultOptionValue[0].element_uuid))
                          currentOption[0].default = true;
                        }
                      } else if (FieldFind[0].element_type == 'multiple_choice' || FieldFind[0].element_type == 'checkbox') {
                        FieldFind[0].element_data.options.forEach(element1 => {
                          element1.default = false
                        });
                        var UCitemDefault: any;
                        if (element.element_data.hasOwnProperty('options')) {
                          UCitemDefault = element.element_data.options.filter((ele => ele.default == true))
                        }

                        if (UCitemDefault != undefined) {
                          UCitemDefault.forEach(element2 => {
                            var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == element2.element_uuid))
                            currentOption[0].default = true;
                          });
                        }
                      } else if (FieldFind[0].element_type == 'address') {

                        FieldFind[0].element_data.element_data.street_address1 = element.element_data.street_address1
                        FieldFind[0].element_data.element_data.city = element.element_data["city"]
                        FieldFind[0].element_data.element_data.state = element.element_data["state"]
                        FieldFind[0].element_data.element_data.zip = element.element_data["zip"]
                        FieldFind[0].element_data.element_data.street_address2 = element.element_data.street_address2
                      } else if (FieldFind[0].element_type == 'uti-entry-field') {
                        FieldFind[0].element_data.default_values = element.element_data['default_values']
                      } else {
                        FieldFind[0].element_data.default_value = element.element_data.default_value
                      }
                    }
                  })

                  editedForm[0].form_data = newFormDataFelds
                  var formfieldIndex = singleDataReceived.annotation_forms.findIndex((ele => ele.form_id == this.currentFormId))
                  singleDataReceived.annotation_forms.splice(formfieldIndex, 1, editedForm[0]);
                  this.modelFieldsForm = editedForm[0].form_data;
                  this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
                  this.undoDatataForForms = _.cloneDeep(editedForm[0].form_data);
                  this.usecaseCopyArray = _.cloneDeep(editedForm[0].form_data);
                  this.process_use_conditions();
                  this.FormulaCalc();
                  if (this.modelFieldsForm.length > 0) {
                    for (let v = 0; v < this.modelFieldsForm.length; v++) {
                      if (this.modelFieldsForm[v].element_type == "uti-entry-field") {
                        this.outputArray = []
                        this.finalArray1 = []
                        var fff = this.modelFieldsForm[v].element_data["fields"];
                        for (let k = 0; k < this.modelFieldsForm[v].element_data['fields'].length; k++) {
                          if (this.modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                            for (let j = 0; j < this.modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                              this.outputArray.push({ 'id': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                            }
                          }
                        }
                        this.elementFields = this.modelFieldsForm[v].element_data['fields']
                        if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                          if (this.modelFieldsForm[v].element_data['default_values'] != "") {
                            this.finalArray = this.modelFieldsForm[v].element_data['default_values']
                            this.displayArryChange(this.modelFieldsForm[v].element_data['fields'], this.modelFieldsForm[v].element_data['default_values'])
                          }
                        }
                      }
                      if (this.modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                        this.totalElementQuantity = Number(this.modelFieldsForm[v].element_data.default_value);
                        this.htmlcalculation();
                      }
                      if (this.modelFieldsForm[v].element_type == "date") {
                        if (this.modelFieldsForm[v].element_data.default_date_time != "") {
                          if (this.modelFieldsForm[v].element_data.default_date_time == "none" || this.modelFieldsForm[v].element_data.default_date_time == "current") {
                            this.modelFieldsForm[v].element_data.default_value = this.assignDates(this.modelFieldsForm[v].element_data.default_date_time)
                          } else {
                            this.modelFieldsForm[v].element_data.default_value = new Date(this.modelFieldsForm[v].element_data.default_date_time).toISOString();
                          }
                        }
                      }
                    }
                  }
                  console.log(this.currentFormId, sortedForms, this.currentFormName);
                }
                else if (singleDataReceived.annotation_forms.length == 0) {
                  this.currentFormName = "";
                }
                console.log(this.propertiesannotationData);

                this.formCount = singleDataReceived.annotation_forms.length;
                //this.mediaCount = singleDataReceived.annotation_media.length;
                this.globalMediaCount(singleDataReceived.annotation_media, 'media')
                this.globalMediaCount(singleDataReceived.annotation_links, 'links')
                //this.linkCount = singleDataReceived.annotation_links.length;
                if (singleDataReceived.annotation_tags.toString() != "") {
                  let tempAnnotationtags = singleDataReceived.annotation_tags.toString();
                  this.tagCount = tempAnnotationtags.split(",").length;
                  console.log(this.tagCount);
                }
                else if (singleDataReceived.annotation_tags.toString() == "") {
                  this.tagCount = 0;
                }
                this.annotNameAnnotation = this.propertiesannotationData["annotation_name"];
                this.propertiesannotationDataString = this.propertiesannotationData["annotation_data"];
                this.annotLabelAnnotation = this.propertiesannotationData["annotation_label"];
                this.degree = singleDataReceived.initial_rotation;
                this.opacityValue = this.propertiesannotationData["opacity"];
                this.backupOpacity = _.cloneDeep(this.propertiesannotationData["opacity"]);
                this.annotShapeAnnotation = this.ShapeNameGet(this.propertiesannotationData["toolbar_element_id"]);
                this.lineWidth = Number(this.propertiesannotationData["Line_width"]).toFixed(2);
                this.backupLinewidth = _.cloneDeep(this.propertiesannotationData["line_width"]);
                var createdDates = this.propertiesannotationData["created_date"];
                this.createdDate = this.datePipe.transform(createdDates, "MM/dd/yyyy");
                this.createdtime = this.datePipe.transform(createdDates, "hh:mm aa");
                console.log(this.createdtime)
                var modifiedDates = this.propertiesannotationData["last_updated_date"];
                this.modifiedDate = this.datePipe.transform(modifiedDates, "MM/dd/yyyy");
                this.modifytime = this.datePipe.transform(modifiedDates, "hh:mm aa");
                let elementId = parseInt(this.propertiesannotationData["toolbar_element_id"]);
                if (elementId < 12) {
                  let x = parseFloat(this.propertiesannotationData["initial_position_x"]);
                  let lessBoxWidth = x - 119;
                  this.optionPositionX = lessBoxWidth;
                  console.log(lessBoxWidth);
                  let y = parseFloat(this.propertiesannotationData["initial_position_y"]);
                  let lessBoxHeight = y - 52;
                  this.optionPositionY = lessBoxHeight;
                  console.log(lessBoxHeight);
                }
                else if (elementId > 11) {
                  let x = parseFloat(this.propertiesannotationData["initial_position_x"]);
                  let lessBoxWidth: any = x - 119;
                  let addWidth = lessBoxWidth + widthC / 2;
                  this.optionPositionX = addWidth;
                  this.optionPositionY = parseFloat(this.propertiesannotationData["initial_position_y"]);
                  let y = parseFloat(this.propertiesannotationData["initial_position_y"]);
                  let lessBoxHeight = y - 42;
                  this.optionPositionY = lessBoxHeight;
                }
                // initial height for area
                this.initialHeight = this.propertiesannotationData["initial_height"];
                if (this.initialHeight == "" || this.initialWidth == 0) {
                  this.initialHeight = 50;
                }
                //initial width for length
                this.initialWidth = this.propertiesannotationData["initial_width"];
                if (this.initialWidth == "" || this.initialWidth == 0) {
                  this.initialWidth = 50;
                }
                var checkActiveorNot = 0;
                if (this.getScaleValue != undefined && this.getScaleValue.length > 0) {
                  for (var i = 0; i < this.getScaleValue.length; i++) {
                    if (
                      this.currentPageId == this.getScaleValue[i].page_id
                    ) {
                      this.initialWidth =
                        (this.getScaleValue[i].scaleValue * 10) /
                        this.initialWidth;
                      this.initialHeight =
                        (this.getScaleValue[i].scaleValue * 10) /
                        this.initialHeight;
                      this.areaValue = this.checkShapes(
                        this.propertiesannotationData["toolbar_element_id"],
                        this.initialWidth,
                        this.initialHeight
                      );
                      this.areaValue = parseInt(this.areaValue);
                      checkActiveorNot = 1;
                    }
                  }
                }
                if (checkActiveorNot != 1) {
                  this.initialHeight = this.propertiesannotationData[
                    "initial_height"
                  ];
                  if (this.initialHeight == "" || this.initialWidth == 0) {
                    this.initialHeight = 50;
                  }
                  //initial width for length
                  this.initialWidth = this.propertiesannotationData[
                    "initial_width"
                  ];
                  if (this.initialWidth == "" || this.initialWidth == 0) {
                    this.initialWidth = 50;
                  }
                  this.areaValue = this.checkShapes(
                    this.propertiesannotationData["toolbar_element_id"],
                    this.initialWidth,
                    this.initialHeight
                  );
                  this.areaValue = parseInt(this.areaValue);
                }
                if (this.media == true) {
                  this.mediaIconClick();
                }
                else if (this.links == true) {
                  this.linkIconClick();
                }
                else if (this.tags == true) {
                  this.tagIconClick();
                }
                else if (this.properties == true) {
                  this.propertyIconClick();
                }
              }
            }
          });
        }
      }
    }


  }

  checkShapes(elementId, length, height) {
    console.log(elementId, length, height);
    switch (elementId) {
      case 1:
        //"circle"
        return (((Math.PI * length) / 2) * length) / 2;
      case 2:
        //                "octagon"
        return 2 * (1 + Math.sqrt(2)) * (length * length);
      case 3:
        //                "square"
        return length * length;
      case 4:
        //                "triangle"
        return (length * height) / 2;
      case 5:
        //                "star"
        return length * length;
      case 6:
        //                "diamond"
        return length * length;
      case 7:
        //"flag"
        return length * length;
      case 8:
        //                "camera"
        return length * length;
      case 9:
        //                "arrow"
        return length * length;
      case 10:
        //                "callout"
        return length * length;
      case 11:
        //                "text"
        return length * length;
      case 12:
        //                "freehand_line"
        return length * length;
      case 13:
        //                "polyline_arrow"
        return length * length;
      case 14:
        //                "polyline"
        return length * length;
      case 15:
        //                "line"
        return length * length;
      case 16:
        //                "line_axial"
        return length * length;
      case 17:
        //                "freehand_area"
        return length * length;
      case 18:
        //                "polygon"
        return length * length;
      case 19:
        //                "ellipse"
        return (((Math.PI * length) / 2) * height) / 2;
      case 20:
        //                "rectangle"
        return length * height;
    }
  }
  //LongPress Functionlity implemented Area End
  public propertycanvasElement: CanvasRenderingContext2D;
  propertiesShapeDraw(getData) {
    console.log(getData);
    this.coordinateX = getData.initial_position_x;
    this.coordinateY = getData.initial_position_y;
    if (this.coordinateX < 0 && this.coordinateY < 0) {
      this.coordinateX = -this.coordinateX;
      this.coordinateY = -this.coordinateY;
      this.show = false;
    }
    var annotationLabel = getData.annotation_label;
    var elementId = getData.toolbar_element_id;
    var getallelement = document.querySelectorAll("canvas");
    // for(let i=0;i<getallelement.length;i++){
    //   if(getallelement[i].getAttribute("customePropertyPreview")!=null){
    //     getallelement[i].remove();
    //   }
    // }
    const pdfImg = document.getElementById("propertyCanvasPreview");
    console.log(pdfImg);
    // if (pdfImg != null && pdfImg.firstChild != null) {
    //   console.log('removed');
    //   pdfImg.removeChild(pdfImg.firstChild);
    // }
    if (pdfImg != null && pdfImg.hasChildNodes() != null) {
      console.log('removed');
      pdfImg.removeChild(pdfImg.firstChild);
    }
    console.log(pdfImg);
    let getannotationLabelElement = document.querySelectorAll("p");
    if (getannotationLabelElement.length > 0) {
      for (var al = 0; al < getannotationLabelElement.length; al++) {
        if (getannotationLabelElement[al].getAttribute("annotationLabelPreview") != null) {
          getannotationLabelElement[al].remove();
        }
      }
    }
    var newcreatedElement = document.createElement("canvas");
    if (elementId < 12) {
      newcreatedElement.setAttribute("width", "50");
      newcreatedElement.setAttribute("height", "50");
      newcreatedElement.style.height = "50px";
      newcreatedElement.style.marginTop = "4px";
    }
    newcreatedElement.setAttribute("customePropertyPreview", "1");
    newcreatedElement.setAttribute("id", "customePropertyPreview1");
    // newcreatedElement.style.opacity = getData.opacity;
    if (getData.initial_rotation == undefined) {
      newcreatedElement.style.transform = "rotate(" + 0 + "deg)";
    } else if (getData.initial_rotation != undefined) {
      newcreatedElement.style.transform =
        "rotate(" + getData.initial_rotation + "deg)";
    }
    // var removepolygonDraw = document.querySelectorAll("canvas");
    // for (var i = 0; i < removepolygonDraw.length; i++) {
    //   if (
    //     removepolygonDraw[i].getAttribute("customeformheaderattribute") != null
    //   ) {
    //     removepolygonDraw[i].remove();
    //   }
    // }
    // newcreatedElement.setAttribute("customeformheaderattribute", "1");
    if (getData.toolbar_element_id == 1 || getData.toolbar_element_id == 8) {
      newcreatedElement.style.marginTop = "8px";
    }
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    if (elementId >= 12) {
      let scaleValueX = 0.8;
      let scaleValueY = 0.8;
      let newwidth = 50;
      let newheight = 50;
      if (getData.initial_width > 50 || getData.initial_height > 50) {
        if ((getData.initial_width > 100 || getData.initial_height > 100) && (getData.initial_width < 200 && getData.initial_height < 200)) {
          console.log('width 100 +');
          newwidth = getData.initial_width * 0.3;
          newheight = getData.initial_height * 0.3;
          scaleValueX = 0.3;
        }
        else if (getData.initial_width > 200 || getData.initial_height > 200) {
          console.log('width 200 +');
          newwidth = getData.initial_width * 0.2;
          newheight = getData.initial_height * 0.2;
          scaleValueX = 0.2;
        }
        else {
          console.log('width 100 below');
          newwidth = getData.initial_width * 0.5;
          newheight = getData.initial_height * 0.5;
          scaleValueX = 0.5;
          if (newwidth < 10 && newheight < 10) {
            newwidth = newwidth + 20;
            newheight = newheight + 20;
            scaleValueX = 0.7;
          }
          else if (newwidth < 20 && newheight < 20) {
            newwidth = newwidth + 10;
            newheight = newheight + 10;
            scaleValueX = 0.6;
          }
        }
      }
      else {
        console.log('width 100 below');
        newwidth = getData.initial_width * 0.5;
        newheight = getData.initial_height * 0.5;
        scaleValueX = 0.5;
        if (newwidth < 10 && newheight < 10) {
          newwidth = newwidth + 20;
          newheight = newheight + 20;
          scaleValueX = 0.7;
        }
        else if (newwidth < 20 && newheight < 20) {
          newwidth = newwidth + 10;
          newheight = newheight + 10;
          scaleValueX = 0.6;
        }
      }
      console.log(getData.initial_height, getData.initial_width, scaleValueX, scaleValueY, newwidth, newheight);
      newwidth = newwidth + 6;
      newheight = newheight + 6;
      this.canvasElement.canvas.width = newwidth > 50 ? 48 : newwidth + 2;
      this.canvasElement.canvas.height = newheight > 50 ? 48 : newheight + 2;
      this.canvasElement.scale(scaleValueX, scaleValueX);
      console.log(getData.line_width);
      this.canvasElement.textAlign = "center";
    }
    if (getData.annotation_label != "") {
      this.annotationLabelBackground(getData, "propertyCanvasPreview", 'annotationLabelPreview');
    }
    //   const img = new Image()
    //   img.src = this.imgUrl;
    //   img.onload = () => {
    //   this.canvasElement.drawImage(img, 0, 0,600,450);
    //   }

    this.canvasElement.beginPath();
    this.canvasElement.globalAlpha = this.opacityValue;
    getData.annotation_data = getData.annotation_data.trim();
    var spaceSplit = getData.annotation_data.split(" ");

    var previous = { x: 0, y: 0 };
    var current = { x: 0, y: 0 };
    var a = 0;
    var last_mousex = this.coordinateX;
    var last_mousey = this.coordinateY;
    var mousex = 0;
    var mousey = 0;
    var cpx = 0;
    var cpy = 0;
    let cp1x = 0;
    let cp1y = 0;
    let cp2x = 0;
    let cp2y = 0;
    let cx = 0;
    let cy = 0;
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");
      for (var j = 0; j < hypenSplit.length; j++) {
        var colonSplit = hypenSplit[j].split(":");
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint" &&
          hypenSplit[0] != "drawRect" &&
          hypenSplit[0] != "controlpoint1" &&
          hypenSplit[0] != "controlpoint2" &&
          hypenSplit[0] != "endCurve"
        ) {
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var w = parseFloat(colonSplit[2]);
          var h = parseFloat(colonSplit[3]);
          switch (hypenSplit[0]) {
            case "move":
              if (elementId != 20) {
                if (
                  getData.toolbar_element_id >= 12 &&
                  getData.toolbar_element_id <= 20
                ) {
                  this.canvasElement.moveTo(
                    x - this.coordinateX + 3,
                    y - this.coordinateY + 3
                  );
                }

                else {
                  this.canvasElement.moveTo(x, y);
                }
                if (elementId == 13 && j == 1) {
                  previous.x = x - this.coordinateX;
                  previous.y = y - this.coordinateY;
                  a++;
                }
              }
              break;
            case "line":
              this.canvasElement.clearRect(
                0,
                0,
                newcreatedElement.width,
                newcreatedElement.height
              );
              if (elementId != 20) {
                if (
                  getData.toolbar_element_id >= 12 &&
                  getData.toolbar_element_id <= 20
                ) {
                  this.canvasElement.lineTo(
                    x - this.coordinateX + 3,
                    y - this.coordinateY + 3
                  );
                }
                else {
                  this.canvasElement.lineTo(x, y);
                }
                // this.canvasElement.lineTo(x-this.coordinateX, y-this.coordinateY);
                if ((elementId == 13 && previous.x != 0 && previous.y != 0) && (spaceSplit.length - 1 == i) && (j == 1)) {
                  console.log(elementId);
                  current.x = x - this.coordinateX + 3;
                  current.y = y - this.coordinateY + 3;
                  var dx = current.x - previous.x;
                  var dy = current.y - previous.y;
                  var headlen = 15;
                  var angle = Math.atan2(dy, dx);
                  var length = Math.sqrt(dx * dx + dy * dy);
                  console.log(angle, dx, dy, current, previous)
                  this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height); //clear canvas
                  this.canvasElement.moveTo(current.x, current.y);
                  this.canvasElement.lineTo(current.x - headlen * Math.cos(angle - Math.PI / 4), current.y - headlen * Math.sin(angle - Math.PI / 4));
                  this.canvasElement.moveTo(current.x, current.y);
                  this.canvasElement.lineTo(current.x - headlen * Math.cos(angle + Math.PI / 4), current.y - headlen * Math.sin(angle + Math.PI / 4));
                  this.canvasElement.lineCap = "round";
                }
                else {
                  previous.x = x - this.coordinateX + 3;
                  previous.y = y - this.coordinateY + 3;
                }
              }
              break;
            case "ovalIn":
              if (elementId == 1 || elementId == 8) {
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.arc(
                  newcreatedElement.clientWidth / 2,
                  newcreatedElement.clientHeight / 2.3,
                  r,
                  0,
                  2 * Math.PI
                );
              } else if (elementId == 19) {
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.ellipse(
                  w / 2 + 5,
                  h / 2 + 5,
                  w / 2,
                  h / 2,
                  Math.PI * 1,
                  0,
                  2 * Math.PI
                );
              }
              break;
          }
        }
        else if (hypenSplit[0] == "controlpoint" || hypenSplit[0] == "curveEnd") {
          if (hypenSplit[0] == "controlpoint") {
            cpx = parseFloat(colonSplit[0]);
            cpy = parseFloat(colonSplit[1]);
          }
          if (hypenSplit[0] == "curveEnd") {
            var ex = parseFloat(colonSplit[0]);
            var ey = parseFloat(colonSplit[1]);

            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
          }
        }
        else if (hypenSplit[0] == "controlpoint1" || hypenSplit[0] == "controlpoint2" || hypenSplit[0] == "endCurve" && j == 1) {

          if (hypenSplit[0] == "controlpoint1") {
            cp1x = parseFloat(colonSplit[0]);
            cp1y = parseFloat(colonSplit[1]);
          }
          else if (hypenSplit[0] == "controlpoint2") {
            cp2x = parseFloat(colonSplit[0]);
            cp2y = parseFloat(colonSplit[1]);
          }
          else if (hypenSplit[0] == "endCurve") {
            cx = parseFloat(colonSplit[0]);
            cy = parseFloat(colonSplit[1]);
            this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);
            this.canvasElement.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, cx, cy);
          }
        }
        else if (hypenSplit[0] == "drawRect" && j == 1) {
          // let colonSplit = hypenSplit[j].split(":");
          let rectX = parseFloat(colonSplit[0]);
          let rectY = parseFloat(colonSplit[1]);
          let rectWidth = parseFloat(colonSplit[2]);
          let rectHeight = parseFloat(colonSplit[3]);
          this.canvasElement.clearRect(0, 0, rectWidth, rectHeight);
          this.canvasElement.rect(
            getData.initial_position_x - rectX + 5,
            getData.initial_position_y - rectY + 5,
            rectWidth,
            rectHeight);
          console.log(getData.line_width);
        }
        if (
          elementId != 12 &&
          elementId != 14 &&
          elementId != 13 &&
          elementId != 15
        ) {
          var checkFill = getData.fill_color;

          this.canvasElement.fillStyle = this.checkStrokeColor1(getData.fill_color);
          this.canvasElement.fill();
        }
        if ((elementId == 12 || elementId == 17 || elementId == 18) && (spaceSplit.length - 1 == i) && (j == 1)) {
          console.log(elementId);
          this.canvasElement.closePath();
        }
        // this.canvasElement.drawImage(newcreatedElement,0,0,50,50,0,0,10,50);
        let linewidth = _.cloneDeep(this.lineWidth);
        this.canvasElement.lineWidth = this.globalLineWidth(linewidth);
        if (elementId == 15 || elementId == 16 || elementId == 13 || elementId == 14 && getData.line_width != 0 && getData.line_width / 5 < 3) {
          this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width) + 2;
        }
        this.canvasElement.strokeStyle = this.checkStrokeColor1(getData.stroke_color);

        this.canvasElement.stroke();
      }
    }
  }
  // property

  checkStrokeColor1(checkStroke) {
    if (checkStroke.includes("#")) {
      if (checkStroke == "#NNNNNN00") {
        return "transparent";
      } else {
        return checkStroke;
      }
    }
    else {
      checkStroke = checkStroke.toLowerCase();
      switch (checkStroke) {
        case "blue":
          return "#002F5F";
        case "red":
          return "#BC0900";
        case "orange":
          return "#F48F00";
        case "yellow":
          return "#FFFF00";
        case "green":
          return "#98D133";
        case "default_blue":
          return "#015ECD";
        case "purple":
          return "#6C2EA7";
        case "pink":
          return "#DF1ED3";
        case "dark_pink":
          return "#C832B1";
        case "light_blue":
          return "#80F1FE";
        case "magenta":
          return "#C832B1";
        case "cyan":
          return "#80F1FE";
        case "brown":
          return "#7C4E40";
        case "grey":
          return "#949494";
        case "gray":
          return "#949494";
        case "medium_grey":
          return "#CCCCCC";
        case "light_grey":
          return "#000000";
        case "black":
          return "#000000";
        case "dark gray":
          return "#949494";
        case "light gray":
          return "#CCCCCC";
        case "white":
          return "#FFFFFF";
        case "clear":
          return "transparent";
        case "":
          return "transparent";
        default:
          return "#002F5F";
      }
    }
  }

  numformValuesUpdate(item, value, addressCheck) {
    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    if (item.element_data.maximum_value != "" && item.element_data.maximum_value != null) {
      if (Number(item.element_data.maximum_value) < Number(value)) {
        item.element_data.default_value = ""

      } else if (item.element_data.minimum_value != "" && item.element_data.minimum_value != null) {
        if (Number(item.element_data.minimum_value) > Number(value)) {
          item.element_data.default_value = ""
        } else {
          item.element_data.default_value = value
        }
      } else {
        item.element_data.default_value = value
      }
    }
    item.element_data.default_value = item.element_data.default_value.toString();
    if (this.createDocumentStore.custom_form_datas != undefined && this.createDocumentStore.custom_form_datas != null && this.createDocumentStore.custom_form_datas.length > 0) {
      let find_custom_form_values = this.createDocumentStore.custom_form_datas.findIndex((numberfield) => numberfield.element_uuid == item.element_uuid);
      if (find_custom_form_values > -1) {
        this.createDocumentStore.custom_form_datas[find_custom_form_values].element_data.default_value = item.element_data.default_value.toString();

      }
    }
    // if (value == null) {
    //   item.element_data.default_value = "";
    // } else if(item.element_data.minimum_value  != "" || item.element_data.maximum_value!="")  {

    // }

    // if(Number(value) >= Number(item.element_data.minimum_value) && Number(value) <=Number(item.element_data.maximum_value) ) {

    //   item.element_data.default_value = value.toString();
    // }

    // else {
    //   item.element_data.default_value = "";
    // }
    item.element_data.last_modified_date = new Date().toISOString();
    item.element_data.default_value = item.element_data.default_value;
    this.formValuesUpdate(item, item.element_uuid, item.element_data.default_value, addressCheck);
  }



  attibutesValueChange(currentOption, get_currentAnnotation) {
    let getDeepClone = _.cloneDeep(get_currentAnnotation);
    let currentAnnotation = get_currentAnnotation;
    console.log(currentAnnotation);
    var annoDataChange = "";
    var annotChangeShapeName = "";
    var toolbarNameCheck = currentOption.icon;
    let toolbarElementId = 1;
    let makeOriginalPropertyJson: any = {
      annotation_data: "", fill_color: "", line_width: 5,
      opacity: 1, stroke_color: "", toolbar_id: 1
    };
    console.log(toolbarNameCheck);
    if (toolbarNameCheck == "Circle") {
      annoDataChange = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
      annotChangeShapeName = "Circle";
      toolbarElementId = 1;
    } else if (toolbarNameCheck == "Octagon") {
      annoDataChange = "move-15:25 line-18:18 line-25:15 line-32:18 line-35:25 line-32:32 line-25:35 line-18:32 line-15:25 line-18:18";
      annotChangeShapeName = "Octagon";
      toolbarElementId = 2;
    } else if (toolbarNameCheck == "Square") {
      annoDataChange = "move-15:15 line-35:15 line-35:35 line-15:35 line-15:15 line-35:15";
      annotChangeShapeName = "Square";
      toolbarElementId = 3;
    } else if (toolbarNameCheck == "Triangle") {
      annoDataChange = "move-25:15 line-35:35 line-15:35 line-25:15 line-35:35";
      annotChangeShapeName = "Triangle";
      toolbarElementId = 4;
    } else if (toolbarNameCheck == "Star") {
      annoDataChange = "move-25:12 line-30:22 line-38:22 line-32:30 line-35:40 line-25:34 line-15:40 line-18:30 line-12:22 line-20:22 line-25:12 line-30:22";
      annotChangeShapeName = "Star";
      toolbarElementId = 5;
    } else if (toolbarNameCheck == "Diamond") {
      annoDataChange = "move-25:15 line-32.5:25 line-25:35 line-17.5:25 line-25:15 line-32.5:25";
      annotChangeShapeName = "Diamond";
      toolbarElementId = 6;
    }
    else if (toolbarNameCheck == "Flag") {
      annoDataChange = "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-17:25 line-17:40 line-15:40 line-15:15";
      annotChangeShapeName = "Flag";
      toolbarElementId = 7;
    } else if (toolbarNameCheck == "Camera") {
      annoDataChange = "move-31:22 controlpoint1-31:25.3137 controlpoint2-28.3137:28 endCurve-25:28 controlpoint1-21.6863:28 controlpoint2-19:25.3137 endCurve-19:22 controlpoint1-19:18.6863 controlpoint2-21.6863:16 endCurve-25:16 controlpoint1-28.3137:16 controlpoint2-31:18.6863 endCurve-31:22 move-17.5:15 line-19.5:12.5 line-30.5:12.5 line-32.5:15 line-36:15 controlpoint-38:15 curveEnd-38:17 line-38:29 controlpoint-38:31 curveEnd-36:31 line-14:31 controlpoint-12:31 curveEnd-12:29 line-12:17 controlpoint-12:15 curveEnd-14:15 line-17.5:15 line-19.5:12.5 move-14:19 line-16:19 line-16:20 line-14:20 move-22:22 controlpoint-22:19 curveEnd-25:19 controlpoint-28:19 curveEnd-28:22 controlpoint-28:25 curveEnd-25:25 controlpoint-22.5:25 curveEnd-22:22";
      annotChangeShapeName = "Camera";
      toolbarElementId = 8;
    } else if (toolbarNameCheck == "Arrow" || toolbarNameCheck == "Right Wide Arrow") {
      annoDataChange = "move-10:22.5 line-25:22.5 line-25:15 line-40:25 line-25:35 line-25:27.5 line-10:27.5 line-10:22.5 line-25:22.5"
      annotChangeShapeName = "Arrow";
      toolbarElementId = 9;
    }
    if (currentOption.icon != "" && currentOption.icon != "0" && currentOption.icon != "No Change") {
      makeOriginalPropertyJson.annotation_data = getDeepClone.annotation_data;
      // let getWidthHeightRA = this.shapeService1.getCanvaswidthandHeight(getDeepClone);
      let initial_width_value = Number(getDeepClone.initial_width);
      let initial_height_value = Number(getDeepClone.initial_height);
      // simple shape only shape change accessible form attributes so allow simple shpaes only
      if (initial_width_value != 0 && initial_height_value != 0) {
        let shape_width = initial_width_value;
        let shape_height = initial_height_value;
        let current_string = JSON.parse(JSON.stringify(annoDataChange));
        let annotationData = this.changeShapeStringForBaseicon(100, shape_width, shape_height, current_string);
        let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id: toolbarElementId, annotation_data: annotationData });
        let changed_shape_data = this.changeShapePositionsInsideCanvas(annotationData, 100, getShapeStringWidth)
        annoDataChange = changed_shape_data.annotationData;
        console.log(annoDataChange);
      }
      currentAnnotation.annotation_data = annoDataChange;
    }
    if (currentOption.fill_color != undefined && currentOption.fill_color != "") {
      makeOriginalPropertyJson.fill_color = getDeepClone.fill_color;
      currentAnnotation.fill_color = this.checkStrokeColor1(currentOption.fill_color);
    }
    else {
      makeOriginalPropertyJson.fill_color = getDeepClone.fill_color;
    }
    if (currentOption.stroke_color != undefined && currentOption.stroke_color != "") {
      makeOriginalPropertyJson.stroke_color = getDeepClone.stroke_color;
      currentAnnotation.stroke_color = this.checkStrokeColor1(currentOption.stroke_color);
    }
    //The below line(else condition) is added for ticket number P3X-1096.It is added for storing the stroke color for original property of current annotation.
    else {
      makeOriginalPropertyJson.stroke_color = getDeepClone.stroke_color;
    }
    if (currentOption.opacity != undefined && currentOption.opacity != "") {
      makeOriginalPropertyJson.opacity = getDeepClone.opacity;
      currentAnnotation.opacity = currentOption.opacity;
    }
    else {
      makeOriginalPropertyJson.opacity = getDeepClone.opacity;
    }
    if (currentOption.line_width != undefined && currentOption.line_width != "") {
      makeOriginalPropertyJson.line_width = getDeepClone.line_width;
      currentAnnotation.line_width = currentOption.line_width;
    }
    else if (currentOption.line_width == 0) {
      makeOriginalPropertyJson.line_width = getDeepClone.line_width;
    }
    else {
      makeOriginalPropertyJson.line_width = getDeepClone.line_width;
    }
    makeOriginalPropertyJson.toolbar_id = getDeepClone.toolbar_element_id;
    currentAnnotation.toolbar_element_id = toolbarElementId;
    if (getDeepClone.original_property == undefined || getDeepClone.original_property == "") {
    
      currentAnnotation.original_property = makeOriginalPropertyJson;
    }
    return currentAnnotation;
  }

  attibutesValueChangeForEmptyShape(currentOption, get_currentAnnotation) {
    let getDeepClone = _.cloneDeep(get_currentAnnotation);
    let currentAnnotation = get_currentAnnotation;
    console.log(currentAnnotation);
    let makeOriginalPropertyJson: any = {
      annotation_data: "", fill_color: "", line_width: 5,
      opacity: 1, stroke_color: "", toolbar_id: 1,
    };
    makeOriginalPropertyJson.annotation_data = getDeepClone.annotation_data;
    if (currentOption.fill_color != undefined && currentOption.fill_color != "") {
      makeOriginalPropertyJson.fill_color = getDeepClone.fill_color;
      currentAnnotation.fill_color = this.checkStrokeColor1(currentOption.fill_color);
    }
    else {
      makeOriginalPropertyJson.fill_color = getDeepClone.fill_color;
    }
    if (currentOption.stroke_color != undefined && currentOption.stroke_color != "") {
      makeOriginalPropertyJson.stroke_color = getDeepClone.stroke_color;
      currentAnnotation.stroke_color = this.checkStrokeColor1(currentOption.stroke_color);
    }
    //The below line(else condition) is added for ticket number P3X-1096.It is added for storing the stroke color for original property of current annotation.
    else {
      makeOriginalPropertyJson.stroke_color = getDeepClone.stroke_color;
    }
    if (currentOption.opacity != undefined && currentOption.opacity != "") {
      makeOriginalPropertyJson.opacity = getDeepClone.opacity;
      currentAnnotation.opacity = currentOption.opacity;
    }
    else {
      makeOriginalPropertyJson.opacity = getDeepClone.opacity;
    }
    if (currentOption.line_width != undefined && currentOption.line_width != "") {
      makeOriginalPropertyJson.line_width = getDeepClone.line_width;
      currentAnnotation.line_width = currentOption.line_width;
    }
    else if (currentOption.line_width == 0) {
      makeOriginalPropertyJson.line_width = getDeepClone.line_width;
    }
    else {
      makeOriginalPropertyJson.line_width = getDeepClone.line_width;
    }

    // console.log(getDeepClone)
    //  currentAnnotation.opacity = 1;
    // currentAnnotation.line_width = currentOption.line_width;
    // currentAnnotation.toolbar_element_id = toolbarElementId;
    makeOriginalPropertyJson.toolbar_id = getDeepClone.toolbar_element_id;
    if (currentAnnotation.original_property == undefined || currentAnnotation.original_property == "") {
  
      currentAnnotation.original_property = makeOriginalPropertyJson;
    }
    return currentAnnotation;
  }


  async formValuesUpdate(item, elementUUID, value, addressCheck,target?) {
    console.log(this.usecaseCopyArray)
    console.log(this.extend_modelFieldsForm)
    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    if (this.multipleSelectOn == false) {
      this.useConditionChange(item, elementUUID, value, addressCheck)
      let layers = [];
      if (this.layerDatas != undefined) {

        for (var i = 0; i < this.layerDatas.length; i++) {
    
          let currentAnnotationData = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
          if (currentAnnotationData.length != 0) {
            var currentAnnotationFormData = currentAnnotationData.length > 0 ? currentAnnotationData[0].annotation_forms.filter((ele => ele.form_id == this.currentFormId)) : [];
            if (currentAnnotationData.length > 0 && currentAnnotationFormData.length == 0) {

              var editedForm1 = this.formList.filter((ele => ele.form_id == this.currentFormId))
              var editedForm = _.cloneDeep(editedForm1);
              var newFormDataFelds;
              var ext_newFormDataFelds;
              if (Array.isArray(editedForm[0].form_data) == false) {
                newFormDataFelds = JSON.parse(editedForm[0].form_data)
              } else {
                newFormDataFelds = editedForm[0].form_data
              }
              // this.undoDatataForForms = _.cloneDeep(newFormDataFelds);
              if (newFormDataFelds.length > 0) {
                newFormDataFelds = this.dataService4.formfieldviewcharacter(newFormDataFelds, 'annotationgetformview');
              }
              editedForm[0].form_data = newFormDataFelds;
              if (editedForm[0].hasOwnProperty('ext_form_data') && editedForm[0].ext_form_data != null) {
                if (Array.isArray(editedForm[0].ext_form_data) == false) {
                  ext_newFormDataFelds = JSON.parse(editedForm[0].ext_form_data)
                } else {
                  ext_newFormDataFelds = editedForm[0].ext_form_data
                }
                editedForm[0].ext_form_data = ext_newFormDataFelds;
              }

              // var utiDefaultCheck = editedForm[0].form_data.filter((ele => ele.element_type == "uti-entry-field"))
              // if (utiDefaultCheck[0].element_data.hasOwnProperty('default_values')) {
              //   if (utiDefaultCheck[0].element_data['default_values'] == "") {
              //     this.finalArray = []
              //   }
              // }else{
              //   this.finalArray = []
              // } 

              if (editedForm[0].form_data.length > 0) {
                for (let v = 0; v < editedForm[0].form_data.length; v++) {
                  if (editedForm[0].form_data[v].element_type == "date") {
                    if (editedForm[0].form_data[v].element_data.default_date_time != "") {
                      if (editedForm[0].form_data[v].element_data.default_date_time == "none" || editedForm[0].form_data[v].element_data.default_date_time == "current") {
                        //  editedForm[0].form_data[v].element_data.default_value = this.assignDates(editedForm[0].form_data[v].element_data.default_date_time)
                      } else {
                        editedForm[0].form_data[v].element_data.default_date_time = editedForm[0].form_data[v].element_data.default_date_time;
                      }
                    }
                  }
                }
              }
              editedForm[0].form_data.forEach(element => {
                if (element.element_uuid == item.element_uuid) {
                  if (element.element_type == "single_choice" || element.element_type == "dropdown" || element.element_type == "multiple_choice") {
                    element.element_data.options = item.element_data.options;
                  }
                }
              });

              if (this.is_extend == true) {
                if (editedForm[0].hasOwnProperty('ext_form_data')) {
                  editedForm[0].ext_form_data.forEach(element => {
                    if (element.element_uuid == item.element_uuid) {
                      if (element.element_type == "single_choice" || element.element_type == "dropdown" || element.element_type == "multiple_choice") {
                        element.element_data.options = item.element_data.options;
                      }
                    }
                  });
                }

                if (editedForm[0].ext_form_data.length > 0) {
                  for (let v = 0; v < editedForm[0].ext_form_data.length; v++) {
                    if (editedForm[0].ext_form_data[v].element_type == "date") {
                      if (editedForm[0].ext_form_data[v].element_data.default_date_time != "") {
                        if (editedForm[0].ext_form_data[v].element_data.default_date_time == "none" || editedForm[0].ext_form_data[v].element_data.default_date_time == "current") {
                          //  editedForm[0].ext_form_data[v].element_data.default_value = this.assignDates(editedForm[0].ext_form_data[v].element_data.default_date_time)
                        } else {
                          editedForm[0].ext_form_data[v].element_data.default_date_time = editedForm[0].ext_form_data[v].element_data.default_date_time;
                        }
                      }
                    }
                  }
                }

              }
              currentAnnotationData[0].annotation_forms.push(editedForm[0])
            }
            var currentAnnotationFormData = currentAnnotationData[0].annotation_forms.filter((ele => ele.form_id == this.currentFormId));
            if (currentAnnotationFormData.length > 0) {
              if (!Array.isArray(currentAnnotationFormData[0].form_data)) {
                currentAnnotationFormData[0].form_data = JSON.parse(currentAnnotationFormData[0].form_data)
              }
              if (currentAnnotationFormData[0].hasOwnProperty("ext_form_data") && !Array.isArray(currentAnnotationFormData[0].ext_form_data)) {
                currentAnnotationFormData[0].ext_form_data = JSON.parse(currentAnnotationFormData[0].ext_form_data)
              }
            }
            // currentAnnotationFormData[0].form_data = _.cloneDeep(this.usecaseCopyArray)
            var fieldFormData = currentAnnotationFormData[0].form_data.filter((ele => ele.element_uuid == elementUUID))
            let itemIndex = currentAnnotationFormData[0].form_data.findIndex(item => item.element_uuid == elementUUID);
            if (fieldFormData.length > 0) {
              let multiple_inspection = false;
              if (fieldFormData[0].element_type == "date") {
          
                let tempDate = value;
                if (tempDate != undefined && tempDate != "" && tempDate != "none") {
                  let convertDate = this.datePipe.transform(tempDate, "yyyy-MM-dd");
                  fieldFormData[0].element_data.default_date_time = convertDate;
                } else {
                  fieldFormData[0].element_data.default_date_time = "";
                }

              }
              else if (fieldFormData[0].element_type == "uti-entry-field") {
                console.log(currentAnnotationData[0])
                let current_annotation = currentAnnotationData[0]
                fieldFormData[0].element_data["default_values"] = value;
                if( fieldFormData[0].element_data["fields"] != undefined){
                  let fields_arr = fieldFormData[0].element_data["fields"]
                  fields_arr.forEach(element => {
                    if(value!=undefined && value.length!=0){
                      var index=value.length;
                      index=index-1;
                    }
                   if(value!=undefined &&  value.length!=0){
                    let element_value = value[index][element.element_uuid]
                    if(element_value != undefined){
                      let options = element.element_data.options;
                      console.log(options)
                      if(options!=undefined){
                        options.forEach(optionelem =>{
                          if (element_value == optionelem.element_uuid){
                            if(optionelem.name!="Not Counted?"){
                              current_annotation.fill_color = optionelem.fill_color
                            let cloneDeepShapeData = _.cloneDeep(current_annotation);
                            this.annotationClearDraw(cloneDeepShapeData);
                            }
                          }
                          
                        })
                      }
                    }
                   }
                   else if(value.length==0){
                    let cloneDeepShapeData = _.cloneDeep(current_annotation);
                    cloneDeepShapeData.fill_color = "blue"; 
                    cloneDeepShapeData.stroke_color = "blue";
                    current_annotation.fill_color = "blue";
                    current_annotation.stroke_color = "blue";
                    this.annotationClearDraw(cloneDeepShapeData);
                   }
                  });
                }
              }
              else if (fieldFormData[0].element_type == "uti-entry-field-WMATA" || fieldFormData[0].element_type == "uti-entry-field-TIMBER" ||
              fieldFormData[0].element_type == "uti-entry-field-WMATA_WELD") {
                if(fieldFormData[0].element_type == "uti-entry-field-WMATA_WELD" && fieldFormData[0].element_data.hasOwnProperty('default_values')
                && fieldFormData[0].element_data.default_values != undefined && fieldFormData[0].element_data.default_values.length > 0){
                  if(addressCheck == "delete"){
                    fieldFormData[0].element_data["default_values"] = [];
                    fieldFormData[0].element_data["default_values"] = value;
                    let index = this.modelFieldsForm.findIndex((id) => id.element_uuid == fieldFormData[0].element_uuid);
                    if(index != -1){
                      this.modelFieldsForm[index].element_data.default_values = value;
                    }
                  }
                  else{
                    const copyValue = value[0];
                    fieldFormData[0].element_data["default_values"].push(copyValue);
                  }
                  
                }
                else{
                  fieldFormData[0].element_data["default_values"] = value;
                }
                this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
              }
              else if (fieldFormData[0].element_type == "single_choice" || fieldFormData[0].element_type == "dropdown" && fieldFormData[0].element_data.options.length != undefined) {
                fieldFormData[0].element_data.options = item.element_data.options
                for (let ck = 0; ck < fieldFormData[0].element_data.options.length; ck++) {
                  if (fieldFormData[0].element_data.options[ck].default == true && fieldFormData[0].element_data.options[ck].attributes == true && value.element_uuid == fieldFormData[0].element_data.options[ck].element_uuid) {
                    let currentOption = fieldFormData[0].element_data.options[ck];
                    if(fieldFormData[0].special_form_attribute==true){
                      var filterElements = currentAnnotationFormData[0].form_data.filter((ele => ele.special_form_attribute == true));
                      var filterrr = filterElements.filter((ele => ele.element_type == "single_line_text"))
                      var final;
                      var label1 = filterrr[0].element_data.default_value;
                      if(target==-1){
                        final = label1;
                      }
                      else{
                        var removeBracket = currentOption.name.split("(");
                        var label = currentAnnotationFormData[0].form_data;
                        final = removeBracket[0] + label1;
                      }
                      currentAnnotationData[0].annotation_label = final;
                    }
                    let currentAnnotation = currentAnnotationData[0];
                    let currentOptionValue = value;
                    let current_form = currentAnnotation.annotation_forms.filter((data) => data.form_id == this.currentFormId);

                    if (current_form != null) {
                      if (this.is_extend == true && current_form[0].ext_form_data != null) {
                        let merge_forms = [...currentAnnotationFormData[0].form_data, ...currentAnnotationFormData[0].ext_form_data];
                        this.usecaseCopyArray = _.cloneDeep(merge_forms);
                      }
                      else {
                        this.usecaseCopyArray = current_form[0].form_data;
                      }
                    }
                    // if (Number(currentAnnotation.toolbar_element_id) > 10) {
                    //   currentOption.icon = "";
                    // }
                    currentAnnotationData[0] = await this.formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue);
                    // let getChangesAttributes = this.attibutesValueChange(fieldFormData[0].element_data.options[ck], currentAnnotationData[0]);
                    // 
                    // if(typeof getChangesAttributes.original_property=='object'){
                    //   currentAnnotationData[0] = getChangesAttributes;  
                    //   
                    //   let cloneDeepShapeData = _.cloneDeep(currentAnnotationData[0]);
                    //   this.annotationClearDraw(cloneDeepShapeData);
                    // }
                    // currentAnnotationData[0] = getChangesAttributes;
                  }
                  else if (value.element_uuid == fieldFormData[0].element_data.options[ck].element_uuid) {
                    let currentOption = fieldFormData[0].element_data.options[ck];
                    this.currentFormId
                    let currentAnnotation = currentAnnotationData[0];
                    if(fieldFormData[0].special_form_attribute==true){
                      var filterElements = currentAnnotationFormData[0].form_data.filter((ele => ele.special_form_attribute == true));
                      var filterrr = filterElements.filter((ele => ele.element_type == "single_line_text"))
                      var final;
                      var label1 = filterrr[0].element_data.default_value;
                      if(target==-1){
                        final = label1;
                      }
                      else{
                        var removeBracket = currentOption.name.split("(");
                        var label = currentAnnotationFormData[0].form_data;
                        final = removeBracket[0] + label1;
                      }
                      currentAnnotationData[0].annotation_label = final;
                      this.annotationClearDraw(currentAnnotationData[0]);
                    }
                    let current_form = currentAnnotation.annotation_forms.filter((data) => data.form_id == this.currentFormId);

                    if (current_form != null) {
                      if (this.is_extend == true && current_form[0].ext_form_data != null) {
                        let merge_forms = [...currentAnnotationFormData[0].form_data, ...currentAnnotationFormData[0].ext_form_data];
                        this.usecaseCopyArray = _.cloneDeep(merge_forms);
                      }
                      else {
                        this.usecaseCopyArray = current_form[0].form_data;
                      }
                    }
                    let currentOptionValue = value;
                    currentAnnotationData[0] = await this.formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue);
                  }
                  console.log(fieldFormData[0].element_data.options[ck].attributes == false, value.element_uuid == fieldFormData[0].element_data.options[ck].element_uuid);
                }
                fieldFormData[0].element_data.last_modified_date = new Date().toISOString();
              }
              else if (fieldFormData[0].element_type == "group_field") {
                fieldFormData[0].element_data.options = item.element_data.options
                for (let ck = 0; ck < fieldFormData[0].element_data.options.length; ck++) {
                   if (value.element_uuid == fieldFormData[0].element_data.options[ck].element_uuid) {
                    let currentOption = fieldFormData[0].element_data.options[ck];
                    let currentAnnotation = currentAnnotationData[0];
                    let current_form = currentAnnotation.annotation_forms.filter((data) => data.form_id == this.currentFormId);
                    if (current_form != null) {
                      if (this.is_extend == true && current_form[0].ext_form_data != null) {
                        let merge_forms = [...currentAnnotationFormData[0].form_data, ...currentAnnotationFormData[0].ext_form_data];
                        this.usecaseCopyArray = _.cloneDeep(merge_forms);
                      }
                      else {
                        this.usecaseCopyArray = current_form[0].form_data;

                      }
                    }
                  }
                }
                fieldFormData[0].element_data.last_modified_date = new Date().toISOString();
              }
              else if (fieldFormData[0].element_type == 'multiple_choice' || fieldFormData[0].element_type == 'checkbox') {
                fieldFormData[0].element_data["default_value"] = value.element_uuid;
                fieldFormData[0].element_data.options = item.element_data.options
                if (fieldFormData[0].element_type == 'checkbox' && fieldFormData[0].element_data.options[0].default == true && fieldFormData[0].element_data.options[0].attributes == true && value.element_uuid == fieldFormData[0].element_data.options[0].element_uuid) {
                  let find_custome_form_timber = currentAnnotationFormData[0].form_data.findIndex((field) => field.element_type == "uti-entry-field-TIMBER");
                  if (find_custome_form_timber > -1) {
                    // default true
                    if (fieldFormData[0].element_data.options[0].default == true) {
                      currentAnnotationData[0].fill_color = "#98D133";
                      let cloneDeepShapeData = _.cloneDeep(currentAnnotationData[0]);
                      await this.annotationClearDraw(cloneDeepShapeData);
                    }
                  }
                  else {
                    let currentOption = fieldFormData[0].element_data.options[0];
                    let currentAnnotation = currentAnnotationData[0];
                    let currentOptionValue = value;
                    // if (Number(currentAnnotation.toolbar_element_id) > 10) {
                    //   currentOption.icon = "";
                    // }
                    currentAnnotationData[0] = await this.formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue);
                  }
                }
                else if ((fieldFormData[0].element_type == 'checkbox') && value.element_uuid == fieldFormData[0].element_data.options[0].element_uuid) {
                  // timber form mean changes the fill color changes checkbox true and false
                  let find_custome_form_timber = currentAnnotationFormData[0].form_data.findIndex((field) => field.element_type == "uti-entry-field-TIMBER");
                  if (find_custome_form_timber > -1 && fieldFormData[0].element_data.options[0].attributes == true) {
                    // default true commented 
                    // if ( fieldFormData[0].element_data.options[0].default == true) {
                    //   currentAnnotationData[0].fill_color = "#98D133";
                    // let makeOriginalPropertyJson: any = {
                    //   annotation_data: currentAnnotationData[0].annotation_data, fill_color: "#BC0900", line_width: currentAnnotationData[0].line_width,
                    //   opacity: currentAnnotationData[0].opacity, stroke_color: currentAnnotationData[0].stroke_color,
                    //   toolbar_id: currentAnnotationData[0].toolbar_element_id, initial_position_x: currentAnnotationData[0].initial_position_x,
                    //   initial_position_y: currentAnnotationData[0].initial_position_y, initial_width: currentAnnotationData[0].initial_width,
                    //   initial_height: currentAnnotationData[0].initial_height
                    // };
                    // timber form changes stored json format
                    // currentAnnotationData[0].original_property = makeOriginalPropertyJson;
                    //   let cloneDeepShapeData = _.cloneDeep(currentAnnotationData[0]);
                    //   await this.annotationClearDraw(cloneDeepShapeData);
                    // }

                    // default false
                    if (fieldFormData[0].element_data.options[0].default == false) {
                      currentAnnotationData[0].fill_color = "#BC0900";
                      let cloneDeepShapeData = _.cloneDeep(currentAnnotationData[0]);
                      await this.annotationClearDraw(cloneDeepShapeData);
                    }
                  }
                  else {
                    let currentOption = fieldFormData[0].element_data.options[0];
                    let currentAnnotation = currentAnnotationData[0];
                    let currentOptionValue = value;
                    // if (Number(currentAnnotation.toolbar_element_id) > 10) {
                    //   currentOption.icon = "";
                    // }
                    currentAnnotationData[0] = await this.formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue);
                  }
                }
                else if (fieldFormData[0].element_type == 'multiple_choice' && fieldFormData[0].element_data.options[0].default == true && value.element_uuid == fieldFormData[0].element_data.options[0].element_uuid) {
                  let find_custome_form = currentAnnotationFormData[0].form_data.findIndex((field) => field.element_type == "uti-entry-field-WMATA");
                  if (find_custome_form > -1 && fieldFormData[0].element_data.options[0].name != "Corner?") {
                    let shape = { icon: "Circle", fill_color: "#98D133", stroke_color: "#000000" };
                    let get_custom_element = currentAnnotationFormData[0].form_data[find_custome_form];
                    if ((get_custom_element.element_data.hasOwnProperty('default_values') && get_custom_element.element_data.default_values != undefined
                      && get_custom_element.element_data.default_values != "" && get_custom_element.element_data.default_values.length > 0) || this.finalArray2.length > 0) {
                      let get_first_array = this.finalArray2[0];
                      // stroke color red changes check
                      if (get_first_array.previouscondition == "" || get_first_array.previouscondition == "No") {
                        shape.stroke_color = "#BC0900";
                      }
                      else {
                        shape.stroke_color = "#000000";
                      }
                      // shape changes based on form entered values
                      if (get_first_array.flagforrReview == "Yes") {
                        shape.icon = "Star";
                      }
                      if ((get_first_array.flagforrReview == "" || get_first_array.flagforrReview == "No") && get_first_array.Condition != "" || get_first_array.previouscondition == "Yes") {
                        shape.icon = "Flag";
                      }

                      // fill color changes
                      let blue_color = ['NM - Not measured', 'NA - No access to anchor rod', 'SI - Indicates similar but opposite side; refers to WMATA anchor rod pattern'];
                      let red_color = ['FR - Full fracture of anchor rod', 'CR - Strong probability of crack development in anchor rod'];
                      let orange_color = ['NT - Anchor rod not tensioned (i.e. the hex nut was loose)', 'PC - Pitting corrosion', 'NO - Notch or thread', 'TN - Strong thread noise', 'TW - Tack weld on anchor rod', 'SP - Anchor rod contains spliced connection', 'UD - Undetermined discontinuity in anchor rod'];
                      let OT_color = ['OT - Other'];
                      if (get_first_array.Condition != "") {
                        if (blue_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#002F5F";
                        }
                        else if (red_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#BC0900";
                        }
                        else if (orange_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#F48F00";
                        }
                        else if (OT_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#DF1ED3";
                        }
                      }
                      else {
                        shape.fill_color = "#FFFF00";
                      }

                      // shape.stroke_color = "#BC0900";
                    }
                    else {
                      shape.fill_color = "#98D133";
                    }
                    let currentAnnotation = currentAnnotationData[0];
                    currentAnnotationData[0] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
                    multiple_inspection = true;
                  }
                  else if (fieldFormData[0].element_data.options[0].name == "Corner?") {
                    let shape = { icon: "Circle", fill_color: "#FFFF00", stroke_color: "#000000" };
                    let currentAnnotation = currentAnnotationData[0];
                    currentAnnotationData[0] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
                    multiple_inspection = true;
                  }
                }
                else if (fieldFormData[0].element_type == 'multiple_choice' && fieldFormData[0].element_data.options[0].default == false && value.element_uuid == fieldFormData[0].element_data.options[0].element_uuid) {
                  let find_custome_form = currentAnnotationFormData[0].form_data.findIndex((field) => (field.element_type == "uti-entry-field-WMATA"));
                  if (find_custome_form > -1) {
                    let custom_form_type = currentAnnotationFormData[0].form_data[find_custome_form].element_type;
                    if (custom_form_type == "uti-entry-field-WMATA") {
                      let shape = { icon: "Circle", fill_color: "#FFFF00", stroke_color: "#000000" };
                      let currentAnnotation = currentAnnotationData[0];
                      currentAnnotationData[0] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
                      multiple_inspection = true;
                    }
                  }
                }
              }
              else if (fieldFormData[0].element_type == 'address') {

                console.log(fieldFormData[0].element_data)
                if (addressCheck == 'city') {
                  fieldFormData[0].element_data.city = value;
                } else if (addressCheck == 'state') {
                  fieldFormData[0].element_data.state = value;
                } else if (addressCheck == 'zip') {
                  fieldFormData[0].element_data.zip = value;
                } else if (addressCheck == 'street_address1') {
                  fieldFormData[0].element_data.street_address1 = value;
                } else if (addressCheck == 'street_address2') {
                  fieldFormData[0].element_data.street_address2 = value;
                }
                //          else    if(addressCheck == 'city'){
                //           fieldFormData[0].element_data.element_data.city = value
                //            }    
                // fieldFormData[0].element_data.element_data.street_address1 = value.street_address1
                // fieldFormData[0].element_data.element_data.city = value["city"]
                // fieldFormData[0].element_data.element_data.state = value["state"]
                // fieldFormData[0].element_data.element_data.zip = value["zip"]
                // fieldFormData[0].element_data.element_data.street_address2 = value["street_address2"]
              }
              else {
                fieldFormData[0].element_data["default_value"] = value;
                if (fieldFormData[0].special_form_attribute == true) {
                  var filterElements = currentAnnotationFormData[0].form_data.filter((ele => ele.special_form_attribute == true));
                  var filterrr = filterElements.filter((ele => ele.element_type == "dropdown"));
                  var fil = filterrr[0].element_data.options.filter((ele => ele.default == true))
                  var add;
                  if(fil.length!=0){
                    let sp = fil[0].name.split("(")
                    let label1 = sp[0];
                    let label2 = value;
                    add = label1.concat(label2);
                  }
                  else{
                    add = value;
                  }
                  console.log(add)
                  currentAnnotationData[0].annotation_label = add;
                  console.log(currentAnnotationData[0]);
                  this.annotationClearDraw(currentAnnotationData[0]);
                }
              }
              let find_custome_form = currentAnnotationFormData[0].form_data.findIndex((field) => field.element_type == "uti-entry-field-WMATA");
              if (find_custome_form > -1 && multiple_inspection == false) {
                // if any update happened custom form shape should be changed circle and yellow fill color
                let find_custome_form = currentAnnotationFormData[0].form_data.findIndex((field) => field.element_type == "multiple_choice" && field.element_name == "Inspection Completed");
                if (find_custome_form > -1) {
                  let get_options = currentAnnotationFormData[0].form_data[find_custome_form].element_data.options;
                  if (get_options[0].default == true) {
                    let shape = { icon: "Circle", fill_color: "#98D133", stroke_color: "#000000" };
                    let get_custom_element = currentAnnotationFormData[0].form_data[find_custome_form];
                    if ((get_custom_element.element_data.hasOwnProperty('default_values') && get_custom_element.element_data.default_values != undefined
                      && get_custom_element.element_data.default_values != "" && get_custom_element.element_data.default_values.length > 0) || this.finalArray2.length > 0) {
                      let get_first_array = this.finalArray2[0];
                      // stroke color red changes check
                      if (get_first_array.previouscondition == "" || get_first_array.previouscondition == "No") {
                        shape.stroke_color = "#BC0900";
                      }
                      else {
                        shape.stroke_color = "#000000";
                      }
                      // shape changes based on form entered values
                      if (get_first_array.flagforrReview == "Yes") {
                        shape.icon = "Star";
                      }
                      else if ((get_first_array.flagforrReview == "" || get_first_array.flagforrReview == "No") && get_first_array.Condition != "" || get_first_array.previouscondition == "Yes") {
                        shape.icon = "Flag";
                      }
                      else if (get_first_array.flagforrReview == "" || get_first_array.flagforrReview == "No" && get_first_array.Condition == "") {
                        shape.icon = "Flag"
                      }
                      // fill color changes
                      let blue_color = ['NM - Not measured', 'NA - No access to anchor rod', 'SI - Indicates similar but opposite side; refers to WMATA anchor rod pattern'];
                      let red_color = ['FR - Full fracture of anchor rod', 'CR - Strong probability of crack development in anchor rod'];
                      let orange_color = ['NT - Anchor rod not tensioned (i.e. the hex nut was loose)', 'PC - Pitting corrosion', 'NO - Notch or thread', 'TN - Strong thread noise', 'TW - Tack weld on anchor rod', 'SP - Anchor rod contains spliced connection', 'UD - Undetermined discontinuity in anchor rod'];
                      let OT_color = ['OT - Other'];
                      if (get_first_array.Condition != "") {
                        if (blue_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#002F5F";
                        }
                        else if (red_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#BC0900";
                        }
                        else if (orange_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#F48F00";
                        }
                        else if (OT_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#DF1ED3";
                        }
                      }
                      else {
                        shape.fill_color = "#FFFF00";
                      }

                      // shape.stroke_color = "#BC0900";
                    }
                    else {
                      shape.fill_color = "#98D133";
                    }
                    let currentAnnotation = currentAnnotationData[0];
                    currentAnnotationData[0] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
                    multiple_inspection = true;
                  }
                  else {
                    let currentAnnotation = currentAnnotationData[0];
                    currentAnnotationData[0] = await this.formattributeChangesCustomWMATA(currentAnnotation);
                  }
                }
                else {
                  let currentAnnotation = currentAnnotationData[0];
                  currentAnnotationData[0] = await this.formattributeChangesCustomWMATA(currentAnnotation);
                }
              }
              fieldFormData[0].element_data.last_modified_date = new Date().toISOString();
              currentAnnotationFormData[0].last_updated_date = new Date().toISOString()
            }
            else if (this.is_extend == true) {
              if (currentAnnotationFormData[0].hasOwnProperty('ext_form_data')) {
                var ext_fieldFormData = currentAnnotationFormData[0].ext_form_data.filter((ele => ele.element_uuid == elementUUID))
                let ext_itemIndex = currentAnnotationFormData[0].ext_form_data.findIndex(item => item.element_uuid == elementUUID);
                if (ext_fieldFormData.length > 0) {
                  if (ext_fieldFormData[0].element_type == "date") {
                    let tempDate = value;
                    if (tempDate != undefined && tempDate != "" && tempDate != "none") {
                      let convertDate = this.datePipe.transform(tempDate, "yyyy-MM-dd");
                      ext_fieldFormData[0].element_data.default_date_time = convertDate;
                    } else {
                      ext_fieldFormData[0].element_data.default_date_time = "";
                    }
                  }
                  else if (ext_fieldFormData[0].element_type == "uti-entry-field") {
                    ext_fieldFormData[0].element_data["default_values"] = value;
                  }
                  else if (ext_fieldFormData[0].element_type == "uti-entry-field-WMATA" || ext_fieldFormData[0].element_type == "uti-entry-field-TIMBER") {
                    ext_fieldFormData[0].element_data["default_values"] = value;
                  }
                  else if (ext_fieldFormData[0].element_type == "single_choice" || ext_fieldFormData[0].element_type == "dropdown" || ext_fieldFormData[0].element_type == "group_field" && ext_fieldFormData[0].element_data.options.length != undefined) {
                    ext_fieldFormData[0].element_data.options = item.element_data.options
                    for (let ck = 0; ck < ext_fieldFormData[0].element_data.options.length; ck++) {
                      if (ext_fieldFormData[0].element_data.options[ck].default == true && ext_fieldFormData[0].element_data.options[ck].attributes == true && value.element_uuid == ext_fieldFormData[0].element_data.options[ck].element_uuid) {
                        let currentOption = ext_fieldFormData[0].element_data.options[ck];
                        let currentAnnotation = currentAnnotationData[0];
                        let currentOptionValue = value;
                        if (Number(currentAnnotation.toolbar_element_id) > 10) {
                          currentOption.icon = "";
                        }
                      if(ext_fieldFormData[0].element_type != "group_field"){
                        currentAnnotationData[0] = await this.formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue);
                        }
                        // let getChangesAttributes = this.attibutesValueChange(ext_fieldFormData[0].element_data.options[ck], currentAnnotationData[0]);
                        // 
                        // if(typeof getChangesAttributes.original_property=='object'){
                        //   currentAnnotationData[0] = getChangesAttributes;  
                        //   
                        //   let cloneDeepShapeData = _.cloneDeep(currentAnnotationData[0]);
                        //   this.annotationClearDraw(cloneDeepShapeData);
                        // }
                        // currentAnnotationData[0] = getChangesAttributes;
                      }
                      else if (value.element_uuid == ext_fieldFormData[0].element_data.options[ck].element_uuid) {
                        // 
                        // if (typeof currentAnnotationData[0].original_property == 'object') {
                        //   let getoriginalProperty = currentAnnotationData[0].original_property;
                        //   currentAnnotationData[0].annotation_data = getoriginalProperty.annotation_data;
                        //   currentAnnotationData[0].fill_color = getoriginalProperty.fill_color;
                        //   currentAnnotationData[0].stroke_color = getoriginalProperty.stroke_color;
                        //   currentAnnotationData[0].line_width = getoriginalProperty.line_width;
                        //   currentAnnotationData[0].toolbar_element_id = getoriginalProperty.toolbar_id;
                        //   currentAnnotationData[0].original_property = "";  
                        //   let cloneDeepShapeData = _.cloneDeep(currentAnnotationData[0]);
                        //   this.annotationClearDraw(cloneDeepShapeData);
                        // }
                        // currentAnnotationData[0] =  this.formattributeChangesDraw(ext_fieldFormData[0].element_data.options[ck],currentAnnotationData[0],value);
                        let currentOption = ext_fieldFormData[0].element_data.options[ck];
                        let currentAnnotation = currentAnnotationData[0];
                        let currentOptionValue = value;
                        if (Number(currentAnnotation.toolbar_element_id) > 10) {
                          currentOption.icon = "";
                        }
                        if(ext_fieldFormData[0].element_type != "group_field"){
                          currentAnnotationData[0] = await this.formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue);
                        }
                      }
                      console.log(ext_fieldFormData[0].element_data.options[ck].attributes == false, value.element_uuid == ext_fieldFormData[0].element_data.options[ck].element_uuid);
                    }
                    ext_fieldFormData[0].element_data.last_modified_date = new Date().toISOString();
                  } else if (ext_fieldFormData[0].element_type == 'multiple_choice' || ext_fieldFormData[0].element_type == 'checkbox') {
                    ext_fieldFormData[0].element_data["default_value"] = value.element_uuid;
                    ext_fieldFormData[0].element_data.options = item.element_data.options
                    if (ext_fieldFormData[0].element_type == 'checkbox' && ext_fieldFormData[0].element_data.options[0].default == true && ext_fieldFormData[0].element_data.options[0].attributes == true && value.element_uuid == ext_fieldFormData[0].element_data.options[0].element_uuid) {
                      let currentOption = ext_fieldFormData[0].element_data.options[0];
                      let currentAnnotation = currentAnnotationData[0];
                      let currentOptionValue = value;
                      if (Number(currentAnnotation.toolbar_element_id) > 10) {
                        currentOption.icon = "";
                      }
                      currentAnnotationData[0] = await this.formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue);
                    }
                    else if (ext_fieldFormData[0].element_type == 'checkbox' && value.element_uuid == ext_fieldFormData[0].element_data.options[0].element_uuid) {
                      let currentOption = ext_fieldFormData[0].element_data.options[0];
                      let currentAnnotation = currentAnnotationData[0];
                      let currentOptionValue = value;
                      if (Number(currentAnnotation.toolbar_element_id) > 10) {
                        currentOption.icon = "";
                      }
                      currentAnnotationData[0] = await this.formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue);
                    }
                  } else if (ext_fieldFormData[0].element_type == 'address') {

                    console.log(ext_fieldFormData[0].element_data)
                    if (addressCheck == 'city') {
                      ext_fieldFormData[0].element_data.city = value;
                    } else if (addressCheck == 'state') {
                      ext_fieldFormData[0].element_data.state = value;
                    } else if (addressCheck == 'zip') {
                      ext_fieldFormData[0].element_data.zip = value;
                    } else if (addressCheck == 'street_address2') {
                      ext_fieldFormData[0].element_data.street_address2 = value;
                    } else if (addressCheck == 'street_address1') {
                      ext_fieldFormData[0].element_data.street_address1 = value;
                    }
                    //          else    if(addressCheck == 'city'){
                    //           ext_fieldFormData[0].element_data.element_data.city = value
                    //            }    
                    // ext_fieldFormData[0].element_data.element_data.street_address1 = value.street_address1
                    // ext_fieldFormData[0].element_data.element_data.city = value["city"]
                    // ext_fieldFormData[0].element_data.element_data.state = value["state"]
                    // ext_fieldFormData[0].element_data.element_data.zip = value["zip"]
                    // ext_fieldFormData[0].element_data.element_data.street_address2 = value["street_address2"]
                  } else {
                    ext_fieldFormData[0].element_data["default_value"] = value;
                  }
                  ext_fieldFormData[0].element_data.last_modified_date = new Date().toISOString();
                  currentAnnotationFormData[0].last_updated_date = new Date().toISOString()
                }
                if (currentAnnotationFormData[0].hasOwnProperty('ext_form_data')) {
                  currentAnnotationFormData[0].ext_form_data.ext_itemIndex = ext_fieldFormData;
                }
              }
              //ext_fieldFormData[0].element_type != "group_field" && 

            }

            // currentAnnotationFormData[0].form_data.splice(itemIndex,1,fieldFormData[0])
            if(fieldFormData.length > 0 && fieldFormData[0].element_type != "group_field"){
              currentAnnotationFormData[0].form_data.itemIndex = fieldFormData;
            }
            //this.modelFieldsForm = currentAnnotationFormData[0].form_data;
            this.newFormData = currentAnnotationFormData[0];
            this.newFormData.last_updated_date = new Date().toISOString();
            this.formCount = currentAnnotationFormData.length;
            if (this.is_extend == true) {
              let merge_forms = [...currentAnnotationFormData[0].form_data, ...currentAnnotationFormData[0].ext_form_data]
              this.usecaseCopyArray = _.cloneDeep(merge_forms);

            } else {
              this.usecaseCopyArray = _.cloneDeep(currentAnnotationFormData[0].form_data);
            }
            // this.useConditionChange(item, elementUUID, value, addressCheck);
            layers.push(this.layerDatas[i]);
          }
        }
      }
    }
    else if (this.multipleSelectOn == true) {
      this.useCaseEmptycellIds = []
      //To check whether we need to add from start or need to append with already existing values in array.
      if(item.element_type == "uti-entry-field-WMATA_WELD"){
        if(item.element_data.hasOwnProperty('default_values') && item.element_data.default_values != undefined
        && item.element_data.default_values.length > 0){
          addressCheck = "add";
        }
      }
      //  this.formCount = this.needUpdateFormCount;
      this.formCount = 0;
      let form_builder_form_data = null;
      var editedForm = this.formListDefaultValues.filter((ele => ele.form_id == this.currentFormId))
      var editedForm1 = _.cloneDeep(editedForm);
      if (editedForm1.length > 0) {
        if (typeof editedForm1[0].form_data === 'string' || editedForm1[0].form_data instanceof String) {
          editedForm1[0].form_data = JSON.parse(editedForm1[0].form_data)
        }
        form_builder_form_data = _.cloneDeep(editedForm1[0].form_data);
      }

      if (this.multiselectionList.length > 0) {
        for (let maf = 0; maf < this.multiselectionList.length; maf++) {
          let multiple_inspection = false;
          let get_annotation_form = this.multiselectionList[maf].annotation_forms;
          let filter_current_Index = get_annotation_form.findIndex((forms) => forms.form_id == this.currentFormId);
          if (filter_current_Index > -1) {
            let get_form_data = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data;
            let check_form_uuid_index = get_form_data.findIndex((form_data_a) => form_data_a.element_uuid == elementUUID);

            if (this.is_extend == true && this.multiselectionList[maf].annotation_forms[filter_current_Index].hasOwnProperty('ext_form_data')) {
              if (this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data == null || this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data.length == 0) {
                this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data = this.extend_modelFieldsForm;
              }
              let temp_extend = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data;
              if (temp_extend != null) {
                if (typeof temp_extend === 'string') {
                  temp_extend = JSON.parse(temp_extend);
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data = temp_extend;
                }
              }
            }
            // form fields in or not 
            // 1 in if condtion
            // 2 not else condtion
            var ext_temp_current_changes;
            var temp_current_changes
            if (check_form_uuid_index > -1) {
              // common value changes function written
              let get_field = get_form_data[check_form_uuid_index];
              if (get_field.element_type != "multiple_choice" && get_field.element_type != "single_choice" && get_field.element_type != "checkbox"
                && get_field.element_type != "dropdown" && get_field.element_type != "group_field" && get_field.element_type != "date" && get_field.element_type != "address"
                && get_field.element_type != "uti-entry-field-WMATA" && get_field.element_type != "uti-entry-field-TIMBER" && get_field.element_type != "uti-entry-field"
                && get_field.element_type != "uti-entry-field-WMATA_WELD") {
                this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.default_value = value;
                if(get_field.special_form_attribute == true && get_field.element_type == "single_line_text") {
                  var filterElements = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.filter((ele => ele.special_form_attribute == true));
                  var filterrr = filterElements.filter((ele => ele.element_type == "dropdown"));
                  var fil = filterrr[0].element_data.options.filter((ele => ele.default == true))
                  let currentAnnotation = this.multiselectionList[maf];
                  var add;
                  if(fil.length!=0){
                    let sp = fil[0].name.split("(")
                    let label1 = sp[0];
                    let label2 = value;
                    add = label1.concat(label2);
                  }
                  else{
                    add = value;
                  }
                  console.log(add)
                  currentAnnotation.annotation_label=add;
                  console.log(currentAnnotation);
                  this.annotationClearDraw(currentAnnotation);
                } 
              }
              else if (get_field.element_type == "multiple_choice") {
                let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options;
                if (get_options != undefined) {
                  let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
                  if (get_selected_option_index > -1) {
                    this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
                  }
                }
                if (get_options != undefined && get_options[0].default == true && value.element_uuid == get_options[0].element_uuid) {
                  // find custom form type
                  let find_custome_form_index = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((field) => field.element_type == "uti-entry-field-WMATA");
                  if (find_custome_form_index > -1) {
                    let custom_form_type = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[find_custome_form_index].element_type;
                    if (custom_form_type == "uti-entry-field-WMATA") {
                      let find_custome_form = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[find_custome_form_index];
                      if (find_custome_form > -1 && this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[0].name != "Corner?") {
                        let shape = { icon: "Circle", fill_color: "#98D133", stroke_color: "#000000" };
                        let get_custom_element = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index];
                        if ((get_custom_element.element_data.hasOwnProperty('default_values') && get_custom_element.element_data.default_values != undefined
                          && get_custom_element.element_data.default_values != "" && get_custom_element.element_data.default_values.length > 0) || this.finalArray2.length > 0) {
                          let get_first_array = this.finalArray2[0];
                          // stroke color red changes check
                          if (get_first_array.previouscondition == "") {
                            shape.stroke_color = "#BC0900";
                          }
                          else {
                            shape.stroke_color = "#000000";
                          }
                          // shape changes based on form entered values
                          if (get_first_array.flagforrReview == "Yes") {
                            shape.icon = "Star";
                          }
                          if ((get_first_array.flagforrReview == "" || get_first_array.flagforrReview == "No") && get_first_array.Condition != "") {
                            shape.icon = "Flag";
                          }
                          // fill color changes
                          let blue_color = ['NM - Not measured', 'NA - No access to anchor rod', 'SI - Indicates similar but opposite side; refers to WMATA anchor rod pattern'];
                          let red_color = ['FR - Full fracture of anchor rod', 'CR - Strong probability of crack development in anchor rod'];
                          let orange_color = ['NT - Anchor rod not tensioned (i.e. the hex nut was loose)', 'PC - Pitting corrosion', 'NO - Notch or thread', 'TN - Strong thread noise', 'TW - Tack weld on anchor rod', 'SP - Anchor rod contains spliced connection', 'UD - Undetermined discontinuity in anchor rod'];
                          let OT_color = ['OT - Other'];
                          if (get_first_array.Condition != "") {
                            if (blue_color.includes(get_first_array.Condition)) {
                              shape.fill_color = "#002F5F";
                            }
                            else if (red_color.includes(get_first_array.Condition)) {
                              shape.fill_color = "#BC0900";
                            }
                            else if (orange_color.includes(get_first_array.Condition)) {
                              shape.fill_color = "#F48F00";
                            }
                            else if (OT_color.includes(get_first_array.Condition)) {
                              shape.fill_color = "#DF1ED3";
                            }
                          }
                          else {
                            shape.fill_color = "#FFFF00";
                          }

                          // shape.stroke_color = "#BC0900";
                        }
                        else {
                          shape.fill_color = "#98D133";
                        }
                        let currentAnnotation = this.multiselectionList[maf];
                        this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
                        multiple_inspection = true;
                      }
                      else if (this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[0].name == "Corner?") {
                        let shape = { icon: "Circle", fill_color: "#FFFF00", stroke_color: "#000000" };
                        let currentAnnotation = this.multiselectionList[maf];
                        this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
                        multiple_inspection = true;
                      }
                    }
                  }
                }
                else if (get_options != undefined && get_options[0].default == false && value.element_uuid == get_options[0].element_uuid) {
                  let find_custome_form_index = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((field) => field.element_type == "uti-entry-field-WMATA");
                  if (find_custome_form_index > -1) {
                    let custom_form_type = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[find_custome_form_index].element_type;
                    if (custom_form_type == "uti-entry-field-WMATA") {
                      let shape = { icon: "Circle", fill_color: "#FFFF00", stroke_color: "#000000" };
                      let currentAnnotation = this.multiselectionList[maf];
                      this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
                      multiple_inspection = true;
                    }
                  }

                }
              }
              // else if(get_field.element_type == 'multiple_choice' && get_field.element_data.options[0].default == false && value.element_uuid == get_field.element_data.options[0].element_uuid){
              //   let shape = {icon:"Circle",fill_color:"#FFFF00",stroke_color:"#000000"};
              //   let currentAnnotation = this.multiselectionList[maf];
              //   this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
              //   multiple_inspection = true;
              // }              
              else if (get_field.element_type == "checkbox") {
                let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options;
                let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
                if (get_selected_option_index > -1) {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
                  // timber form mean changes the fill color changes checkbox true and false
                  let find_custome_form_timber = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((field) => field.element_type == "uti-entry-field-TIMBER");
                  let get_current_option_timber = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index];
                  if (find_custome_form_timber > -1 && get_current_option_timber.attributes == true) {
                    // default true
                    if (get_current_option_timber.default == true) {
                      this.multiselectionList[maf].fill_color = "#98D133";
                      let cloneDeepShapeData = _.cloneDeep(this.multiselectionList[maf]);
                      await this.annotationClearDraw(cloneDeepShapeData);
                    }
                    // default false
                    else if (get_current_option_timber.default == false) {
                      this.multiselectionList[maf].fill_color = "#BC0900";
                      let cloneDeepShapeData = _.cloneDeep(this.multiselectionList[maf]);
                      await this.annotationClearDraw(cloneDeepShapeData);
                    }
                  }
                  else {
                    let currentAnnotation_multiple = this.multiselectionList[maf];
                    let currentOptionValue_multiple = _.cloneDeep(value);
                    if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
                      currentOptionValue_multiple.icon = "";
                    }
                    this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
                  }
                }
              }
              else if (get_field.element_type == "single_choice" || get_field.element_type == "dropdown" || get_field.element_type == "group_field") {
                let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options;
                for (let k = 0; k < get_options.length; k++) {
                  if (get_options[k].element_uuid == value.element_uuid) {
                    get_options[k].default = value.default
                  }
                  else {
                    get_options[k].default = false;
                  }
                }
                let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
                if (get_selected_option_index > -1) {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
                  // check draw form attributes
                  let get_option_attributes = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index];
                  if (get_option_attributes.default == true && get_option_attributes.attributes == true) {
                    let currentOption_multiple = get_option_attributes;
                    let currentAnnotation_multiple = this.multiselectionList[maf];
                    let currentOptionValue_multiple = _.cloneDeep(value);
                    if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
                      currentOptionValue_multiple.icon = "";
                    }
                    let form_annotations = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
                    this.multiselectionList[maf] = form_annotations
                  }
                  else {
                    let currentOption_multiple = get_option_attributes;
                    let currentAnnotation_multiple = this.multiselectionList[maf];
                    let currentOptionValue_multiple = _.cloneDeep(value);
                    if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
                      currentOptionValue_multiple.icon = "";
                    }
                    var specialformCheck = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].special_form_attribute;
                    if(specialformCheck == true){
                      var filterElements = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.filter((ele => ele.special_form_attribute == true));
                      var filterrr = filterElements.filter((ele => ele.element_type == "single_line_text"))
                      var label1 = filterrr[0].element_data.default_value;
                      let current_annotation = this.multiselectionList[maf];
                      var final;
                      if(target==-1){
                        final = label1;
                      }
                      else{
                        var removeBracket=currentOption_multiple.name.split("(")
                        final = removeBracket[0] + label1;
                      }
                      current_annotation.annotation_label = final;
                      this.annotationClearDraw(current_annotation);
                      console.log(current_annotation)
                    }
                    let form_annotations = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
                    this.multiselectionList[maf] = form_annotations
                  }
                }
              }
              else if (get_field.element_type == "date") {

                let tempDate = value;
                if (tempDate != undefined && tempDate != "" && tempDate != "none") {
                  let convertDate = this.datePipe.transform(tempDate, "yyyy-MM-dd");
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.default_date_time = convertDate;
                } else {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.default_date_time = "";
                }
              }
              else if (get_field.element_type == "address" && addressCheck == 'city') {
                this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.city = value;
              }
              else if (get_field.element_type == "address" && addressCheck == 'state') {
                this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.state = value;
              }
              else if (get_field.element_type == "address" && addressCheck == 'street_address1') {
                this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.street_address1 = value;
              }
              else if (get_field.element_type == "address" && addressCheck == 'street_address2') {
                this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.street_address2 = value;
              }
              else if (get_field.element_type == "address" && addressCheck == 'zip') {
                this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.zip = value;
              }
              else if (get_field.element_type == "uti-entry-field-WMATA" || get_field.element_type == "uti-entry-field-TIMBER" || get_field.element_type=="uti-entry-field"
              || get_field.element_type == "uti-entry-field-WMATA_WELD") {
                if(get_field.element_data.hasOwnProperty('default_values')
                && get_field.element_data.default_values != undefined && get_field.element_data.default_values.length > 0){
                  if(addressCheck == "add"){
                    const copyValue = value[0];
                    get_field.element_data["default_values"].push(copyValue);
                  }
                  else if(addressCheck == "delete"){
                    get_field.element_data["default_values"] = [];
                    get_field.element_data["default_values"] = value;
                    console.log(this.modelFieldsForm)
                  }
                  else {
                    this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data["default_values"] = value;
                  }
                  // else{
                  //   const copyValue = value[0];
                  //   get_field.element_data["default_values"].push(copyValue);
                  // }
                }
                else{
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data["default_values"] = value;
                }
                this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
              }
              let find_form_data = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data;

              console.log(find_form_data)
              let find_custome_form_ficap = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((multiplefield) => multiplefield.element_type == "uti-entry-field");
              if(find_custome_form_ficap>-1){
                 let find_form = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[find_custome_form_ficap];
                 let current_annotation = this.multiselectionList[maf];
                 if( find_form.element_data["fields"] != undefined){
                  let fields_arr = find_form.element_data["fields"]
                  fields_arr.forEach(element => {
                    if(Array.isArray(value) == true){
                      if(value!=undefined && value.length!=0){
                        var index=value.length;
                        index=index-1;
                        var element_value = value[index][element.element_uuid]
                      }
                    }
                    else{
                      var element_value = value.element_uuid
                    }
                    if(element_value != undefined){
                      let options = element.element_data.options;
                      console.log(options)
                      if(options!=undefined){
                        options.forEach(optionelem =>{
                          if (element_value == optionelem.element_uuid){
                            if(optionelem.name!="Not Counted?"){
                              current_annotation.fill_color = optionelem.fill_color
                            let cloneDeepShapeData = _.cloneDeep(current_annotation);
                            this.annotationClearDraw(cloneDeepShapeData);
                            }
                          }
                        })
                      }
                    }
                  });
                 }
              }
              let find_custome_form = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((multiplefield) => multiplefield.element_type == "uti-entry-field-WMATA");
              if (find_custome_form > -1 && multiple_inspection == false) {
                // if any update happened custom form shape should be changed circle and yellow fill color
                let find_custome_form = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((multiplefield_1) => multiplefield_1.element_type == "multiple_choice" && multiplefield_1.element_name == "Inspection Completed");
                if (find_custome_form > -1) {
                  let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[find_custome_form].element_data.options;
                  if (get_options[0].default == true) {
                    let shape = { icon: "Circle", fill_color: "#98D133", stroke_color: "#000000" };
                    let get_custom_element = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[find_custome_form];
                    if ((get_custom_element.element_data.hasOwnProperty('default_values') && get_custom_element.element_data.default_values != undefined
                      && get_custom_element.element_data.default_values != "" && get_custom_element.element_data.default_values.length > 0) || this.finalArray2.length > 0) {
                      let get_first_array = this.finalArray2[0];
                      // stroke color red changes check
                      if (get_first_array.previouscondition == "") {
                        shape.stroke_color = "#BC0900";
                      }
                      else {
                        shape.stroke_color = "#000000";
                      }
                      // shape changes based on form entered values
                      if (get_first_array.flagforrReview == "Yes") {
                        shape.icon = "Star";
                      }
                      if ((get_first_array.flagforrReview == "" || get_first_array.flagforrReview == "No") && get_first_array.Condition != "") {
                        shape.icon = "Flag";
                      }
                      // fill color changes
                      let blue_color = ['NM - Not measured', 'NA - No access to anchor rod', 'SI - Indicates similar but opposite side; refers to WMATA anchor rod pattern'];
                      let red_color = ['FR - Full fracture of anchor rod', 'CR - Strong probability of crack development in anchor rod'];
                      let orange_color = ['NT - Anchor rod not tensioned (i.e. the hex nut was loose)', 'PC - Pitting corrosion', 'NO - Notch or thread', 'TN - Strong thread noise', 'TW - Tack weld on anchor rod', 'SP - Anchor rod contains spliced connection', 'UD - Undetermined discontinuity in anchor rod'];
                      let OT_color = ['OT - Other'];
                      if (get_first_array.Condition != "") {
                        if (blue_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#002F5F";
                        }
                        else if (red_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#BC0900";
                        }
                        else if (orange_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#F48F00";
                        }
                        else if (OT_color.includes(get_first_array.Condition)) {
                          shape.fill_color = "#DF1ED3";
                        }
                      }
                      else {
                        shape.fill_color = "#FFFF00";
                      }

                      // shape.stroke_color = "#BC0900";
                    }
                    else {
                      shape.fill_color = "#98D133";
                    }
                    let currentAnnotation = this.multiselectionList[maf];
                    this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
                  }
                  else {
                    let currentAnnotation = this.multiselectionList[maf];
                    this.multiselectionList[maf] = await this.formattributeChangesCustomWMATA(currentAnnotation);
                  }
                }
                else {
                  let currentAnnotation = this.multiselectionList[maf];
                  this.multiselectionList[maf] = await this.formattributeChangesCustomWMATA(currentAnnotation);
                }
              }
              this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.last_modified_date = new Date().toISOString();
              temp_current_changes = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data;
              // attaching when they using only form_data secction
              if (this.is_extend == true) {
                if (this.multiselectionList[maf].annotation_forms[filter_current_Index].hasOwnProperty('ext_form_data')) {
                  ext_temp_current_changes = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data;
                  if (ext_temp_current_changes != null && ext_temp_current_changes.length > 0) {
                    if (typeof ext_temp_current_changes === 'string') {
                      ext_temp_current_changes = JSON.parse(ext_temp_current_changes);
                    }
                  } else {
                    ext_temp_current_changes = this.extend_modelFieldsForm;
                  }
                } else {
                  ext_temp_current_changes = this.extend_modelFieldsForm;
                }
              }
              console.log(temp_current_changes);

            }
            else if (this.is_extend == true && this.multiselectionList[maf].annotation_forms[filter_current_Index].hasOwnProperty('ext_form_data')) {
              let get_form_data = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data;
              if (typeof get_form_data === 'string') {
                get_form_data = JSON.parse(get_form_data);
              }
              let check_form_uuid_index = get_form_data.findIndex((form_data_a) => form_data_a.element_uuid == elementUUID);
              if (this.is_extend == true) {
                let temp_extend = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data;
                if (temp_extend != null) {
                  if (typeof temp_extend === 'string') {
                    temp_extend = JSON.parse(temp_extend);
                    this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data = temp_extend;
                  }
                }
              }
              if (check_form_uuid_index > -1) {
                // common value changes function written
                let get_field = get_form_data[check_form_uuid_index];
                if (get_field.element_type != "multiple_choice" && get_field.element_type != "single_choice" && get_field.element_type != "checkbox"
                  && get_field.element_type != "dropdown" && get_field.element_type != "date" && get_field.element_type != "address" &&  get_field.element_type != "group_field") {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.default_value = value;
                }
                else if (get_field.element_type == "multiple_choice") {
                  let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options;
                  let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
                  if (get_selected_option_index > -1) {
                    this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
                    let currentAnnotation_multiple = this.multiselectionList[maf];
                    let currentOptionValue_multiple = value;
                    this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
                  }
                }
                else if (get_field.element_type == "checkbox") {
                  let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options;
                  let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
                  if (get_selected_option_index > -1) {
                    this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
                    let currentAnnotation_multiple = this.multiselectionList[maf];
                    let currentOptionValue_multiple = _.cloneDeep(value);
                    if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
                      currentOptionValue_multiple.icon = "";
                    }
                    this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
                  }
                }
                else if (get_field.element_type == "single_choice" || get_field.element_type == "dropdown" || get_field.element_type == "group_field") {
                  let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options;
                  for (let k = 0; k < get_options.length; k++) {
                    if (get_options[k].element_uuid == value.element_uuid) {
                      get_options[k].default = value.default
                    }
                    else {
                      get_options[k].default = false;
                    }
                  }
                  let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
                  if (get_selected_option_index > -1) {
                    this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
                    // check draw form attributes
                    let get_option_attributes = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options[get_selected_option_index];
                    if (get_option_attributes.default == true && get_option_attributes.attributes == true) {
                      let currentOption_multiple = get_option_attributes;
                      let currentAnnotation_multiple = this.multiselectionList[maf];
                      let currentOptionValue_multiple = _.cloneDeep(value);
                      if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
                        currentOptionValue_multiple.icon = "";
                      }
                      let form_annotations = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
                      this.multiselectionList[maf] = form_annotations
                    }
                    else {
                      let currentOption_multiple = get_option_attributes;
                      let currentAnnotation_multiple = this.multiselectionList[maf];
                      let currentOptionValue_multiple = _.cloneDeep(value);
                      if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
                        currentOptionValue_multiple.icon = "";
                      }
                      if(get_field.element_type != "group_field"){
                        let form_annotations = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
                        this.multiselectionList[maf] = form_annotations//this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
                      }
                    }
                  }
                }
                else if (get_field.element_type == "date") {

                  let tempDate = value;
                  if (tempDate != undefined && tempDate != "" && tempDate != "none") {
                    let convertDate = this.datePipe.transform(tempDate, "yyyy-MM-dd");
                    this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.default_date_time = convertDate;
                  } else {
                    this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.default_date_time = "";
                  }
                }
                else if (get_field.element_type == "address" && addressCheck == 'city') {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.city = value;
                }
                else if (get_field.element_type == "address" && addressCheck == 'state') {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.state = value;
                }
                else if (get_field.element_type == "address" && addressCheck == 'street_address1') {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.street_address1 = value;
                }
                else if (get_field.element_type == "address" && addressCheck == 'street_address2') {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.street_address2 = value;
                }
                else if (get_field.element_type == "address" && addressCheck == 'zip') {
                  this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.zip = value;
                }
                this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.last_modified_date = new Date().toISOString();
                ext_temp_current_changes = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data;
                temp_current_changes = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data
                console.log(temp_current_changes);

              }
            }
            if (this.is_extend == true) {
              if(temp_current_changes!=undefined){
              let current_annotation_form = [...temp_current_changes, ...ext_temp_current_changes];
             
              // update the current changes and check use condition and form calculation
              this.undoDatataForForms = _.cloneDeep(current_annotation_form);
              this.usecaseCopyArray = _.cloneDeep(current_annotation_form);
            }
              this.useConditionChange(item, elementUUID, value, addressCheck)
            }
            else {
              let current_annotation_form = [...temp_current_changes];
              // update the current changes and check use condition and form calculation
              this.undoDatataForForms = _.cloneDeep(current_annotation_form);
              this.usecaseCopyArray = _.cloneDeep(current_annotation_form);
              this.useConditionChange(item, elementUUID, value, addressCheck)
            }
          }
          // else {
          //   var untemp_current_changes;
          //   var ext_untemp_current_changes
          //   // new attached forms
          //   let clone_default_forms = _.cloneDeep(this.formListDefaultValues);
          //   let get_unattached_forms_ = clone_default_forms.filter((forms) => forms.form_id == this.currentFormId);
          //   let get_unattached_forms = _.cloneDeep(get_unattached_forms_);
          //   if (get_unattached_forms.length > 0) {
          //     if (typeof get_unattached_forms[0].form_data === 'string' || get_unattached_forms[0].form_data instanceof String) {
          //       get_unattached_forms[0].form_data = JSON.parse(get_unattached_forms[0].form_data)
          //     }
          //     if (get_unattached_forms[0].hasOwnProperty('ext_form_data')) {
          //       if (typeof get_unattached_forms[0].ext_form_data === 'string' || get_unattached_forms[0].ext_form_data instanceof String) {
          //         get_unattached_forms[0].ext_form_data = JSON.parse(get_unattached_forms[0].ext_form_data)
          //       }
          //     }
          //     this.multiselectionList[maf].annotation_forms.push(get_unattached_forms[0]);
          //     let get_annotation_form = this.multiselectionList[maf].annotation_forms;
          //     let filter_current_Index = get_annotation_form.findIndex((forms) => forms.form_id == this.currentFormId);
          //     if (filter_current_Index > -1) {
          //       let get_form_data = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data;
          //       let check_form_uuid_index = get_form_data.findIndex((form_data_a) => form_data_a.element_uuid == elementUUID);
          //       // form fields in or not 
          //       // 1 in if condtion
          //       // 2 not else condtion
          //       if (check_form_uuid_index > -1) {
          //         // common value changes function written
          //         let get_field = get_form_data[check_form_uuid_index];
          //         if (get_field.element_type != "multiple_choice" && get_field.element_type != "single_choice" && get_field.element_type != "checkbox"
          //           && get_field.element_type != "dropdown" && get_field.element_type != "date" && get_field.element_type != "address"
          //           && get_field.element_type != "uti-entry-field-WMATA" && get_field.element_type != "uti-entry-field-TIMBER") {
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.default_value = value;
          //         }
          //         else if (get_field.element_type == "multiple_choice") {


          //           let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options;
          //           if (get_options != undefined) {
          //             let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
          //             if (get_selected_option_index > -1) {
          //               this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
          //             }
          //           }
          //           if (get_options != undefined && get_options[0].default == true && value.element_uuid == get_options[0].element_uuid) {
          //             let find_custome_form = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((field) => field.element_type == "uti-entry-field-WMATA");
          //             if (find_custome_form > -1 && this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[0].name != "Corner?") {
          //               let shape = { icon: "Circle", fill_color: "#98D133", stroke_color: "#000000" };
          //               let get_custom_element = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index];
          //               if ((get_custom_element.element_data.hasOwnProperty('default_values') && get_custom_element.element_data.default_values != undefined
          //                 && get_custom_element.element_data.default_values != "" && get_custom_element.element_data.default_values.length > 0) || this.finalArray2.length > 0) {
          //                 let get_first_array = this.finalArray2[0];
          //                 // stroke color red changes check
          //                 if (get_first_array.previouscondition == "") {
          //                   shape.stroke_color = "#BC0900";
          //                 }
          //                 else {
          //                   shape.stroke_color = "#000000";
          //                 }
          //                 // shape changes based on form entered values
          //                 if (get_first_array.flagforrReview == "Yes") {
          //                   shape.icon = "Star";
          //                 }
          //                 if ((get_first_array.flagforrReview == "" || get_first_array.flagforrReview == "No") && get_first_array.Condition != "") {
          //                   shape.icon = "Flag";
          //                 }
          //                 // fill color changes
          //                 let blue_color = ['NM - Not measured', 'NA - No access to anchor rod', 'SI - Indicates similar but opposite side; refers to WMATA anchor rod pattern'];
          //                 let red_color = ['FR - Full fracture of anchor rod', 'CR - Strong probability of crack development in anchor rod'];
          //                 let orange_color = ['NT - Anchor rod not tensioned (i.e. the hex nut was loose)', 'PC - Pitting corrosion', 'NO - Notch or thread', 'TN - Strong thread noise', 'TW - Tack weld on anchor rod', 'SP - Anchor rod contains spliced connection', 'UD - Undetermined discontinuity in anchor rod'];
          //                 let OT_color = ['OT - Other'];
          //                 if (get_first_array.Condition != "") {
          //                   if (blue_color.includes(get_first_array.Condition)) {
          //                     shape.fill_color = "#002F5F";
          //                   }
          //                   else if (red_color.includes(get_first_array.Condition)) {
          //                     shape.fill_color = "#BC0900";
          //                   }
          //                   else if (orange_color.includes(get_first_array.Condition)) {
          //                     shape.fill_color = "#F48F00";
          //                   }
          //                   else if (OT_color.includes(get_first_array.Condition)) {
          //                     shape.fill_color = "#DF1ED3";
          //                   }
          //                 }
          //                 else {
          //                   shape.fill_color = "#FFFF00";
          //                 }

          //                 // shape.stroke_color = "#BC0900";
          //               }
          //               else {
          //                 shape.fill_color = "#98D133";
          //               }
          //               let currentAnnotation = this.multiselectionList[maf];
          //               this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
          //               multiple_inspection = true;
          //             }
          //             else if (this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[0].name == "Corner?") {
          //               let shape = { icon: "Circle", fill_color: "#FFFF00", stroke_color: "#000000" };
          //               let currentAnnotation = this.multiselectionList[maf];
          //               this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
          //               multiple_inspection = true;
          //             }
          //           }
          //           else if (get_options != undefined && get_options[0].default == false && value.element_uuid == get_options[0].element_uuid) {
          //             let shape = { icon: "Circle", fill_color: "#FFFF00", stroke_color: "#000000" };
          //             let currentAnnotation = this.multiselectionList[maf];
          //             this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
          //             multiple_inspection = true;
          //           }
          //         }
          //         else if (get_field.element_type == 'multiple_choice' && get_field.element_data.options[0].default == false && value.element_uuid == get_field.element_data.options[0].element_uuid) {
          //           let shape = { icon: "Circle", fill_color: "#FFFF00", stroke_color: "#000000" };
          //           let currentAnnotation = this.multiselectionList[maf];
          //           this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
          //           multiple_inspection = true;
          //         }
          //         else if (get_field.element_type == "checkbox") {
          //           let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options;
          //           let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
          //           if (get_selected_option_index > -1) {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
          //             let currentAnnotation_multiple = this.multiselectionList[maf];
          //             let currentOptionValue_multiple = _.cloneDeep(value);
          //             if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
          //               currentOptionValue_multiple.icon = "";
          //             }
          //             this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
          //           }
          //         }
          //         else if (get_field.element_type == "single_choice" || get_field.element_type == "dropdown") {
          //           let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options;
          //           for (let k = 0; k < get_options.length; k++) {
          //             if (get_options[k].element_uuid == value.element_uuid) {
          //               get_options[k].default = value.default
          //             }
          //             else {
          //               get_options[k].default = false;
          //             }
          //           }
          //           let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
          //           if (get_selected_option_index > -1) {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
          //             // check draw form attributes
          //             let get_option_attributes = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.options[get_selected_option_index];
          //             if (get_option_attributes.default == true && get_option_attributes.attributes == true) {
          //               let currentOption_multiple = get_option_attributes;
          //               let currentAnnotation_multiple = this.multiselectionList[maf];
          //               let currentOptionValue_multiple = _.cloneDeep(value);
          //               if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
          //                 currentOptionValue_multiple.icon = "";
          //               }
          //               this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
          //             }
          //             else {
          //               let currentOption_multiple = get_option_attributes;
          //               let currentAnnotation_multiple = this.multiselectionList[maf];
          //               let currentOptionValue_multiple = _.cloneDeep(value);
          //               if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
          //                 currentOptionValue_multiple.icon = "";
          //               }
          //               this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
          //             }
          //           }
          //         }
          //         else if (get_field.element_type == "date") {

          //           let tempDate = value;
          //           if (tempDate != undefined && tempDate != "" && tempDate != "none") {
          //             let convertDate = this.datePipe.transform(tempDate, "yyyy-MM-dd");
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.default_date_time = convertDate;
          //           } else {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.default_date_time = "";
          //           }
          //         }
          //         else if (get_field.element_type == "address" && addressCheck == 'city') {
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.city = value;
          //         }
          //         else if (get_field.element_type == "address" && addressCheck == 'state') {
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.state = value;
          //         }
          //         else if (get_field.element_type == "address" && addressCheck == 'street_address1') {
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.street_address1 = value;
          //         }
          //         else if (get_field.element_type == "address" && addressCheck == 'street_address2') {
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.street_address2 = value;
          //         }
          //         else if (get_field.element_type == "address" && addressCheck == 'zip') {
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.zip = value;
          //         }
          //         else if (get_field.element_type == "uti-entry-field-WMATA" || get_field.element_type == "uti-entry-field-TIMBER") {
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data["default_values"] = value;
          //         }
          //         let find_custome_form = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((field) => field.element_type == "uti-entry-field-WMATA");
          //         if (find_custome_form > -1 && multiple_inspection == false) {
          //           // if any update happened custom form shape should be changed circle and yellow fill color
          //           let find_custome_form = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data.findIndex((field) => field.element_type == "multiple_choice" && field.element_name == "Inspection Completed");
          //           if (find_custome_form > -1) {
          //             let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[find_custome_form].element_data.options;
          //             if (get_options[0].default == true) {
          //               let shape = { icon: "Circle", fill_color: "#98D133", stroke_color: "#000000" };
          //               let get_custom_element = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[find_custome_form];
          //               if ((get_custom_element.element_data.hasOwnProperty('default_values') && get_custom_element.element_data.default_values != undefined
          //                 && get_custom_element.element_data.default_values != "" && get_custom_element.element_data.default_values.length > 0) || this.finalArray2.length > 0) {
          //                 let get_first_array = this.finalArray2[0];
          //                 // stroke color red changes check
          //                 if (get_first_array.previouscondition == "") {
          //                   shape.stroke_color = "#BC0900";
          //                 }
          //                 else {
          //                   shape.stroke_color = "#000000";
          //                 }
          //                 // shape changes based on form entered values
          //                 if (get_first_array.flagforrReview == "Yes") {
          //                   shape.icon = "Star";
          //                 }
          //                 if ((get_first_array.flagforrReview == "" || get_first_array.flagforrReview == "No") && get_first_array.Condition != "") {
          //                   shape.icon = "Flag";
          //                 }
          //                 // fill color changes
          //                 let blue_color = ['NM - Not measured', 'NA - No access to anchor rod', 'SI - Indicates similar but opposite side; refers to WMATA anchor rod pattern'];
          //                 let red_color = ['FR - Full fracture of anchor rod', 'CR - Strong probability of crack development in anchor rod'];
          //                 let orange_color = ['NT - Anchor rod not tensioned (i.e. the hex nut was loose)', 'PC - Pitting corrosion', 'NO - Notch or thread', 'TN - Strong thread noise', 'TW - Tack weld on anchor rod', 'SP - Anchor rod contains spliced connection', 'UD - Undetermined discontinuity in anchor rod'];
          //                 let OT_color = ['OT - Other'];
          //                 if (get_first_array.Condition != "") {
          //                   if (blue_color.includes(get_first_array.Condition)) {
          //                     shape.fill_color = "#002F5F";
          //                   }
          //                   else if (red_color.includes(get_first_array.Condition)) {
          //                     shape.fill_color = "#BC0900";
          //                   }
          //                   else if (orange_color.includes(get_first_array.Condition)) {
          //                     shape.fill_color = "#F48F00";
          //                   }
          //                   else if (OT_color.includes(get_first_array.Condition)) {
          //                     shape.fill_color = "#DF1ED3";
          //                   }
          //                 }
          //                 else {
          //                   shape.fill_color = "#FFFF00";
          //                 }

          //                 // shape.stroke_color = "#BC0900";
          //               }
          //               else {
          //                 shape.fill_color = "#98D133";
          //               }
          //               let currentAnnotation = this.multiselectionList[maf];
          //               this.multiselectionList[maf] = await this.formattributeChangesDrawWMata(currentAnnotation, shape);
          //             }
          //             else {
          //               let currentAnnotation = this.multiselectionList[maf];
          //               this.multiselectionList[maf] = await this.formattributeChangesCustomWMATA(currentAnnotation);
          //             }
          //           }
          //           else {
          //             let currentAnnotation = this.multiselectionList[maf];
          //             this.multiselectionList[maf] = await this.formattributeChangesCustomWMATA(currentAnnotation);
          //           }
          //         }
          //         this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data[check_form_uuid_index].element_data.last_modified_date = new Date().toISOString();
          //         untemp_current_changes = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data;
          //       }
          //       else if (this.is_extend == true && this.multiselectionList[maf].annotation_forms[filter_current_Index].hasOwnProperty('ext_form_data')) {

          //         let ext_get_form_data = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data;
          //         if (typeof ext_get_form_data === 'string') {
          //           ext_get_form_data = JSON.parse(ext_get_form_data);
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data = ext_get_form_data;
          //         }

          //         let check_form_uuid_index = ext_get_form_data.findIndex((form_data_a) => form_data_a.element_uuid == elementUUID);
          //         if (check_form_uuid_index > -1) {
          //           // common value changes function written
          //           let get_field = ext_get_form_data[check_form_uuid_index];
          //           if (get_field.element_type != "multiple_choice" && get_field.element_type != "single_choice" && get_field.element_type != "checkbox"
          //             && get_field.element_type != "dropdown" && get_field.element_type != "date" && get_field.element_type != "address") {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.default_value = value;
          //           }
          //           else if (get_field.element_type == "multiple_choice") {
          //             let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options;
          //             let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
          //             if (get_selected_option_index > -1) {
          //               this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
          //             }
          //           }
          //           else if (get_field.element_type == "checkbox") {
          //             let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options;
          //             let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
          //             if (get_selected_option_index > -1) {
          //               this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
          //               let currentAnnotation_multiple = this.multiselectionList[maf];
          //               let currentOptionValue_multiple = _.cloneDeep(value);
          //               if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
          //                 currentOptionValue_multiple.icon = "";
          //               }
          //               this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
          //             }
          //           }
          //           else if (get_field.element_type == "single_choice" || get_field.element_type == "dropdown") {
          //             let get_options = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options;
          //             for (let k = 0; k < get_options.length; k++) {
          //               if (get_options[k].element_uuid == value.element_uuid) {
          //                 get_options[k].default = value.default
          //               }
          //               else {
          //                 get_options[k].default = false;
          //               }
          //             }
          //             let get_selected_option_index = get_options.findIndex((s_option) => s_option.element_uuid == value.element_uuid);
          //             if (get_selected_option_index > -1) {
          //               this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options[get_selected_option_index].default = value.default;
          //               // check draw form attributes
          //               let get_option_attributes = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.options[get_selected_option_index];
          //               if (get_option_attributes.default == true && get_option_attributes.attributes == true) {
          //                 let currentOption_multiple = get_option_attributes;
          //                 let currentAnnotation_multiple = this.multiselectionList[maf];
          //                 let currentOptionValue_multiple = _.cloneDeep(value);
          //                 if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
          //                   currentOptionValue_multiple.icon = "";
          //                 }
          //                 this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
          //               }
          //               else {
          //                 let currentOption_multiple = get_option_attributes;
          //                 let currentAnnotation_multiple = this.multiselectionList[maf];
          //                 let currentOptionValue_multiple = _.cloneDeep(value);
          //                 if (Number(currentAnnotation_multiple.toolbar_element_id) > 10) {
          //                   currentOptionValue_multiple.icon = "";
          //                 }
          //                 this.multiselectionList[maf] = await this.formattributeChangesDraw(currentOptionValue_multiple, currentAnnotation_multiple, currentOptionValue_multiple);
          //               }
          //             }
          //           }
          //           else if (get_field.element_type == "date") {
          //             let tempDate = value;
          //             if (tempDate != undefined && tempDate != "" && tempDate != "none") {
          //               let convertDate = this.datePipe.transform(tempDate, "yyyy-MM-dd");
          //               this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.default_date_time = convertDate;
          //             } else {
          //               this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.default_date_time = "";
          //             }
          //           }
          //           else if (get_field.element_type == "address" && addressCheck == 'city') {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.city = value;
          //           }
          //           else if (get_field.element_type == "address" && addressCheck == 'state') {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.state = value;
          //           }
          //           else if (get_field.element_type == "address" && addressCheck == 'street_address1') {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.street_address1 = value;
          //           }
          //           else if (get_field.element_type == "address" && addressCheck == 'street_address2') {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.street_address2 = value;
          //           }
          //           else if (get_field.element_type == "address" && addressCheck == 'zip') {
          //             this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.zip = value;
          //           }
          //           this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data[check_form_uuid_index].element_data.last_modified_date = new Date().toISOString();
          //           ext_untemp_current_changes = this.multiselectionList[maf].annotation_forms[filter_current_Index].ext_form_data;
          //           untemp_current_changes = this.multiselectionList[maf].annotation_forms[filter_current_Index].form_data;
          //         }
          //         if (this.is_extend == true) {
          //           let current_annotation_form = [...untemp_current_changes, ...ext_untemp_current_changes]
          //           // update the current changes and check use condition and form calculation
          //           this.undoDatataForForms = _.cloneDeep(current_annotation_form);
          //           this.usecaseCopyArray = _.cloneDeep(current_annotation_form);
          //           this.useConditionChange(item, elementUUID, value, addressCheck)
          //         } else {
          //           let current_annotation_form = _.cloneDeep(untemp_current_changes);
          //           // update the current changes and check use condition and form calculation
          //           this.undoDatataForForms = _.cloneDeep(current_annotation_form);
          //           this.usecaseCopyArray = _.cloneDeep(current_annotation_form);
          //           this.useConditionChange(item, elementUUID, value, addressCheck)
          //         }
          //       }
          //     }
          //   }
          // }
        }
      }
      console.log(this.multiselectionList);
      this.useConditionChange(item, elementUUID, value, addressCheck);
    }
    console.log(this.multiselectionList);

    for (let k = 0; k < this.multiselectionList.length; k++) {
      if (this.multiselectionList[k].annotation_forms != null && this.multiselectionList[k].annotation_forms.length != 0)
        this.formCount = this.formCount + this.multiselectionList[k].annotation_forms.length;
    }
    this.formCountmultiselect = this.formCount;
    this.checkAlign_usecase();
    console.log(this.modelFieldsForm);
  }


  datachange(currentOption, currentAnnotation) {
    var annoDataChange = "";
    var annotChangeShapeName = "";
    var toolbarNameCheck = currentAnnotation.toolbar_element_id;
    let toolbarElementId = 1;
    if (toolbarNameCheck == 1) {
      annoDataChange = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
      annotChangeShapeName = "Circle";
      toolbarElementId = 1;
    } else if (toolbarNameCheck == 2) {
      annoDataChange = "move-15:25 line-18:18 line-25:15 line-32:18 line-35:25 line-32:32 line-25:35 line-18:32 line-15:25 line-18:18";
      annotChangeShapeName = "Octagon";
      toolbarElementId = 2;
    } else if (toolbarNameCheck == 3) {
      annoDataChange = "move-15:15 line-35:15 line-35:35 line-15:35 line-15:15 line-35:15";
      annotChangeShapeName = "Square";
      toolbarElementId = 3;
    } else if (toolbarNameCheck == 4) {
      annoDataChange = "move-25:15 line-35:35 line-15:35 line-25:15 line-35:35";
      annotChangeShapeName = "Triangle";
      toolbarElementId = 4;
    } else if (toolbarNameCheck == 5) {
      annoDataChange = "move-25:12 line-30:22 line-38:22 line-32:30 line-35:40 line-25:34 line-15:40 line-18:30 line-12:22 line-20:22 line-25:12 line-30:22";
      annotChangeShapeName = "Star";
      toolbarElementId = 5;
    } else if (toolbarNameCheck == 6) {
      annoDataChange = "move-25:15 line-32.5:25 line-25:35 line-17.5:25 line-25:15 line-32.5:25";
      annotChangeShapeName = "Diamond";
      toolbarElementId = 6;
    }
    else if (toolbarNameCheck == 7) {
      annoDataChange = "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-17:25 line-17:40 line-15:40 line-15:15";
      annotChangeShapeName = "Flag";
      toolbarElementId = 7;
    } else if (toolbarNameCheck == 8) {
      annoDataChange = "move-31:22 controlpoint1-31:25.3137 controlpoint2-28.3137:28 endCurve-25:28 controlpoint1-21.6863:28 controlpoint2-19:25.3137 endCurve-19:22 controlpoint1-19:18.6863 controlpoint2-21.6863:16 endCurve-25:16 controlpoint1-28.3137:16 controlpoint2-31:18.6863 endCurve-31:22 move-17.5:15 line-19.5:12.5 line-30.5:12.5 line-32.5:15 line-36:15 controlpoint-38:15 curveEnd-38:17 line-38:29 controlpoint-38:31 curveEnd-36:31 line-14:31 controlpoint-12:31 curveEnd-12:29 line-12:17 controlpoint-12:15 curveEnd-14:15 line-17.5:15 line-19.5:12.5 move-14:19 line-16:19 line-16:20 line-14:20 move-22:22 controlpoint-22:19 curveEnd-25:19 controlpoint-28:19 curveEnd-28:22 controlpoint-28:25 curveEnd-25:25 controlpoint-22.5:25 curveEnd-22:22";
      annotChangeShapeName = "Camera";
      toolbarElementId = 8;
    } else if (toolbarNameCheck == 9) {
      annoDataChange = "move-10:22.5 line-25:22.5 line-25:15 line-40:25 line-25:35 line-25:27.5 line-10:27.5 line-10:22.5 line-25:22.5"
      annotChangeShapeName = "Arrow";
      toolbarElementId = 9;
    }
    let shapeWidth = currentAnnotation.initial_width;
    let shapeHeight = currentAnnotation.initial_height;
    annoDataChange = this.changeShapeStringForBaseicon(toolbarElementId, shapeWidth, shapeHeight, annoDataChange);
    currentAnnotation.annotation_data = annoDataChange;
  }


  // async formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue) {
  //   if (currentOption.default == true && currentOption.attributes == true && currentOptionValue.element_uuid == currentOption.element_uuid && currentOption.icon != "") {
  //     // let getChangesAttributes = this.attibutesValueChange(currentOption, currentAnnotation);
  //     let getChangesAttributes = this.sampleattibutesValueChange(currentOption, currentAnnotation);
  //     if (typeof getChangesAttributes.original_property == 'object') {
  //       currentAnnotation = getChangesAttributes;
  //       let cloneDeepShapeData = _.cloneDeep(currentAnnotation);
  //       await this.annotationClearDraw(cloneDeepShapeData);
  //     }
  //     currentAnnotation = getChangesAttributes;
  //     if (this.multipleSelectOn == false) {
  //       // header svg drawing
  //       this.single_view_svg_drawing(getChangesAttributes);
  //     }
  //   }
  //   else if (currentOptionValue.element_uuid == currentOption.element_uuid) {
  //     if (typeof currentAnnotation.original_property == 'object' && currentOption.default == false) {
  //       let getoriginalProperty = currentAnnotation.original_property;
  //       currentAnnotation.annotation_data = getoriginalProperty.annotation_data;
  //       currentAnnotation.toolbar_element_id = getoriginalProperty.toolbar_id;
  //       // The below if condition is added for the purpose of ticket number P3X 1198. 
  //       if (currentAnnotation.initial_height != 0 && currentAnnotation.toolbar_element_id < 11) {
  //         let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
  //         let shapeWidth = currentAnnotation.initial_width;
  //         let shapeHeight = currentAnnotation.initial_height;
  //         if (getElementStyle != null) {
  //           let getStyle = getComputedStyle(getElementStyle);
  //           let getLeft_A: any = getStyle.left;
  //           getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
  //           let getTop_B: any = getStyle.top;
  //           getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
  //           console.log(getLeft_A, getTop_B);
  //           let get_height: any = getElementStyle.getAttribute("height");
  //           get_height = Number(get_height);
  //           let get_width: any = getElementStyle.getAttribute("width");
  //           get_width = Number(get_width);
  //           console.log(get_width, get_height);
  //           // add extra line width values because initial x and initial y position reduced values added when changing atrributes
  //           // let current_annot_line_width = 0;
  //           // let change_annot_line_width = 0;
  //           // let adding_extra_line_width = current_annot_line_width - change_annot_line_width;
  //           // currentAnnotation.initial_position_x = Number(currentAnnotation.initial_position_x) - adding_extra_line_width;
  //           // currentAnnotation.initial_position_y = Number(currentAnnotation.initial_position_y) - adding_extra_line_width;
  //           // add extra line width values because initial x and initial y position reduced values added when changing atrributes
  //           console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((get_height - shapeHeight) / 2), ((get_width - shapeWidth) / 2))
  //           this.datachange(currentOption, currentAnnotation);
  //         }
  //       }
  //       else {
  //         currentAnnotation.initial_position_x = getoriginalProperty.initial_position_x;
  //         currentAnnotation.initial_position_y = getoriginalProperty.initial_position_y;
  //         currentAnnotation.initial_width = getoriginalProperty.initial_width;
  //         currentAnnotation.initial_height = getoriginalProperty.initial_height;
  //       }
  //       // properties below added
  //       currentAnnotation.fill_color = getoriginalProperty.fill_color;
  //       if (getoriginalProperty.stroke_color != "") {
  //         currentAnnotation.stroke_color = getoriginalProperty.stroke_color;
  //       }
  //       currentAnnotation.line_width = getoriginalProperty.line_width;
  //       currentAnnotation.original_property = "";
  //       let cloneDeepShapeData = _.cloneDeep(currentAnnotation);
  //       await this.annotationClearDraw(cloneDeepShapeData);
  //       if (this.multipleSelectOn == false) {
  //         // header svg drawing
  //         this.single_view_svg_drawing(currentAnnotation);
  //       }
  //     } else if (currentOption.default == true && currentOption.attributes == true && currentOptionValue.element_uuid == currentOption.element_uuid && currentOption.icon == "") {
  //       let getChangesAttributes = this.attibutesValueChangeForEmptyShape(currentOption, currentAnnotation);
  //       currentAnnotation = getChangesAttributes
  //       let cloneDeepShapeData = _.cloneDeep(currentAnnotation);
  //       await this.annotationClearDraw(cloneDeepShapeData);
  //       if (this.multipleSelectOn == false) {
  //         // header svg drawing
  //         this.single_view_svg_drawing(currentAnnotation);
  //       }
  //     }
  //   }
  //   return currentAnnotation;
  // }

  async formattributeChangesDraw(currentOption, currentAnnotation, currentOptionValue) {
    if (currentOption.default == true && currentOption.attributes == true && currentOptionValue.element_uuid == currentOption.element_uuid && currentOption.icon != "") {
      // let getChangesAttributes = this.attibutesValueChange(currentOption, currentAnnotation);
      let getChangesAttributes = this.attibutesValueChange(currentOption, currentAnnotation);

      //Jose added for form properties
      if(currentAnnotation.original_property!="" && currentAnnotation.original_property.toolbar_id>10){
      let getShapeStringWidth_value = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id: currentAnnotation.toolbar_element_id, annotation_data: currentAnnotation.original_property.annotation_data });

      
      let annotationData_change = this.changeShapeStringForBaseicon(currentAnnotation.toolbar_element_id, getShapeStringWidth_value.width, getShapeStringWidth_value.height, currentAnnotation.annotation_data)
      console.log(annotationData_change);
      currentAnnotation.annotation_data = annotationData_change
      let getShapeStringWidth_value_new = this.shapeService1.getCanvaswidthandHeight({toolbar_element_id:currentAnnotation.toolbar_element_id, annotation_data: annotationData_change})
      if(Number(getChangesAttributes.initial_position_x)==0 && Number(getChangesAttributes.initial_position_y)==0){
        getChangesAttributes.initial_position_x = (getShapeStringWidth_value.left)+17.5;
        getChangesAttributes.initial_position_y = (getShapeStringWidth_value.top)+17.5;
        getChangesAttributes.initial_width = getShapeStringWidth_value.width
        getChangesAttributes.initial_height = getShapeStringWidth_value.height
      }
      else if(currentAnnotation.original_property.toolbar_id>10 && getShapeStringWidth_value_new.left!=0){
        // getChangesAttributes.initial_width = getShapeStringWidth_value_new.width
        // getChangesAttributes.initial_height = getShapeStringWidth_value_new.height
        // let x = (getShapeStringWidth_value.width-getShapeStringWidth_value_new.width)
        // let y = (getShapeStringWidth_value.height-getShapeStringWidth_value_new.height);
        // getChangesAttributes.initial_position_x = (Number(getChangesAttributes.initial_position_x)-x)-17.5;
        // getChangesAttributes.initial_position_y = (Number(getChangesAttributes.initial_position_y)-y)-17.5;
      }
     
      }
      /////// Jose
      if (typeof getChangesAttributes.original_property == 'object') {
        currentAnnotation = getChangesAttributes;
        let cloneDeepShapeData = _.cloneDeep(currentAnnotation);
        await this.annotationClearDraw(cloneDeepShapeData);
      }
      currentAnnotation = getChangesAttributes;
      if (this.multipleSelectOn == false) {
        // header svg drawing

        this.single_view_svg_drawing(getChangesAttributes);
      }
    }
    else if (currentOptionValue.element_uuid == currentOption.element_uuid) {
      if (typeof currentAnnotation.original_property == 'object' && currentOption.default == false) {
        let getoriginalProperty = currentAnnotation.original_property;
        currentAnnotation.annotation_data = getoriginalProperty.annotation_data;
        currentAnnotation.toolbar_element_id = getoriginalProperty.toolbar_id;
        // The below if condition is added for the purpose of ticket number P3X 1198. 
        let initial_width_value = Number(currentAnnotation.initial_width);
        let initial_height_value = Number(currentAnnotation.initial_height);
        if (initial_width_value != 0 && initial_height_value != 0 && currentAnnotation.toolbar_element_id < 11) {
          let shape_width = initial_width_value;
          let shape_height = initial_height_value;
          let current_string = JSON.parse(JSON.stringify(currentAnnotation.annotation_data));
          let annotationData = this.changeShapeStringForBaseicon(100, shape_width, shape_height, current_string);
          let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id: currentAnnotation.toolbar_element_id, annotation_data: annotationData });
          let changed_shape_data = this.changeShapePositionsInsideCanvas(annotationData, 100, getShapeStringWidth)
          let annoDataChange = changed_shape_data.annotationData;
          currentAnnotation.annotation_data = annoDataChange;
        }
        if (getoriginalProperty.fill_color != undefined && getoriginalProperty.fill_color != "") {
          currentAnnotation.fill_color = getoriginalProperty.fill_color;
        }
        if (getoriginalProperty.stroke_color != undefined && getoriginalProperty.stroke_color != "") {
          currentAnnotation.stroke_color = getoriginalProperty.stroke_color;
        }
        if (getoriginalProperty.line_width != undefined && getoriginalProperty.line_width != "") {
          currentAnnotation.line_width = getoriginalProperty.line_width;
        }

        console.log(currentAnnotation)
        currentAnnotation.original_property = "";
        currentAnnotation.opacity = getoriginalProperty.opacity;
        let cloneDeepShapeData = _.cloneDeep(currentAnnotation);
        await this.annotationClearDraw(cloneDeepShapeData);
        if (this.multipleSelectOn == false) {
          // header svg drawing
          this.single_view_svg_drawing(currentAnnotation);
        }
      } else if (currentOption.default == true && currentOption.attributes == true && currentOptionValue.element_uuid == currentOption.element_uuid && currentOption.icon == "") {

        let getChangesAttributes = this.attibutesValueChangeForEmptyShape(currentOption, currentAnnotation);
        currentAnnotation = getChangesAttributes;
        let cloneDeepShapeData = _.cloneDeep(currentAnnotation);
        await this.annotationClearDraw(cloneDeepShapeData);
        if (this.multipleSelectOn == false) {
          // header svg drawing
          this.single_view_svg_drawing(currentAnnotation);
        }
      }
    }

    return currentAnnotation;
  }

  async formattributeChangesCustomWMATA(currentAnnotation) {
    let get_annotation = Object.assign({}, currentAnnotation);
    let getChangesAttributes = this.attibutesValueChangeCustomWMATA(get_annotation);
    currentAnnotation = getChangesAttributes;
    let cloneDeepShapeData = _.cloneDeep(currentAnnotation);
    await this.annotationClearDraw(cloneDeepShapeData);
    let isnegativeCoordinates = false;
    this.coordinateX = Number(getChangesAttributes.initial_position_x);
    this.coordinateY = Number(getChangesAttributes.initial_position_y);
    if (this.coordinateX < 0 && this.coordinateY < 0) {
      this.coordinateX = -this.coordinateX;
      this.coordinateY = -this.coordinateY;
      isnegativeCoordinates = true;
    }
    if (this.multipleSelectOn == false) {
      // header svg drawing
      this.single_view_svg_drawing(getChangesAttributes);
    }
    return currentAnnotation;
  }

  attibutesValueChangeCustomWMATA(currentAnnotation) {
    let getDeepClone = _.cloneDeep(currentAnnotation.toolbar_element_id);
    console.log(currentAnnotation);
    var annoDataChange = "";
    var annotChangeShapeName = "";
    let toolbarElementId = 1;
    annoDataChange = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
    annotChangeShapeName = "Circle";
    toolbarElementId = 1;
    let getNewAnnotationData;
    if (getNewAnnotationData == "" || getNewAnnotationData == undefined) {
      let getWidthHeightRA = this.shapeService1.getCanvaswidthandHeight(currentAnnotation);
      let initial_width_value = Number(currentAnnotation.initial_width);
      let initial_height_value = Number(currentAnnotation.initial_height);
      let initial_position_X_value = Number(currentAnnotation.initial_position_x);
      let initial_position_Y_value = Number(currentAnnotation.initial_position_y);
      let initial_position: boolean = false;
      let move_check: boolean = false;
      let resize_check: boolean = false;
      let simple_shape_resize: boolean = false;
      //freehand shapes only allow if condition
      if (getDeepClone > 11) {
        if (initial_width_value == 0 && initial_height_value == 0 && initial_position_X_value == 0 && initial_position_Y_value == 0) {
          initial_position = true;
          currentAnnotation["initial_width"] = getWidthHeightRA.width;
          currentAnnotation["initial_height"] = getWidthHeightRA.height;
        }
        else if (initial_width_value == 0 && initial_height_value == 0 && initial_position_X_value != 0 && initial_position_Y_value != 0) {
          move_check = true;
          currentAnnotation["initial_width"] = getWidthHeightRA.width;
          currentAnnotation["initial_height"] = getWidthHeightRA.height;
        }
        else {
          resize_check = true;
          if (initial_width_value == 0 && initial_height_value == 0) {
            currentAnnotation["initial_width"] = getWidthHeightRA.width;
            currentAnnotation["initial_height"] = getWidthHeightRA.height;
          }
        }
      }
      else if (initial_width_value != 0 && initial_height_value != 0) {
        simple_shape_resize = true;
        let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
        if (getElementStyle != null) {
          let getStyle = getComputedStyle(getElementStyle);
          let getLeft_A: any = getStyle.left;
          getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
          let getTop_B: any = getStyle.top;
          getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
        }
      }
      let shapeWidth = currentAnnotation.initial_width;
      let shapeHeight = currentAnnotation.initial_height;
      if (shapeWidth != 0 || shapeHeight != 0) {
        shapeWidth = shapeWidth == 0 ? 35 : shapeWidth;
        shapeHeight = shapeHeight == 0 ? 35 : shapeHeight;
        let margin_reduces_left: any = 0;
        let margin_reduces_top: any = 0;
        let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
        if (getElementStyle != null) {
          let getStyle = getComputedStyle(getElementStyle);
          margin_reduces_left = getStyle.marginLeft;
          margin_reduces_left = margin_reduces_left.substring(margin_reduces_left.length - 2, 0);
          let margin_reduces_top: any = getStyle.marginTop;
          margin_reduces_top = margin_reduces_top.substring(margin_reduces_top.length - 2, 0);
        }
        let checkRound_width = Math.round(shapeWidth);
        let checkRound_height = Math.round(shapeHeight);
        if (shapeWidth < shapeHeight && (checkRound_height != checkRound_width)) {
          shapeHeight = shapeWidth;
        }
        else if (shapeWidth > shapeHeight && (checkRound_height != checkRound_width)) {
          shapeWidth = shapeHeight;
        }
        if (shapeWidth < 35 || shapeHeight < 35) {
          shapeWidth = 35;
          shapeHeight = 35;
        }
        if (initial_position == true) {
          // line_width_reduce added at 11.01.2022 reason initial_width 0 and x !=0 shapes mismatch position fixed by this code.
          // let line_width_reduce = (currentAnnotation.line_width/6)/2;
          currentAnnotation.initial_position_x = getWidthHeightRA.left + ((getWidthHeightRA.width - shapeWidth) / 2) + 17.5;
          currentAnnotation.initial_position_y = getWidthHeightRA.top + ((getWidthHeightRA.height - shapeHeight) / 2) + 17.5;
          console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((currentAnnotation.initial_height - shapeHeight) / 2), ((currentAnnotation.initial_width - shapeWidth) / 2))
        }
        else if (move_check == true) {
          let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          if (getElementStyle != null) {
            let getStyle = getComputedStyle(getElementStyle);
            let getLeft_A: any = getStyle.left;
            getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
            let getTop_B: any = getStyle.top;
            getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
            console.log(getLeft_A, getTop_B);
            let get_height: any = getElementStyle.getAttribute("height");
            get_height = Number(get_height);
            let get_width: any = getElementStyle.getAttribute("width");
            get_width = Number(get_width);
            console.log(get_width, get_height);
            currentAnnotation.initial_position_x = Number(getLeft_A) + ((get_width - shapeWidth) / 2) + 17.5;
            currentAnnotation.initial_position_y = Number(getTop_B) + ((get_height - shapeHeight) / 2) + 17.5;
            console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((currentAnnotation.initial_height - shapeHeight) / 2), ((currentAnnotation.initial_width - shapeWidth) / 2))
          }

        }
        else if (resize_check == true) {
          let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          if (getElementStyle != null) {
            let getStyle = getComputedStyle(getElementStyle);
            let getLeft_A: any = getStyle.left;
            getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
            let getTop_B: any = getStyle.top;
            getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
            console.log(getLeft_A, getTop_B);
            let get_height: any = getElementStyle.getAttribute("height");
            get_height = Number(get_height);
            let get_width: any = getElementStyle.getAttribute("width");
            get_width = Number(get_width);
            console.log(get_width, get_height);
            currentAnnotation.initial_position_x = Number(getLeft_A) + 17.5 + ((get_width - shapeWidth) / 2);
            currentAnnotation.initial_position_y = Number(getTop_B) + 17.5 + ((get_height - shapeHeight) / 2);
            console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((get_height - shapeHeight) / 2), ((get_width - shapeWidth) / 2))
          }

        }
        else if (simple_shape_resize == true) {
          let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          if (getElementStyle != null) {
            let getStyle = getComputedStyle(getElementStyle);
            let getLeft_A: any = getStyle.left;
            getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
            let getTop_B: any = getStyle.top;
            getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
            console.log(getLeft_A, getTop_B);
            let get_height: any = getElementStyle.getAttribute("height");
            get_height = Number(get_height);
            let get_width: any = getElementStyle.getAttribute("width");
            get_width = Number(get_width);
            console.log(get_width, get_height);
            currentAnnotation.initial_position_x = Number(getLeft_A) + 17.5 + ((get_width - shapeWidth) / 2);
            currentAnnotation.initial_position_y = Number(getTop_B) + 17.5 + ((get_height - shapeHeight) / 2);
            console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((get_height - shapeHeight) / 2), ((get_width - shapeWidth) / 2))
          }
        }
        currentAnnotation.initial_width = shapeWidth;
        currentAnnotation.initial_height = shapeHeight;
        annoDataChange = this.changeShapeStringForBaseicon(toolbarElementId, shapeWidth, shapeHeight, annoDataChange);
      }
      currentAnnotation.annotation_data = annoDataChange;
    }
    // ipad change shape name not mentioned.
    // currentAnnotation.annotation_name = annotChangeShapeName;

    currentAnnotation.annotation_name = "Circle";
    currentAnnotation.fill_color = "yellow";
    currentAnnotation.stroke_color = "#000000";

    currentAnnotation.toolbar_element_id = toolbarElementId;

    return currentAnnotation;
  }
  async formSubmit(multiselect: boolean, syncaction: string, event?: any) {
    console.log(this.layerDatas);
    if (this.userrole != 'view') {
      this.show = true;
      if (this.multipleSelectOn === true || multiselect == true) {
        this.undoDatataForForms = _.cloneDeep(this.usecaseCopyArray)
        let generateCloneLayer = _.cloneDeep(this.layerDatas);
        let annotation_ids = this.createDocumentStore.selectedAnnotations;
        let unique_ids = annotation_ids.filter((c, index) => { return annotation_ids.indexOf(c) === index; });
        this.createDocumentStore.selectedAnnotations = unique_ids;
        let clone_multi_selectionlist = _.cloneDeep(this.multiselectionList);
        let findCurGroupIndex = this.findGroupindex(this.multiselectionList[0].annotation_id);
          var ids = {
            proj_id: this.projectId,
            folder_id: this.folderId,
            user_id: this.su.user_id,
            // group_id: this.createJSON_grpAnnts.group_data[findCurGroupIndex].group_annotation_id
          }
        if(this.groupValueUpdate == true){
          var copy_grpAnnts = _.cloneDeep(this.createJSON_grpAnnts);
           const first = this.documentService.annotationMultipleUpdate(generateCloneLayer, clone_multi_selectionlist,'form');
           const second = this.documentService.updatingGroupAnntsService(ids,copy_grpAnnts);
           forkJoin([first,second]).subscribe(res => {
            let formRes = res[0];
            if(formRes["response_code"] == 200){
              if (syncaction == 'sync') {
                this.getAnnotationForm();
              }
              else if (syncaction == 'rightclick' && event != undefined && event.which == 3) {
                
                this.canvasRightClick(event, this.createDocumentStore.single_select_annotation[0]);
              }
              else if (syncaction == 'leftclick' && event != undefined && event.which != 3) {
                if (this.createDocumentStore.single_select_annotation != undefined && this.createDocumentStore.single_select_annotation.length != 0)
                  this.canvasClick(this.createDocumentStore.single_select_annotation[0]);
              }
              else if (syncaction == 'deselect' && event != undefined) {
                this.deselectAnnotation();
                this.show = false;
              }
              else {
                this.show = false;
              }
            }
            else {
              this.errorMessage();
            }
           })
        }
        else{
          this.documentService.annotationMultipleUpdate(generateCloneLayer, clone_multi_selectionlist,'form').subscribe((response) => {
            console.log(response);
            if (response["response_code"] == 200) {
              if (syncaction == 'sync') {
                this.getAnnotationForm();
              }
              else if (syncaction == 'rightclick' && event != undefined && event.which == 3) {
               
                this.canvasRightClick(event, this.createDocumentStore.single_select_annotation[0]);
              }
              else if (syncaction == 'leftclick' && event != undefined && event.which != 3) {
                if (this.createDocumentStore.single_select_annotation != undefined && this.createDocumentStore.single_select_annotation.length != 0)
                  this.canvasClick(this.createDocumentStore.single_select_annotation[0]);
              }
              else if (syncaction == 'deselect' && event != undefined) {
                this.deselectAnnotation();
                this.show = false;
              }
              else {
                this.show = false;
              }
            }
            else {
              this.errorMessage();
            }
          });
        }
      }
      else {
        for (var i = 0; i < this.layerDatas.length; i++) {
          var currentAnnotationData = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
          console.log('form current annotation', currentAnnotationData);
          if (currentAnnotationData.length > 0) {
            var undoData = _.cloneDeep(currentAnnotationData)
            this.formCount = currentAnnotationData[0].annotation_forms.length;

            let formData = currentAnnotationData[0].annotation_forms.filter(item => item.form_id == this.currentFormId);
            if (formData.length > 0) {
              let datevalue = formData[0].form_data.filter((ele => ele.element_type == "date"))
              let ext_datevalue = []
              if (this.is_extend == true) {
                ext_datevalue = formData[0].ext_form_data.filter((ele => ele.element_type == "date"))
              }
              if (datevalue.length > 0 || ext_datevalue.length > 0) {
                for (let i = 0; i < this.usecaseCopyArray.length; i++) {
                  if (this.usecaseCopyArray[i].element_type === "date") {

                    let element_data = this.usecaseCopyArray[i].element_data
                    if (element_data.default_date_time != undefined && element_data.default_date_time != "" && element_data.default_date_time != "none" && element_data.default_date_time != "current") {
                      this.usecaseCopyArray[i].element_data.default_date_time = this.datePipe.transform(element_data.default_date_time, 'yyyy-MM-dd');
                    }
                  }
                }
              }
              let form_model_values = [];
              for (let i = 0; i < formData[0].form_data.length; i++) {
                let filter_element = this.usecaseCopyArray.filter(data => data.element_uuid == formData[0].form_data[i].element_uuid);
                if (filter_element != null && filter_element.length > 0) {
                  if (filter_element[0].element_type == "uti-entry-field-WMATA" || filter_element[0].element_type == "uti-entry-field-WMATA_WELD") {
                    filter_element[0].element_data.default_value = "";
                  }
                  form_model_values.push(filter_element[0]);
                }
              }
              formData[0].form_data = _.cloneDeep(form_model_values);
              let formId = formData[0].form_id;
              let formIndex = this.currentSelectedAnnotationData.annotation_forms.findIndex((id)=>id.form_id == formId);
              if(formIndex > -1){
                this.currentSelectedAnnotationData.annotation_forms[formIndex].form_data = formData[0].form_data;
              }
              console.log(this.currentSelectedAnnotationData.annotation_forms);
              if (this.is_extend == true && formData[0].hasOwnProperty('ext_form_data')) {
                let ext_form_model_values = [];
                for (let i = 0; i < formData[0].ext_form_data.length; i++) {
                  let filter_element = this.usecaseCopyArray.filter(data => data.element_uuid == formData[0].ext_form_data[i].element_uuid);
                  if (filter_element != null && filter_element.length > 0) {
                    ext_form_model_values.push(filter_element[0]);
                  }
                }
                formData[0].ext_form_data = _.cloneDeep(ext_form_model_values);
              }

              //this.modelFieldsForm = formData[0].form_data
            }
          }
        }

        let get_layer_id = this.currentSelectedAnnotationData.layer_id;
        let get_current_layer = this.layerDatas.findIndex((data_layer) => data_layer.layer_id == get_layer_id);
        if (get_current_layer > -1) {
          let filter_annotation = this.layerDatas[get_current_layer].annotations.findIndex((a_f_data) => a_f_data.annotation_id == this.currentSelectedAnnotationData.annotation_id);
          if (filter_annotation > -1) {
            let current_annotation_forms = this.layerDatas[get_current_layer].annotations[filter_annotation].annotation_forms;
            let filter_changes_form = current_annotation_forms.filter((f_c_data) => f_c_data.form_id == this.currentFormId);
            if (filter_changes_form.length > 0) {
              let form_values = filter_changes_form[0].form_data;
              let filter_custom_form_value = form_values.filter((formdata_value) => {
                if (formdata_value.hasOwnProperty('special_form_attribute')) {
                  if (formdata_value.special_form_attribute == true) {
                    return true;
                  }
                  else {
                    return false;
                  }
                }
                else if (formdata_value.element_type == "uti-entry-field") {
                  return true;
                }
                else {
                  return false;
                }
              });
              if (filter_custom_form_value.length > 0) {
                let dropdown_label_value = "";
                for (let values_check = 0; values_check < filter_custom_form_value.length; values_check++) {
                  //element type dropdown option checking
                  if (filter_custom_form_value[values_check].element_type == "dropdown") {
                    let checkselect_option = filter_custom_form_value[values_check].element_data.options.filter((options_value) => { return options_value.default == true });
                    if (checkselect_option.length > 0) {
                      let get_selected_option_name = checkselect_option[0].name;
                      if (get_selected_option_name != '') {
                        let split_value = get_selected_option_name.split('(');
                        let getshort_form_value = split_value[0].trim();
                        this.layerDatas[get_current_layer].annotations[filter_annotation].annotation_label = getshort_form_value;
                        dropdown_label_value = getshort_form_value;
                      }
                      else {
                        this.layerDatas[get_current_layer].annotations[filter_annotation].annotation_label = '';
                      }
                    }
                  }
                  else if (filter_custom_form_value[values_check].element_type == "single_line_text") {
                    let get_input_value = filter_custom_form_value[values_check].element_data.default_value;
                    if (get_input_value == undefined) {
                      get_input_value = "";
                    }
                    else {
                      get_input_value = get_input_value.trim();
                    }
                    if (get_input_value != '') {
                      if (dropdown_label_value != '') {
                        this.layerDatas[get_current_layer].annotations[filter_annotation].annotation_label = dropdown_label_value + ' ' + get_input_value;
                      }
                      else {
                        this.layerDatas[get_current_layer].annotations[filter_annotation].annotation_label = get_input_value;
                      }
                    }
                  }
                  else if (filter_custom_form_value[values_check].element_type == "uti-entry-field") {
                    let get_default_values = filter_custom_form_value[values_check].element_data.default_values;
                    if (get_default_values!=undefined && get_default_values.length > 0) {

                      let get_last_default_value = get_default_values[get_default_values.length - 1];
                      let get_input_value = filter_custom_form_value[values_check].element_data.fields;
                      let get_single_choice_option = get_input_value[1];
                      let get_single_choice_element_uuid = get_single_choice_option.element_uuid;
                      let get_selected_single_choice = get_last_default_value[get_single_choice_element_uuid.toString()];
                      let get_single_choice_option_values = get_single_choice_option.element_data.options;
                      let get_attributes_enable_option = get_single_choice_option_values.filter((data_option) => { return data_option.attributes == true });
                      if (get_attributes_enable_option.length > 0) {
                        let get_selected_option = get_attributes_enable_option.filter((option_value) => { return option_value.element_uuid == get_selected_single_choice });
                        if (get_selected_option.length > 0) {
                          let get_fill_color = get_selected_option[0].fill_color;
                          this.layerDatas[get_current_layer].annotations[filter_annotation].fill_color = get_fill_color;
                        }
                      }
                    }
                  }
                }

                let current_annotation_data = this.layerDatas[get_current_layer].annotations[filter_annotation];
                // this.updatedocumentandsidebardrawing(current_annotation_data);
              }
            }
          }
        }
        this.undoDatataForForms = _.cloneDeep(this.usecaseCopyArray)
        let generateCloneLayer = _.cloneDeep(this.layerDatas);
        let starttime = this.functionstarttime('update form api');
        console.log(this.groupValueUpdate);
        if (this.groupValueUpdate == true) {
          let findCurGroupIndex = this.findGroupindex(this.getId);
          let groupid = null;
          if(findCurGroupIndex != -1){
            groupid = this.createJSON_grpAnnts.group_data[findCurGroupIndex].group_annotation_id;
          }
          var ids_single = {
            proj_id: this.projectId,
            folder_id: this.folderId,
            user_id: this.su.user_id,
            group_id: groupid
          }
          var copy_grpAnnts = _.cloneDeep(this.createJSON_grpAnnts);
          let modifiedGroup = copy_grpAnnts.group_data.filter(id => id.group_annotation_id == ids_single.group_id);
          if (modifiedGroup.length > 0) {
            copy_grpAnnts.group_data = [];
            copy_grpAnnts.group_data.push(modifiedGroup[0])
          }
        }
        if(this.groupValueUpdate == true){
          const first = this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw, 'form');
          const second = this.documentService.updatingGroupAnntsService(ids_single,copy_grpAnnts);
          forkJoin([first,second]).subscribe(res => {
            let abc = res[0];
            console.log(res[0]);
            console.log(res[1]);
            this.functionendtime('update form api',starttime)
            if (abc["response_code"] == 200) {
              if (syncaction == 'sync') {
                const get_formlist = new Promise(async resolve => {
                  let get_form_response = await this.getAnnotationForm();
                  resolve(get_form_response);
                });
                get_formlist.then(responses => {
                  console.log(responses)
                  if (responses == 200) {
                    this.getGroupAnnotationDatas();
                  }
                });
              }
              else if (syncaction == 'rightclick' && event != undefined && event.which == 3) {
                
                this.canvasRightClick(event, this.createDocumentStore.single_select_annotation[0]);
              }
              else if (syncaction == 'leftclick' && event != undefined && event.which != 3) {
                this.canvasClick(this.createDocumentStore.single_select_annotation[0]);
              }
              else if (syncaction == 'deselect' && event != undefined) {
                this.deselectAnnotation();
                this.show = false;
              }
              else {
                this.show = false;
              }
            }
            else {
              this.errorMessage();
            }
          })
        }
        else{
          this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw, 'form').subscribe((response) => {
            console.log(response);
          
            this.functionendtime('update form api',starttime)
            if (response["response_code"] == 200) {
              if (syncaction == 'sync') {
                this.getAnnotationForm();
              }
              else if (syncaction == 'rightclick' && event != undefined && event.which == 3) {
                alert("hi")
                this.canvasRightClick(event, this.createDocumentStore.single_select_annotation[0]);
              }
              else if (syncaction == 'leftclick' && event != undefined && event.which != 3) {
                this.canvasClick(this.createDocumentStore.single_select_annotation[0]);
              }
              else if (syncaction == 'deselect' && event != undefined) {
                this.deselectAnnotation();
                this.show = false;
              }
              else {
                this.show = false;
              }
              // if(this.media != true && this.links != true && this.tags != true && this.properties != true){
              //   this.formContentleft = [];
              //   this.formContentright = [];
              // }
            }
            else {
              this.errorMessage();
            }
          });
        }
      }
    }
  }
  sizeincrease(percentage?: boolean, resize_per_input?: number) {
    console.log(this.moveAnnotationsStore);
    if(this.moveAnnotationsStore.length!=0){
      this.propertiesannotationData = this.moveAnnotationsStore[0];
    }
    this.resizedone=false;
    console.log(percentage, resize_per_input, typeof resize_per_input);
    if (this.multipleSelectOn == false) {
      let backupproperytData = _.cloneDeep(this.propertiesannotationData)
      console.log(_.cloneDeep(this.propertiesannotationData));
      let getElementRemove = document.getElementById(this.propertiesannotationData["annotation_id"]);
      // let getlabelRemove = document.getElementById('label' + this.propertiesannotationData["annotation_id"]);
      // if (getlabelRemove != null) {
      //   console.log(getElementRemove, getlabelRemove)
      //   getlabelRemove.remove();
      // }
      let currentelementWidth = getElementRemove.getBoundingClientRect();
      console.log(currentelementWidth);
      let get_width = Number(getElementRemove.getAttribute('width')) + 2;
      let get_height = Number(getElementRemove.getAttribute('height')) + 2;
      let get_left = getElementRemove.style.left;
      get_left = get_left.substring(get_left.length - 2, 0);
      let get_top = getElementRemove.style.top;
      get_top = get_top.substring(get_top.length - 2, 0);
      let calculate_width = Number(get_left) + get_width;
      let calculate_height = Number(get_top) + get_height;
      var checkroattion = { x: 0, y: 0 };
      let percentage_divide_value_w = 0;
      let percentage_divide_value_h = 0;
      if (this.propertiesannotationData["initial_rotation"] != undefined && this.propertiesannotationData["initial_rotation"] != "0" && this.propertiesannotationData["initial_rotation"] != "") {
        checkroattion = this.lineToAngle(get_left, get_top, get_width, get_height, this.propertiesannotationData["initial_rotation"]);
        console.log(checkroattion);
      }

      if ((get_width >= this.realWidth || get_height >= this.realHeight ||
        (Number(get_left) <= 1 && checkroattion.x == 0 && resize_per_input > 0) || (Number(get_top) <= 1 && resize_per_input > 0) ||
        calculate_width >= this.realWidth || calculate_height >= this.realHeight)) {
        return;
      }
      console.log(get_width, get_height);
      let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      let changeWidth = getShapeStringWidth.width;
      let changeHeight = getShapeStringWidth.height;
      console.log("getShapeStringWidth",getShapeStringWidth)
      if (percentage == true) {
        percentage_divide_value_w = (getShapeStringWidth.width / 100) * resize_per_input;
        percentage_divide_value_h = (getShapeStringWidth.height / 100) * resize_per_input;
        changeWidth = getShapeStringWidth.width + percentage_divide_value_w;
        changeHeight = getShapeStringWidth.height + percentage_divide_value_h;
        if (changeWidth < 5 && changeHeight < 5) {
          return;
        }
        // text annotation height or width 5px below resize restrict
        else if (this.propertiesannotationData["toolbar_element_id"] == 11 && (changeWidth < 5 || changeHeight < 5)) {
          return
        }
      }
      else {
        if(getShapeStringWidth.width < getShapeStringWidth.height){
          changeHeight = getShapeStringWidth.height + 5;
          changeWidth = (getShapeStringWidth.width * changeHeight) / getShapeStringWidth.height;
        }else{
          changeWidth = getShapeStringWidth.width + 5;
          changeHeight = (getShapeStringWidth.height * changeWidth) / getShapeStringWidth.width;
        }
        // changeWidth = getShapeStringWidth.width + 5;
        // // changeHeight = getShapeStringWidth.height + 5;
        // //below calcualtion is to find the height based on width increase ratio. uncomment above code and comment below code if it it not working - Jose
        // changeHeight = (getShapeStringWidth.height * changeWidth) / getShapeStringWidth.width;
      }
      // very first time ipad resize annotation width and height same that changewidth and changeheight. so it is changing width and height
      // add one more time +5 then increase the shape width and height what we expect in first time. 
      if (changeWidth == Number(this.propertiesannotationData["initial_width"]) && changeHeight == Number(this.propertiesannotationData["initial_height"])) {
        if (percentage == true) {
          percentage_divide_value_w = (changeWidth / 100) * resize_per_input;
          percentage_divide_value_h = (changeHeight / 100) * resize_per_input;
          changeWidth = changeWidth + percentage_divide_value_w;
          changeHeight = changeHeight + percentage_divide_value_h;
          if (changeWidth < 5 && changeHeight < 5) {
            return;
          }
          // text annotation height or width 5px below resize restrict
          else if (this.propertiesannotationData["toolbar_element_id"] == 11 && (changeWidth < 5 || changeHeight < 5)) {
            return
          }
        }
        else {
          // changeWidth = changeWidth + 4;
          // changeHeight = changeHeight + 4;
          //Below code is to find ratio of height based on width increment. Please comment below code and uncomment above code if it is not working -- Jose
          if(changeWidth<changeHeight){
            changeWidth = (changeWidth * (changeHeight+4)) / changeHeight;
            changeHeight = changeHeight + 4;
          }else{
            changeHeight = (changeHeight * (changeWidth+4)) / changeWidth;
            changeWidth = changeWidth + 4;
          }
          // changeHeight = (changeHeight * (changeWidth+4)) / changeWidth;
          // changeWidth = changeWidth + 4;
        }
      }
      // restrict percentage out of bounds
      if (percentage == true) {
        get_width = Number(getElementRemove.getAttribute('width')) + percentage_divide_value_w;
        get_height = Number(getElementRemove.getAttribute('height')) + percentage_divide_value_h;
        get_left = getElementRemove.style.left;
        get_left = get_left.substring(get_left.length - 2, 0);
        get_top = getElementRemove.style.top;
        get_top = get_top.substring(get_top.length - 2, 0);
        calculate_width = Number(get_left) + get_width;
        calculate_height = Number(get_top) + get_height;
        if ((get_width >= this.realWidth || get_height >= this.realHeight ||
          (Number(get_left) <= 1 && checkroattion.x == 0 && resize_per_input > 0) || (Number(get_top) <= 1 && resize_per_input > 0) ||
          calculate_width >= this.realWidth || calculate_height >= this.realHeight)) {
          console.log('percentage bounds')
          return;
        }
      }
      let changeelementId = Number(this.propertiesannotationData["toolbar_element_id"]) > 10 ? Number(this.propertiesannotationData["toolbar_element_id"]) : 100//this.propertiesannotationData["toolbar_element_id"];
      let annotationData = this.propertiesannotationData["annotation_data"];
      let getShapeStringWidthAB = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      if (this.propertiesannotationData.toolbar_element_id == 15 || this.propertiesannotationData.toolbar_element_id == 16) {
        let splitData: any = annotationData.split(" ");
        let moveX = 0;
        let moveY = 0;
        let lineX = 0;
        let lineY = 0;
        let height_add = 0, width_add = 0;
        for (var i = 0; i < splitData.length; i++) {
          var splitString = splitData[i].replaceAll('--', '-n');
          splitString = splitString.replaceAll(':-', ':n');
          let hypenSplit = splitString.split("-");
          if (hypenSplit.length > 2) {
            let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
            hypenSplit = [hypenSplit[0], localString1];
          }
          if (hypenSplit != '') {
            let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
            colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
            colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));

            if (hypenSplit[0] == "line") {
              lineX = colonSplit[0];
              lineY = colonSplit[1];
            } else {
              moveX = colonSplit[0];
              moveY = colonSplit[1];
            }

          }
        }
        // After rotate and resize line get mismatch commended. ramkumar
        // if (moveY > lineY) {
        //   let tempY = moveY
        //   moveY = lineY
        //   lineY = tempY
        // }
        // if (moveX > lineX) {
        //   let tempX = moveX
        //   moveX = lineX
        //   lineX = tempX
        // }
        let moveXdiff = (moveX - lineX) < 0 ? -(moveX - lineX) : (moveX - lineX)
        let moveYdiff = (moveY - lineY) < 0 ? -(moveY - lineY) : (moveY - lineY)
        let default_percentage = 2;
        if (percentage == false) {
          percentage_divide_value_w = (getShapeStringWidth.width / 100) * default_percentage;
          percentage_divide_value_h = (getShapeStringWidth.height / 100) * default_percentage;
          // if (getShapeStringWidth.width < 10) {
          //   moveY = (moveY - 2.5)
          //   lineY = (lineY + 2.5)
          // } else if (getShapeStringWidth.height < 10) {
          //   moveX = (moveX - 2.5)
          //   lineX = (lineX + 2.5)
          // } else if (moveXdiff < 50) {
          //   moveY = (moveY - 2.5)
          //   lineY = (lineY + 2.5)
          // } else if (moveYdiff < 50) {
          //   moveX = (moveX - 2.5)
          //   lineX = (lineX + 2.5)
          // } else {
          //   if (moveX < lineX) {
          //     moveX = moveX - 2.5
          //     lineX = lineX + 2.5
          //   } else if (moveX > lineX) {
          //     moveX = moveX + 2.5
          //     lineX = lineX - 2.5
          //   }
          //   if (moveY < lineY) {
          //     moveY = moveY - 2.5
          //     lineY = lineY + 2.5
          //   } else if (moveY > lineY) {
          //     moveY = moveY + 2.5
          //     lineY = lineY - 2.5
          //   }
          // }
          moveX = moveX - percentage_divide_value_w;
          lineX = lineX + percentage_divide_value_w;
          moveY = (moveY - percentage_divide_value_h);
          lineY = (lineY + percentage_divide_value_h);
        }
        else if (percentage == true) {
          moveX = moveX - percentage_divide_value_w;
          lineX = lineX + percentage_divide_value_w;
          moveY = (moveY - percentage_divide_value_h);
          lineY = (lineY + percentage_divide_value_h);
          // if (getShapeStringWidth.width < 10) {
          //   moveY = (moveY - percentage_divide_value_h)
          //   lineY = (lineY + percentage_divide_value_h)
          // } else if (getShapeStringWidth.height < 10) {
          //   moveX = (moveX - percentage_divide_value_w)
          //   lineX = (lineX + percentage_divide_value_w)
          // } else if (moveXdiff < 50 && moveXdiff != getShapeStringWidth.width) {
          //   moveY = (moveY - percentage_divide_value_h)
          //   lineY = (lineY + percentage_divide_value_h)
          // } else if (moveYdiff < 50 && moveYdiff != getShapeStringWidth.height) {
          //   moveX = (moveX - percentage_divide_value_w)
          //   lineX = (lineX + percentage_divide_value_w)
          // } else {
          //   if (moveX < lineX) {
          //     moveX = moveX - percentage_divide_value_w
          //     lineX = lineX + percentage_divide_value_w
          //   } else if (moveX > lineX) {
          //     moveX = moveX + percentage_divide_value_w
          //     lineX = lineX - percentage_divide_value_w
          //   }
          //   if (moveY < lineY) {
          //     moveY = moveY - percentage_divide_value_h
          //     lineY = lineY + percentage_divide_value_h
          //   } else if (moveY > lineY) {
          //     moveY = moveY + percentage_divide_value_h
          //     lineY = lineY - percentage_divide_value_h
          //   }
          // }
        }
        annotationData = "move-" + moveX + ":" + moveY + " line-" + lineX + ":" + lineY
      }
      // else if(this.propertiesannotationData.toolbar_element_id == 11){
      //   
      //   let correctedShapeWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      //   if (Number(this.propertiesannotationData["initial_width"]) != 0 && Number(this.propertiesannotationData["initial_height"] != 0)){
      //     this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["initial_width"]) + 10
      //     this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["initial_height"]) + 5
      //   }else{
      //     this.propertiesannotationData["initial_width"] = correctedShapeWidth.width + 10
      //     this.propertiesannotationData["initial_height"] = correctedShapeWidth.height + 5
      //   }

      //   this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"])-5
      //   this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"])-2.5
      // }
      else {

        if (Number(this.propertiesannotationData["toolbar_element_id"]) <= 11) {
          // let getresizeShapeString = this.shapeService1.resizeFunctionNew(data, false);
          // annotationData = getresizeShapeString.shapeString

          // this.propertiesannotationData["initial_position_x"] = getresizeShapeString.initialX-(2.5/2)
          // this.propertiesannotationData["initial_position_y"] = getresizeShapeString.initialY-(2.5/2)
          // annotationData = this.propertiesannotationData["annotation_data"]
          // this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_position_x"]) - (2.5) : Number(this.propertiesannotationData["initial_position_x"])
          // this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_position_y"]) - (2.5) : Number(this.propertiesannotationData["initial_position_y"])
          // this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_width"]) + 5 : 35
          // this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_height"]) + 5 : 35
          annotationData = this.changeShapeStringForBaseicon(changeelementId, changeWidth, changeHeight, annotationData)
          let data = _.cloneDeep(this.propertiesannotationData)
          data.annotation_data = annotationData;
          let changed_shape_data = this.changeShapePositionsInsideCanvas(annotationData, changeelementId, getShapeStringWidth)
          annotationData = changed_shape_data.annotationData

          // this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + changed_shape_data.left
          // this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + changed_shape_data.top
          // resize shape position mismatch issue solved below x and y changes
          if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11) {
            this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + ((getShapeStringWidth.width - changed_shape_data.width) / 2);
            this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + ((getShapeStringWidth.height - changed_shape_data.height) / 2);
          } else if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11) {
            this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + changed_shape_data.left;
            this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + changed_shape_data.top;
          } else if (this.propertiesannotationData["initial_width"] == 0 && this.propertiesannotationData["initial_height"] == 0) {
            if (Number(this.propertiesannotationData["initial_position_x"]) != 0 && Number(this.propertiesannotationData["initial_position_y"]) != 0) {
              // form attribute changes on simple shapes then it will change x!=0 and y!=0 on that time sizeincrease firstime position mismatch happen so reduced the line_width_reduce value; 
              let line_width_reduce = (Number(this.propertiesannotationData["line_width"]) / 6) / 2;
              this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + ((getElementRemove.clientWidth - changed_shape_data.width) / 2) //- 2.5;
              this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + ((getElementRemove.clientHeight - changed_shape_data.height) / 2) //- 2.5;
            }
            else {
              this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + ((getElementRemove.clientWidth - changed_shape_data.width) / 2) //- 2.5;
              this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + ((getElementRemove.clientHeight - changed_shape_data.height) / 2) //- 2.5;
            }
          } else {
            if (percentage == true) {
              this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) - (percentage_divide_value_w / 2);
              this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) - (percentage_divide_value_h / 2);
            }
            else {
              this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) - 2.5 + changed_shape_data.X;
              this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) - 2.5 + changed_shape_data.Y;
              // The below lines are commented for the purpose of ticket number P3X-2102 and the above ines are added.
              // this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) - 2.5;
              // this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) - 2.5;
            }
          }
          this.propertiesannotationData["initial_width"] = changed_shape_data.width//Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_width"]) + 5 : 35
          this.propertiesannotationData["initial_height"] = changed_shape_data.height//Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_height"]) + 5 : 35
          // adding the extra key reference ipad
        } else {
          annotationData = this.changeShapeStringForBaseicon(changeelementId, changeWidth, changeHeight, annotationData)
          let data = _.cloneDeep(this.propertiesannotationData)
          data.annotation_data = annotationData
          let correctedShapeWidth = this.shapeService1.getCanvaswidthandHeight(data);
          // if (correctedShapeWidth.width > 36 || correctedShapeWidth.height > 36) {
          // this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 12 ? this.propertiesannotationData["initial_position_y"] : this.dbyposition-2.5
          this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 11 ? 0 : correctedShapeWidth.width;
          this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 11 ? 0 : correctedShapeWidth.height;
        }
        // }
      }
      console.log("changeWidth-changeHeight",changeWidth,changeHeight)
      this.propertiesannotationData["annotation_data"] = annotationData;
      console.log("this.propertiesannotationData", this.propertiesannotationData["initial_position_x"], this.propertiesannotationData["initial_position_y"])
      console.log("this.dbxposition", this.dbxposition, this.dbyposition)
      let verifyXY = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      if ((getElementRemove.offsetLeft - 5) <= 0 || (getElementRemove.offsetTop - 5) <= 0 || (getElementRemove.offsetLeft + getElementRemove.offsetWidth + 5) >= this.realWidth || (getElementRemove.offsetTop + getElementRemove.offsetHeight + 5) >= this.realHeight) {
        this.propertiesannotationData = backupproperytData
      }
      // add original property 
      if (this.propertiesannotationData["toolbar_element_id"] > 11) {
        if (typeof this.propertiesannotationData["original_property"] == 'object') {
          this.propertiesannotationData["original_property"].annotation_data = this.propertiesannotationData["annotation_data"];
        }
      }
      this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]) + (2.5 / 2)
      this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]) + (2.5 / 2)
      this.coordinateX = Number(this.propertiesannotationData["initial_position_x"]) + (2.5 / 2)
      this.coordinateY = Number(this.propertiesannotationData["initial_position_y"]) + (2.5 / 2)
      // this.propertiesannotationData["initial_width"] = getShapeStringWidthAB.width;  
      // this.propertiesannotationData["initial_height"] = getShapeStringWidthAB.height;
      // getElementRemove.remove();
      // this.getshapeDrawing(this.propertiesannotationData, false);
      // if (this.createDocumentStore.view_annotation_array.length > 0) {
      //   let findIndex = this.createDocumentStore.view_annotation_array.findIndex((delete1) => delete1.annotation_id == this.propertiesannotationData["annotation_id"]);
      //   if (findIndex > -1) {
      //     this.createDocumentStore.view_annotation_array.splice(findIndex,1);
      //   }
      // }
      // this.getActiveLayerId();
      this.replacecurrentChangeInSVG(this.propertiesannotationData, true, backupproperytData);
      console.log('size increase', this.propertiesannotationData);
      console.log(this.layerDatas);
    }

  }
   

  //Properties section in sideBar update Start
  annotLabelUpdate1(changeValue) {
    changeValue = changeValue.trim();
    this.labelChange = true;
    this.attribute_change = true;
    this.propertiesannotationDataCopy["annotation_label"] = changeValue;
    if (this.multipleSelectOn == true) {
      this.updateSettingValueMultiple('label', changeValue);
    }
    this.single_view_preview_svg.annotation_label = changeValue;
    // this.combindSidebarDrawLogic(this.propertiesannotationDataCopy, 'propertyCanvasPreview', 'annotationLabelPreview');

  }

  annotNameUpdate1(changeValue) {
    this.attribute_change = true;
    changeValue = changeValue.trim();
    this.propertiesannotationDataCopy["annotation_name"] = changeValue;
    if (this.multipleSelectOn == true) {
      this.updateSettingValueMultiple('name', changeValue);
    }
  }

  updateSettingValueMultiple(field, value) {

    console.log(field, value);
    for (let ma = 0; ma < this.multiselectionList.length; ma++) {
      switch (field) {
        case 'name':
          this.multiselectionList[ma].annotation_name = value;
          break;
        case 'label':
          this.multiselectionList[ma].annotation_label = value;
          break;
        case 'stroke':
          this.multiselectionList[ma].stroke_color = value;
          break;
        case 'fill':
          this.multiselectionList[ma].fill_color = value;
          break;
        case 'opacity':
          this.multiselectionList[ma].opacity = value.toString();
          break;
        case 'linewidth':
          this.multiselectionList[ma].line_width = value;
          break;
        case 'shape':
          this.multiselectionList[ma].annotation_data = value.annotation_data;
          this.multiselectionList[ma].toolbar_element_id = value.toolbar_element_id;
          break;
      }
    }
  }
  //Properties section in sideBar update End

  //setColor canvas start
  strokeColor: string = "";
  fillColor: string = "";
  setStrokeColor(strokeColor) {
    this.attribute_change = true;
    this.checkShapeBoxOpen();
    if (this.multipleSelectOn == false) {
      this.propertiesannotationDataCopy["stroke_color"] = strokeColor;
      //this.propertiesShapeDraw(this.propertiesannotationDataCopy);
    } else {
      this.propertiesannotationDataCopy["stroke_color"] = strokeColor;
      this.updateSettingValueMultiple('stroke', strokeColor);
      // this.propertiesShapeDraw(this.propertiesannotationDataCopy);
    }
    if (strokeColor == "#NNNNNN00") {
      strokeColor="transparent";
    }
    this.single_view_preview_svg.stroke_color = strokeColor;
    // this.combindSidebarDrawLogic(this.propertiesannotationDataCopy, 'propertyCanvasPreview', 'annotationLabelPreview');
  }

  setFillColor(fillColor) {
    this.attribute_change = true;
    this.checkShapeBoxOpen();
    if (this.multipleSelectOn == false) {
      this.propertiesannotationDataCopy["fill_color"] = fillColor;
      // this.propertiesShapeDraw(this.propertiesannotationDataCopy);
    } else {
      this.propertiesannotationDataCopy["fill_color"] = fillColor;
      this.updateSettingValueMultiple('fill', fillColor);
      // this.propertiesShapeDraw(this.propertiesannotationDataCopy);
    }
    if (fillColor == "#NNNNNN00") {
      fillColor="transparent";
    }
    this.single_view_preview_svg.fill_color = fillColor;
    console.log(this.single_view_preview_svg);
    // this.combindSidebarDrawLogic(this.propertiesannotationDataCopy, 'propertyCanvasPreview', 'annotationLabelPreview');
  }

  changeOpacity(opacity) {
    if (this.multipleSelectOn == false) {
      console.log(this.opacityValue);
      // this.propertiesShapeDraw(this.propertiesannotationDataCopy);
    } else {
      this.updateSettingValueMultiple('opacity', opacity);
      // this.propertiesShapeDraw(this.propertiesannotationDataCopy);
    }
    let drawData = this.propertiesannotationDataCopy;
    drawData.opacity = this.opacityValue;
    this.single_view_preview_svg.opacity = this.opacityValue;
    // this.combindSidebarDrawLogic(drawData, 'propertyCanvasPreview', 'annotationLabelPreview');
  }

  changeLinewidth(linewidth) {
    this.attribute_change = true;
    this.checkShapeBoxOpen();
    this.lineWidth = Math.trunc(this.lineWidth);
    if (this.multipleSelectOn == false) {
      // this.propertiesShapeDraw(this.propertiesannotationDataCopy);
    } else {
      this.updateSettingValueMultiple('linewidth', this.lineWidth);
      // this.propertiesShapeDraw(this.propertiesannotationDataCopy);
    }
    let drawData = this.propertiesannotationDataCopy;
    if (drawData.toolbar_element_id < 12) {
      drawData.line_width = 0;
      drawData.line_width = this.lineWidth / 6;
    }
    else {
      drawData.line_width = this.lineWidth / 2;
    }
    // drawData.line_width = this.lineWidth;

    if (this.single_view_preview_svg != null && this.single_view_preview_svg != undefined) {
      let elementId = Number(this.single_view_preview_svg.toolbar_element_id);
      if (elementId < 12) {
        // this.single_view_preview_svg.linewidth =0;
        this.single_view_preview_svg.linewidth = this.lineWidth / 6;
      }
      else {
        this.single_view_preview_svg.linewidth = this.lineWidth / 2;
      }
      console.log(this.lineWidth);
      // lines checking
      let lines = [13, 14, 15, 16];
      if (lines.includes(Number(this.single_view_preview_svg.toolbar_element_id))) {
        this.single_view_preview_svg.linewidth = this.single_view_preview_svg.linewidth * 2;
      }
      
      // check resize shapes line width increase simple shapes only
      // if (this.single_view_preview_svg.toolbar_element_id < 12) {
      //   if (Number(this.single_view_preview_svg.initial_width) > 100 || Number(this.single_view_preview_svg.initial_height) > 100) {
      //     this.single_view_preview_svg.linewidth = this.lineWidth;
      //   }
      // }
    }
    // this.combindSidebarDrawLogic(drawData, 'propertyCanvasPreview', 'annotationLabelPreview');
  console.log(this.single_view_preview_svg);
  }

  async applySettingAPI(value) {
    var start = new Date().getTime();
    console.log('Properties apply click Start time: ' + start);
    this.show = true;
    if (this.multipleSelectOn == false) {
      await this.changeUpdateAPISingle();
      this.attribute_change = false;
    }
    else {
      await this.changeUpdateAPIMultiple();
      this.attribute_change = false;
    }
  }

  changeUpdateAPI() {
    let layers = [];
    if (this.layerDatas != undefined) {
      for (var i = 0; i < this.layerDatas.length; i++) {
        for (var j = 0; j < this.layerDatas[i].annotations.length; j++) {
          if (this.multiselectionList[this.multiselectionList.length - 1].annotation_id == this.layerDatas[i].annotations[j].annotation_id) {
            this.layerDatas[i].annotations[j] = this.multiselectionList[this.multiselectionList.length - 1];
            this.propertiesannotationData = this.multiselectionList[this.multiselectionList.length - 1];
          }
        }
        layers.push(this.layerDatas[i]);
      }
    }
  }

  async changeUpdateAPISingle() {
    this.show = true;
    let layers = [];
    if (this.layerDatas != undefined) {
      for (var i = 0; i < this.layerDatas.length; i++) {
        let itemIndex = this.layerDatas[i].annotations.findIndex(item => item.annotation_id == this.getId);
        var currentAnnotationMediaData = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
        if (currentAnnotationMediaData.length > 0) {
          if(this.lineWidth!="NaN"){
            this.propertiesannotationDataCopy["line_width"] = this.lineWidth;
          }
          // The below 2 if conditions are for changing text font size 
          if(this.propertiesannotationDataCopy.annotation_label!="" && this.textsize==undefined){
            this.textsize = parseInt(this.propertiesannotationDataCopy.text_font_size)
          }
          // if(this.textsize!=undefined && this.textsize!=13){
          //   this.propertiesannotationDataCopy.text_font_size = this.textsize.toString()
          // }
          if(this.textsize!=undefined){
            this.propertiesannotationDataCopy.text_font_size = this.textsize.toString()
          }
          this.propertiesannotationDataCopy["opacity"] = this.opacityValue.toString();
          console.log(typeof this.propertiesannotationDataCopy["opacity"]);
          if (this.propertiesannotationDataCopy["toolbar_element_id"] == 11) {
            let current_label_value = this.propertiesannotationDataCopy["annotation_label"];
            if (this.labelChange == true) {
              this.propertiesannotationDataCopy["annotation_data"] = this.textShapeDrawingLabelChanging(current_label_value);
            }
          }
          this.labelChange = false;
          this.propertiesannotationData = this.propertiesannotationDataCopy;
          // this.propertiesShapeDrawApply(this.propertiesannotationData);
          // let resizeCheck = this.sidebarDrawCalculation(this.propertiesannotationData);
          // this.shapeService1.formsheaderCanvas('propertyCanvasPreview', resizeCheck, 'annotationLabelPreview', 'DocPage');
          this.layerDatas[i].annotations.splice(itemIndex, 1, this.propertiesannotationDataCopy);
        }
        layers.push(this.layerDatas[i]);
      }
      let cloneSettingLayers = _.cloneDeep(this.layerDatas);
      // this.getAnnotationForm1(layers);
      let annotationIds = [];
      annotationIds.push(this.getId);
      // document view svg update
      await this.replacecurrentChangeInSVG(this.propertiesannotationDataCopy, true);
      // header svg drawing
      await this.single_view_svg_drawing(this.propertiesannotationDataCopy);
      var start = new Date().getTime();
      console.log('apicall Start time: ' + start);
      this.documentService.annotationUpdateForm1(cloneSettingLayers, this.getId, this.activeLayerIdDraw, 'property').subscribe((response) => {
        console.log(response);
        this.attribute_change = false;
        if (response["response_code"] == 200) {
          this.show = false;
          var end = new Date().getTime();
          var time = end - start;
          console.log('apicall' + ' end time: ' + end);
          console.log('apicall' + ' Execution time: ' + time);
        }
        else {
          this.errorMessage();
        }
      });
    }
  }
  
  async changeUpdateAPIMultiple() {
    this.show = true;
    var annotationIds = [];
    console.log(this.multiselectionList);
    if (this.layerDatas != undefined) {
      for (let ma = 0; ma < this.multiselectionList.length; ma++) {
        let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.multiselectionList[ma].layer_id);
        if (findLayerIndex != -1) {
          let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == this.multiselectionList[ma].annotation_id);
          if (findAnnotationIndexS != -1) {
            annotationIds.push(this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS].annotation_id);
            if(this.multiselectionList[ma].annotation_label!="" && this.textsize==undefined){
              this.textsize = parseInt(this.multiselectionList[ma].text_font_size)
            }
            if(this.textsize!=undefined && this.textsize!=13){
              this.multitextlabel = true;
              this.multiselectionList[ma].text_font_size = this.textsize.toString()
            }
            this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS] = this.multiselectionList[ma];
            // document view svg update
            await this.replacecurrentChangeInSVG(this.multiselectionList[ma], true);
          }
        }
      }
      let cloneSettingLayers = _.cloneDeep(this.layerDatas);
      for (let j = 0; j < annotationIds.length; j++) {
        let getElement_apply_after = document.getElementById(annotationIds[j]);
        if (getElement_apply_after != null) {
          getElement_apply_after.setAttribute('multimoving', '1');
        }
      }
      // header svg drawing
      if(this.multitextlabel == false){
        await this.single_view_svg_drawing(this.propertiesannotationDataCopy);
      }
      var start = new Date().getTime();
      console.log('multiple properties Start time: ' + start);
      this.documentService.annotationMultipleUpdate(cloneSettingLayers, this.multiselectionList,'property').subscribe((response) => {
        console.log(response);
        if (response["response_code"] == 200) {
          this.multitextlabel = false;
          this.show = false;
          var end = new Date().getTime();
          var time = end - start;
          console.log('multiple properties' + ' end time: ' + end);
          console.log('multiple properties' + ' Execution time: ' + time);
        }
        else {
          this.errorMessage();
        }
      });
    }
  }

  multiAnnotationTags: any[] = [];
  addTagsAnnot(project_tag_name) {

    console.log(this.userrole, "add annotclick");
    this.show = true;
    for (var i = 0; i < this.layerDatas.length; i++) {
      var currentAnnotation = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
      this.udoArrayChange(_.cloneDeep(currentAnnotation[0]))
    }
    var tagses = project_tag_name.trim();
    console.log(tagses);

    var filterTagsArray = [];
    let tagArrayComma = tagses.split(",");
    var tagArray = [];
    var tagArrayUnique = tagArrayComma.filter((value, index) => {
      return tagArrayComma.indexOf(value) === index;
    });
    // let uniquesCase = _.uniq(tagArrayUnique, (a,b) => a.toLowerCase() === b.toLowerCase())
    let uniquesCase = [];
    tagArrayUnique.forEach((e) => {
      if (uniquesCase.findIndex((r) => {
        return r.trim().toLowerCase() === e.trim().toLowerCase();
      }) === -1
      )
        uniquesCase.push(e);
    });
    uniquesCase.forEach((element) => {
      if (element.trim != "") {
        tagArray.push(element);
      }
    });
    console.log(tagArray);
    if (this.multipleSelectOn == false) {
      for (var i = 0; i < tagArray.length; i++) {
        // tagArray[i] = this.dataService4.changeFormat(tagArray[i]);
        if (this.annotationTags != undefined) {
          var a = 0;
          for (var j = 0; j < this.annotationTags.length; j++) {
            if (
              tagArray[i].trim().toLowerCase() ==
              this.annotationTags[j].trim().toLowerCase()
            ) {
              console.log(tagArray[i].trim() + "1");
              a--;
            } else if (tagArray[i].trim() == "") {
              console.log(tagArray[i].trim());
              a--;
            } else {
              a++;
              console.log(a);
            }
          }
          if (a == this.annotationTags.length) {
            filterTagsArray.push(tagArray[i]);
          }
        } else {
          for (var i = 0; i < tagArray.length; i++) {
            filterTagsArray.push(tagArray[i]);
          }
        }
        filterTagsArray = filterTagsArray.filter((element) => {
          return element.trim() != "";
        });
      }
      var convertStringTags = "";
      for (var l = 0; l < filterTagsArray.length; l++) {
        let firsttypeLetter = filterTagsArray[l][0].toUpperCase();
        let othertypeletters = filterTagsArray[l].slice(1);
        let changeUpperCaseProjectName = firsttypeLetter + othertypeletters;
        filterTagsArray[l] = changeUpperCaseProjectName;
        convertStringTags = convertStringTags + filterTagsArray[l].trim();
        if (filterTagsArray.length - 1 != l) {
          convertStringTags = convertStringTags + ",";
        }
        console.log(convertStringTags);
      }
    }
    if (filterTagsArray.length > 0 || this.multipleSelectOn == true) {
      if (this.multipleSelectOn == false) {
        let layers = [];
        for (var i = 0; i < this.layerDatas.length; i++) {
          let findAnnotate = this.layerDatas[i].annotations.findIndex((TData) => TData.annotation_id === this.propertiesannotationData["annotation_id"]);
          if (findAnnotate != -1) {
            // convertStringTags = this.dataService4.changeFormat(convertStringTags);
            this.layerDatas[i].annotations[findAnnotate].annotation_tags =
              this.layerDatas[i].annotations[findAnnotate].annotation_tags.length == 0 ? convertStringTags : this.layerDatas[i].annotations[findAnnotate].annotation_tags + "," + convertStringTags;
            this.annotationTags = this.layerDatas[i].annotations[findAnnotate].annotation_tags.split(",");
            this.annotationtagsName = "";
          }
          layers.push(this.layerDatas[i]);
        }
        this.layerDatas = layers;
        let cloneTagsLayer = _.cloneDeep(this.layerDatas);
        console.log(layers);
        this.annotationTagGet(this.propertiesannotationData["annotation_id"]);
        this.documentService.annotationUpdateForm1(cloneTagsLayer, this.getId, this.activeLayerIdDraw, 'property').subscribe((response) => {
          
          if (response["response_code"] == 200) {

            this.show = false;
          }
          else {
            this.errorMessage();
          }
        });
      }
      else if (this.multipleSelectOn == true) {
        this.multipleSelectOnTags = true;
        console.log(this.layerDatas);
        // var multilayers = [];
        console.log(this.checkTempList);
        for (var addtag = 0; addtag < this.multiselectionList.length; addtag++) {
          // multilayers = [];
          for (let i = 0; i < this.layerDatas.length; i++) {
            let findAnnotationIndex = this.layerDatas[i].annotations.findIndex((AData) => AData.annotation_id === this.multiselectionList[addtag].annotation_id);
            if (findAnnotationIndex != -1) {
              if (this.multiselectionList[addtag].annotation_tags == "" || this.multiselectionList[addtag].annotation_tags.length == 0) {
                for (let tk = 0; tk < tagArray.length; tk++) {
                  let firsttypeLetter = tagArray[tk][0].toUpperCase();
                  let othertypeletters = tagArray[tk].slice(1);
                  let changeUpperCaseProjectName = firsttypeLetter + othertypeletters;
                  tagArray[tk] = changeUpperCaseProjectName;
                }
                // tagArray.forEach((dataUpp) => {
                //   let firsttypeLetter = dataUpp[0].toUpperCase();
                //   let othertypeletters = dataUpp.slice(1);
                //   let changeUpperCaseProjectName = firsttypeLetter + othertypeletters;
                //   
                //   dataUpp = this.dataService4.changeFormat(changeUpperCaseProjectName);
                // });
                this.multiselectionList[addtag].annotation_tags = tagArray.toString();
              }
              else {
                let getTags = this.multiselectionList[addtag].annotation_tags;
                let convertCheck = getTags.split(',');
                for (let t = 0; t < tagArray.length; t++) {
                  //special
                  // tagArray[t] = this.dataService4.changeFormat(tagArray[t]);
                  if (convertCheck.some((data) => data.toLowerCase() == tagArray[t].toLowerCase())) {
                    let convertStringDb = this.multiselectionList[addtag].annotation_tags.toString();
                    this.multiselectionList[addtag].annotation_tags = convertStringDb;
                  }
                  else {
                    let convertStringDb = this.multiselectionList[addtag].annotation_tags.toString();
                    let firsttypeLetter = tagArray[t][0].toUpperCase();
                    let othertypeletters = tagArray[t].slice(1);
                    let changeUpperCaseProjectName = firsttypeLetter + othertypeletters;
                    tagArray[t] = changeUpperCaseProjectName;
                    let mergetString = convertStringDb + "," + tagArray[t].toString();
                    this.multiselectionList[addtag].annotation_tags = mergetString;
                  }
                }
              }
              this.layerDatas[i].annotations[findAnnotationIndex] = this.multiselectionList[addtag];
              this.annotationtagsName = "";
            }
            // multilayers.push(this.layerDatas[i]);
          }
        }
        // this.layerDatas = multilayers;
        console.log(this.layerDatas);
        this.tempTagLayerDatas = _.cloneDeep(this.layerDatas);
        this.multipleSelectTags();
        let cloneLayer = this.layerDatas;

        console.log(this.layerDatas);
        let cloneLayerDataTags = _.cloneDeep(cloneLayer);
        this.show = true;
        this.documentService.annotationMultipleUpdate(cloneLayerDataTags, this.multiselectionList,'property').subscribe((response) => {
          console.log(response);
          if (response["response_code"] == 200) {
            this.show = false;
          }
          else {
            this.errorMessage();
          }
        });
      }
    }
    else {
      this.show = false;
    }
  }
  //AddTags for annotation End

  //remove for annotaton tag start

  removeAnnotationTag(indexValue, annotationId, tagsname) {
    this.show = true;
    for (var i = 0; i < this.layerDatas.length; i++) {
      var currentAnnotation = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
      this.udoArrayChange(_.cloneDeep(currentAnnotation[0]))
    }
    if (this.multipleSelectOn == false) {
      console.log(indexValue);
      for (var i = 0; i < this.annotationTags.length; i++) {
        if (i == indexValue) {
          var a = this.annotationTags.splice(i, 1);
          var removeTagString = this.annotationTags.toString();
        }
      }
      let layers = [];
      for (var i = 0; i < this.layerDatas.length; i++) {
        let findAnnotationIndex = this.layerDatas[i].annotations.findIndex((AData) => AData.annotation_id == this.propertiesannotationData["annotation_id"]);
        if (findAnnotationIndex != -1) {
          this.layerDatas[i].annotations[findAnnotationIndex].annotation_tags = removeTagString;
        }
        // for (var j = 0; j < this.layerDatas[i].annotations.length; j++) {
        //   if (
        //     this.propertiesannotationData["annotation_id"] == this.layerDatas[i].annotations[j].annotation_id
        //   ) {
        //     this.layerDatas[i].annotations[j].annotation_tags = removeTagString;
        //   }
        // }
        layers.push(this.layerDatas[i]);
      }
      this.layerDatas = layers;
      console.log(layers);
      this.annotationTagGet(this.propertiesannotationData["annotation_id"]);
      let cloneTagsLayer = _.cloneDeep(this.layerDatas);
      this.documentService.annotationUpdateForm1(cloneTagsLayer, this.getId, this.activeLayerIdDraw,'property').subscribe((response) => {
     
        if (response["response_code"] == 200) {
          this.show = false;
        }
        else {
          this.errorMessage();
        }
      });
    } else if (this.multipleSelectOn == true) {
      this.multipleSelectOnTags = true;
      console.log(annotationId, indexValue);
      for (let i = 0; i < this.checkTempList.length; i++) {
        if (this.checkTempList[i] == tagsname) {
          let removedArray = this.checkTempList.splice(i, 1);
          var convertStringMethod = removedArray.toString();
        }
      }
      let layers = [];
      for (let removetag = 0; removetag < this.multiselectionList.length; removetag++) {
        let multitagsTemp = this.multiselectionList[removetag].annotation_tags;
        let multiconvertArrayTags = multitagsTemp.split(',');
        let multifindTagsIndex = multiconvertArrayTags.findIndex((tags) => tags == tagsname);
        if (multifindTagsIndex != -1) {
          multiconvertArrayTags.splice(multifindTagsIndex, 1);
          multiconvertArrayTags = multiconvertArrayTags.toString();
          this.multiselectionList[removetag].annotation_tags = multiconvertArrayTags;
        }
        layers = [];
        for (let k = 0; k < this.layerDatas.length; k++) {

          let findAnnotationIndex = this.layerDatas[k].annotations.findIndex((AData) => AData.annotation_id === this.multiselectionList[removetag].annotation_id);
          if (findAnnotationIndex != -1) {
            this.layerDatas[k].annotations[findAnnotationIndex] = this.multiselectionList[removetag];
          }
          layers.push(this.layerDatas[k]);
        }
      }
      this.layerDatas = layers;
      this.tempTagLayerDatas = _.cloneDeep(this.layerDatas);
      this.multipleSelectTags();
      let databackupLayer = this.layerDatas;
      let cloneRemoveData = _.cloneDeep(databackupLayer);
      this.documentService.annotationMultipleUpdate(cloneRemoveData, this.multiselectionList,'property').subscribe((response) => {
        console.log(response);
        if (response["response_code"] == 200) {
          this.show = false;
        }
        else {
          this.errorMessage();
        }
      });
    }
  }

  imagePreview(element) {
    var Previewdata: any = {
      imgUrl: element.media_url,
      FormData: this.sampleFormObject,
      Comment: element.media_comment,
      Stubid: element.stub_id,
      LayerData: this.layerDatas,
      AnnotationData: this.propertiesannotationData,
      name: element.media_name,
      projectid: this.projectId,
      multipleSelectOn: this.multipleSelectOn,
      multiselectionList: this.multiselectionList,
      folderlevel: this.route.snapshot.queryParamMap.get("folderlevel"),
      pfolderid: this.route.snapshot.queryParamMap.get("pfolderid"),
      projectFolderList: this.projectFolderList,
      getId: element.annotation_id,
      activeLayerIdDraw: this.activeLayerIdDraw
    };

    // setTimeout(() => {
    //   this.imgdataService.sendMessage(Previewdata);
    // }, 50);
    // this.imgdataService.sendMessage(Previewdata);
    // localStorage.setItem('preview_image_data',JSON.stringify(Previewdata));
    // this.encrptdecrpt.setItem("preview_image_data", Previewdata);//security
    let open_window = (<any>window).open("/previewImage");
    open_window.pass_variable = Previewdata

    // window.open("/previewImage");
    // this.router.navigateByUrl("/previewImage");
  }
  //remove for annotaton tag End

  openLinkToDocument() {
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    this.dialogBox.open(LinksToDocumentComponent, {
      data: {
        projectFolderList: this.projectFolderList,
        projectId: this.projectId,
        projectName: this.projectName,
        documentDetails: this.documentDetails,
        activatedAnnotationId: this.getId,
        layerDatas: this.layerDatas,
        linkDocument: true,
        multipleSelectOn: this.multipleSelectOn,
        multiselectionList: this.multiselectionList,
        allDocumentPages: this.getAllDocumentPagesValue,
        getId: this.getId,
        activeLayerIdDraw: this.activeLayerIdDraw
      },
    });
    // this.dialogRef.close();
  }
  openLinktoUrl() {
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    console.log(this.propertiesannotationData)
    let dialogBoxLinkToURL = this.dialogBox.open(LinkToUrlComponent, {
      width: "400px",
      data: {
        projectFolderList: this.projectFolderList,
        projectId: this.projectId,
        documentDetails: this.documentDetails,
        activatedAnnotationId: this.getId,
        layerDatas: this.layerDatas,
        multipleSelectOn: this.multipleSelectOn,
        multiselectionList: this.multiselectionList,
        getId: this.getId,
        linksarray: this.linksarray,

        activeLayerIdDraw: this.activeLayerIdDraw
      },
    });
    // this.dialogBox.close();
    dialogBoxLinkToURL.afterClosed().subscribe((count) => {
      if (count != undefined) {
        this.linkCount = count;
        this.annotationlinkGet(this.getId);
      }
    });
  }

  projectFolderList: any[];

  myFunction(event) {
    this.dataService4.specialCharacterPasteRestrict(event);
  }

  getProjectfolderlist(linksupdate: boolean) {
    return new Promise((resolve, reject) => {
      var start = new Date().getTime();
      console.log('project folder list' + ' Start time: ' + start);
      this.documentService.getProjectfolder(this.projectId).subscribe((response) => {
        if (response["response_code"] == 200) {
          var end = new Date().getTime();
          var time = end - start;
          console.log('project folder list' + ' end time: ' + end);
          console.log('project folder list' + ' Execution time: ' + time);
          let localvalueresponse = response["response_body"]["project_master"];
          this.projectFolderList = localvalueresponse;
          if (this.projectFolderList != undefined) {
            var changesome1 = this.projectFolderList.filter((data) => {
              return data["is_hidden"] == false;
            });
            var dateFilter1 = changesome1.filter((dateonly) => {
              return (dateonly.created_date = this.datePipe.transform(
                dateonly.created_date,
                "MM/dd/yyyy"
              ));
            });
            var changesome3 = dateFilter1.filter((dateonly1) => {
              return (dateonly1.last_updated_date = this.datePipe.transform(
                dateonly1.last_updated_date,
                "MM/dd/yyyy"
              ));
            });
            this.projectFolderList = changesome3;
            // getCount and Location of links
            if (linksupdate == true) {
              this.annotationlinkGet(this.getId);
            }
          }
          resolve(200);
        }
      });
    })
  }

  //openLinkOptionMenu open dialog Start
  openLinkOptionMenu(event, annotationLink, id, v) {
    console.log(this.getId, id, v)
    event.preventDefault();
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    this.dialogBox.open(LinkOptionMenuComponent, {
      width: "380px",
      data: {
        annotationLink: annotationLink,
        activatedAnnotationId: this.getId,
        layerDatas: this.layerDatas,
        multipleSelectOn: this.multipleSelectOn,
        multiselectionList: this.multiselectionList,
        getId: this.getId,
        getActiveId: id,
        index: v,
        activeLayerIdDraw: this.activeLayerIdDraw
      },
    });
  }
  //openLinkOptionMenu open dialog End
  
  onContextMenu(event, stubid, url, filename, data) {
    console.log(data["annotation_id"]);
    if (this.multipleSelectOn == true) {
      this.getId = data["annotation_id"];
    }
    console.log(data);
    event.preventDefault();
    var dialogref = this.dialogBox.open(MediamenuComponent, {
      width: "380px",
      data: {
        mediacount: this.mediaCount,
        mediaData: data,
        stubIdData: stubid,
        media_url: url,
        media_filename: filename,
        layer_data: this.layerDatas,
        folderid: this.folderId,
        folderlevel: this.route.snapshot.queryParamMap.get("folderlevel"),
        pfolderid: this.route.snapshot.queryParamMap.get("pfolderid"),
        layerDatas: this.layerDatas,
        getId: this.getId,
        multipleSelectOn: this.multipleSelectOn,
        multiselectionList: this.multiselectionList,
        projectFolderList: this.projectFolderList,
        activeLayerIdDraw: this.activeLayerIdDraw
      },
    });
    // dialogref.afterClosed().subscribe((res) => {
    //   this.getAnnotationForm();
    // });
  }

  polygonmethod() {
    // this.drawShapeDonePolygon = true;
    console.log('call polygon method');
    this.stringPathArray = [];
    this.getPositionString = "";
    this.annotationName = "Polygon";
    var coords = [];

    var pdfImg = document.getElementById("pdfImg");
    var canvas = document.createElement("canvas");
    canvas.setAttribute("width", this.realWidth);
    canvas.setAttribute("height", this.realHeight);
    canvas.setAttribute("customepolygonattribute", "1");
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.style.zIndex = "999";
    pdfImg.appendChild(canvas);

    this.polygonMethodCommon(canvas, pdfImg, coords);
  }

  polygonmethodSVG() {
    // this.drawShapeDonePolygon = true;
    console.log('call polygon method');
    this.stringPathArray = [];
    this.getPositionString = "";
    // this.annotationName = "Polygon";
    var coords = [];
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customepolygonattribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    create_path.setAttribute("customepolygonattributepath", "1");
    newcreatedElement.appendChild(create_path);
    pdfImg.appendChild(newcreatedElement);
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    this.polygonMethodCommonSVG(newcreatedElement, create_path, coords);
  }

  polygonMethodCommon(canvas, pdfImg, coords) {
    this.drawCanvasContext = canvas.getContext("2d");
    canvas.addEventListener("click", (event: any) => {
      let circle = this.addredCircles(event.offsetX, event.offsetY);
      pdfImg.appendChild(circle);
      if (this.getPositionSetMove != 1) {
        this.getPositionString = " " + "line" + "-" + event.offsetX + ":" + event.offsetY;
        this.stringPathArray.push(this.getPositionString);
      }
      if (this.getPositionSetMove == 1) {
        this.getPositionString = "move" + "-" + event.offsetX + ":" + event.offsetY;
        coords = [];
        this.getPositionSetMove++;
        this.stringPathArray.push(this.getPositionString);
      }
      console.log(this.stringPathArray);
      this.accessPolygonMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      var coord = { x: event.offsetX, y: event.offsetY };
      coords.push(coord);
      var max = coords.length - 1;
      if (typeof coords[max - 1] !== "undefined") {
        var curr = coords[max], prev = coords[max - 1];
        this.drawCanvasContext.beginPath();
        this.drawCanvasContext.moveTo(prev.x, prev.y);
        this.drawCanvasContext.lineTo(curr.x, curr.y);
        this.drawCanvasContext.strokeStyle = "black";
        this.drawCanvasContext.lineWidth = 2;
        this.drawCanvasContext.stroke();
      }
    });
  }

  polygonMethodCommonSVG(svg_handler, path, coords) {
    path.setAttribute('stroke', "black");
    path.setAttribute('stroke-width', "2");
    path.setAttribute('fill', "none");
    //line and circles points zooming 
    this.checkZoomInorOut();
    let path_value = "";
    if (coords.length > 0) {
      for (let k = 0; k < coords.length; k++) {
        path_value = k == 0 ? `M${coords[k].x}  ${coords[k].y}` : (path_value + ` L${coords[k].x} ${coords[k].y}`);
      }
    }
    svg_handler.addEventListener("click", (event: any) => {
      if(this.showvisible==false){
        return
      }
      if(this.layerDatas.length==0){
        return
      }
      
      if((this.layerDatas.length!=0)){
var active=this.layerDatas;
active=active.filter(res=>res.layer_id==this.activeLayerIdDraw)
     }
     if(this.layerDatas.length!=0 && active.length==0){
       return
     }
      let circle = this.addredCirclesSVG(event.offsetX, event.offsetY);
      svg_handler.appendChild(circle);
      if (this.getPositionSetMove != 1) {
        this.getPositionString = " " + "line" + "-" + event.offsetX + ":" + event.offsetY;
        this.stringPathArray.push(this.getPositionString);
        path_value = path_value + ` L${event.offsetX} ${event.offsetY}`;
      }
      if (this.getPositionSetMove == 1) {
        this.getPositionString = "move" + "-" + event.offsetX + ":" + event.offsetY;
        coords = [];
        this.getPositionSetMove++;
        this.stringPathArray.push(this.getPositionString);
        path_value = `M${event.offsetX} ${event.offsetY}`;
      }
      console.log(this.stringPathArray);
      this.accessPolygonMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      var coord = { x: event.offsetX, y: event.offsetY };
      coords.push(coord);
      var max = coords.length - 1;
      if (typeof coords[max - 1] !== "undefined") {
        path.setAttribute("d", path_value);
      }
    });
  }

  updateDrawShapes() {
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    if (this.toolbarElementId == 18) {
      this.polygonFillDraw();
    } else if (this.toolbarElementId == 14 ) {
      this.polylinemethodUpdateAPI();
    } else if (this.toolbarElementId == 13) {
      this.polylinearrowmethodUpdateAPI();
    }
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  removeRedCircles() {
    this.red = true;
    var redCircle = document.querySelectorAll("span.tempcircle").forEach((circleData) => {
      circleData.remove();
    });
  }


  //polygon Draw Method Start
  polygonFillDraw() {
    this.show = true;
    var convertAnnotationData = "";
    this.drawShapeDonePolygon = false;
    this.drawCanvasContext = null;
    this.accessPolygonMenuFeatureStop = false;
    this.toolbarSet = false;
    this.removeredCirclesSVG();
    this.removesvgAttribute('customepolygonattribute');
    let close_path_string = "";
    for (var i = 0; i < this.stringPathArray.length; i++) {
      if (i == 0) {
        let get_first_point = this.stringPathArray[i];
        let split_hyphen = get_first_point.split('-');
        split_hyphen[0] = "line-";
        close_path_string = split_hyphen[0] + split_hyphen[1];
      }
      convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
    }
    convertAnnotationData = convertAnnotationData + " " + close_path_string;
    convertAnnotationData = convertAnnotationData.trim();
    var annontationidDate = new Date().getTime();
    var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
    var MyDateString = new Date().toISOString();
    // this.annotationName = "Polygon";
    let label_string = "";
    label_string = this.annotationLabelTemplate();
    this.createJson = {
      annotation_data: convertAnnotationData,
      annotation_forms: this.selectAnnotationForms,
      annotation_id: uuid,
      annotation_label: label_string,
      annotation_links: [],
      annotation_media: [],
      annotation_name: this.annotationName,
      annotation_stubs: [],
      annotation_tags: "",
      annotation_url: "",
      created_by_user_id: this.su.user_id,
      created_date: MyDateString,
      document_id: this.folderId,
      element_size: 1,
      fill_color: this.currentSelectedItems.element_data.fill_color,
      initial_rotation:0,
      initial_height: 0,
      initial_position_x: 0,
      initial_position_y: 0,
      initial_width: 0,
      is_removed: false,
      last_updated_date: MyDateString,
      layer_id: this.activeLayerIdDraw,
      line_width: this.currentSelectedItems.element_data.line_width,
      opacity: 1,
      original_property: "",
      page_id: this.currentPageId,
      project_id: this.projectId,
      stroke_color: this.currentSelectedItems.element_data.stroke_color,
      toolbar_element_id: 18,
      updated_by_user_id: this.su.user_id,
      version_number: 1,
    };
    this.annotationUpdate();
  }

  getAnnotationWidthandHeightAction(getString) {
    let convertAnnotationWH = getString;
    let xCoordinate = [];
    let yCoordinate = [];
    let startx;
    let starty;
    let endx;
    let endy;
    convertAnnotationWH = convertAnnotationWH.trim();
    let splitData = convertAnnotationWH.split(" ");
    for (var i = 0; i < splitData.length; i++) {
      let splitString = splitData[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      let hypenSplit = splitString.split("-");
      let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
      xCoordinate.push(colonSplit[0]);
      xCoordinate.push(colonSplit[2]);
      yCoordinate.push(colonSplit[1]);
      yCoordinate.push(colonSplit[3]);
    }
    startx = Math.min.apply(null, xCoordinate);
    endx = Math.max.apply(null, xCoordinate);
    starty = Math.min.apply(null, yCoordinate);
    endy = Math.max.apply(null, yCoordinate);
    console.log(startx, starty, endx, endy);
    let getDrawWidthandHeight = this.calculateRectPos(
      startx,
      starty,
      endx,
      endy
    );
    return getDrawWidthandHeight;
  }

  //polygon Draw Method end
  //Polygon Draw Done Click Draw Method
  annotationUpdatePolygonDraw(convertAnnotationString) {
    this.drawShapeDonePolygon = false;
    this.show = false;
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    //   const img = new Image()
    //   img.src = this.imgUrl;
    //   img.onload = () => {
    //   this.canvasElement.drawImage(img, 0, 0,600,450);
    //   }
    this.canvasElement.beginPath();
    convertAnnotationString = convertAnnotationString.trim();
    var spaceSplit = convertAnnotationString.split(" ");
    console.log(spaceSplit);
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");
      for (var j = 0; j < hypenSplit.length; j++) {
        if (hypenSplit[0] == "controlpoint") {
          var cpx = parseFloat(colonSplit[0]);
          var cpy = parseFloat(colonSplit[1]);
        }
        if (hypenSplit[0] == "curveEnd") {
          var ex = parseFloat(colonSplit[0]);
          var ey = parseFloat(colonSplit[1]);
        }
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var colonSplit = hypenSplit[j].split(":");
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var h = parseFloat(colonSplit[2]);
          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            // this.canvasElement.drawImage(urlImg,this.coordinateX,this.coordinateX)
            this.canvasElement.moveTo(x, y);
            break;
          case "line":
            this.canvasElement.clearRect(
              0,
              0,
              newcreatedElement.width,
              newcreatedElement.height
            );
            this.canvasElement.lineTo(x, y);
            break;
          case "ovalIn":
            var r = (w * w) / (8 * h) + h / 2;
            // this.canvasElement.ellipse(x, y, h, w,  90 * Math.PI/180, 0, 2 * Math.PI)
            this.canvasElement.arc(
              newcreatedElement.clientWidth / 2,
              newcreatedElement.clientHeight / 2.3,
              r,
              0,
              2 * Math.PI
            );
            break;
          case "curveEnd":
            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
            break;
        }
        var checkFill = "red";
        this.canvasElement.closePath();
        this.canvasElement.fillStyle = this.checkStrokeColor1(checkFill);
        this.canvasElement.fill();
        this.canvasElement.lineWidth = 1;
        this.canvasElement.stroke();
      }
    }
  }

  //Polygon Draw Done Click Draw Method

  //undo polygon method start
  undoPolygon() {
    this.stringPathArray.splice(-1, 1);
    this.removeRedCircles();
    if (this.stringPathArray.length > 0) {
      console.log(this.stringPathArray);
      this.accessPolygonMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      this.removeCanvasAttribute('customepolygonattribute');
      console.log(this.stringPathArray);
      var convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      console.log(convertAnnotationData);
      this.seperateDrawUndoPolygon(convertAnnotationData);
    }
    if (this.stringPathArray.length == 0) {
      console.log(this.stringPathArray);
      this.removeCanvasAttribute("customepolygonattribute");
      this.accessPolygonMenuFeatureStop = true;
      this.polygonmethod();
      this.getPositionSetMove = 1;
    }

  }

  undoPolygonSVG() {
    this.stringPathArray.splice(-1, 1);
    this.removeredCirclesSVG();
    if (this.stringPathArray.length > 0) {
      console.log(this.stringPathArray);
      this.accessPolygonMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      this.removesvgAttribute('customepolygonattribute');
      console.log(this.stringPathArray);
      var convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      console.log(convertAnnotationData);
      this.seperateDrawUndoPolygonSVG(convertAnnotationData);
    }
    if (this.stringPathArray.length == 0) {
      console.log(this.stringPathArray);
      this.removesvgAttribute("customepolygonattribute");
      this.accessPolygonMenuFeatureStop = true;
      this.polygonmethodSVG();
      this.getPositionSetMove = 1;
    }

  }
  //undo polygon method end

  // Undo After draw the polyline shape end

  seperateDrawUndoPolyline(convertAnnotationData) {
    var coords = [];
    if (this.stringPathArray.length > 0) {
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var hypenSplit = this.stringPathArray[i].split("-");
        var colonSplit = hypenSplit[1].split(":");
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
      }
      console.log(coords);
      var pdfImg = document.getElementById("pdfImg");
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", this.realWidth);
      canvas.setAttribute("height", this.realHeight);
      canvas.setAttribute("customepolylineattribute", "1");
      canvas.style.position = "absolute";
      canvas.style.top = "0px";
      canvas.style.left = "0px";
      canvas.style.zIndex = "999";
      pdfImg.appendChild(canvas);
      this.polylineMethodReDraw(canvas, pdfImg, coords);
      var max = coords.length - 1;
      for (var l = 0; l < coords.length; l++) {
        let circle = this.addredCircles(coords[l].x, coords[l].y);
        pdfImg.appendChild(circle);
        if (typeof coords[max - 1] !== "undefined" && l >= 1) {
          var curr = coords[l], prev = coords[l - 1];
          console.log(curr);
          console.log(prev);
          this.drawCanvasContext.beginPath();
          this.drawCanvasContext.moveTo(prev.x, prev.y);
          this.drawCanvasContext.lineTo(curr.x, curr.y);
          this.drawCanvasContext.strokeStyle = "black";
          this.drawCanvasContext.lineWidth = 2;
          this.drawCanvasContext.stroke();
        }
      }
    } else {
      this.accessPolylineMenuFeatureStop = true;
      this.polylinemethod();
    }
  }

  // Undo After draw the polyline shape end

  //undo polyline draw common function start
  polylineMethodReDraw(canvas, pdfImg, coords) {
    this.drawCanvasContext = canvas.getContext("2d");
    canvas.addEventListener("click", (event: any) => {
      console.log('polyline click method');
      let circle = this.addredCircles(event.offsetX, event.offsetY);
      pdfImg.appendChild(circle);
      if (this.getPositionSetMove != 1) {
        this.getPositionString = " " + "line" + "-" + event.offsetX + ":" + event.offsetY;
        this.stringPathArray.push(this.getPositionString);
      }
      if (this.getPositionSetMove == 1) {
        this.getPositionString = "move" + "-" + event.offsetX + ":" + event.offsetY;
        coords = [];
        this.stringPathArray.push(this.getPositionString);
        this.getPositionSetMove++;
      }
      this.accessPolylineMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      var coord = { x: event.offsetX, y: event.offsetY };
      coords.push(coord);
      var max = coords.length - 1;
      if (typeof coords[max - 1] !== "undefined") {
        var curr = coords[max], prev = coords[max - 1];
        this.drawCanvasContext.beginPath();
        this.drawCanvasContext.moveTo(prev.x, prev.y);
        this.drawCanvasContext.lineTo(curr.x, curr.y);
        this.drawCanvasContext.strokeStyle = "black";
        this.drawCanvasContext.lineWidth = 2;
        this.drawCanvasContext.stroke();
      }
      console.log(this.stringPathArray);
    });
  }

  //undo polyline draw common function end
  //undo polyline method start
  undoPolyline() {
    this.stringPathArray.splice(-1, 1);
    this.removeRedCircles();
    if (this.stringPathArray.length > 0) {
      this.accessPolylineMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      this.removeCanvasAttribute('customepolylineattribute');
      var convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      console.log(convertAnnotationData);
      this.seperateDrawUndoPolyline(convertAnnotationData);
    }
    if (this.stringPathArray.length == 0) {
      this.removeCanvasAttribute('customepolylineattribute');
      this.accessPolylineMenuFeatureStop = true;
      this.polylinemethod();
      this.getPositionSetMove = 1;
    }
  }

  //line and circles points zooming 
  checkZoomInorOut() {
    if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
      || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
      let local_scale = this.pngFormat ? this.scale : this.pdfScaleValue > 1 ? this.pdfScaleValue : this.scale;
      if (local_scale >= 1.24049) {
        this.zoomingLineShapeHandle();
      }
      else if (local_scale < 1.24049) {
        this.zoomingLineShapeHandle_revert();
      }
    }
  }

  checkZoomInorOut_repoint() {
    if (this.createDocumentStore.enablerepointButtons == true) {
      let local_scale = this.pngFormat ? this.scale : this.pdfScaleValue > 1 ? this.pdfScaleValue : this.scale;
      if (local_scale >= 1.24049) {
        this.zoomingLineShapeHandle_Repoint();
      }
      else if (local_scale < 1.24049) {
        this.zoomingLineShapeHandle_revert();
      }
    }
  }

  polyline_zoomingpoint(attributeName: string) {
    // this.stringPathArray.splice(-1, 1);
    // circle reducing size when zooming
    let local_scale = this.pngFormat ? this.scale : this.pdfScaleValue > 1 ? this.pdfScaleValue : this.scale;
    let get_circles = document.querySelectorAll('circle.tempcircle');
    if (get_circles.length > 0) {
      for (let cir = 0; cir < get_circles.length; cir++) {
        let default_radius = 6;
        let calculate_scaling = 6 / local_scale;
        calculate_scaling = calculate_scaling <= 0.5 ? 0.5 : calculate_scaling;
        get_circles[cir].setAttribute('r', calculate_scaling.toString());
      }
    }
    // line reducing size when zooming
    let get_drawing_element = document.querySelector(`path[${attributeName}]`);
    console.log(get_drawing_element);
    if (get_drawing_element != null && this.pdf_zoom == false) {
      let default_stroke_width = 2;
      let calculate_scaling = 2 / local_scale;
      calculate_scaling = calculate_scaling <= 0.5 ? 0.5 : calculate_scaling;
      get_drawing_element.setAttribute('stroke-width', calculate_scaling.toString());
    }
  }


  polyline_zoomingpoint_revert(attributeName: string) {
    let local_scale = this.pngFormat ? this.scale : this.pdfScaleValue > 1 ? this.pdfScaleValue : this.scale;
    let get_circles = document.querySelectorAll('circle.tempcircle');
    if (get_circles.length > 0) {
      for (let cir = 0; cir < get_circles.length; cir++) {
        // let default_radius = 6;
        // get_circles[cir].setAttribute('r', default_radius.toString());
        let default_radius = 6;
        let calculate_scaling = 6 / local_scale;
        calculate_scaling = calculate_scaling <= 0.5 ? 0.5 : calculate_scaling;
        get_circles[cir].setAttribute('r', calculate_scaling.toString());
      }
    }
    // line reducing size when zooming
    let get_drawing_element = document.querySelector(`path[${attributeName}]`);
    console.log(get_drawing_element);
    if (get_drawing_element != null && this.pdf_zoom == false) {
      // let default_stroke_width = 2;
      // get_drawing_element.setAttribute('stroke-width', default_stroke_width.toString());
      let default_stroke_width = 2;
      let calculate_scaling = 2 / local_scale;
      calculate_scaling = calculate_scaling <= 0.5 ? 0.5 : calculate_scaling;
      get_drawing_element.setAttribute('stroke-width', calculate_scaling.toString());
    }
  }

  undoPolygonDrawing_zoomingpoint() {
    this.removeRedCircles();
    if (this.stringPathArray.length > 0) {
      console.log(this.stringPathArray);
      this.accessPolygonMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      this.removeCanvasAttribute('customepolygonattribute');
      console.log(this.stringPathArray);
      var convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      console.log(convertAnnotationData);
      this.seperateDrawUndoPolygon(convertAnnotationData);
    }
    if (this.stringPathArray.length == 0) {
      console.log(this.stringPathArray);
      this.removeCanvasAttribute("customepolygonattribute");
      this.accessPolygonMenuFeatureStop = true;
      this.polygonmethod();
      this.getPositionSetMove = 1;
    }

  }

  undoPolylineArrowDrawing_zoomingpoint() {
    this.removeRedCircles();
    if (this.stringPathArray.length > 0) {
      this.accessPolylineArrowMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      this.removeCanvasAttribute('customepolylinearrowattribute')
      var convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      console.log(convertAnnotationData);
      this.seperateDrawUndoPolylineArrow(convertAnnotationData);
    }
    if (this.stringPathArray.length == 0) {
      this.removeCanvasAttribute('customepolylinearrowattribute');
      this.accessPolylineArrowMenuFeatureStop = true;
      this.polylinearrowmethodSVG();
      this.getPositionSetMove = 1;
    }
  }
  //undo polyline method end

  //undo polyline arrow method start
  undoPolylineArrow() {
    this.stringPathArray.splice(-1, 1);
    this.removeRedCircles();
    if (this.stringPathArray.length > 0) {
      this.accessPolylineArrowMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      this.removeCanvasAttribute('customepolylinearrowattribute')
      var convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      console.log(convertAnnotationData);
      this.seperateDrawUndoPolylineArrow(convertAnnotationData);
    }
    if (this.stringPathArray.length == 0) {
      this.removeCanvasAttribute('customepolylinearrowattribute');
      this.accessPolylineArrowMenuFeatureStop = true;
      this.polylinearrowmethod();
      this.getPositionSetMove = 1;
    }
  }

  undoPolylineArrowSVG() {
    this.stringPathArray.splice(-1, 1);
    this.removeredCirclesSVG();
    if (this.stringPathArray.length > 0) {
      this.accessPolylineArrowMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      this.removesvgAttribute('customepolylinearrowattribute')
      var convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      console.log(convertAnnotationData);
      this.seperateDrawUndoPolylineArrowSVG(convertAnnotationData);
    }
    if (this.stringPathArray.length == 0) {
      this.removesvgAttribute('customepolylinearrowattribute');
      this.accessPolylineArrowMenuFeatureStop = true;
      this.polylinearrowmethodSVG();
      this.getPositionSetMove = 1;
    }
  }
  //undo polyline arrow method end

  //after click undo polyline arrow draw shape method start
  seperateDrawUndoPolylineArrow(convertAnnotationData) {
    var coords = [];
    if (this.stringPathArray.length > 0) {
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var hypenSplit = this.stringPathArray[i].split("-");
        var colonSplit = hypenSplit[1].split(":");
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
      }
      console.log(coords);
      var pdfImg = document.getElementById("pdfImg");
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", this.realWidth);
      canvas.setAttribute("height", this.realHeight);
      canvas.setAttribute("customepolylinearrowattribute", "1");
      canvas.style.position = "absolute";
      canvas.style.top = "0px";
      canvas.style.left = "0px";
      canvas.style.zIndex = "999";
      pdfImg.appendChild(canvas);
      this.polylinearrowMethodReDraw(canvas, pdfImg, coords);
      var max = coords.length - 1;
      for (var l = 0; l < coords.length; l++) {
        let circle = this.addredCircles(coords[l].x, coords[l].y);
        pdfImg.appendChild(circle);
        if (typeof coords[max - 1] !== "undefined" && l >= 1) {
          var curr = coords[l],
            prev = coords[l - 1];
          this.drawCanvasContext.beginPath();
          this.drawCanvasContext.moveTo(prev.x, prev.y);
          this.drawCanvasContext.lineTo(curr.x, curr.y);
          this.drawCanvasContext.strokeStyle = "black";
          this.drawCanvasContext.lineWidth = 2;
          this.drawCanvasContext.stroke();
        }
      }
      console.log(this.stringPathArray);
    } else {
      this.accessPolylineArrowMenuFeatureStop = true;
      this.polylinearrowmethod();
    }
  }

  seperateDrawUndoPolylineArrowSVG(convertAnnotationData) {
    var coords = [];
    if (this.stringPathArray.length > 0) {
      let path_value = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var hypenSplit = this.stringPathArray[i].split("-");
        var colonSplit = hypenSplit[1].split(":");
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
        path_value = i == 0 ? `M${coord.x} ${coord.y}` : (path_value + ` L${coord.x} ${coord.y}`);
      }
      console.log(coords);

      var pdfImg = document.getElementById("pdfImg");
      var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      newcreatedElement.setAttribute("width", this.realWidth);
      newcreatedElement.setAttribute("height", this.realHeight);
      newcreatedElement.setAttribute("customepolylinearrowattribute", "1");
      newcreatedElement.style.position = "absolute";
      newcreatedElement.style.top = "0px";
      newcreatedElement.style.left = "0px";
      newcreatedElement.style.zIndex = "999";
      let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      create_path.setAttribute("customepolylinearrowattributepath", "1");
      newcreatedElement.appendChild(create_path);
      pdfImg.appendChild(newcreatedElement);
      // add transform on svg If zoomin 1 above
      this.addZoom(newcreatedElement);
      this.polylinearrowMethodReDrawSVG(newcreatedElement, create_path, coords);
      var max = coords.length - 1;
      create_path.setAttribute('stroke', "black");
      create_path.setAttribute('stroke-width', "2");
      create_path.setAttribute('fill', "none");
      //line and circles points zooming 
      this.checkZoomInorOut();
      for (var l = 0; l < coords.length; l++) {
        let circle = this.addredCirclesSVG(coords[l].x, coords[l].y);
        newcreatedElement.appendChild(circle);
      }
      if (typeof coords[max - 1] !== "undefined") {
        create_path.setAttribute("d", path_value);
      }
    } else {
      this.accessPolylineArrowMenuFeatureStop = true;
      this.polylinearrowmethodSVG();
    }
  }
  //after click undo polyline arrow draw shape method end

  //seperate draw polygon after undo start
  seperateDrawUndoPolygon(convertAnnotationData) {
    var coords = [];
    if (this.stringPathArray.length > 0) {
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var hypenSplit = this.stringPathArray[i].split("-");
        var colonSplit = hypenSplit[1].split(":");
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
      }
      var pdfImg = document.getElementById("pdfImg");
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", this.realWidth);
      canvas.setAttribute("height", this.realHeight);
      canvas.setAttribute("customepolygonattribute", "1");
      canvas.style.position = "absolute";
      canvas.style.top = "0px";
      canvas.style.left = "0px";
      canvas.style.zIndex = "999";
      pdfImg.appendChild(canvas);
      this.polygonMethodCommon(canvas, pdfImg, coords);
      console.log(coords);
      var max = coords.length - 1;
      for (var l = 0; l < coords.length; l++) {
        let circle = this.addredCircles(coords[l].x, coords[l].y);
        pdfImg.appendChild(circle);
        if (typeof coords[max - 1] !== "undefined" && l >= 1) {
          var curr = coords[l], prev = coords[l - 1];
          this.drawCanvasContext.beginPath();
          this.drawCanvasContext.moveTo(prev.x, prev.y);
          this.drawCanvasContext.lineTo(curr.x, curr.y);
          this.drawCanvasContext.strokeStyle = "black";
          this.drawCanvasContext.lineWidth = 2;
          this.drawCanvasContext.stroke();
        }
      }
    } else {
      this.polygonmethod();
    }
  }

  seperateDrawUndoPolygonSVG(convertAnnotationData) {
    var coords = [];
    if (this.stringPathArray.length > 0) {
      let path_value = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var hypenSplit = this.stringPathArray[i].split("-");
        var colonSplit = hypenSplit[1].split(":");
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
        path_value = i == 0 ? `M${coord.x} ${coord.y}` : (path_value + ` L${coord.x} ${coord.y}`);
      }
      var pdfImg = document.getElementById("pdfImg");
      var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      newcreatedElement.setAttribute("width", this.realWidth);
      newcreatedElement.setAttribute("height", this.realHeight);
      newcreatedElement.setAttribute("customepolygonattribute", "1");
      newcreatedElement.style.position = "absolute";
      newcreatedElement.style.top = "0px";
      newcreatedElement.style.left = "0px";
      newcreatedElement.style.zIndex = "999";
      let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      create_path.setAttribute("customepolygonattributepath", "1");
      newcreatedElement.appendChild(create_path);
      pdfImg.appendChild(newcreatedElement);
      // add transform on svg If zoomin 1 above
      this.addZoom(newcreatedElement);
      this.polygonMethodCommonSVG(newcreatedElement, create_path, coords);
      console.log(coords);
      var max = coords.length - 1;
      create_path.setAttribute('stroke', "black");
      create_path.setAttribute('stroke-width', "2");
      create_path.setAttribute('fill', "none");
      //line and circles points zooming 
      this.checkZoomInorOut();
      for (var l = 0; l < coords.length; l++) {
        let circle = this.addredCirclesSVG(coords[l].x, coords[l].y);
        newcreatedElement.appendChild(circle);
      }
      if (typeof coords[max - 1] !== "undefined") {
        create_path.setAttribute("d", path_value);
      }
    } else {
      this.polygonmethodSVG();
    }
  }
  //seperate draw polygon after undo end

  //Polyline Draw method start

  polylinemethod() {
    console.log('call polyline method');
    this.getPositionString = "";
    this.stringPathArray = [];
    this.annotationName = "Polyline";
    var coords = [];
    var pdfImg = document.getElementById("pdfImg");
    var canvas = document.createElement("canvas");
    canvas.setAttribute("width", this.realWidth);
    canvas.setAttribute("height", this.realHeight);
    canvas.setAttribute("customepolylineattribute", "1");
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.style.zIndex = "9999";
    pdfImg.appendChild(canvas);
    this.polylineMethodReDraw(canvas, pdfImg, coords);
  }
  //Polyline Draw method End

  //common freehand Shapes remove canvas using attribute start

  removeCanvasAttribute(attributeName) {
    var remove_canvas_element = document.querySelectorAll(`[${attributeName}]`);
    for (var i = 0; i < remove_canvas_element.length; i++) {
      remove_canvas_element[i].remove();
    }
  }

  removesvgAttribute(attributeName) {
    var removeelement = document.querySelectorAll(`[${attributeName}]`);
    for (var i = 0; i < removeelement.length; i++) {
      removeelement[i].remove();
    }
  }

  //common freehand Shapes remove canvas using attribute end
  //Polyline Draw Update method start
  polylinemethodUpdateAPI() {
    this.show = true;
    var convertAnnotationData = "";
    this.drawShapeDonePolyline = false;
    this.drawCanvasContext = null;
    this.toolbarSet = false;
    this.accessPolylineMenuFeatureStop = false;
    this.removeRedCircles();
    this.removesvgAttribute('customepolylineattribute');
    for (var i = 0; i < this.stringPathArray.length; i++) {
      convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
    }
    convertAnnotationData = convertAnnotationData.trim();
    console.log('path=', convertAnnotationData);
    var annontationidDate = new Date().getTime();
    var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
    var MyDateString = new Date().toISOString();
    console.log(MyDateString);
    // this.annotationName = "Polyline";
    let label_string = "";
    label_string = this.annotationLabelTemplate();
    this.createJson = {
      annotation_data: convertAnnotationData,
      annotation_forms: this.selectAnnotationForms,
      annotation_id: uuid,
      annotation_label: label_string,
      annotation_links: [],
      annotation_media: [],
      annotation_name: this.annotationName,
      annotation_stubs: [],
      annotation_tags: "",
      annotation_url: "",
      created_by_user_id: this.su.user_id,
      created_date: MyDateString,
      document_id: this.folderId,
      element_size: 1,
      fill_color: this.currentSelectedItems.element_data.fill_color,
      initial_rotation:0,
      initial_height: 0,
      initial_position_x: 0,
      initial_position_y: 0,
      initial_width: 0,
      is_removed: false,
      last_updated_date: MyDateString,
      layer_id: this.activeLayerIdDraw,
      line_width: this.currentSelectedItems.element_data.line_width,
      opacity: 1,
      original_property: "",
      page_id: this.currentPageId,
      project_id: this.projectId,
      stroke_color: this.currentSelectedItems.element_data.stroke_color,
      toolbar_element_id: 14,
      updated_by_user_id: this.su.user_id,
      version_number: 1,
    };
    this.annotationUpdate();
  }
  //Polyline Draw Update method End

  new() {
    var coords = [];
    if (this.stringPathArray.length > 0) {
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var hypenSplit = this.stringPathArray[i].split("-");
        var colonSplit = hypenSplit[1].split(":");
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
      }
      console.log(coords);
      var pdfImg = document.getElementById("pdfImg");
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", this.realWidth);
      canvas.setAttribute("height", this.realHeight);
      canvas.setAttribute("customepolylineattribute", "1");
      canvas.style.position = "absolute";
      canvas.style.top = "0px";
      canvas.style.left = "0px";
      canvas.style.zIndex = "999";
      pdfImg.appendChild(canvas);
      // this.polylineMethodReDraw(canvas, pdfImg, coords);
      var max = coords.length - 1;
      for (var l = 0; l < coords.length; l++) {
        let circle = this.addredCircles(coords[l].x, coords[l].y);
        pdfImg.appendChild(circle);

      }
    }
  }

  //polyline done Click Draw Start
  annotationUpdatePolylineDraw(convertAnnotationString) {
    this.drawShapeDonePolyline = false;
    this.show = false;
    console.log(convertAnnotationString);
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.setAttribute("width", this.realHeight);
    newcreatedElement.setAttribute("height", this.realWidth);
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    //   const img = new Image()
    //   img.src = this.imgUrl;
    //   img.onload = () => {
    //   this.canvasElement.drawImage(img, 0, 0,600,450);
    //   }
    this.canvasElement.beginPath();
    convertAnnotationString = convertAnnotationString.trim();
    var spaceSplit = convertAnnotationString.split(" ");
    console.log(spaceSplit);
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");
      for (var j = 0; j < hypenSplit.length; j++) {
        var colonSplit = hypenSplit[j].split(":");
        if (hypenSplit[0] == "controlpoint") {
          var cpx = parseFloat(colonSplit[0]);
          var cpy = parseFloat(colonSplit[1]);
        }
        if (hypenSplit[0] == "curveEnd") {
          var ex = parseFloat(colonSplit[0]);
          var ey = parseFloat(colonSplit[1]);
        }
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var h = parseFloat(colonSplit[2]);
          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            // this.canvasElement.drawImage(urlImg,this.coordinateX,this.coordinateX)
            this.canvasElement.moveTo(x, y);
            break;
          case "line":
            this.canvasElement.lineTo(x, y);
            break;
          case "ovalIn":
            var r = (w * w) / (8 * h) + h / 2;
            // this.canvasElement.ellipse(x, y, h, w,  90 * Math.PI/180, 0, 2 * Math.PI)
            this.canvasElement.arc(
              newcreatedElement.clientWidth / 2,
              newcreatedElement.clientHeight / 2.3,
              r,
              0,
              2 * Math.PI
            );
            break;
          case "curveEnd":
            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
            break;
        }
        this.canvasElement.lineWidth = this.currentSelectedItems.element_data.line_width;
        var checkStroke = this.currentSelectedItems.element_data.stroke_color;
        this.canvasElement.strokeStyle = this.checkStrokeColor1(checkStroke);
        this.canvasElement.stroke();
      }
    }
  }
  //polyline done Click Draw end
  //PolylineArrow draw method Start
  polylinearrowmethod() {
    this.getPositionString = "";
    this.stringPathArray = [];
    this.annotationName = "Polyline Arrow";
    var coords = [];

    var pdfImg = document.getElementById("pdfImg");
    var canvas = document.createElement("canvas");
    canvas.setAttribute("width", this.realWidth);
    canvas.setAttribute("height", this.realHeight);
    canvas.setAttribute("customepolylinearrowattribute", "1");
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.style.zIndex = "9999";
    pdfImg.appendChild(canvas);
    this.polylinearrowMethodReDraw(canvas, pdfImg, coords);
  }

  polylinearrowmethodSVG() {
    this.getPositionString = "";
    this.stringPathArray = [];
    // this.annotationName = "Polyline Arrow";
    var coords = [];
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customepolylinearrowattribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    create_path.setAttribute("customepolylinearrowattributepath", "1");
    newcreatedElement.appendChild(create_path);
    pdfImg.appendChild(newcreatedElement);
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    this.polylinearrowMethodReDrawSVG(newcreatedElement, create_path, coords);
  }
  //PolylineArrow Draw method End

  polylinearrowMethodReDraw(canvas, pdfImg, coords) {
    this.drawCanvasContext = canvas.getContext("2d");
    canvas.addEventListener("click", (event: any) => {
      // if(this.scale>=1.24049 && this.opcitychange==false)
      // {
      //   this.opcitychange=true;
      //   this.removeRedCircles();
      //   this.new();
      // }
      // else if(this.opcitychange==true && this.scale<1.24049)
      // {
      //   this.opcitychange=false;
      //   this.removeRedCircles();
      //   this.new();
      // }
      let circle = this.addredCircles(event.offsetX, event.offsetY);
      pdfImg.appendChild(circle);
      if (this.getPositionSetMove != 1) {
        this.getPositionString = " " + "line" + "-" + event.offsetX + ":" + event.offsetY;
        this.stringPathArray.push(this.getPositionString);
      }
      if (this.getPositionSetMove == 1) {
        this.getPositionString = "move" + "-" + event.offsetX + ":" + event.offsetY;
        coords = [];
        this.stringPathArray.push(this.getPositionString);
        this.getPositionSetMove++;
      }
      this.accessPolylineArrowMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      var coord = { x: event.offsetX, y: event.offsetY };
      coords.push(coord);
      console.log(coord);
      var max = coords.length - 1;
      if (typeof coords[max - 1] !== "undefined") {
        var curr = coords[max], prev = coords[max - 1];
        this.drawCanvasContext.beginPath();
        this.drawCanvasContext.moveTo(prev.x, prev.y);
        this.drawCanvasContext.lineTo(curr.x, curr.y);
        var strokeColor = this.currentSelectedItems.element_data.stroke_color;
        this.drawCanvasContext.lineWidth = 2;
        this.drawCanvasContext.strokeStyle = "black";
        this.drawCanvasContext.stroke();
      }
      console.log(this.stringPathArray);
    });
  }

  polylinearrowMethodReDrawSVG(svg_handler, path, coords) {
    path.setAttribute('stroke', "black");
    path.setAttribute('stroke-width', "2");
    path.setAttribute('fill', "none");
    //line and circles points zooming 
    this.checkZoomInorOut();
    let path_value = "";
    if (coords.length > 0) {
      for (let k = 0; k < coords.length; k++) {
        path_value = k == 0 ? `M${coords[k].x}  ${coords[k].y}` : (path_value + ` L${coords[k].x} ${coords[k].y}`);
      }
    }
    svg_handler.addEventListener("click", (event: any) => {
    if(this.showvisible==false || this.isReadonly == true){
      return
    }
    if(this.layerDatas.length==0){
      return
    }
    
    if((this.layerDatas.length!=0)){
var active=this.layerDatas;
active=active.filter(res=>res.layer_id==this.activeLayerIdDraw)
   }
   if(this.layerDatas.length!=0 && active.length==0){
     return
   }
    
      let circle = this.addredCirclesSVG(event.offsetX, event.offsetY);
      svg_handler.appendChild(circle);
      if (this.getPositionSetMove != 1) {
        this.getPositionString = " " + "line" + "-" + event.offsetX + ":" + event.offsetY;
        this.stringPathArray.push(this.getPositionString);
        path_value = path_value + ` L${event.offsetX} ${event.offsetY}`;

      }
      if (this.getPositionSetMove == 1) {
        this.getPositionString = "move" + "-" + event.offsetX + ":" + event.offsetY;
        coords = [];
        this.stringPathArray.push(this.getPositionString);
        this.getPositionSetMove++;
        path_value = `M${event.offsetX} ${event.offsetY}`;
      }
      this.accessPolylineArrowMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      var coord = { x: event.offsetX, y: event.offsetY };
      coords.push(coord);

      var max = coords.length - 1;
      if (typeof coords[max - 1] !== "undefined") {
        path.setAttribute("d", path_value);
      }
    });
  }
  //PolylineArrow Draw Update method start
  polylinearrowmethodUpdateAPI() {
    this.show = true;
    this.drawShapeDonePolylineArrow = false;
    this.drawCanvasContext = null;
    this.accessPolylineArrowMenuFeatureStop = false;
    this.toolbarSet = false;
    var convertAnnotationData = "";
    this.removeredCirclesSVG();
    this.removesvgAttribute('customepolylinearrowattribute');

    let arrowString = this.createArrow();
    for (var i = 0; i < this.stringPathArray.length; i++) {
      convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
    }
    convertAnnotationData = convertAnnotationData.trim();
    convertAnnotationData = convertAnnotationData + arrowString;
    console.log(convertAnnotationData);
    var annontationdDate = new Date().getTime();
    var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationdDate;
    var MyDateString = new Date().toISOString();
    // this.annotationName = "Polyline Arrow";
    let label_string = "";
    label_string = this.annotationLabelTemplate();
    this.createJson = {
      annotation_data: convertAnnotationData,
      annotation_forms: this.selectAnnotationForms,
      annotation_id: uuid,
      annotation_label: label_string,
      annotation_links: [],
      annotation_media: [],
      annotation_name: this.annotationName,
      annotation_stubs: [],
      annotation_tags: "",
      annotation_url: "",
      created_by_user_id: this.su.user_id,
      created_date: MyDateString,
      document_id: this.folderId,
      element_size: 1,
      fill_color: this.currentSelectedItems.element_data.fill_color,
      initial_rotation:0,
      initial_height: 0,
      initial_position_x: 0,
      initial_position_y: 0,
      initial_width: 0,
      is_removed: false,
      last_updated_date: MyDateString,
      layer_id: this.activeLayerIdDraw,
      line_width: this.currentSelectedItems.element_data.line_width,
      opacity: 1,
      original_property: "",
      page_id: this.currentPageId,
      project_id: this.projectId,
      stroke_color: this.currentSelectedItems.element_data.stroke_color,
      toolbar_element_id: 13,
      updated_by_user_id: this.su.user_id,
      version_number: 1,
    };
    this.annotationUpdate();
  }

  createArrow() {
    if (this.stringPathArray.length > 1) {
      let current = this.stringPathArray[this.stringPathArray.length - 1];
      let currentSplit = current.split("-");
      let colonSplit1 = currentSplit[1].split(":");
      let currentx = colonSplit1[0];
      let currenty = colonSplit1[1];
      let previous = this.stringPathArray[this.stringPathArray.length - 2];
      let currentSplit2 = previous.split("-");
      let colonSplit2 = currentSplit2[1].split(":");
      let previousx = colonSplit2[0];
      let previousy = colonSplit2[1];
      let headlen = 15;
      let dx = currentx - previousx;
      let dy = currenty - previousy;
      let angle = Math.atan2(dy, dx);
      // latest comment 18.06.2021 arrow inbetween space created so comment this line
      // let arrowString1 = ' move-' + currentx + ":" + currenty;
      // let arrowString2X = currentx - headlen * Math.cos(angle - Math.PI / 4);
      // let arrowString2Y = currenty - headlen * Math.sin(angle - Math.PI / 4);
      // let arrowString2 = ' line-' + arrowString2X + ":" + arrowString2Y;
      // let arrowString3 = ' move-' + currentx + ":" + currenty;
      // let arrowString4X = currentx - headlen * Math.cos(angle + Math.PI / 4);
      // let arrowString4Y = currenty - headlen * Math.sin(angle + Math.PI / 4);
      // let arrowString4 = ' line-' + arrowString4X + ":" + arrowString4Y;
      // let merge4Line = arrowString1 + arrowString2 + arrowString3 + arrowString4;
      // let arrowString1 = ' move-' + currentx + ":" + currenty;
      let arrowString1X = currentx - headlen * Math.cos(angle - Math.PI / 4);
      let arrowString1Y = currenty - headlen * Math.sin(angle - Math.PI / 4);
      let arrowString1 = ' move-' + arrowString1X + ":" + arrowString1Y;
      let arrowString2 = ' line-' + currentx + ":" + currenty;
      let arrowString3X = currentx - headlen * Math.cos(angle + Math.PI / 4);
      let arrowString3Y = currenty - headlen * Math.sin(angle + Math.PI / 4);
      let arrowString3 = ' line-' + arrowString3X + ":" + arrowString3Y;
      let merge4Line = arrowString1 + arrowString2 + arrowString3;
      console.log(merge4Line);
      return merge4Line;
    }
  }
  //Polyline Draw Update method End
  //polyline arrow done click after draw start
  annotationUpdatePolylinearrowDraw(convertAnnotationString) {
    this.show = false;
    console.log(convertAnnotationString);
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    convertAnnotationString = convertAnnotationString.trim();
    var spaceSplit = convertAnnotationString.split(" ");
    console.log(spaceSplit);
    var previous = { x: 0, y: 0 };
    var current = { x: 0, y: 0 };
    var a = 0;
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");
      for (var j = 0; j < hypenSplit.length; j++) {
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var colonSplit = hypenSplit[j].split(":");
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var h = parseFloat(colonSplit[2]);
          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            // this.canvasElement.drawImage(urlImg,this.coordinateX,this.coordinateX)
            this.canvasElement.moveTo(x, y);
            if (j == 1) {
              previous.x = x;
              previous.y = y;
              a++;
            }
            break;
          case "line":
            this.canvasElement.lineTo(x, y);
            if (a == 1 && j == 1 && previous.x != 0 && previous.y != 0) {
              current.x = x;
              current.y = y;
              var dx = current.x - previous.x;
              var dy = current.y - previous.y;
              var headlen = 10;
              var angle = Math.atan2(dy, dx);
              this.canvasElement.lineTo(
                current.x - headlen * Math.cos(angle - Math.PI / 6),
                current.y - headlen * Math.sin(angle - Math.PI / 6)
              );
              this.canvasElement.moveTo(current.x, current.y);
              this.canvasElement.lineTo(
                current.x - headlen * Math.cos(angle + Math.PI / 6),
                current.y - headlen * Math.sin(angle + Math.PI / 6)
              );
            }
            previous.x = x;
            previous.y = y;
            break;
        }
        this.canvasElement.lineWidth = 1;
        this.canvasElement.strokeStyle = "rgba(0.999999999885,44.999999991,98.0000000025,1)";
        this.canvasElement.stroke();
      }
    }
  }
  //polyline arrow done click after draw end

  //freehand close menu start

  closeFooter1() {
    this.undoFreehandflag = false;
    this.drawFreehandMenu = false;
    this.accessMenuFeatureStop = false;
    this.drawCanvasContext = null;
    this.closeFooterCommonSVG('customefreehandattribute');
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     // this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }
  //freehand close menu end
  firstTimeUndo: number = 1;
  //Freehand menu undo method start
  undoFreehand() {
    this.undoFreehandflag = true
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    //Jose check
    this.removeCanvasAttribute('customefreehandattribute');
    this.stringPathArray.splice(-1, 1);
    if (this.stringPathArray.length > 0) {
      var pdfImg = document.getElementById("pdfImg");
      let newcreatedElement = document.createElement("canvas");
      newcreatedElement.setAttribute("width", this.realWidth);
      newcreatedElement.setAttribute("height", this.realHeight);
      newcreatedElement.setAttribute("customefreehandattribute", "1");
      newcreatedElement.style.position = "absolute";
      newcreatedElement.style.top = "0px";
      newcreatedElement.style.left = "0px";
      newcreatedElement.style.zIndex = "999";
      pdfImg.appendChild(newcreatedElement);
      this.drawCanvasContext = newcreatedElement.getContext("2d");
      this.drawCanvasContext.lineCap = "round";
      this.drawCanvasContext.lineWidth = this.currentSelectedItems.element_data.line_width;
      var strokeColor = this.currentSelectedItems.element_data.stroke_color;
      this.drawCanvasContext.strokeStyle = this.checkStrokeColor1(strokeColor);
      this.drawCanvasContext.stroke();
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var trimString = this.stringPathArray[i].trim();
        this.seperateDrawUndo(trimString, newcreatedElement);
      }
      fromEvent(newcreatedElement, "mousedown")
        .pipe(
          switchMap((e) => {
            console.log(e);
            this.stringPath = "";
            this.a = 0;
            // after a mouse down, we'll record all mouse moves
            return fromEvent(newcreatedElement, "mousemove").pipe(
              // we'll stop (and unsubscribe) once the user releases the mouse
              // this will trigger a 'mouseup' event
              takeUntil(
                fromEvent(newcreatedElement, "mouseup").do(() => {
                  console.log(this.stringPath);
                  if (this.stringPath != "") {
                    this.accessMenuFeatureStop = false;
                    this.stringPathArray.push(this.stringPath);
                    if (this.toolbarElementId == 17) {
                      var fillColor = this.currentSelectedItems.element_data.fill_color;
                      this.drawCanvasContext.fillStyle = this.checkStrokeColor1(fillColor);
                      this.drawCanvasContext.fill();
                    }
                  }
                })
              ),
              // we'll also stop (and unsubscribe) once the mouse leaves the canvas (mouseleave event)
              takeUntil(fromEvent(newcreatedElement, "mouseleave")),
              // pairwise lets us get the previous value to draw a line from
              // the previous point to the current point
              pairwise()
            );
          })
        )
        .subscribe((res: [MouseEvent, MouseEvent]) => {
          const rect = newcreatedElement.getBoundingClientRect();
          console.log(rect);
          const prevPos = {
            x: res[0].clientX - rect.left,
            y: res[0].clientY - rect.top,
          };

          const currentPos = {
            x: res[1].clientX - rect.left,
            y: res[1].clientY - rect.top,
          };
          // this method we'll implement soon to do the actual drawing
          this.drawOnCanvas(prevPos, currentPos, this.toolbarElementId);
        });
    }
    else {
      this.accessMenuFeatureStop = true;
      this.captureEvents(this.annotationName);
    }
  }

  undoFreehandSVG() {
    this.undoFreehandflag = true
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    //Jose check
    this.removesvgAttribute('customefreehandattribute');
    this.stringPathArray.splice(-1, 1);
    if (this.stringPathArray.length > 0) {
      var pdfImg = document.getElementById("pdfImg");
      var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      newcreatedElement.setAttribute("width", this.realWidth);
      newcreatedElement.setAttribute("height", this.realHeight);
      newcreatedElement.setAttribute("customeFreehandAttribute", "1");
      newcreatedElement.style.position = "absolute";
      newcreatedElement.style.top = "0px";
      newcreatedElement.style.left = "0px";
      newcreatedElement.style.zIndex = "999";
      pdfImg.appendChild(newcreatedElement);
      var create_path: any = "";
      // add transform on svg If zoomin 1 above
      this.addZoom(newcreatedElement);
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var trimString = this.stringPathArray[i].trim();
        this.seperateDrawUndoSVG(trimString, newcreatedElement);
      }
      fromEvent(newcreatedElement, "mousedown")
        .pipe(
          switchMap((e) => {
            e.preventDefault();
            console.log(e);
            this.stringPath = "";
            this.freehand_path_value = "";
            this.a = 0;
            create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            newcreatedElement.appendChild(create_path);
            create_path.setAttribute('stroke', "black");
            create_path.setAttribute('stroke-width', "0.5");
            create_path.setAttribute('fill', "none");
            // after a mouse down, we'll record all mouse moves
            return fromEvent(newcreatedElement, "mousemove").pipe(
              // we'll stop (and unsubscribe) once the user releases the mouse
              // this will trigger a 'mouseup' event
              takeUntil(
                fromEvent(newcreatedElement, "mouseup").do(() => {
                  console.log(this.stringPath);
                  if (this.stringPath != "") {
                    this.accessMenuFeatureStop = false;
                    this.stringPathArray.push(this.stringPath);
                    let strokeColor = this.currentSelectedItems.element_data.stroke_color;
                    let get_stroke = this.checkStrokeColor1(strokeColor);
                    create_path.setAttribute('stroke', get_stroke);
                    if (this.toolbarElementId == 17) {
                      let fillColor = this.currentSelectedItems.element_data.fill_color;
                      let get_fill_color = this.checkStrokeColor1(fillColor);
                      create_path.setAttribute('fill', get_fill_color);
                      create_path.setAttribute('d', `${this.freehand_path_value} Z`);
                    }
                  }
                })
              ),
              // we'll also stop (and unsubscribe) once the mouse leaves the canvas (mouseleave event)
              takeUntil(fromEvent(newcreatedElement, "mouseleave").do(() => {
                if (this.stringPath != "") {
                  this.accessMenuFeatureStop = false;
                  this.stringPathArray.push(this.stringPath);
                  console.log('mouse_leave');
                  if (this.toolbarElementId == 17) {
                    let fillColor = this.currentSelectedItems.element_data.fill_color;
                    let get_fill_color = this.checkStrokeColor1(fillColor);
                    create_path.setAttribute('fill', get_fill_color);
                    let strokeColor = this.currentSelectedItems.element_data.stroke_color;
                    let get_stroke = this.checkStrokeColor1(strokeColor);
                    create_path.setAttribute('stroke', get_stroke);
                    create_path.setAttribute('d', `${this.freehand_path_value} Z`);
                  }
                }
              })),
              // pairwise lets us get the previous value to draw a line from
              // the previous point to the current point
              pairwise()
            );
          })
        )
        .subscribe((res: [MouseEvent, MouseEvent]) => {
          const rect = newcreatedElement.getBoundingClientRect();
          console.log(rect);
          const prevPos = {
            x: res[0].offsetX,
            y: res[0].offsetY,
          };

          const currentPos = {
            x: res[1].offsetX,
            y: res[1].offsetY,
          };
          // this method we'll implement soon to do the actual drawing
          this.drawOnCanvasSVG(prevPos, currentPos, create_path);
        });
    }
    else {
      this.accessMenuFeatureStop = true;
      this.captureEventsSVG(this.annotationName);
    }
  }
  //Freehand menu undo method end

  // when click Undo create seperate canvas Start
  seperateDrawUndo(trimstring, newcreatedElement) {
    this.drawCanvasContext = newcreatedElement.getContext("2d");
    this.drawCanvasContext.beginPath();
    trimstring = trimstring.trim();
    var spaceSplit = trimstring.split(" ");
    console.log(spaceSplit);
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");

      for (var j = 0; j < hypenSplit.length; j++) {
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var colonSplit = hypenSplit[j].split(":");
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var h = parseFloat(colonSplit[2]);
          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            this.drawCanvasContext.moveTo(x, y);
            break;
          case "line":
            this.drawCanvasContext.lineTo(x, y);
            break;
        }
      }
    }
    let lineWidth123 = Number(this.currentSelectedItems.element_data.line_width) > 1 ? (Number(this.currentSelectedItems.element_data.line_width) - 1) : (Number(this.currentSelectedItems.element_data.line_width));
    this.drawCanvasContext.lineWidth = lineWidth123;
    this.drawCanvasContext.strokeStyle = this.checkStrokeColor1(this.currentSelectedItems.element_data.stroke_color);
    this.drawCanvasContext.stroke();
    if (this.toolbarElementId == 17) {
      var fillColor = this.currentSelectedItems.element_data.fill_color;
      this.drawCanvasContext.fillStyle = this.checkStrokeColor1(fillColor);
      this.drawCanvasContext.fill();
    }
  }
  seperateDrawUndoSVG(trimstring, newcreatedElement) {
    let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    newcreatedElement.appendChild(create_path);
    let path_value = "";
    trimstring = trimstring.trim();
    var spaceSplit = trimstring.split(" ");
    console.log(spaceSplit);
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");
      var colonSplit = hypenSplit[1].split(":");
      var x = parseFloat(colonSplit[0]);
      var y = parseFloat(colonSplit[1]);
      switch (hypenSplit[0]) {
        case "move":
          path_value = `M${x} ${y}`;
          break;
        case "line":
          path_value = path_value + ` L${x} ${y}`;
          break;
      }
    }

    let strokeColor = this.currentSelectedItems.element_data.stroke_color;
    let get_stroke = this.checkStrokeColor1(strokeColor);
    create_path.setAttribute('stroke', get_stroke);
    create_path.setAttribute('stroke-width', "2");
    create_path.setAttribute('fill', "none");
    create_path.setAttribute("d", path_value);
    if (this.toolbarElementId == 17) {
      let fillColor = this.currentSelectedItems.element_data.fill_color;
      let get_fill_color = this.checkStrokeColor1(fillColor);
      create_path.setAttribute('fill', get_fill_color);
      create_path.setAttribute('d', `${path_value} Z`);
    }
  }
  // when click Undo create seperate canvas end
  // draw the line shape start
  drawLineMethod(valuecheck) {
    console.log('drawLineMethod');
    this.getPositionString = "";
    var startPosition = { x: 0, y: 0 };
    var lineCoordinates = { x: 0, y: 0 };
    var convertAnnotationData = "";
    this.stringPathArray = [];
    var isDrawStart = false;
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeLineAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    pdfImg.appendChild(newcreatedElement);
    this.drawCanvasContext = newcreatedElement.getContext("2d");
    newcreatedElement.addEventListener("mousedown", (event: any) => {
      this.stringPathArray = [];
      startPosition = getClientOffset(event);
      isDrawStart = true;
      this.getPositionString = "move" + "-" + startPosition.x + ":" + startPosition.y;
      this.stringPathArray.push(this.getPositionString);
    });
    newcreatedElement.addEventListener("mousemove", (event: any) => {
      if (!isDrawStart) return;
      lineCoordinates = getClientOffset(event);
      clearCanvas();
      drawLine(event);
    });
    newcreatedElement.addEventListener("mouseup", (event: any) => {
      isDrawStart = false;
      lineCoordinates = getClientOffset(event);
      clearCanvas();
      drawLine(event);
      this.getPositionString = " " + "line" + "-" + lineCoordinates.x + ":" + lineCoordinates.y;
      this.stringPathArray.push(this.getPositionString);
      console.log(this.stringPathArray);
      this.accessLineMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      console.log('mouse up line', this.accessLineMenuFeatureStop);
    });
    newcreatedElement.addEventListener("mouseleave", (event: any) => {
      if (isDrawStart == true) {
        isDrawStart = false;
        lineCoordinates = getClientOffset(event);
        lineCoordinates.x = lineCoordinates.x < 0 ? 0 : lineCoordinates.x;
        lineCoordinates.y = lineCoordinates.y < 0 ? 0 : lineCoordinates.y;
        lineCoordinates.x = Number(this.realWidth) < lineCoordinates.x ? Number(this.realWidth) : lineCoordinates.x;
        lineCoordinates.y = Number(this.realHeight) < lineCoordinates.y ? Number(this.realHeight) : lineCoordinates.y;
        clearCanvas();
        drawLine(event);
        this.getPositionString = " " + "line" + "-" + lineCoordinates.x + ":" + lineCoordinates.y;
        this.stringPathArray.push(this.getPositionString);
        console.log(this.stringPathArray);
        this.accessLineMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
        console.log('mouse leave line', this.accessLineMenuFeatureStop);
      }
    });
    const getClientOffset = (event) => {
      const x = event.offsetX;
      const y = event.offsetY;
      console.log(x, y);
      return {
        x,
        y,
      };
    };

    const drawLine = (event: MouseEvent) => {
      this.drawCanvasContext.beginPath();
      this.drawCanvasContext.moveTo(startPosition.x, startPosition.y);
      this.drawCanvasContext.lineTo(lineCoordinates.x, lineCoordinates.y);
      this.drawCanvasContext.lineWidth = this.currentSelectedItems.element_data.line_width;
      var strokeColor = this.currentSelectedItems.element_data.stroke_color;
      this.drawCanvasContext.strokeStyle = this.checkStrokeColor1(strokeColor);
      this.drawCanvasContext.stroke();
    };

    const clearCanvas = () => {
      this.drawCanvasContext.clearRect(
        0,
        0,
        newcreatedElement.width,
        newcreatedElement.height
      );
    };
  }

  drawLineMethodSVG(valuecheck) {
    this.borderLinePresent = true;
    console.log('drawLineMethod');
    this.getPositionString = "";
    var startPosition = { x: 0, y: 0 };
    var lineCoordinates = { x: 0, y: 0 };
    var convertAnnotationData = "";
    this.stringPathArray = [];
    var isDrawStart = false;
    let path_value = "";
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeLineAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    create_path.setAttribute("customelineattributepath", "1");
    newcreatedElement.appendChild(create_path);
    let get_stroke = this.currentSelectedItems.element_data.stroke_color;
    let stroke_color = this.checkStrokeColor1(get_stroke);
    create_path.setAttribute('stroke', stroke_color);
    create_path.setAttribute('stroke-width', "2");
    create_path.setAttribute('fill', "none");
    let annontationidDate = new Date().getTime();
    let uuid_border = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
    let border_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    border_path.setAttribute("customelineattributepath", "1");
    newcreatedElement.appendChild(border_path);
    let get_stroke_border = this.currentSelectedItems.element_data.stroke_color;
    let stroke_color_border = this.checkStrokeColor1(get_stroke_border);
    border_path.setAttribute('stroke', stroke_color_border);
    border_path.setAttribute('stroke-width', "2");
    border_path.setAttribute('fill', "none");
    border_path.setAttribute('id', 'border' + uuid_border);


    pdfImg.appendChild(newcreatedElement);
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    newcreatedElement.addEventListener("mousedown", (event: any) => {
      event.preventDefault();
      if(this.showvisible==false || this.isReadonly == true){
        return
      }
      this.stringPathArray = [];
      startPosition = getClientOffset(event);
      this.lineStartPosition = _.cloneDeep(startPosition);
      isDrawStart = true;
      this.getPositionString = "move" + "-" + startPosition.x + ":" + startPosition.y;
      path_value = `M${startPosition.x} ${startPosition.y}`;
      this.stringPathArray.push(this.getPositionString);
    });
    newcreatedElement.addEventListener("mousemove", (event: any) => {
      if (!isDrawStart) return;
      lineCoordinates = getClientOffset(event);
      // clearCanvas();
      drawLine(event);
    });
    newcreatedElement.addEventListener("mouseup", (event: any) => {
      isDrawStart = false;
      if(this.showvisible==false || this.isReadonly == true){
        return
      }
      lineCoordinates = getClientOffset(event);
      this.lineEndPosition = _.cloneDeep(lineCoordinates);
      // clearCanvas();
      drawLine(event);
      this.getPositionString = " " + "line" + "-" + lineCoordinates.x + ":" + lineCoordinates.y;
      path_value = path_value == "" ? `L${lineCoordinates.x} ${lineCoordinates.y}` : path_value + ` L${lineCoordinates.x} ${lineCoordinates.y}`;
      this.stringPathArray.push(this.getPositionString);
      console.log(this.stringPathArray);
      this.accessLineMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      console.log('mouse up line', this.accessLineMenuFeatureStop);
    });
    newcreatedElement.addEventListener("mouseleave", (event: any) => {
      if (isDrawStart == true) {
        isDrawStart = false;
        lineCoordinates = getClientOffset(event);
        lineCoordinates.x = lineCoordinates.x < 0 ? 0 : lineCoordinates.x;
        lineCoordinates.y = lineCoordinates.y < 0 ? 0 : lineCoordinates.y;
        lineCoordinates.x = Number(this.realWidth) < lineCoordinates.x ? Number(this.realWidth) : lineCoordinates.x;
        lineCoordinates.y = Number(this.realHeight) < lineCoordinates.y ? Number(this.realHeight) : lineCoordinates.y;
        drawLine(event);
        this.getPositionString = " " + "line" + "-" + lineCoordinates.x + ":" + lineCoordinates.y;
        path_value = path_value == "" ? `L${lineCoordinates.x} ${lineCoordinates.y}` : path_value + ` L${lineCoordinates.x} ${lineCoordinates.y}`;
        this.stringPathArray.push(this.getPositionString);
        console.log(this.stringPathArray);
        this.accessLineMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
        console.log('mouse leave line', this.accessLineMenuFeatureStop);
      }
    });
    const getClientOffset = (event) => {
      const x = event.offsetX;
      const y = event.offsetY;
      console.log(x, y);
      return {
        x,
        y,
      };
    };

    const drawLine = (event: MouseEvent) => {
      path_value = `M${startPosition.x} ${startPosition.y} L${lineCoordinates.x} ${lineCoordinates.y}`;
      create_path.setAttribute("d", path_value);
    };

    // const clearCanvas = () => {
    //   this.drawCanvasContext.clearRect(
    //     0,
    //     0,
    //     newcreatedElement.width,
    //     newcreatedElement.height
    //   );
    // };
  }

  drawLineAxialMethod() {
    this.getPositionString = "";
    var startPosition = { x: 0, y: 0 };
    var lineCoordinates = { x: 0, y: 0 };
    this.stringPathArray = [];
    var isDrawStart = false;
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeLineAxialAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    pdfImg.appendChild(newcreatedElement);
    this.drawCanvasContext = newcreatedElement.getContext("2d");
    newcreatedElement.addEventListener("mousedown", (event: any) => {
      this.stringPathArray = [];
      startPosition = getClientOffset(event);
      isDrawStart = true;
      this.getPositionString = "move" + "-" + startPosition.x + ":" + startPosition.y;
      this.stringPathArray.push(this.getPositionString);
    });
    newcreatedElement.addEventListener("mousemove", (event: any) => {
      if (!isDrawStart) return;
      lineCoordinates = getClientOffset(event);
      clearCanvas();
      drawLine();
    });
    newcreatedElement.addEventListener("mouseup", (event: any) => {
      lineCoordinates = getClientOffset(event);
      console.log(lineCoordinates);
      clearCanvas();
      drawLine();
      isDrawStart = false;
      this.getPositionString = " " + "line" + "-" + lineCoordinates.x + ":" + lineCoordinates.y;
      this.stringPathArray.push(this.getPositionString);
      console.log(this.stringPathArray);
      this.accessLineAxialMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      console.log('mouse up line axial', this.accessLineAxialMenuFeatureStop);
    });
    newcreatedElement.addEventListener("mouseleave", (event: any) => {
      if (isDrawStart == true) {
        isDrawStart = false;
        lineCoordinates = getClientOffset(event);
        lineCoordinates.x = lineCoordinates.x < 0 ? 0 : lineCoordinates.x;
        lineCoordinates.y = lineCoordinates.y < 0 ? 0 : lineCoordinates.y;
        lineCoordinates.x = Number(this.realWidth) < lineCoordinates.x ? Number(this.realWidth) : lineCoordinates.x;
        lineCoordinates.y = Number(this.realHeight) < lineCoordinates.y ? Number(this.realHeight) : lineCoordinates.y;
        console.log(lineCoordinates);
        clearCanvas();
        drawLine();
        this.getPositionString = " " + "line" + "-" + lineCoordinates.x + ":" + lineCoordinates.y;
        this.stringPathArray.push(this.getPositionString);
        console.log(this.stringPathArray);
        this.accessLineAxialMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
        console.log('mouse leave line axial', this.accessLineAxialMenuFeatureStop);
      }
    });
    const getClientOffset = (event) => {
      const x = event.offsetX;
      const y = event.offsetY;
      console.log(x, y);
      return {
        x,
        y,
      };
    };

    const drawLine = () => {
      var dx = startPosition.x - lineCoordinates.x;
      var dy = startPosition.y - lineCoordinates.y;
      console.log("drawLine", lineCoordinates, startPosition);
      lineCoordinates =
        Math.abs(dx) < Math.abs(dy)
          ? { x: startPosition.x, y: lineCoordinates.y }
          : { x: lineCoordinates.x, y: startPosition.y };
      this.drawCanvasContext.beginPath();
      this.drawCanvasContext.moveTo(startPosition.x, startPosition.y);
      this.drawCanvasContext.lineTo(startPosition.x, startPosition.y);
      this.drawCanvasContext.lineTo(lineCoordinates.x, lineCoordinates.y);
      console.log(startPosition.x, startPosition.y);
      console.log(lineCoordinates.x, lineCoordinates.y);
      if (this.currentSelectedItems.hasOwnProperty('element_data') && this.setScaleOn != true) {
        this.drawCanvasContext.lineWidth = this.currentSelectedItems.element_data.line_width;
        var strokeColor = this.currentSelectedItems.element_data.stroke_color;
        this.drawCanvasContext.strokeStyle = this.checkStrokeColor1(strokeColor);
      }
      else {
        this.drawCanvasContext.lineWidth = 5;
        this.drawCanvasContext.strokeStyle = this.checkStrokeColor1('blue');
      }
      this.drawCanvasContext.stroke();
    };

    const clearCanvas = () => {
      this.drawCanvasContext.clearRect(
        0,
        0,
        newcreatedElement.width,
        newcreatedElement.height
      );
    };
  }

  drawLineAxialMethodSVG() {
    this.getPositionString = "";
    var startPosition = { x: 0, y: 0 };
    var lineCoordinates = { x: 0, y: 0 };
    this.stringPathArray = [];
    var isDrawStart = false;
    let path_value = "";
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeLineAxialAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    create_path.setAttribute("customelineaxialattributepath", "1");
    newcreatedElement.appendChild(create_path);
    let get_stroke;
    if (this.currentSelectedItems.hasOwnProperty('element_data') && this.setScaleOn != true) {
      get_stroke = this.currentSelectedItems.element_data.stroke_color;
    }
    else {
      get_stroke = 'blue';
    }
    let stroke_color = this.checkStrokeColor1(get_stroke);
    create_path.setAttribute('stroke', stroke_color);
    create_path.setAttribute('stroke-width', "2");
    create_path.setAttribute('fill', "none");
    pdfImg.appendChild(newcreatedElement);
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    newcreatedElement.addEventListener("mousedown", (event: any) => {
      event.preventDefault();
      if(this.showvisible==false || this.isReadonly == true){
        return
      }
      this.stringPathArray = [];
      startPosition = getClientOffset(event);
      isDrawStart = true;
      this.getPositionString = "move" + "-" + startPosition.x + ":" + startPosition.y;
      path_value = `M${startPosition.x} ${startPosition.y}`;
      this.stringPathArray.push(this.getPositionString);
    });
    newcreatedElement.addEventListener("mousemove", (event: any) => {
      if (!isDrawStart) return;
      lineCoordinates = getClientOffset(event);
      drawLine();
    });
    newcreatedElement.addEventListener("mouseup", (event: any) => {
      lineCoordinates = getClientOffset(event);
      if(this.showvisible==false || this.isReadonly == true){
        return
      }
      console.log(lineCoordinates);
      drawLine();
      isDrawStart = false;
      this.getPositionString = " " + "line" + "-" + lineCoordinates.x + ":" + lineCoordinates.y;
      path_value = path_value == "" ? `L${lineCoordinates.x} ${lineCoordinates.y}` : path_value + ` L${lineCoordinates.x} ${lineCoordinates.y}`;
      this.stringPathArray.push(this.getPositionString);
      console.log(this.stringPathArray);
      this.accessLineAxialMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      console.log('mouse up line axial', this.accessLineAxialMenuFeatureStop);
    });
    newcreatedElement.addEventListener("mouseleave", (event: any) => {
      if (isDrawStart == true) {
        isDrawStart = false;
        lineCoordinates = getClientOffset(event);
        lineCoordinates.x = lineCoordinates.x < 0 ? 0 : lineCoordinates.x;
        lineCoordinates.y = lineCoordinates.y < 0 ? 0 : lineCoordinates.y;
        lineCoordinates.x = Number(this.realWidth) < lineCoordinates.x ? Number(this.realWidth) : lineCoordinates.x;
        lineCoordinates.y = Number(this.realHeight) < lineCoordinates.y ? Number(this.realHeight) : lineCoordinates.y;
        console.log(lineCoordinates);
        drawLine();
        this.getPositionString = " " + "line" + "-" + lineCoordinates.x + ":" + lineCoordinates.y;
        path_value = path_value == "" ? `L${lineCoordinates.x} ${lineCoordinates.y}` : path_value + ` L${lineCoordinates.x} ${lineCoordinates.y}`;
        this.stringPathArray.push(this.getPositionString);
        console.log(this.stringPathArray);
        this.accessLineAxialMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
        console.log('mouse leave line axial', this.accessLineAxialMenuFeatureStop);
      }
    });
    const getClientOffset = (event) => {
      const x = event.offsetX;
      const y = event.offsetY;
      console.log(x, y);
      return {
        x,
        y,
      };
    };

    const drawLine = () => {
      var dx = startPosition.x - lineCoordinates.x;
      var dy = startPosition.y - lineCoordinates.y;
      console.log("drawLine", lineCoordinates, startPosition);
      lineCoordinates =
        Math.abs(dx) < Math.abs(dy)
          ? { x: startPosition.x, y: lineCoordinates.y }
          : { x: lineCoordinates.x, y: startPosition.y };
      path_value = `M${startPosition.x} ${startPosition.y} L${lineCoordinates.x} ${lineCoordinates.y}`;
      create_path.setAttribute("d", path_value);
      // this.drawCanvasContext.moveTo(startPosition.x, startPosition.y);
      // this.drawCanvasContext.lineTo(startPosition.x, startPosition.y);
      // this.drawCanvasContext.lineTo(lineCoordinates.x, lineCoordinates.y);

    };

  }

  updateLineAxialDrawShapes() {
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    if (this.stringPathArray.length != 0) {
      this.drawShapeDoneLineAxial = false;
      this.drawCanvasContext = null;
      this.accessLineAxialMenuFeatureStop = true;
      this.toolbarSet = false;
      var convertAnnotationData = "";
      this.removesvgAttribute('customeLineAxialAttribute');
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      this.show = true;
      var annontationdDate = new Date().getTime();
      var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationdDate;
      var MyDateString = new Date().toISOString();
      console.log(MyDateString);
      // this.annotationName = "Line Axial";
      let label_string = "";
      label_string = this.annotationLabelTemplate();
      this.createJson = {
        annotation_data: convertAnnotationData,
        annotation_forms: this.selectAnnotationForms,
        annotation_id: uuid,
        annotation_label: label_string,
        annotation_links: [],
        annotation_media: [],
        annotation_name: this.annotationName,
        annotation_stubs: [],
        annotation_tags: "",
        annotation_url: "",
        created_by_user_id: this.su.user_id,
        created_date: MyDateString,
        document_id: this.folderId,
        element_size: 1,
        fill_color: this.currentSelectedItems.element_data.fill_color,
        initial_height: 0,
        initial_position_x: 0,
        initial_position_y: 0,
        initial_rotation: 0,
        initial_width: 0,
        is_removed: false,
        last_updated_date: MyDateString,
        layer_id: this.activeLayerIdDraw,
        line_width: this.currentSelectedItems.element_data.line_width,
        opacity: 1,
        original_property: "",
        page_id: this.currentPageId,
        project_id: this.projectId,
        stroke_color: this.currentSelectedItems.element_data.stroke_color,
        toolbar_element_id: 16,
        updated_by_user_id: this.su.user_id,
        version_number: 1,
      };
      this.annotationUpdate();
    }
  }

  // draw the line axial shape end
  //seperate Draw Polygon method start
  //draw line done click method start
  updateLineDrawShapes() {
    this.borderLine = this.calculateCornerpoints(this.lineStartPosition,this.lineEndPosition);
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    console.log('click over', this.stringPathArray, this.accessLineMenuFeatureStop);
    if (this.stringPathArray.length != 0) {
      this.drawShapeDoneLine = false;
      this.drawCanvasContext = null;
      this.accessLineMenuFeatureStop = false;
      this.toolbarSet = false;
      var convertAnnotationData = "";
      this.removesvgAttribute('customeLineAttribute');
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      this.show = true;
      var annontationdDate = new Date().getTime();
      var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationdDate;
      var MyDateString = new Date().toISOString();
      console.log(MyDateString);
      // this.annotationName = "Line";
      let label_string = "";
      label_string = this.annotationLabelTemplate();
      this.createJson = {
        annotation_data: convertAnnotationData,
        annotation_forms: this.selectAnnotationForms,
        annotation_id: uuid,
        annotation_label: label_string,
        annotation_links: [],
        annotation_media: [],
        annotation_name: this.annotationName,
        annotation_stubs: [],
        annotation_tags: "",
        annotation_url: "",
        created_by_user_id: this.su.user_id,
        created_date: MyDateString,
        document_id: this.folderId,
        element_size: 1,
        fill_color: this.currentSelectedItems.element_data.fill_color,
        initial_height: 0,
        initial_position_x: 0,
        initial_position_y: 0,
        initial_rotation: 0,
        initial_width: 0,
        is_removed: false,
        last_updated_date: MyDateString,
        layer_id: this.activeLayerIdDraw,
        line_width: this.currentSelectedItems.element_data.line_width,
        opacity: 1,
        original_property: "",
        page_id: this.currentPageId,
        project_id: this.projectId,
        stroke_color: this.currentSelectedItems.element_data.stroke_color,
        toolbar_element_id: 15,
        updated_by_user_id: this.su.user_id,
        version_number: 1,
      };
      this.borderLineArray.push(this.createJson.annotation_id);
      this.lineDraw = true;
      this.annotationUpdate();
    }
  }

  annotationUpdateLineDraw(convertAnnotationData) {
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.pointerEvents = "none";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    convertAnnotationData = convertAnnotationData.trim();
    var spaceSplit = convertAnnotationData.split(" ");
    console.log(spaceSplit);
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");

      for (var j = 0; j < hypenSplit.length; j++) {
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var colonSplit = hypenSplit[j].split(":");
          var x = colonSplit[0];
          var y = colonSplit[1];
        }
        switch (hypenSplit[0]) {
          case "move":
            this.canvasElement.moveTo(x, y);
            break;
          case "line":
            this.canvasElement.lineTo(x, y);
            break;
        }
        this.canvasElement.lineWidth = 1;
        this.canvasElement.strokeStyle = "rgba(0.999999999885,44.999999991,98.0000000025,1)";
        this.canvasElement.stroke();
      }
    }
  }
  //draw line done click method end

  //seperate Draw Polygon method end
  closeFooter2() {
    this.drawShapeDonePolygon = false;
    this.accessPolygonMenuFeatureStop = false;
    this.drawCanvasContext = null;
    this.closeFooterCommonSVG('customepolygonattribute');
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  closeFooter3() {
    this.drawShapeDonePolyline = false;
    this.accessPolylineMenuFeatureStop = false;
    this.drawCanvasContext = null;
    this.closeFooterCommonSVG("customepolylineattribute");
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = closeFooterLine.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  closeFooter4() {
    this.drawShapeDonePolylineArrow = false;
    this.accessPolylineArrowMenuFeatureStop = false;
    this.drawCanvasContext = null;
    this.closeFooterCommonSVG('customepolylinearrowattribute');
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  closeFooterCommon(attributeName) {
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    this.getPositionSetMove = 1;
    this.receiveString = "";
    this.getPositionString = "";
    this.stringPathArray = [];
    this.toolbarBg = -1;
    this.getPositionActive = false;
    this.drawFunctionActive = false;
    //getposition click event trigger when select toolbar shape only purpose using toolbarset
    this.toolbarSet = false;
    var getCanvasElements = document.querySelectorAll("canvas");
    for (var i = 0; i < getCanvasElements.length; i++) {
      if (getCanvasElements[i].getAttribute(attributeName) != null) {
        getCanvasElements[i].remove();
      }
    }
    if (this.toolbarElementId != 12 && this.toolbarElementId != 17 &&
      this.toolbarElementId != 15 && this.toolbarElementId != 16 &&
      this.toolbarElementId != 19 && this.toolbarElementId != 20) {
      this.removeRedCircles();
    }
  }
  // replace svg close
  closeFooterCommonSVG(attributeName) {
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    this.getPositionSetMove = 1;
    this.receiveString = "";
    this.getPositionString = "";
    this.stringPathArray = [];
    this.toolbarBg = -1;
    this.getPositionActive = false;
    this.drawFunctionActive = false;
    //getposition click event trigger when select toolbar shape only purpose using toolbarset
    this.toolbarSet = false;
    var getSVGElements: any = document.querySelector(`svg[${attributeName}]`);
    if (getSVGElements != null) {
      getSVGElements.remove();
    }
    if (this.toolbarElementId != 12 && this.toolbarElementId != 17 &&
      this.toolbarElementId != 15 && this.toolbarElementId != 16 &&
      this.toolbarElementId != 19 && this.toolbarElementId != 20) {
      this.removeRedCircles();
    }
    // disable drag scroll
    this.createDocumentStore.disable_drag_scroll = false;
  }

  closeFooterLine() {
    this.drawShapeDoneLine = false;
    this.accessLineMenuFeatureStop = true;
    this.drawCanvasContext = null;
    this.closeFooterCommonSVG("customeLineAttribute");
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     // this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  closeFooterRectangle() {
    this.drawRectangleDone = false;
    this.accessRectangleMenuFeatureStop = true;
    this.drawCanvasContext = null;
    this.removeredCirclesSVG();
    this.closeFooterCommonSVG('customeDrawRectangleAttribute');
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  closeFooterEllipse() {
    
    this.drawEllipseDone = false;
    this.accessdrawEllipseMenuStop = true;
    this.drawCanvasContext = null;
    this.closeFooterCommonSVG("customeDrawEllipseAttribute");
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  closeFooterLineAxial() {
    this.drawShapeDoneLineAxial = false;
    this.accessLineAxialMenuFeatureStop = true;
    this.drawCanvasContext = null;
    this.closeFooterCommonSVG('customeLineAxialAttribute');
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   // this.multiselectionList = [];
    //   // this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     // this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  dropdownChange1(item, elementUUID, targetValue, fullItem) {
    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    console.log(item, elementUUID, typeof targetValue, targetValue, fullItem);
    targetValue = Number(targetValue);
    if (targetValue == -1) {
      let get_previous_default_true = item.findIndex((opt_loop) => this.createDocumentStore.data_allow_conditionT.includes(opt_loop.default));
      if (get_previous_default_true > -1) {
        let field_element = this.modelFieldsForm.filter((ele) => ele.element_uuid == elementUUID);
        if (field_element.length == 0) {
          if (this.is_extend == true) {
            field_element = this.extend_modelFieldsForm.filter((ele) => ele.element_uuid == elementUUID);
          }
        }
        if (field_element.length > 0) {
          for (let c = 0; c < field_element[0].element_data.options.length; c++) {
            field_element[0].element_data.options[c].default = false;
          }
          this.cdRef.detectChanges();
        
          this.formValuesUpdate(fullItem, elementUUID, field_element[0].element_data.options[get_previous_default_true], null,targetValue);
        }
      }
    }
    else {
      let field_element = this.modelFieldsForm.filter((ele) => ele.element_uuid == elementUUID);
      if (field_element.length == 0) {
        if (this.is_extend == true) {
          field_element = this.extend_modelFieldsForm.filter((ele) => ele.element_uuid == elementUUID);
        }
      }
      if (field_element.length > 0) {
        for (let c = 0; c < field_element[0].element_data.options.length; c++) {
          if (c == targetValue) {
            field_element[0].element_data.options[c].default = true;
          }
          else {
            field_element[0].element_data.options[c].default = false;
          }
        }
        this.cdRef.detectChanges()
      
        this.formValuesUpdate(fullItem, elementUUID, field_element[0].element_data.options[targetValue], null);
      }

    }

  }

  dropdownChange_Grouping(item, elementUUID, targetValue, fullItem) {
    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    console.log(item, elementUUID, typeof targetValue, targetValue, fullItem);
    targetValue = Number(targetValue);
    if (targetValue == -1) {
      let get_previous_default_true = item.findIndex((opt_loop) => this.createDocumentStore.data_allow_conditionT.includes(opt_loop.default));
      if (get_previous_default_true > -1) {
        let field_element = this.modelFieldsForm.filter((ele) => ele.element_uuid == elementUUID);
        if (field_element.length == 0) {
          if (this.is_extend == true) {
            field_element = this.extend_modelFieldsForm.filter((ele) => ele.element_uuid == elementUUID);
          }
        }
        if (field_element.length > 0) {
          for (let c = 0; c < field_element[0].element_data.options.length; c++) {
            field_element[0].element_data.options[c].default = false;
          }
          this.cdRef.detectChanges();
        
          this.formValuesUpdate(fullItem, elementUUID, field_element[0].element_data.options[get_previous_default_true], null,targetValue);
        }
      }
    }
    else {
      let field_element = this.modelFieldsForm.filter((ele) => ele.element_uuid == elementUUID);
      if (field_element.length == 0) {
        if (this.is_extend == true) {
          field_element = this.extend_modelFieldsForm.filter((ele) => ele.element_uuid == elementUUID);
        }
      }
      if (field_element.length > 0) {
        for (let c = 0; c < field_element[0].element_data.options.length; c++) {
          if (c == targetValue) {
            field_element[0].element_data.options[c].default = true;
          }
          else {
            field_element[0].element_data.options[c].default = false;
          }
        }
        this.cdRef.detectChanges()
        let currentAnnid = this.currentSelectedAnnotationData.annotation_id;
        let findCurGroupIndex;
        if (this.multipleSelectOn == false){
          findCurGroupIndex = this.findGroupindex(currentAnnid);
          if(findCurGroupIndex != -1){
            this.checkBoxUpdate_grouping(fullItem, currentAnnid, field_element[0].element_data.options[targetValue], targetValue);
            fullItem.element_data.last_modified_date = new Date().toISOString();
          }
        }
        else{
            this.checkBoxUpdate_grouping(fullItem, currentAnnid, field_element[0].element_data.options[targetValue], targetValue);
            fullItem.element_data.last_modified_date = new Date().toISOString();
        }
        this.formValuesUpdate(fullItem, elementUUID, field_element[0].element_data.options[targetValue], null);
      }
    }
    console.log(this.modelFieldsForm);
  }

  dropdownChange(item, itemValue, button) {
    console.log(item)
    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    //check already selected element
    let findValueAccept = false;

    let findTrueValue = item.element_data.options.findIndex((dataV) => dataV.element_uuid == itemValue);
    if (findTrueValue > -1) {
      let getTrueorFalse = item.element_data.options[findTrueValue].default;
      console.log(getTrueorFalse);
      if (getTrueorFalse == true || getTrueorFalse == "true" || getTrueorFalse == "1") {
        findValueAccept = true;
      }
    }
    item.element_data.options.forEach(element => {
      element.default = false;

    });
    let UCitemDefault = item.element_data.options.filter((ele => ele.element_uuid == itemValue))
    if (UCitemDefault.length > 0) {
      if (findValueAccept == true) {


        UCitemDefault[0].default = false;
        // UCitemDefault[0].Opacity=UCitemDefault[0].opacity
      }

      else {


        UCitemDefault[0].default = true;

        if (UCitemDefault[0].attributes == true) {

          // let shapedrawing = this.checkShapestring(UCitemDefault[0].icon);

        }
      }
      console.log(UCitemDefault[0])
      item.element_data.default_value = itemValue;
      item.element_data.last_modified_date = new Date().toISOString();
      var gg = this.modelFieldsForm;

      this.formValuesUpdate(item, item.element_uuid, UCitemDefault[0], null);
      //The below lines are added to enable the moving functionality after multiselecting and changing the attributes shapes(form).[P3X-1081]
      var idCollections = [];
      for (let i = 0; i < this.multiselectionList.length; i++) {
        idCollections.push([this.multiselectionList[i].annotation_id]);
      }
      for (let j = 0; j < idCollections.length; j++) {
        let getElement = document.getElementById(idCollections[j]);
        if (getElement != null) {
          getElement.setAttribute('multimoving', '1');
        }
      }
      this.process_use_conditions();
    }

  }

  checkShapestring(shapename) {
    let currentPathString = '';
    let elementId = 0;
    shapename = shapename.toLowerCase();
    switch (shapename) {
      case "circle":
        currentPathString = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
        break;
      case "octagon":
        currentPathString = "move-15:25 line-18:18 line-25:15 line-32:18 line-35:25 line-32:32 line-25:35 line-18:32 line-15:25 line-18:18";
        break;
      case "square":
        currentPathString = "move-15:15 line-35:15 line-35:35 line-15:35 line-15:15 line-35:15";
        break;
      case "triangle":
        currentPathString = "move-25:15 line-35:35 line-15:35 line-25:15 line-35:35";
        break;
      case "star":
        currentPathString = "move-25:12 line-30:22 line-38:22 line-32:30 line-35:40 line-25:34 line-15:40 line-18:30 line-12:22 line-20:22 line-25:12 line-30:22";
        break;
      case "diamond":
        currentPathString = "move-25:15 line-32.5:25 line-25:35 line-17.5:25 line-25:15 line-32.5:25";
        break;
      case "flag":
        currentPathString = "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-17:25 line-17:40 line-15:40 line-15:15";
        break;
      case "camera":
        currentPathString = "move-31:22 controlpoint1-31:25.3137 controlpoint2-28.3137:28 endCurve-25:28 controlpoint1-21.6863:28 controlpoint2-19:25.3137 endCurve-19:22 controlpoint1-19:18.6863 controlpoint2-21.6863:16 endCurve-25:16 controlpoint1-28.3137:16 controlpoint2-31:18.6863 endCurve-31:22 move-17.5:15 line-19.5:12.5 line-30.5:12.5 line-32.5:15 line-36:15 controlpoint-38:15 curveEnd-38:17 line-38:29 controlpoint-38:31 curveEnd-36:31 line-14:31 controlpoint-12:31 curveEnd-12:29 line-12:17 controlpoint-12:15 curveEnd-14:15 line-17.5:15 line-19.5:12.5 move-14:19 line-16:19 line-16:20 line-14:20 move-22:22 controlpoint-22:19 curveEnd-25:19 controlpoint-28:19 curveEnd-28:22 controlpoint-28:25 curveEnd-25:25 controlpoint-22.5:25 curveEnd-22:22";
        break;
      case "arrow":
        currentPathString = "move-10:22.5 line-25:22.5 line-25:15 line-40:25 line-25:35 line-25:27.5 line-10:27.5 line-10:22.5 line-25:22.5";
        break;
    }
    return currentPathString;
  }

  multipleChange(item, itemValue) {
    console.log(this.multipleSelectOn);
    console.log(this.multiselectionList);
    let currentAnnid = this.currentSelectedAnnotationData.annotation_id;
    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    let UCitemDefault = item.element_data.options.filter((ele => ele.element_uuid == itemValue));
    if (UCitemDefault[0].default == true) {
      UCitemDefault[0].default = false;
    } else {
      UCitemDefault[0].default = true;
    }
    item.element_data.last_modified_date = new Date().toISOString();
    this.formValuesUpdate(item, item.element_uuid, UCitemDefault[0], null);
  }
  
  checkBoxUpdate_grouping(item, currentAnnid, UCitemDefault,targetValue) {
    if (this.createJSON_grpAnnts != undefined) {
      const colorCheck = item.element_data.group_color_details;
      let dropDownColorPresent = colorCheck != undefined ? true : false;
      if (dropDownColorPresent == true) {
        this.dropDownColorDetails = colorCheck;
      }
      else{
        this.dropDownColorDetails = undefined;
      }
      if (this.multipleSelectOn == true) {
        this.groupValueUpdate = true;
        for (let i = 0; i < this.multiselectionList.length; i++) {
          currentAnnid = this.multiselectionList[i].annotation_id;
          let findCurGroup = this.createJSON_grpAnnts.group_data.findIndex((data) => {
            let curAnn = data.annotation_ids.filter(id => id == currentAnnid);
            if (curAnn.length > 0) {
              return true;
            }
            else {
              return false;
            }
          })
          if(findCurGroup == -1){
            continue;
          }
          let groupEnable = true;
          if (groupEnable == true) {
            let state = 0;
            var filAnn;
            let annColor;
            if (targetValue == 0) {
              filAnn = this.createDocumentStore.view_annotation_array.filter(data => data.annotation_id == currentAnnid);
              state = 0;
            }
            else if (targetValue == 1) {
              filAnn = this.createDocumentStore.view_annotation_array.filter(data => data.annotation_id == currentAnnid);
              state = 1;
            }
            else if (targetValue == 2) {
              filAnn = this.createDocumentStore.view_annotation_array.filter(data => data.annotation_id == currentAnnid);
              state = 2;
            }
            else if (targetValue == 3) {
              filAnn = this.createDocumentStore.view_annotation_array.filter(data => data.annotation_id == currentAnnid);
              state = 3;
            }
            if (this.dropDownColorDetails != undefined) {
              annColor = this.findAnnColor_FormBuilder(state)
            }
            else{
              annColor = this.findColor(state);
            }
            if (filAnn[0].toolbar_element_id != 11 && filAnn[0].toolbar_element_id != 12 && filAnn[0].toolbar_element_id != 13 && filAnn[0].toolbar_element_id != 14) {
              filAnn[0].fill_color = annColor;
            }
            filAnn[0].stroke_color = annColor;
            let groupDetails = this.changeBorderforGroup(currentAnnid, state, dropDownColorPresent);
          }
        }
      }
      else {
        let findCurGroup = this.createJSON_grpAnnts.group_data.findIndex((data) => {
          let curAnn = data.annotation_ids.filter(id => id == currentAnnid);
          if (curAnn.length > 0) {
            return true;
          }
          else {
            return false;
          }
        })
        this.groupValueUpdate = true;
        let state = 0;
        var filAnn;
        let annColor;
        if (targetValue == 0) {
          filAnn = this.createDocumentStore.view_annotation_array.filter(data => data.annotation_id == currentAnnid);
          state = 0;
        }
        else if (targetValue == 1) {
          filAnn = this.createDocumentStore.view_annotation_array.filter(data => data.annotation_id == currentAnnid);
          state = 1;
        }
        else if (targetValue == 2) {
          filAnn = this.createDocumentStore.view_annotation_array.filter(data => data.annotation_id == currentAnnid);
          state = 2;
        }
        else if (targetValue == 3) {
          filAnn = this.createDocumentStore.view_annotation_array.filter(data => data.annotation_id == currentAnnid);
          state = 3;
        }
        if (this.dropDownColorDetails != undefined) {
          annColor = this.findAnnColor_FormBuilder(state)
        }
        else{
          annColor = this.findColor(state);
        }
        if (filAnn[0].toolbar_element_id != 11 && filAnn[0].toolbar_element_id != 12 && filAnn[0].toolbar_element_id != 13 && filAnn[0].toolbar_element_id != 14) {
          filAnn[0].fill_color = annColor;
        }
        filAnn[0].stroke_color = annColor;
        filAnn[0].opacity = 0.5;
        let groupDetails = this.changeBorderforGroup(currentAnnid, state, dropDownColorPresent);
      }
    }
  }

  copyAnnotationShapes(getData) {
    var annotationLabel = getData.annotation_label;
    var pdfImg = document.getElementById("copyofAnnotationDiv");
    var newcreatedElement = document.createElement("canvas");
    if (
      annotationLabel == "Freehand Line" ||
      annotationLabel == "Freehand Area" ||
      annotationLabel == "Polygon" ||
      annotationLabel == "Polyline" ||
      annotationLabel == "Polyline Arrow" ||
      annotationLabel == "Line" ||
      annotationLabel == "Line Axial"
    ) {
      console.log(getData.annotation_data);
      newcreatedElement.setAttribute("width", this.realWidth);
      newcreatedElement.setAttribute("height", this.realHeight);
      newcreatedElement.style.top = "0px";
      newcreatedElement.style.left = "0px";
      newcreatedElement.style.pointerEvents = "none";
    } else {
      newcreatedElement.setAttribute("id", getData.annotation_id);
      newcreatedElement.setAttribute("width", "50");
      newcreatedElement.setAttribute("height", "50");
      newcreatedElement.setAttribute("customeMultiSelectAttribute", "1");
    }
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    getData.annotation_data = getData.annotation_data.trim();
    var spaceSplit = getData.annotation_data.split(" ");

    var previous = { x: 0, y: 0 };
    var current = { x: 0, y: 0 };
    var a = 0;
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");

      for (var j = 0; j < hypenSplit.length; j++) {
        var colonSplit = hypenSplit[j].split(":");
        if (hypenSplit[0] == "controlpoint") {
          var cpx = parseFloat(colonSplit[0]);
          var cpy = parseFloat(colonSplit[1]);
        }
        if (hypenSplit[0] == "curveEnd") {
          var ex = parseFloat(colonSplit[0]);
          var ey = parseFloat(colonSplit[1]);
        }
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {

          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var h = parseFloat(colonSplit[2]);
          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            this.canvasElement.moveTo(x, y);
            if (getData.annotation_label == "Polyline Arrow" && j == 1) {
              previous.x = x;
              previous.y = y;
              a++;
            }
            break;
          case "line":
            this.canvasElement.lineTo(x, y);
            if (
              getData.annotation_label == "Polyline Arrow" &&
              a == 1 &&
              j == 1 &&
              previous.x != 0 &&
              previous.y != 0
            ) {
              current.x = x;
              current.y = y;
              var dx = current.x - previous.x;
              var dy = current.y - previous.y;
              var headlen = 10;
              var angle = Math.atan2(dy, dx);
              this.canvasElement.lineTo(
                current.x - headlen * Math.cos(angle - Math.PI / 6),
                current.y - headlen * Math.sin(angle - Math.PI / 6)
              );
              this.canvasElement.moveTo(current.x, current.y);
              this.canvasElement.lineTo(
                current.x - headlen * Math.cos(angle + Math.PI / 6),
                current.y - headlen * Math.sin(angle + Math.PI / 6)
              );
            }
            previous.x = x;
            previous.y = y;
            break;
          case "ovalIn":
            var r = (w * w) / (8 * h) + h / 2;
            this.canvasElement.arc(
              newcreatedElement.clientWidth / 2,
              newcreatedElement.clientHeight / 2.3,
              r,
              0,
              2 * Math.PI
            );
            break;
          case "curveEnd":
            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
            break;
        }
        if (
          annotationLabel != "Freehand Line" &&
          annotationLabel != "Polyline" &&
          annotationLabel != "Polyline Arrow" &&
          annotationLabel != "Line"
        ) {
          var checkFill = getData.fill_color;

          this.canvasElement.fillStyle = this.checkStrokeColor1(getData.fill_color);
          this.canvasElement.fill();
        }


        this.canvasElement.strokeStyle = this.checkStrokeColor1(getData.stroke_color);
        this.canvasElement.stroke();
        this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width);
      }
    }
  }

  copyannotationId: string;
  async copyAnnotationAction(copyannotationfile) {
    this.copyAnnotationStart = true;
    // need to work svg
    this.multiselectionList = copyannotationfile;
    // draw side bar multiple_annotations when local changes happened in the multiselection list 
    await this.drawing_multiple_annotations();
    var getCanvasElement = document.querySelectorAll("canvas");
    for (var i = 0; i < getCanvasElement.length; i++) {
      if (
        getCanvasElement[i].getAttribute("customeMultiSelectAttribute") != null
      ) {
        getCanvasElement[i].style.border = "2px solid transparent";
        var getBorderId = getCanvasElement[i].getAttribute("id");
        console.log(getBorderId);
        getCanvasElement[i].setAttribute("borderChoice", getBorderId + "B");
        getCanvasElement[i].addEventListener("click", (e: any) => {
          this.getannotationDetailsMultiSelect(e);
        });
      } else {
        getCanvasElement[i].style.pointerEvents = "none";
        // getCanvasElement[i].style.background = "transparent";
        // getCanvasElement[i].style.border = "2px solid transparent";
        this.transparentBorder(getCanvasElement[i]);
      }
    }
  }

  copyAnnotationSingleAction(copyannotationfile) {
    console.log(copyannotationfile);
    var getCanvasElement = document.querySelectorAll("canvas");
    for (var i = 0; i < getCanvasElement.length; i++) {
      if (
        getCanvasElement[i].getAttribute("customeMultiSelectAttribute") != null
      ) {
        getCanvasElement[i].remove();
      }
    }
    this.copyAnnotationData = copyannotationfile;
    this.copyAnnotationStart = true;
    // this.showMultiSelectFooter = true;
    // latest comment
    // this.drawMultiSelectShapes(this.copyAnnotationData);
    var getCanvasElement = document.querySelectorAll("canvas");
    for (var i = 0; i < getCanvasElement.length; i++) {
      if (
        getCanvasElement[i].getAttribute("customeMultiSelectAttribute") != null
      ) {
        getCanvasElement[i].style.border = "2px solid transparent";
        var getBorderId = getCanvasElement[i].getAttribute("id");
        console.log(getBorderId);
        getCanvasElement[i].setAttribute("borderChoice", getBorderId + "B");
        getCanvasElement[i].addEventListener("click", (e: any) => {
          this.getannotationDetailsSingle(e);
        });
      }
    }
  }

  seperateFunction(copyannotationfile) {
    console.log(copyannotationfile);
    // this.drawMultiSelectShapes(copyannotationfile);
    var getCanvasElement = document.querySelectorAll("canvas");
    for (var i = 0; i < getCanvasElement.length; i++) {
      if (
        getCanvasElement[i].getAttribute("customeMultiSelectAttribute") != null
      ) {
        getCanvasElement[i].addEventListener("click", (e: any) => {
          this.getannotationDetailsSingle(e);
        });
      }
    }
  }

  copyAnnotationData: any;
  getannotationDetailsMultiSelect(e: any) {
    console.log(e);
    this.copyannotationId = e.target.id;
    let getCanvassetBorderElement = document.querySelectorAll("canvas");
    for (var a = 0; a < getCanvassetBorderElement.length; a++) {
      if (getCanvassetBorderElement[a].getAttribute("borderChoice") != null) {
        var findCanvassetBorderElement = getCanvassetBorderElement[
          a
        ].getAttribute("borderChoice");
        for (var b = 0; b < getCanvassetBorderElement.length; b++) {
          if (findCanvassetBorderElement == e.target.id + "B") {
            this.drawFunctionActive = true;
            getCanvassetBorderElement[a].style.border = "2px solid #F98E2C";
          } else {
            getCanvassetBorderElement[a].style.border = "2px solid transparent";
          }
        }
      }
    }

    console.log(this.multiselectionList);
    for (var i = 0; i < this.multiselectionList.length; i++) {
      if (this.copyannotationId == this.multiselectionList[i].annotation_id) {
        var getannotationName = this.multiselectionList[i].annotation_name;
        this.copyAnnotationData = this.multiselectionList[i];
        this.toolbarElementId = this.multiselectionList[i].toolbar_element_id;
        console.log(this.copyAnnotationData);
        console.log(getannotationName);
        this.annotationName = getannotationName;
        this.copyAnnotationSetString(this.toolbarElementId);
      }
    }
  }

  getannotationDetailsSingle(e: any) {
    this.copyannotationId = e.target.id;
    let getCanvassetBorderElement = document.querySelectorAll("canvas");
    for (var a = 0; a < getCanvassetBorderElement.length; a++) {
      if (getCanvassetBorderElement[a].getAttribute("borderChoice") != null) {
        var findCanvassetBorderElement = getCanvassetBorderElement[
          a
        ].getAttribute("borderChoice");
        for (var b = 0; b < getCanvassetBorderElement.length; b++) {
          if (findCanvassetBorderElement == e.target.id + "B") {
            getCanvassetBorderElement[a].style.border = "2px solid #F98E2C";
          } else {
            getCanvassetBorderElement[a].style.border = "2px solid transparent";
          }
        }
      }
    }
    var getannotationId = this.copyAnnotationData.toolbar_element_id;
    console.log(this.copyAnnotationData);
    this.copyAnnotationSetString(getannotationId);
  }

  copyAnnotationSetString(toolbarElementId) {
    this.drawFunctionActive = true;
    this.getPositionActive = true;
    // this.annotationName = itemName;
    if (toolbarElementId == 7) {
      this.receiveString =
        "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-15:25";
    } else if (toolbarElementId == 3) {
      this.receiveString =
        "move-15:15 line-35:15 line-35:35 line-15:35 line-15:15 line-35:15";
    } else if (toolbarElementId == 8) {
      this.receiveString =
        "ovalIn-21.5:18:7:7 move-10:15 line-17:15 line-17:10 line-33:10 line-33:15 line-40:15 line-40:31 line-10:31 line-10:15 line-17:15 move-34:19 line-35:19";
    } else if (toolbarElementId == 1) {
      this.receiveString = "ovalIn-15:15:20:20";
    } else if (toolbarElementId == 2) {
      this.receiveString =
        "move-15:25 line-18:18 line-25:15 line-32:18 line-35:25 line-32:32 line-25:35 line-18:32 line-15:25 line-18:18";
    } else if (toolbarElementId == 4) {
      this.receiveString =
        "move-25:15 line-35:35 line-15:35 line-25:15 line-35:35";
    } else if (toolbarElementId == 5) {
      this.receiveString =
        "move-25:12 line-30:22 line-38:22 line-32:30 line-35:40 line-25:34 line-15:40 line-18:30 line-12:22 line-20:22 line-25:12";
      // this.receiveString =
      //   "move-25:15 line-28:21.5 line-35:25 line-30:30 line-32.5:37.5 line-25:34 line-17.5:37.5 line-20:30 line-15:25 line-22:21.5 line-25:15 line-28:21.5";
    } else if (toolbarElementId == 6) {
      this.receiveString =
        "move-25:15 line-32.5:25 line-25:35 line-17.5:25 line-25:15 line-32.5:25";
    } else if (toolbarElementId == 9) {
      this.receiveString =
        "move-10:25 line-25:25 line-25:20 line-35:25 line-25:30 line-25:25";
    } else if (toolbarElementId == 16) {
      this.panZoomController.pause();
      this.drawLineAxialMethodSVG();
    } else if (toolbarElementId == 13) {
      this.polylinearrowmethodSVG();
    } else if (toolbarElementId == 15) {
      this.panZoomController.pause();
      this.drawLineMethodSVG(0);
    } else if (toolbarElementId == 19) {
      this.receiveString = "ovalIn-20:20:15:20";
      this.drawShapeDoneLineAxial = false;
    } else if (toolbarElementId == 18) {
      this.polygonmethodSVG();
    } else if (toolbarElementId == 14) {
      this.polylinemethodSVG();
    } else if (toolbarElementId == 12 || toolbarElementId == 17) {
      this.panZoomController.pause();
      // var element = document.getElementById('scene');
      // var instance = panzoom(element);
      // instance.isPaused(); //  returns false
      // instance.pause();    //  Pauses event handlin
      this.captureEventsSVG(toolbarElementId);
    }
    if (this.stringPath != "") {
      var stringPathAsOne = [];
      stringPathAsOne.push(this.stringPath);
      console.log(stringPathAsOne);
    }
  }

  updatecodedMultiSelectCopy() {
    this.receiveString = "";
    this.toolbarBg = -1;
    this.getPositionActive = false;
    let layers = [];

    if (this.layerDatas != undefined) {
      this.layerDatas.forEach((data) => {
        if (data.layer_id === this.activeLayerIdDraw) {
          data.annotations.push(this.createJson);

          layers.push(data);
        } else {
          layers.push(data);
        }
      });
      this.layerDatas = layers;
      console.log(this.layerDatas);
      this.documentService.annotationUpdateAUC(layers).subscribe((response) => {
        console.log(response);
        this.show = false;
        this.getPositionString = "";
        this.stringPathArray = [];
        this.getPositionSetMove = 1;
      });
    }
  }


  formsheaderCanvas(id, getData, labelid) {
    console.log(getData);
    var elementId = getData.toolbar_element_id;
    var pdfImg = document.getElementById(id);
    let getWidth = 0;
    let getHeight = 0;
    if (getData.initial_width <= 0 && getData.initial_height <= 0 && elementId >= 12 && elementId <= 18) {
      let convertAnnotationWH = getData.annotation_data;
      let xCoordinate = [];
      let yCoordinate = [];
      let startx;
      let starty;
      let endx;
      let endy;
      convertAnnotationWH = convertAnnotationWH.trim();
      let splitData = convertAnnotationWH.split(" ");
      for (var i = 0; i < splitData.length; i++) {
        let hypenSplit = splitData[i].split("-");
        let colonSplit = hypenSplit[1].split(":");
        xCoordinate.push(colonSplit[0]);
        yCoordinate.push(colonSplit[1]);
      }
      startx = Math.min.apply(null, xCoordinate);
      endx = Math.max.apply(null, xCoordinate);
      starty = Math.min.apply(null, yCoordinate);
      endy = Math.max.apply(null, yCoordinate);

      let getDrawWidthandHeight = this.calculateRectPos(
        startx,
        starty,
        endx,
        endy
      );
      this.coordinateX = getDrawWidthandHeight.left;
      this.coordinateY = getDrawWidthandHeight.top;
      getWidth = getDrawWidthandHeight.width;
      getHeight = getDrawWidthandHeight.height;
    }
    else if (Number(getData.initial_width) != 0 && Number(getData.initial_height) != 0) {
      getWidth = getData.initial_width + 5;
      getHeight = getData.initial_height + 5;
    }
    else if (elementId <= 11) {
      getWidth = 40;
      getHeight = 40;
    }
    else if (elementId == 19 || elementId == 20) {
      let hypenSplitCD = getData.annotation_data.split("-");
      let colonSplitCD = hypenSplitCD[1].split(":");
      this.coordinateX = colonSplitCD[0];
      this.coordinateY = colonSplitCD[1];
      getWidth = parseInt(colonSplitCD[2]) + 5;
      getHeight = parseInt(colonSplitCD[3]) + 5;
      console.log(getWidth, getHeight);
    }
    var annotationLabel = getData.annotation_label;

    // if (pdfImg.hasChildNodes()!=null && pdfImg != null) {
    //   pdfImg.removeChild(pdfImg.childNodes[0]);
    // }
    if (pdfImg != null && pdfImg.firstChild != null) {
      pdfImg.removeChild(pdfImg.firstChild);
    }
    let getannotationLabelElement = document.querySelectorAll("p");
    if (getannotationLabelElement.length > 0) {
      for (var al = 0; al < getannotationLabelElement.length; al++) {
        if (getannotationLabelElement[al].getAttribute(labelid) != null) {
          getannotationLabelElement[al].remove();
        }
      }
    }
    // else if (this.properties == true) {
    //   var pdfImg = document.getElementById("headerCanvasProperties");
    // }
    var newcreatedElement = document.createElement("canvas");
    if (elementId < 12) {
      newcreatedElement.setAttribute("width", "50");
      newcreatedElement.setAttribute("height", "50");
      newcreatedElement.style.height = "50px";
      newcreatedElement.style.marginTop = "4px";
      newcreatedElement.style.pointerEvents = "none";
    }
    // newcreatedElement.style.opacity = getData.opacity;
    if (getData.initial_rotation == undefined) {
      newcreatedElement.style.transform = "rotate(" + 0 + "deg)";
    } else if (getData.initial_rotation != undefined) {
      newcreatedElement.style.transform =
        "rotate(" + getData.initial_rotation + "deg)";
    }
    if (this.form == true) {
      this.removeCanvasAttribute('customeformheaderattribute');
      newcreatedElement.setAttribute("customeformheaderattribute", "1");
    }
    if (getData.toolbar_element_id == 1 || getData.toolbar_element_id == 8) {
      newcreatedElement.style.marginTop = "8px";
    }
    console.log(newcreatedElement, pdfImg, id);
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    console.log(getWidth, getHeight, this.coordinateX, this.coordinateY);
    if (elementId >= 12) {
      let scaleValueX = 0.8;
      let scaleValueY = 0.8;
      let newwidth = 50;
      let newheight = 50;
      if (getWidth > 50 || getHeight > 50) {
        var scale_val = Math.min(50 / (getWidth), 50 / (getHeight))
        newwidth = getWidth * scale_val;
        newheight = getHeight * scale_val;
        scaleValueX = scale_val;
        scaleValueY = scale_val;
        console.log(scale_val);
      }
      console.log(getHeight, getWidth, scaleValueX, scaleValueY, newwidth, newheight);
      this.canvasElement.canvas.width = newwidth > 50 ? 48 : newwidth;
      this.canvasElement.canvas.height = newheight > 50 ? 48 : newheight;
      this.canvasElement.scale(scaleValueX, scaleValueX);
      this.canvasElement.textAlign = "center";
    }
    if (getData.annotation_label != "") {
      this.annotationLabelBackground(getData, id, labelid);
    }
    if (Number(getData.initial_width) != 0 && Number(getData.initial_height) != 0) {
      getData.initial_width = Number(getData.initial_width) + 5;
      getData.initial_height = Number(getData.initial_height) + 5;
      newcreatedElement.setAttribute("width", getData.initial_width.toString());
      newcreatedElement.setAttribute("height", getData.initial_height.toString());
    }
    //jose sir logic
    var scale_val = Math.max(50 / Number(getData.initial_width), 50 / Number(getData.initial_height))
    console.log(scale_val, getData.initial_width, getData.initial_height);
    //ganesh
    // scale_val = scale_val != 0 ? scale_val : 0.5;
    //jose sir logic  
    scale_val = scale_val < 0.5 ? 0.5 : scale_val;
    newcreatedElement.style.transform = "scale(" + scale_val + ")";
    console.log(newcreatedElement.getBoundingClientRect());
    var getafterScale = newcreatedElement.getBoundingClientRect();
    if (getafterScale.width > 70 || getafterScale.height > 70) {
      scale_val = Math.max(50 / Number(getData.initial_width), 50 / Number(getData.initial_height))
      newcreatedElement.style.transform = "scale(" + scale_val + ")";
      getafterScale = newcreatedElement.getBoundingClientRect();
      if (getafterScale.width > 70 || getafterScale.height > 70) {
        scale_val = Math.min(50 / Number(getData.initial_width), 50 / Number(getData.initial_height))
        newcreatedElement.style.transform = "scale(" + scale_val + ")";
      }
    }
    // newcreatedElement = this.shapeService1.createHIDPIcanvs(50,50,10,newcreatedElement);
    this.canvasElement.beginPath();
    this.canvasElement.globalAlpha = getData.opacity;
    getData.annotation_data = getData.annotation_data.trim();
    var spaceSplit = getData.annotation_data.split(" ");

    var previous = { x: 0, y: 0 };
    var current = { x: 0, y: 0 };
    var a = 0;
    var last_mousex = this.coordinateX;
    var last_mousey = this.coordinateY;
    var mousex = 0;
    var mousey = 0;
    var cpx = 0;
    var cpy = 0;
    let cp1x = 0;
    let cp1y = 0;
    let cp2x = 0;
    let cp2y = 0;
    let cx = 0;
    let cy = 0;
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");
      for (var j = 0; j < hypenSplit.length; j++) {
        var colonSplit = hypenSplit[j].split(":");
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint" &&
          hypenSplit[0] != "drawRect" &&
          hypenSplit[0] != "controlpoint1" &&
          hypenSplit[0] != "controlpoint2" &&
          hypenSplit[0] != "endCurve"
        ) {
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var w = parseFloat(colonSplit[2]);
          var h = parseFloat(colonSplit[3]);
          switch (hypenSplit[0]) {
            case "move":
              if (elementId != 20) {
                if (
                  getData.toolbar_element_id >= 12 && Number(getData.initial_height) == 0 &&
                  getData.toolbar_element_id <= 20
                ) {
                  this.canvasElement.moveTo(
                    x - this.coordinateX,
                    y - this.coordinateY
                  );
                }
                else if (
                  getData.toolbar_element_id >= 12 && Number(getData.initial_height) != 0 &&
                  getData.toolbar_element_id <= 20 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16) {
                  this.canvasElement.moveTo(x, y
                  );
                }
                else {
                  console.log(x, y)
                  this.canvasElement.moveTo(x, y);
                }
                if (elementId == 13 && j == 1) {
                  previous.x = x - this.coordinateX;
                  previous.y = y - this.coordinateY;
                  a++;
                }
              }
              break;
            case "line":
              this.canvasElement.clearRect(
                0,
                0,
                newcreatedElement.width,
                newcreatedElement.height
              );
              if (elementId != 20) {
                if (
                  getData.toolbar_element_id >= 12 && Number(getData.initial_height) == 0 &&
                  getData.toolbar_element_id <= 20
                ) {
                  this.canvasElement.lineTo(
                    x - this.coordinateX,
                    y - this.coordinateY
                  );
                }
                else if (
                  getData.toolbar_element_id >= 12 && Number(getData.initial_height) != 0 &&
                  getData.toolbar_element_id <= 20 && getData.toolbar_element_id != 15 && getData.toolbar_element_id != 16) {
                  this.canvasElement.lineTo(x, y
                  );
                }
                else {
                  console.log(x, y)
                  this.canvasElement.lineTo(x, y);
                }
                // this.canvasElement.lineTo(x-this.coordinateX, y-this.coordinateY);
                if ((elementId == 13 && previous.x != 0 && previous.y != 0) && (spaceSplit.length - 1 == i) && (j == 1)) {
                  console.log(elementId);
                  current.x = x - this.coordinateX + 3;
                  current.y = y - this.coordinateY + 3;
                  var dx = current.x - previous.x;
                  var dy = current.y - previous.y;
                  var headlen = 15;
                  var angle = Math.atan2(dy, dx);
                  var length = Math.sqrt(dx * dx + dy * dy);
                  console.log(angle, dx, dy, current, previous)
                  this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height); //clear canvas
                  this.canvasElement.moveTo(current.x, current.y);
                  this.canvasElement.lineTo(
                    current.x - headlen * Math.cos(angle - Math.PI / 4),
                    current.y - headlen * Math.sin(angle - Math.PI / 4)
                  );
                  this.canvasElement.moveTo(current.x, current.y);
                  this.canvasElement.lineTo(
                    current.x - headlen * Math.cos(angle + Math.PI / 4),
                    current.y - headlen * Math.sin(angle + Math.PI / 4)
                  );
                  this.canvasElement.lineCap = "round";
                }
                else {
                  previous.x = x - this.coordinateX + 3;
                  previous.y = y - this.coordinateY + 3;
                }
              }
              break;
            case "ovalIn":
              if (elementId == 1 || elementId == 8) {
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.arc(
                  newcreatedElement.clientWidth / 2,
                  newcreatedElement.clientHeight / 2.3,
                  r,
                  0,
                  2 * Math.PI
                );
              } else if (elementId == 19) {
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.ellipse(
                  w / 2,
                  h / 2,
                  w / 2,
                  h / 2,
                  Math.PI * 1,
                  0,
                  2 * Math.PI
                );
              }
              break;
          }
        }
        else if (hypenSplit[0] == "controlpoint" || hypenSplit[0] == "curveEnd") {
          if (hypenSplit[0] == "controlpoint") {
            cpx = parseFloat(colonSplit[0]);
            cpy = parseFloat(colonSplit[1]);
          }
          if (hypenSplit[0] == "curveEnd") {
            var ex = parseFloat(colonSplit[0]);
            var ey = parseFloat(colonSplit[1]);

            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
          }
        }
        else if (hypenSplit[0] == "controlpoint1" || hypenSplit[0] == "controlpoint2" || hypenSplit[0] == "endCurve" && j == 1) {

          if (hypenSplit[0] == "controlpoint1") {
            cp1x = parseFloat(colonSplit[0]);
            cp1y = parseFloat(colonSplit[1]);
          }
          else if (hypenSplit[0] == "controlpoint2") {
            cp2x = parseFloat(colonSplit[0]);
            cp2y = parseFloat(colonSplit[1]);
          }
          else if (hypenSplit[0] == "endCurve") {
            cx = parseFloat(colonSplit[0]);
            cy = parseFloat(colonSplit[1]);
            this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);
            this.canvasElement.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, cx, cy);

          }
        }
        else if (hypenSplit[0] == "drawRect" && j == 1) {
          // let colonSplit = hypenSplit[j].split(":");
          let rectX = parseFloat(colonSplit[0]);
          let rectY = parseFloat(colonSplit[1]);
          let rectWidth = parseFloat(colonSplit[2]);
          let rectHeight = parseFloat(colonSplit[3]);
          this.canvasElement.clearRect(0, 0, rectWidth, rectHeight);
          this.canvasElement.rect(
            5,
            5,
            rectWidth,
            rectHeight);
          console.log(getData.line_width);
        }
        if ((elementId == 12 || elementId == 17 || elementId == 18) && (spaceSplit.length - 1 == i) && (j == 1)) {
          console.log(elementId);
          this.canvasElement.closePath();
        }
        if (
          elementId != 12 &&
          elementId != 14 &&
          elementId != 13 &&
          elementId != 15
        ) {
          var checkFill = getData.fill_color;
          this.canvasElement.fillStyle = this.checkStrokeColor1(getData.fill_color);
          this.canvasElement.fill();
        }
        // this.canvasElement.drawImage(newcreatedElement,0,0,50,50,0,0,10,50);
        // this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width);
        if (elementId == 15 || elementId == 16 || elementId == 13 || elementId == 14 && getData.line_width != 0 && getData.line_width / 5 < 3) {
          // this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width) + 2;
          this.canvasElement.lineWidth = 10;
        }
        else {
          this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width);
        }
        this.canvasElement.strokeStyle = this.checkStrokeColor1(getData.stroke_color);
        this.canvasElement.stroke();
      }
    }
  }

  drawMediaAnnotations() {

    // let isnegativeCoordinates = false;
    // let coordinateX = Number(this.propertiesannotationData.initial_position_x);
    // let coordinateY = Number(this.propertiesannotationData.initial_position_y);
    // if (coordinateX < 0 && coordinateY < 0) {
    //   // this.coordinateX = -this.coordinateX;
    //   // this.coordinateY = -this.coordinateY;
    //   isnegativeCoordinates = true;
    // }
    for (let i = 0; i < this.multiselectionList.length; i++) {
      this.combindSidebarDrawLogic(this.multiselectionList[i], 'mediaannotation' + i, 'mediaannotationLabel');
      //  unwanted
      // let resizeCheck = this.sidebarDrawCalculation(this.multiselectionList[i]);
      // this.shapeService1.formsheaderCanvas('mediaannotation' + i, resizeCheck, 'mediaannotationLabel', 'DocPage');
      // this.shapeService1.canvasToImageConvert('mediaannotation' + i, 'DocPage', resizeCheck);
      // this.shapeService1.getshapeDrawing(resizeCheck, isnegativeCoordinates, 'propertyCanvasPreview', 'annotationLabelPreview', 'DocPage')
    }
  }

  drawLinkAnnotations() {
    for (let i = 0; i < this.multiselectionList.length; i++) {
      this.combindSidebarDrawLogic(this.multiselectionList[i], 'linkannotation' + i, 'linkannotationLabel');
      // let resizeCheck = this.sidebarDrawCalculation(this.multiselectionList[i]);
      // this.shapeService1.formsheaderCanvas('linkannotation' + i, resizeCheck, 'linkannotationLabel', 'DocPage');
      // this.shapeService1.canvasToImageConvert('linkannotation' + i, 'DocPage', resizeCheck);
    }
  }


  async ngForRendred1() {

    let clone_model_fields = _.cloneDeep(this.modelFields);
    for (let k = 0; k < clone_model_fields.length; k++) {
      if (clone_model_fields[k].element_data.hasOwnProperty("shape")) {
        let elementuuid = clone_model_fields[k].element_uuid;
        let find_already_draw_shape_index = this.toolbarElements_view_svg.findIndex((draw) => draw.element_uuid == elementuuid);
        if (find_already_draw_shape_index == -1) {
          var shapeAttributes = clone_model_fields[k].element_data;
          if (shapeAttributes['shape'].is_stamp != 0) {
            console.log(shapeAttributes);
            let custome_shapes = new Object();
            custome_shapes = Object.assign({}, shapeAttributes['shape']);
            custome_shapes["line_width"] = shapeAttributes['line_width'];
            custome_shapes["toolbar_element_id"] = shapeAttributes['shape']['element_id'];
            console.log(shapeAttributes['shape']);
            console.log(custome_shapes);
            if(custome_shapes["element_id"]==0){
              custome_shapes["element_id"]=shapeAttributes.element_id; 
            }
            if(custome_shapes["toolbar_element_id"]==0){
              custome_shapes["toolbar_element_id"]=shapeAttributes.element_id;
            }
            // change svg view
            let clone_custome_shape_json = _.cloneDeep(custome_shapes);
            let get_path = this.documentPage.changesvgpath(clone_custome_shape_json, 'toolbar', this.pngFormat);
            // lines checking
            let lines = [11, 13, 14, 15, 16];

            if (lines.includes(Number(get_path.toolbar_element_id))) {
              get_path.linewidth = get_path.linewidth * 2;
            }
            // check resize shapes line width increase simple shapes only
            get_path = linewidthchanges(get_path);
            clone_model_fields[k].element_data["shape"] = get_path;
            this.toolbarElements_view_svg.push(clone_model_fields[k]);
          }
          else {
            this.toolbarElements_view_svg.push(clone_model_fields[k]);
          }
        }

      }
      else {

        let elementuuid = clone_model_fields[k].element_uuid;
        let find_already_draw_shape_index = this.toolbarElements_view_svg.findIndex((draw) => draw.element_uuid == elementuuid);
        if (find_already_draw_shape_index == -1) {
          this.toolbarElements_view_svg.push(clone_model_fields[k]);
        }
      }
    }
    console.log(this.toolbarElements_view_svg);
  }

  ngForRendredPreview(t, a) {
    console.log(t, a);
    if (a == 1) {
      this.formsheaderCanvas("propertyCanvasPreview", this.propertiesannotationData, 'annotationLabelPreview');
    }
  }

  formsheaderCanvas2(getData, fullData, uuid) {

    console.log(getData, fullData, uuid);
    this.coordinateX = getData.initial_position_x;
    this.coordinateY = getData.initial_position_y;
    if (this.coordinateX < 0 && this.coordinateY < 0) {
      this.coordinateX = -this.coordinateX;
      this.coordinateY = -this.coordinateY;
    }
    var elementId = fullData.element_id;
    this.cdRef.detectChanges();
    var newcreatedElement: any = document.getElementById(uuid);
    console.log(newcreatedElement);
    this.transparentBorder(newcreatedElement);
    if (elementId < 12) {
      newcreatedElement.setAttribute("width", "50");
      newcreatedElement.setAttribute("height", "35");
      newcreatedElement.style.height = "35px";
      newcreatedElement.style.marginTop = "4px";
    }
    // newcreatedElement.style.opacity = getData.opacity;
    if (getData.initial_rotation == undefined) {
      newcreatedElement.style.transform = "rotate(" + 0 + "deg)";
    } else if (getData.initial_rotation != undefined) {
      newcreatedElement.style.transform =
        "rotate(" + getData.initial_rotation + "deg)";
    }
    newcreatedElement.setAttribute("customefooterattribute", "1");
    if (getData.toolbar_element_id == 1 || getData.toolbar_element_id == 8) {
      newcreatedElement.style.marginTop = "8px";
    }
    this.canvasElement = newcreatedElement.getContext("2d");
    if (elementId >= 12) {
      let scaleValueX = 0.5;
      let scaleValueY = 0.5;
      let newwidth = 50;
      let newheight = 35;
      if (getData.initial_width > 50 || getData.initial_height > 50) {
        if ((getData.initial_width > 100 || getData.initial_height > 100) && (getData.initial_width < 200 && getData.initial_height < 200)) {
          console.log('width 100 +');
          newwidth = getData.initial_width * 0.3;
          newheight = getData.initial_height * 0.3;
          scaleValueX = 0.3;
          scaleValueY = 0.2;
        }
        else if (getData.initial_width > 200 || getData.initial_height > 200) {
          console.log('width 200 +');
          newwidth = getData.initial_width * 0.2;
          newheight = getData.initial_height * 0.2;
          scaleValueX = 0.2;
          scaleValueY = 0.1;
        }
        else {
          console.log('width 100 below');
          newwidth = getData.initial_width * 0.5;
          newheight = getData.initial_height * 0.5;
          scaleValueX = 0.5;
          scaleValueY = 0.4;
          if (newwidth > newheight) {
            scaleValueX = 0.5;
            scaleValueY = 0.4;
          }
          else if (newwidth < newheight) {
            scaleValueX = 0.5;
            scaleValueY = 0.3;
          }
          if (newwidth < 10 && newheight < 10) {
            newwidth = newwidth + 20;
            newheight = newheight + 20;
            scaleValueX = 0.6;
            scaleValueY = 0.5;
          }
          else if (newwidth < 20 && newheight < 20) {
            newwidth = newwidth + 10;
            newheight = newheight + 10;
            scaleValueX = 0.5;
            scaleValueY = 0.4;
          }
        }
      }
      else {
        console.log('width 100 below');
        newwidth = getData.initial_width * 0.5;
        newheight = getData.initial_height * 0.5;
        scaleValueX = 0.5;
        scaleValueY = 0.4;
        if (newwidth < 10 && newheight < 10) {
          newwidth = newwidth + 20;
          newheight = newheight + 20;
          scaleValueX = 0.6;
          scaleValueY = 0.5;
        }
        else if (newwidth < 20 && newheight < 20) {
          newwidth = newwidth + 10;
          newheight = newheight + 10;
          scaleValueX = 0.5;
          scaleValueY = 0.4;
        }
      }
      console.log(getData.initial_height, getData.initial_width, scaleValueX, scaleValueY, newwidth, newheight);
      newwidth = newwidth + 6;
      newheight = newheight + 6;
      this.canvasElement.canvas.width = newwidth > 50 ? 48 : newwidth + 2;
      this.canvasElement.canvas.height = newheight > 35 ? 35 : newheight + 2;
      this.canvasElement.scale(scaleValueX, scaleValueY);
      console.log(getData.line_width);
      this.canvasElement.textAlign = "center";
    }
    // if (getData.annotation_label != "") {
    //   this.annotationLabelBackground(getData, id, labelid);
    // }
    //   const img = new Image()
    //   img.src = this.imgUrl;
    //   img.onload = () => {
    //   this.canvasElement.drawImage(img, 0, 0,600,450);
    //   }

    this.canvasElement.beginPath();
    this.canvasElement.globalAlpha = fullData.opacity;
    getData.annotation_data = getData.annotation_data.trim();
    var spaceSplit = getData.annotation_data.split(" ");

    var previous = { x: 0, y: 0 };
    var current = { x: 0, y: 0 };
    var a = 0;
    var last_mousex = this.coordinateX;
    var last_mousey = this.coordinateY;
    var mousex = 0;
    var mousey = 0;
    var cpx = 0;
    var cpy = 0;
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");
      for (var j = 0; j < hypenSplit.length; j++) {
        var colonSplit = hypenSplit[j].split(":");
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint" &&
          hypenSplit[0] != "drawRect"
        ) {
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var w = parseFloat(colonSplit[2]);
          var h = parseFloat(colonSplit[3]);
          switch (hypenSplit[0]) {
            case "move":
              if (elementId != 20) {
                if (
                  elementId >= 12 &&
                  elementId <= 20
                ) {
                  this.canvasElement.moveTo(
                    x - this.coordinateX + 3,
                    y - this.coordinateY + 3
                  );
                }

                else {
                  this.canvasElement.moveTo(x, y);
                }
                if (elementId == 13 && j == 1) {
                  previous.x = x - this.coordinateX + 3;
                  previous.y = y - this.coordinateY + 3;
                  a++;
                }
              }
              break;
            case "line":
              this.canvasElement.clearRect(
                0,
                0,
                newcreatedElement.width,
                newcreatedElement.height
              );
              if (elementId != 20) {
                if (
                  elementId >= 12 &&
                  elementId <= 20
                ) {
                  this.canvasElement.lineTo(
                    x - this.coordinateX + 3,
                    y - this.coordinateY + 3
                  );
                }
                else {
                  this.canvasElement.lineTo(x, y);
                }
                // this.canvasElement.lineTo(x-this.coordinateX, y-this.coordinateY);
                if ((elementId == 13 && previous.x != 0 && previous.y != 0) && (spaceSplit.length - 1 == i) && (j == 1)) {
                  console.log(elementId);
                  current.x = x - this.coordinateX + 3;
                  current.y = y - this.coordinateY + 3;
                  var dx = current.x - previous.x;
                  var dy = current.y - previous.y;
                  var headlen = 15;
                  var angle = Math.atan2(dy, dx);
                  var length = Math.sqrt(dx * dx + dy * dy);
                  console.log(angle, dx, dy, current, previous)
                  this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height); //clear canvas
                  this.canvasElement.moveTo(current.x, current.y);
                  this.canvasElement.lineTo(
                    current.x - headlen * Math.cos(angle - Math.PI / 4),
                    current.y - headlen * Math.sin(angle - Math.PI / 4)
                  );
                  this.canvasElement.moveTo(current.x, current.y);
                  this.canvasElement.lineTo(
                    current.x - headlen * Math.cos(angle + Math.PI / 4),
                    current.y - headlen * Math.sin(angle + Math.PI / 4)
                  );
                  this.canvasElement.lineCap = "round";
                }
                else {
                  previous.x = x - this.coordinateX + 3;
                  previous.y = y - this.coordinateY + 3;
                }
              }
              break;
            case "ovalIn":
              if (elementId == 1 || elementId == 8) {
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.arc(
                  newcreatedElement.clientWidth / 2,
                  newcreatedElement.clientHeight / 2.3,
                  r,
                  0,
                  2 * Math.PI
                );
              } else if (elementId == 19) {
                var r = (w * w) / (8 * h) + h / 2;
                this.canvasElement.ellipse(
                  w / 2 + 3,
                  h / 2 + 3,
                  w / 2,
                  h / 2,
                  Math.PI * 1,
                  0,
                  2 * Math.PI
                );
              }
              break;
          }
        }
        else if (hypenSplit[0] == "controlpoint" || hypenSplit[0] == "curveEnd") {
          if (hypenSplit[0] == "controlpoint") {
            cpx = parseFloat(colonSplit[0]);
            cpy = parseFloat(colonSplit[1]);
          }
          if (hypenSplit[0] == "curveEnd") {
            var ex = parseFloat(colonSplit[0]);
            var ey = parseFloat(colonSplit[1]);

            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
          }
        }
        else if (hypenSplit[0] == "drawRect" && j == 1) {
          // let colonSplit = hypenSplit[j].split(":");
          let rectX = parseFloat(colonSplit[0]);
          let rectY = parseFloat(colonSplit[1]);
          let rectWidth = parseFloat(colonSplit[2]);
          let rectHeight = parseFloat(colonSplit[3]);
          this.canvasElement.clearRect(0, 0, rectWidth, rectHeight);
          this.canvasElement.rect(
            getData.initial_position_x - rectX + 3,
            getData.initial_position_y - rectY + 3,
            rectWidth,
            rectHeight);
          console.log(getData.line_width);
        }

        if (
          elementId != 12 &&
          elementId != 14 &&
          elementId != 13 &&
          elementId != 15
        ) {
          var checkFill = fullData.fill_color;

          if (fullData.fill_color != "clear") {
            this.canvasElement.fillStyle = this.checkStrokeColor1(getData.fill_color);
            this.canvasElement.fill();
          }
        }
        if ((elementId == 12 || elementId == 17 || elementId == 18) && (spaceSplit.length - 1 == i) && (j == 1)) {
          console.log(elementId);
          this.canvasElement.closePath();
        }
        // this.canvasElement.drawImage(newcreatedElement,0,0,50,50,0,0,10,50);

        // this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width);
        if (fullData.line_width / 2 < 1) {
          this.canvasElement.lineWidth = 1;
        }
        else {
          this.canvasElement.lineWidth = fullData.line_width / 2;
        }
        if (elementId == 15 || elementId == 16 && fullData.line_width != 0 && fullData.line_width < 4) {
          this.canvasElement.lineWidth = fullData.line_width + 2;
        }


        this.canvasElement.strokeStyle = this.checkStrokeColor1(getData.stroke_color);
        this.canvasElement.stroke();
      }
    }
  }

  propertiesShapeDrawApply(getData) {
    // var propertyElement = document.getElementById("propertyCanvasPreview");
    // if (propertyElement != null && propertyElement.hasChildNodes()!=null) {
    //   propertyElement.removeChild(propertyElement.childNodes[0]);
    // }
    this.propertiesShapeDraw(getData);
  }

  degree: any = 0;

  // shapebgchangerotate() {
  //   var bgChange = document.getElementById(this.getId);
  //   bgChange.style.background = "#A7A9A3";
  //   console.log(this.propertiesannotationData);
  // }

  // rotateAction() {
  //   console.log("clicked");
  //   this.degree = this.degree + 90;
  //   var rotateImage = document.getElementById(this.getId);
  //   rotateImage.style.transform = "rotate(" + this.degree + "deg)";
  //   if (this.degree == 360) {
  //     this.degree = 0;
  //   }
  //   //Jose Rotate
  //   var initial_rotate = this.currentSelectedAnnotationData.initial_rotation != "" ? (+this.currentSelectedAnnotationData.initial_rotation) : 0
  //   initial_rotate = (initial_rotate * 180) / Math.PI
  //   let rotate_angle = ((initial_rotate + 45) * Math.PI) / 180
  //   // for (var i = 0; i < this.layerDatas.length; i++) {
  //   //   var annotation_selected = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
  //   //   annotation_selected
  //   // }
  //   rotateImage.remove();
  //   console.log("rotate_angle:" + initial_rotate + "then" + rotate_angle);
  //   this.currentSelectedAnnotationData.initial_rotation = rotate_angle
  //   this.getshapeDrawing(this.currentSelectedAnnotationData, false);
  // }

  rotatesiliderValue: number = 0;

  rotateActionHit() {
    this.createDocumentStore.enablerotateButtons = true;
    this.createDocumentStore_1.rotate_deg_input = null;
    this.rotateresizeButtonHandles('rotate');
    if (this.propertiesannotationData['initial_rotation'] != undefined && this.propertiesannotationData['initial_rotation'] != 0 && this.propertiesannotationData['initial_rotation'] != "0" && this.propertiesannotationData['initial_rotation'] != "") {
      let radians = Number(this.propertiesannotationData['initial_rotation']);
      let convert_degree = radians * (180 / Math.PI);
      this.rotatesiliderValue = convert_degree;
    }
    else {
      this.rotatesiliderValue = 0;
    }
    // if (this.multipleSelectOn == false) {
    //   console.log(_.cloneDeep(this.propertiesannotationData));
    //   let getElementRemove = document.getElementById(this.propertiesannotationData["annotation_id"]);
    //   let getElementRemove1 = document.getElementById(this.propertiesannotationData["annotation_label"]);
    //   if (getElementRemove1 != null) {
    //     getElementRemove1.remove();
    //   }
    //   let currentelementWidth = getElementRemove.getBoundingClientRect();
    //   console.log(currentelementWidth);
    //   let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
    //   let annotationData = this.propertiesannotationData["annotation_data"];
    //   let rotatevalues = this.rotateByCoordinates(currentelementWidth.left, currentelementWidth.top, currentelementWidth.width, currentelementWidth.height, 45)
    //   let rotatevaluesReverse = this.rotateByCoordinates(currentelementWidth.width, currentelementWidth.height, currentelementWidth.top, currentelementWidth.left, 45)

    //   // if(rotatevalues[0] > 0 && rotatevalues[1] > 0 && rotatevaluesReverse[0] > 0 && rotatevaluesReverse[1] > 0 && rotatevalues[0] < this.realWidth && rotatevalues[1] < this.realHeight && rotatevaluesReverse[0] < this.realWidth && rotatevaluesReverse[1] < this.realHeight)
    //   // {
    //   if (Number(this.propertiesannotationData["toolbar_element_id"]) < 12 || Number(this.propertiesannotationData["toolbar_element_id"]) == 19 || Number(this.propertiesannotationData["toolbar_element_id"]) == 20) {
    //     let rotate_angle = this.propertiesannotationData["initial_rotation"] != undefined && this.propertiesannotationData["initial_rotation"] != "" ? Number(this.propertiesannotationData["initial_rotation"]) : 0
    //     rotate_angle = Math.floor((rotate_angle * 180) / 3.14)
    //     var radians = (Math.PI / 180) * (rotate_angle + 45);
    //     radians = Number(this.propertiesannotationData["toolbar_element_id"]) == 2 ? (Math.PI / 180) * (rotate_angle + 22.5) : radians;
    //     this.propertiesannotationData["initial_rotation"] = radians;
    //   } else {
    //     annotationData = this.rotateShape(annotationData, this.propertiesannotationData["toolbar_element_id"], 45)
    //     this.propertiesannotationData["annotation_data"] = annotationData;
    //   }
    //   let getShapeStringWidthAB = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
    //   this.coordinateX = Number(this.propertiesannotationData["initial_position_x"]);
    //   this.coordinateY = Number(this.propertiesannotationData["initial_position_y"]);
    //   this.dbxposition = Number(this.propertiesannotationData["initial_position_x"])
    //   this.dbyposition = Number(this.propertiesannotationData["initial_position_y"])

    //   getElementRemove.remove();
    //   // this.getshapeDrawing(this.propertiesannotationData, false);
    //   this.isforResize = true;
    //   this.getActiveLayerId();
    //   this.isforResize = false;
    //   // }
    // }
  }
  rotate_angle: any = 0;
  formatLabel(value: number) {
    console.log("tast", value)
    if (Number(this.propertiesannotationData["toolbar_element_id"]) < 12 || Number(this.propertiesannotationData["toolbar_element_id"]) == 19 || Number(this.propertiesannotationData["toolbar_element_id"]) == 20) {
      this.rotate_angle = this.propertiesannotationData["initial_rotation"] != undefined && this.propertiesannotationData["initial_rotation"] != "" ? Number(this.propertiesannotationData["initial_rotation"]) : 0
    } else {
      this.rotate_angle = 0
    }
  }

  rotate_angle_start: any = 0;

  rotate_degree_apply(value: number, click_action: boolean) {
    if (this.propertiesannotationData["toolbar_element_id"] > 11) {
      value = value / (Math.PI / 22.5);
    }
    this.rotateActionsliderleaveSVG(value, click_action);
  }

  rotateActionsliderleaveSVG(value: number, click_action?: boolean) {
    console.log(value);
    let getrotateelement = document.getElementById(this.propertiesannotationData['annotation_id']);
    let get_label_Element = document.getElementById("label" + this.propertiesannotationData['annotation_id']);
    if (this.propertiesannotationData["toolbar_element_id"] > 11) {
      // freehand shape only opposite dirction is rotated. so we have to change negative to positive and positive to negative it will rotate correct way.
      value = -(value);
    }

    if (click_action == true && this.propertiesannotationData["toolbar_element_id"] < 12) {
      let rotate_angle = this.propertiesannotationData["initial_rotation"] != undefined && this.propertiesannotationData["initial_rotation"] != "" ? Number(this.propertiesannotationData["initial_rotation"]) : 0
      rotate_angle = Math.floor((rotate_angle * 180) / 3.14);
      if (rotate_angle > 360) {
        rotate_angle = 360;
      }
      else if (rotate_angle < -360) {
        rotate_angle = -360;
      }

      console.log('rotate_angle', rotate_angle);
      value = value + rotate_angle;
      if (value > 360) {
        value = value - 360;
      }
      else if (value < -360) {
        value = value + 360;
      }
    }
    if (getrotateelement != null) {
      if (this.rotate_angle_start != value || click_action == true) {
        this.rotate_angle_start = value;
        if (this.propertiesannotationData["toolbar_element_id"] > 11) {
          let radians = (Math.PI / 22.5) * (value);
          // radians = radians * 3;
          let radians_convert_2_deci = Math.round(radians * 100) / 100;
          console.log(radians, radians_convert_2_deci)
          radians = radians_convert_2_deci;
          this.changefreehandshaperotation(radians);
          let rotatevalue = 'matrix(' + Math.cos(radians) + ',' + Math.sin(radians) + ',' + -(Math.sin(radians)) + ',' + Math.cos(radians) + ',' + 0 + ',' + 0 + ')';
        }
        else {
          let radians = (Math.PI / 180) * (value);
          let radians_convert_2_deci = Math.round(radians * 100) / 100;
          console.log(radians, radians_convert_2_deci)
          radians = radians_convert_2_deci;
          let rotatevalue = 'matrix(' + Math.cos(radians) + ',' + Math.sin(radians) + ',' + -(Math.sin(radians)) + ',' + Math.cos(radians) + ',' + 0 + ',' + 0 + ')';
          getrotateelement.style.transform = rotatevalue;
          this.propertiesannotationData["initial_rotation"] = radians;
          console.log(this.propertiesannotationData["initial_rotation"]);
          if (get_label_Element != null) {
            get_label_Element.style.transform = rotatevalue;
          }
        }
      }
    }
  }

  rotateActionsliderleave = (value: number) => {
    console.log("rotateActionsliderleave", value, this.rotate_angle_start)

    if (this.rotate_angle_start != value) {
      this.rotate_angle_start = value;
      if (this.propertiesannotationData.toolbar_element_id > 11) {
        var value_to_send = (Math.PI / 22.5) * (value);
        this.rotateActionsliderHit(value_to_send)
      } else {
        this.rotateActionsliderHit(value)
      }
    }
  }
  rotateActionsliderHit(value) {

    console.log("before rotate--", this.propertiesannotationData["annotation_data"], value)
    if (this.multipleSelectOn == false) {
      let rotateValue = 0;
      console.log(this.propertiesannotationData);
      let backupproperytData = _.cloneDeep(this.propertiesannotationData);
      let getElementRemove = document.getElementById(this.propertiesannotationData["annotation_id"]);
      // let getElementRemove1 = document.getElementById(this.propertiesannotationData["annotation_label"]);
      // if (getElementRemove1 != null) {
      //   getElementRemove1.remove();
      // }

      //remove label from annotation
      let annotationLabelClear = document.getElementById('label' + this.propertiesannotationData["annotation_id"]);
      if (annotationLabelClear != null) {
        annotationLabelClear.remove();
      }
      let currentelementWidth = getElementRemove.getBoundingClientRect();
      console.log(currentelementWidth);
      let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      let annotationData = this.propertiesannotationData["annotation_data"];

      // if(rotatevalues[0] > 0 && rotatevalues[1] > 0 && rotatevaluesReverse[0] > 0 && rotatevaluesReverse[1] > 0 && rotatevalues[0] < this.realWidth && rotatevalues[1] < this.realHeight && rotatevaluesReverse[0] < this.realWidth && rotatevaluesReverse[1] < this.realHeight)
      // {
      if (Number(this.propertiesannotationData["toolbar_element_id"]) < 12) {
        let rotate_angle = this.propertiesannotationData["initial_rotation"] != undefined && this.propertiesannotationData["initial_rotation"] != "" ? Number(this.propertiesannotationData["initial_rotation"]) : 0
        rotate_angle = Math.floor((rotate_angle * 180) / 3.14)
        var radians = 0;
        // if(value>0){
        //   radians = (Math.PI / 180) * (value);
        // }else{

        // }
        if (Number(this.propertiesannotationData["toolbar_element_id"]) == 19 || Number(this.propertiesannotationData["toolbar_element_id"]) == 20) {
          radians = (Math.PI / 25) * (value);
        } else {
          radians = (Math.PI / 180) * (value);
        }

        // radians = Number(this.propertiesannotationData["toolbar_element_id"]) == 2 ? (Math.PI / 180) * (rotate_angle + 22.5) : radians;
        rotateValue = radians
        this.propertiesannotationData["initial_rotation"] = radians;
        console.log('radius', radians);
      }
      else if (Number(this.propertiesannotationData["toolbar_element_id"]) == 19 || Number(this.propertiesannotationData["toolbar_element_id"]) == 20) {
        let cloneRotateAnnotation = _.cloneDeep(this.propertiesannotationData);
        let rotate_after_change_string = cloneRotateAnnotation.annotation_data;
        if (this.propertiesannotationData.annotation_data.includes('ovalIn') || this.propertiesannotationData.annotation_data.includes('drawRect')) {
          //sent x y position to below method and made all x and y as 0 to fix P3X-1226
          rotate_after_change_string = this.repointStringForRectandElipse(cloneRotateAnnotation.annotation_data, cloneRotateAnnotation.toolbar_element_id, cloneRotateAnnotation.initial_position_x, cloneRotateAnnotation.initial_position_y)
          cloneRotateAnnotation.initial_position_x = 0;
          this.propertiesannotationData.initial_position_x = 0;
          cloneRotateAnnotation.initial_position_y = 0;
          this.propertiesannotationData.initial_position_y = 0;
        }
        annotationData = this.rotateShape(rotate_after_change_string, this.propertiesannotationData["toolbar_element_id"], value)
        console.log('rotation_inprogress', annotationData);
        this.propertiesannotationData["annotation_data"] = annotationData;
      }
      else {
        // if(value>0){
        //   annotationData = this.rotateShape(annotationData, this.propertiesannotationData["toolbar_element_id"], value)
        // }else{
        annotationData = this.rotateShape(annotationData, this.propertiesannotationData["toolbar_element_id"], value)
        // }
        rotateValue = value
        this.propertiesannotationData["annotation_data"] = annotationData;
      }

      let centerX = (getElementRemove.offsetLeft) + (getElementRemove.offsetWidth / 2)
      let centerY = (getElementRemove.offsetTop) + (getElementRemove.offsetHeight / 2)

      let rotatevaluesxy = this.rotateByCoordinates(centerX, centerY, getElementRemove.offsetLeft, getElementRemove.offsetTop, rotateValue)
      let rotatevalueswh = this.rotateByCoordinates(centerX, centerY, (getElementRemove.offsetLeft + getElementRemove.offsetWidth), (getElementRemove.offsetTop + getElementRemove.offsetHeight), rotateValue)

      let getPixels = this.getPixelsByAngle(getElementRemove.offsetLeft, getElementRemove.offsetTop, getElementRemove.offsetWidth, getElementRemove.offsetHeight, rotateValue)
      let newCordinates = getPixels.coordinates
      console.log("rotatevaluesxy", getPixels, getElementRemove.offsetLeft, getElementRemove.offsetTop, (getElementRemove.offsetLeft + getElementRemove.offsetWidth), (getElementRemove.offsetTop + getElementRemove.offsetHeight), this.realWidth, "this.realHeight", this.realHeight)

      if (newCordinates.top <= (getElementRemove.offsetWidth / 2.5) || newCordinates.left <= (getElementRemove.offsetHeight / 2.5) || (newCordinates.right + (getElementRemove.offsetWidth / 2.5)) >= this.realWidth || (newCordinates.bottom + (getElementRemove.offsetHeight / 2.5)) >= this.realHeight) {
        this.propertiesannotationData = backupproperytData
      }
      let getShapeStringWidthAB = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      this.coordinateX = Number(this.propertiesannotationData["initial_position_x"]);
      this.coordinateY = Number(this.propertiesannotationData["initial_position_y"]);
      this.dbxposition = Number(this.propertiesannotationData["initial_position_x"])
      this.dbyposition = Number(this.propertiesannotationData["initial_position_y"])

      getElementRemove.remove();
      // this.getshapeDrawing(this.propertiesannotationData, false);
      // this.isforResize = true;
      this.getActiveLayerId();
      // this.isforResize = false;
      // }
    }
    console.log("after rotate--", this.propertiesannotationData["annotation_data"])
    return value;
  }

  changefreehandshaperotation(value: number) {
    if (Number(this.propertiesannotationData["toolbar_element_id"]) < 19 && Number(this.propertiesannotationData["toolbar_element_id"]) > 11) {
      let annotationData = this.propertiesannotationData["annotation_data"];
      annotationData = this.rotateShape(annotationData, this.propertiesannotationData["toolbar_element_id"], value)
      this.propertiesannotationData["annotation_data"] = annotationData;
      //svg path change action below code
      this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
    }
    else if (Number(this.propertiesannotationData["toolbar_element_id"]) == 19 || Number(this.propertiesannotationData["toolbar_element_id"]) == 20) {
      let cloneRotateAnnotation = _.cloneDeep(this.propertiesannotationData);
      let rotate_after_change_string = cloneRotateAnnotation.annotation_data;
      if (this.propertiesannotationData.annotation_data.includes('ovalIn') || this.propertiesannotationData.annotation_data.includes('drawRect')) {
        //sent x y position to below method and made all x and y as 0 to fix P3X-1226
        rotate_after_change_string = this.repointStringForRectandElipse(cloneRotateAnnotation.annotation_data, cloneRotateAnnotation.toolbar_element_id, cloneRotateAnnotation.initial_position_x, cloneRotateAnnotation.initial_position_y)
        cloneRotateAnnotation.initial_position_x = 0;
        this.propertiesannotationData.initial_position_x = 0;
        cloneRotateAnnotation.initial_position_y = 0;
        this.propertiesannotationData.initial_position_y = 0;
      }
      let annotationData = this.rotateShape(rotate_after_change_string, this.propertiesannotationData["toolbar_element_id"], value)
      console.log('rotation_inprogress', annotationData);
      this.propertiesannotationData["annotation_data"] = annotationData;
      //svg path change action below code
      this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
    }
  }

  getPixelsByAngle(x, y, width, height, angle) {
    // var bounds = [
    //    //upper left
    //    [x + (halfWidth) * Math.cos(angle) - (halfHeight) * Math.sin(angle) + halfWidth, y + (halfHeight) * Math.cos(angle) + (halfWidth) * Math.sin(angle) + halfHeight],
    //    //upper right
    //    [x - (halfWidth) * Math.cos(angle) - (halfHeight) * Math.sin(angle) + halfWidth, y + (halfHeight) * Math.cos(angle) - (halfWidth) * Math.sin(angle) + halfHeight],
    //    //bottom right
    //    [x - (halfWidth) * Math.cos(angle) + (halfHeight) * Math.sin(angle) + halfWidth, y - (halfHeight) * Math.cos(angle) - (halfWidth) * Math.sin(angle) + halfHeight],
    //    //bottom left
    //    [x + (halfWidth) * Math.cos(angle) + (halfHeight) * Math.sin(angle) + halfWidth, y - (halfHeight) * Math.cos(angle) + (halfWidth) * Math.sin(angle) + halfHeight]
    // ];
    // return bounds;
    var radians = angle * Math.PI / 180;
    let xVals = [x + width / 2 + width / -2 * Math.cos(radians) - height / -2 * Math.sin(radians), x + width / 2 + width / 2 * Math.cos(radians) - height / -2 * Math.sin(radians), x + width / 2 + width / 2 * Math.cos(radians) - height / 2 * Math.sin(radians), x + width / 2 + width / -2 * Math.cos(radians) - height / 2 * Math.sin(radians)]
    let yVals = [y + height / 2 + width / -2 * Math.sin(radians) + height / -2 * Math.cos(radians), y + height / 2 + width / 2 * Math.sin(radians) + height / -2 * Math.cos(radians), y + height / 2 + width / 2 * Math.sin(radians) + height / 2 * Math.cos(radians), y + height / 2 + width / -2 * Math.sin(radians) + height / 2 * Math.cos(radians)]
    xVals.sort((a, b) => a - b)
    yVals.sort((a, b) => a - b)
    return {
      "coordinates": { "top": yVals[0], "left": xVals[0], "bottom": yVals[3], "right": xVals[3] },
      "positions": [
        //upper left
        [x + width / 2 + width / -2 * Math.cos(radians) - height / -2 * Math.sin(radians), y + height / 2 + width / -2 * Math.sin(radians) + height / -2 * Math.cos(radians)],
        //upper right
        [x + width / 2 + width / 2 * Math.cos(radians) - height / -2 * Math.sin(radians), y + height / 2 + width / 2 * Math.sin(radians) + height / -2 * Math.cos(radians)],
        //bottom right
        [x + width / 2 + width / 2 * Math.cos(radians) - height / 2 * Math.sin(radians), y + height / 2 + width / 2 * Math.sin(radians) + height / 2 * Math.cos(radians)],
        //bottom left
        [x + width / 2 + width / -2 * Math.cos(radians) - height / 2 * Math.sin(radians), y + height / 2 + width / -2 * Math.sin(radians) + height / 2 * Math.cos(radians)],
      ]
    };
  }

  rotationSucceed: boolean = false;

  async rotateResizeupdateAPI() {
    this.resizeMove = false;
    this.resizedone=true
    let start = this.functionstarttime('rotateresize');
    this.rotate_angle_start = 0
    this.show = true;
    // this.createDocumentStore.enableresizeButtons = false;
    this.rotateandresize = false;
    this.dataService1.changeRotateandResizeMessage(this.rotateandresize);
    this.resizebutton = false;
    this.currentSelectedAnnotationData = this.propertiesannotationData;
    let filterLayerId = this.propertiesannotationData["layer_id"];
    let findLayerId = this.layerDatas.findIndex((ad) => ad.layer_id === filterLayerId);
    console.log(this.repoint_AnnotationStore);
    if (findLayerId > -1) {
      let filterAnnotation = this.layerDatas[findLayerId].annotations.findIndex((annot) => annot.annotation_id === this.propertiesannotationData["annotation_id"]);
      if (filterAnnotation > -1) {
        if (this.createDocumentStore.enablerepointButtons == true) {
          if (this.propertiesannotationData["toolbar_element_id"] == 13) {
            let annotation_string = this.propertiesannotationData["annotation_data"];
            let arrowString = this.createArrow();
            annotation_string = annotation_string.trim();
            annotation_string = annotation_string + arrowString;
            this.propertiesannotationData["annotation_data"] = annotation_string;
          }
          this.propertiesannotationData.initial_position_x = 0;
          this.propertiesannotationData.initial_position_y = 0;
          this.propertiesannotationData.initial_width = 0;
          this.propertiesannotationData.initial_height = 0;
        }
        this.createDocumentStore.enableresizeButtons = false;
        if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11 &&
          Number(this.propertiesannotationData["initial_width"]) != 0 && Number(this.propertiesannotationData["initial_height"]) != 0) {
          this.propertiesannotationData["annotation_url"] = { "text_resize": "true" };
        }
        this.layerDatas[findLayerId].annotations[filterAnnotation] = this.propertiesannotationData;
        let generateCloneLayer = _.cloneDeep(this.layerDatas);
        console.log(this.resizeAnnotationsStore);
        return new Promise((resolve, reject) => {
          console.log("Inside the promise");
          this.functionendtime('rotateresize', start);
          let api_start = this.functionstarttime('rotateresize api');
          this.documentService.annotationUpdateForm1(generateCloneLayer, this.propertiesannotationData.annotation_id, filterLayerId, 'property').subscribe(async (response) => {
            console.log(response);
            
            if (response["response_code"] == 200) {
              if(this.properties == true){
                this.single_view_Preview_svg_drawing(this.propertiesannotationData)
              }
              this.functionendtime('rotateresize api', api_start);
              this.rotateresizeAnnotationStore = [];
              // should be empty single selection stored array
              this.createDocumentStore.single_select_annotation = [];
              // disable drag scroll
              this.createDocumentStore.disable_drag_scroll = false;
              if (this.createDocumentStore.enablerepointButtons == true) {
                this.stringPathArray = [];
                this.createDocumentStore.enablerepointButtons = false;
                // clear the temporary drawing svg 
                this.removesvgAttribute("repointSVG");
                // clear the temporary drawing svg circles 
                this.removeredCirclesSVG();
                // replace the points to SVG current shape
                await this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
                this.removeMoveEvents();
                // remove the annotation click disabled function.
                this.annotationselectEnableDisable('remove');
                this.show = false;
              }
              else if (this.createDocumentStore.enablerotateButtons == true) {
                this.createDocumentStore.enablerotateButtons = false;
                this.createDocumentStore_1.rotate_deg_input = null;
                let getrotateelement = document.getElementById(this.propertiesannotationData['annotation_id']);
                if (getrotateelement != null) {
                  getrotateelement.classList.add('svg-block');
                }
                this.show = false;
              }
              else {
                this.removeMoveEvents();
                // this.annotationClear(this.propertiesannotationData);
                this.annotationselectEnableDisable('remove');
                // this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]);
                // this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]);
                // this.propertiesannotationData = this.annotation_data_change(this.propertiesannotationData);
                // this.getshapeDrawing(this.propertiesannotationData, false);
                // await this.replacecurrentChangeInSVG(this.propertiesannotationData);
                this.show = false;
              }
              console.log(this.createDocumentStore.enableresizeButtons);
              if(this.propertiesannotationData.toolbar_element_id == 15){
                let getAllCanvas = document.querySelectorAll("svg.svg-block");
                getAllCanvas.forEach((data) => {
                  data.classList.remove('svg-block');
                });
                let get_current_element = document.getElementById(this.getId);
                this.colorBorderSVG(get_current_element);
              }
              // for attributes changing issue datacopy values assinged
              this.propertiesannotationDataCopy["initial_width"] = this.propertiesannotationData["initial_width"];
              this.propertiesannotationDataCopy["initial_height"] = this.propertiesannotationData["initial_height"];
              this.propertiesannotationDataCopy["initial_rotation"] = this.propertiesannotationData["initial_rotation"];
              this.propertiesannotationDataCopy["annotation_data"] = this.propertiesannotationData["annotation_data"];
              this.propertiesannotationDataCopy["initial_position_x"] = this.propertiesannotationData["initial_position_x"];
              this.propertiesannotationDataCopy["initial_position_y"] = this.propertiesannotationData["initial_position_y"];
              resolve('done');
            }
            else {
              this.resizedone=false
              this.errorMessage();
              resolve('done');
            }
            this.resizeAnnotationsStore = [];
          });
        });
      }
    }
    // if (this.degree != this.propertiesannotationData["initial_rotation"]) {
    //   this.rotationSucceed = true;
    //   var removeselectedRotateShape = document.getElementById(this.getId);
    //   removeselectedRotateShape.remove();
    //   this.rotateshapeDrawing(this.propertiesannotationData);
    // }
  }

  // async rotateResizeupdateAPI() {
  //   this.rotate_angle_start = 0
  //   this.show = true;
  //   // this.createDocumentStore.enableresizeButtons = false;
  //   this.rotateandresize = false;
  //   this.dataService1.changeRotateandResizeMessage(this.rotateandresize);
  //   this.resizebutton = false;
  //   this.currentSelectedAnnotationData = this.propertiesannotationData;
  //   if(this.repoint_AnnotationStore.length!=0 && this.createDocumentStore.enablerotateButtons!=true){
  //     await this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
  //     if (this.layerDatas != undefined && this.repoint_AnnotationStore.length != 0) {
  //       for (let ma = 0; ma < this.repoint_AnnotationStore.length; ma++) {
  //         let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.repoint_AnnotationStore[ma].layer_id);
  //         if (findLayerIndex != -1) {
  //           let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == this.repoint_AnnotationStore[ma].annotation_id);
  //           if (findAnnotationIndexS != -1) {
  //             this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS] = this.repoint_AnnotationStore[ma];
  //             if (this.repoint_AnnotationStore[ma]["toolbar_element_id"] == 13) {
  //               let annotation_string = this.repoint_AnnotationStore[ma]["annotation_data"];
  //               let arrowString = this.createArrow();
  //               annotation_string = annotation_string.trim();
  //               annotation_string = annotation_string + arrowString;
  //               this.repoint_AnnotationStore[ma]["annotation_data"] = annotation_string;
  //             }
  //             if (Number(this.repoint_AnnotationStore[ma]["toolbar_element_id"]) == 11 &&
  //               Number(this.repoint_AnnotationStore[ma]["initial_width"]) != 0 && Number(this.repoint_AnnotationStore[ma]["initial_height"]) != 0) {
  //               this.repoint_AnnotationStore[ma]["annotation_url"] = { "text_resize": "true" };
  //             }
  //           }
  //         }
  //       }
  //       let generateCloneLayer = _.cloneDeep(this.layerDatas);
  //       this.documentService.annotationMultipleUpdate(generateCloneLayer, this.repoint_AnnotationStore).subscribe((response) => {
  //         console.log(response);
  //         if (response["response_code"] == 200) {
  //           if (this.createDocumentStore.enablerepointButtons == true) {
  //             this.stringPathArray = [];
  //             this.createDocumentStore.enablerepointButtons = false;
  //             // clear the temporary drawing svg 
  //             this.removesvgAttribute("repointSVG");
  //             // clear the temporary drawing svg circles 
  //             this.removeredCirclesSVG();
  //             // replace the points to SVG current shape
  //             // this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
  //             this.removeMoveEvents();
  //             // remove the annotation click disabled function.
  //             this.annotationselectEnableDisable('remove');
  //             this.show = false;
  //           }
  //           else if (this.createDocumentStore.enablerotateButtons == true) {
  //             this.createDocumentStore.enablerotateButtons = false;
  //             let getrotateelement = document.getElementById(this.propertiesannotationData['annotation_id']);
  //             if (getrotateelement != null) {
  //               getrotateelement.classList.add('svg-block');
  //             }
  //             // svg annotation dont want to redraw purpose disabled.
  //             // this.annotationClear(this.propertiesannotationData);
  //             // this.annotationselectEnableDisable('remove');
  //             // this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]);
  //             // this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]);
  //             // this.propertiesannotationData = this.annotation_data_change(this.propertiesannotationData);
  //             // this.getshapeDrawing(this.propertiesannotationData, false);
  //             this.show = false;
  //           }
  //           else {
  //             this.removeMoveEvents();
  //             this.createDocumentStore.enableresizeButtons = false;
  //             // this.annotationClear(this.propertiesannotationData);
  //             this.annotationselectEnableDisable('remove');
  //             // this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]);
  //             // this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]);
  //             // this.propertiesannotationData = this.annotation_data_change(this.propertiesannotationData);
  //             // this.getshapeDrawing(this.propertiesannotationData, false);
  //             // await this.replacecurrentChangeInSVG(this.propertiesannotationData);
  //             this.show = false;
  //           }
  //           this.show = false;
  //         }

  //         else {
  //           this.errorMessage();
  //         }
  //       });
  //       this.repoint_AnnotationStore = [];
  //       this.repoint_AnnotationStore_Id = [];
  //     }
  //   }
  //   else{
  //     let filterLayerId = this.propertiesannotationData["layer_id"];
  //     let findLayerId = this.layerDatas.findIndex((ad) => ad.layer_id === filterLayerId);
  //     console.log(this.repoint_AnnotationStore);
  //     if (findLayerId > -1) {
  //       let filterAnnotation = this.layerDatas[findLayerId].annotations.findIndex((annot) => annot.annotation_id === this.propertiesannotationData["annotation_id"]);
  //       if (filterAnnotation > -1) {
  //         if (this.createDocumentStore.enablerepointButtons == true) {
  //           if (this.propertiesannotationData["toolbar_element_id"] == 13) {
  //             let annotation_string = this.propertiesannotationData["annotation_data"];
  //             let arrowString = this.createArrow();
  //             annotation_string = annotation_string.trim();
  //             annotation_string = annotation_string + arrowString;
  //             this.propertiesannotationData["annotation_data"] = annotation_string;
  //           }
  //           this.propertiesannotationData.initial_position_x = 0;
  //           this.propertiesannotationData.initial_position_y = 0;
  //           this.propertiesannotationData.initial_width = 0;
  //           this.propertiesannotationData.initial_height = 0;
  //         }
  //         this.createDocumentStore.enableresizeButtons = false;
  //         if(Number(this.propertiesannotationData["toolbar_element_id"]) == 11 && 
  //         Number(this.propertiesannotationData["initial_width"])!=0 && Number(this.propertiesannotationData["initial_height"])!=0) {
  //           this.propertiesannotationData["annotation_url"] = {"text_resize":"true"};
  //         }
  //         this.layerDatas[findLayerId].annotations[filterAnnotation] = this.propertiesannotationData;
  //         let generateCloneLayer = _.cloneDeep(this.layerDatas);
  //         console.log(this.resizeAnnotationsStore);
  //         this.documentService.annotationUpdateForm1(generateCloneLayer, this.propertiesannotationData.annotation_id, filterLayerId).subscribe(async (response) => {
  //           console.log(response);
  //           if (response["response_code"] == 200) {
  //             this.rotateresizeAnnotationStore = [];
  //             // should be empty single selection stored array
  //             this.createDocumentStore.single_select_annotation = [];
  //             if (this.createDocumentStore.enablerepointButtons == true) {
  //               this.stringPathArray = [];
  //               this.createDocumentStore.enablerepointButtons = false;
  //               // clear the temporary drawing svg 
  //               this.removesvgAttribute("repointSVG");
  //               // clear the temporary drawing svg circles 
  //               this.removeredCirclesSVG();
  //               // replace the points to SVG current shape
  //               await this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
  //               this.removeMoveEvents();
  //               // remove the annotation click disabled function.
  //               this.annotationselectEnableDisable('remove');
  //               this.show = false;
  //             }
  //             else if (this.createDocumentStore.enablerotateButtons == true) {
  //               this.createDocumentStore.enablerotateButtons = false;
  //               let getrotateelement = document.getElementById(this.propertiesannotationData['annotation_id']);
  //               if (getrotateelement != null) {
  //                 getrotateelement.classList.add('svg-block');
  //               }
  //               // svg annotation dont want to redraw purpose disabled.
  //               // this.annotationClear(this.propertiesannotationData);
  //               // this.annotationselectEnableDisable('remove');
  //               // this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]);
  //               // this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]);
  //               // this.propertiesannotationData = this.annotation_data_change(this.propertiesannotationData);
  //               // this.getshapeDrawing(this.propertiesannotationData, false);
  //               this.show = false;
  //             }
  //             else {
  //               this.removeMoveEvents();
  //               // this.annotationClear(this.propertiesannotationData);
  //               this.annotationselectEnableDisable('remove');
  //               // this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]);
  //               // this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]);
  //               // this.propertiesannotationData = this.annotation_data_change(this.propertiesannotationData);
  //               // this.getshapeDrawing(this.propertiesannotationData, false);
  //               // await this.replacecurrentChangeInSVG(this.propertiesannotationData);
  //               this.show = false;
  //             }
  //             // for attributes changing issue datacopy values assinged
  //             this.propertiesannotationDataCopy["initial_width"] = this.propertiesannotationData["initial_width"];
  //             this.propertiesannotationDataCopy["initial_height"] = this.propertiesannotationData["initial_height"];
  //             this.propertiesannotationDataCopy["initial_rotation"] = this.propertiesannotationData["initial_rotation"];
  //             this.propertiesannotationDataCopy["annotation_data"] = this.propertiesannotationData["annotation_data"];
  //             this.propertiesannotationDataCopy["initial_position_x"] = this.propertiesannotationData["initial_position_x"];
  //             this.propertiesannotationDataCopy["initial_position_y"] = this.propertiesannotationData["initial_position_y"];

  //           }
  //           else {
  //             this.errorMessage();
  //           }
  //           this.resizeAnnotationsStore=[];
  //         });
  //       }
  //     }
  //   }
  //   // if (this.degree != this.propertiesannotationData["initial_rotation"]) {
  //   //   this.rotationSucceed = true;
  //   //   var removeselectedRotateShape = document.getElementById(this.getId);
  //   //   removeselectedRotateShape.remove();
  //   //   this.rotateshapeDrawing(this.propertiesannotationData);
  //   // }
  // }

  async rotateresizeButtonHandles(value?: string) {
    this.dbxposition = this.propertiesannotationData.initial_position_x
    this.dbyposition = this.propertiesannotationData.initial_position_y
    if (this.createDocumentStore.enablerepointButtons == true && value != 'repoint') {

      if (this.propertiesannotationData["toolbar_element_id"] == 13) {
        let annotation_string = this.propertiesannotationData["annotation_data"];
        let arrowString = this.createArrow();
        annotation_string = annotation_string.trim();
        annotation_string = annotation_string + arrowString;
        this.propertiesannotationData["annotation_data"] = annotation_string;
      }
      this.stringPathArray = [];
      this.createDocumentStore.enablerepointButtons = false;
      // disable drag scroll
      this.createDocumentStore.disable_drag_scroll = false;
      this.removesvgAttribute("repointSVG");
      this.removeredCirclesSVG();
      await this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
      this.removeMoveEvents();
      this.annotationselectEnableDisable('remove');
      this.show = false;
      // this.current_value_updateto_layer();
    }
    else if (this.createDocumentStore.enablerotateButtons == true && value != 'rotate') {
      this.createDocumentStore.enablerotateButtons = false;
      console.log(this.propertiesannotationData);
      //update layerdata changes
      // this.annotationClear(this.propertiesannotationData);
      // this.annotationselectEnableDisable('remove');
      // this.getshapeDrawing(this.propertiesannotationData, false);

      this.show = false;
    }
    else if (this.createDocumentStore.enableresizeButtons == true && value != 'resize') {
      this.createDocumentStore.enableresizeButtons = false;
      this.resizebutton = false;
      // this.annotationClear(this.propertiesannotationData);dfsafdf
      this.annotationselectEnableDisable('remove');
      // this.propertiesannotationData = this.annotation_data_change(this.propertiesannotationData);
      // this.getshapeDrawing(this.propertiesannotationData, false);
    }

  }

  rotateshapeDrawing(getData) {
    console.log(getData);
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("id", getData.annotation_id);
    newcreatedElement.addEventListener("click", (e: any) => {
      this.canvasClick(e);
    });
    newcreatedElement.setAttribute("width", getData.initial_width);
    newcreatedElement.setAttribute("height", getData.initial_height);
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = getData.initial_position_y + "px";
    newcreatedElement.style.left = getData.initial_position_x + "px";
    newcreatedElement.style.marginLeft = "-" + getData.initial_width / 2 + "px";
    newcreatedElement.style.marginTop = "-" + getData.initial_height / 2 + "px";
    newcreatedElement.style.transform = "rotate(" + this.degree + "deg)";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    getData.annotation_data = getData.annotation_data.trim();
    var spaceSplit = getData.annotation_data.split(" ");
    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");

      for (var j = 0; j < hypenSplit.length; j++) {
        if (hypenSplit[0] == "controlpoint" && j == 1) {
          var colonSplit = hypenSplit[j].split(":");
          var cpx = parseFloat(colonSplit[0]);
          var cpy = parseFloat(colonSplit[1]);
        }
        // "move-10:25 line-22:25 line-22:19 controlpoint-22:16 curveEnd-25:16 line-37:16 controlpoint-40:16 curveEnd-40:19 line-40:31 controlpoint-40:34 curveEnd-37:34 line-25:34 controlpoint-22:34 curveEnd-22:31 line-22:25";

        if (hypenSplit[0] == "curveEnd" && j == 1) {
          var colonSplit = hypenSplit[j].split(":");
          var ex = parseFloat(colonSplit[0]);
          var ey = parseFloat(colonSplit[1]);
        }
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var colonSplit = hypenSplit[j].split(":");

          var x = parseFloat(colonSplit[0]);

          var y = parseFloat(colonSplit[1]);

          var h = parseFloat(colonSplit[2]);

          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            // this.canvasElement.drawImage(urlImg,this.coordinateX,this.coordinateX)
            this.canvasElement.moveTo(x, y);
            break;
          case "line":
            this.canvasElement.lineTo(x, y);
            break;
          case "ovalIn":
            var r = (w * w) / (8 * h) + h / 2;
            this.canvasElement.arc(
              newcreatedElement.clientWidth / 2,
              newcreatedElement.clientHeight / 2.3,
              r,
              0,
              2 * Math.PI
            );
            break;
          case "curveEnd":
            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
            break;
        }
      }
      var checkFill = getData.fill_color;

      this.canvasElement.fillStyle = this.checkStrokeColor1(getData.fill_color);
      this.canvasElement.fill();
      this.canvasElement.lineWidth = this.globalLineWidth(getData.line_width);


      this.canvasElement.strokeStyle = this.checkStrokeColor1(getData.stroke_color);
      this.canvasElement.stroke();

    }
    let layers = [];
    if (this.layerDatas != undefined) {
      for (var i = 0; i < this.layerDatas.length; i++) {
        for (var j = 0; j < this.layerDatas[i].annotations.length; j++) {
          if (this.getId == this.layerDatas[i].annotations[j].annotation_id) {
            this.layerDatas[i].annotations[j].initial_rotation = this.degree;
          }
        }
        layers.push(this.layerDatas[i]);
      }
      this.documentService.annotationUpdateAUC(layers).subscribe((response) => {
        console.log(response);
        this.rotateandresize = false;
        this.dataService1.changeRotateandResizeMessage(this.rotateandresize);
        this.resizebutton = false;
      });
    }
  }

 
  closeRotateFooter(event?: any) {
    this.repoint_AnnotationStore = [];
    this.repoint_AnnotationStore_Id = [];
    this.rotateandresize = false;
    this.show = true;
    this.dataService1.changeRotateandResizeMessage(this.rotateandresize);
    this.resizebutton = false;
    // after done and canvas rotate footer after moving selected element issue purpose it is commented.
    // this.currentSelectedAnnotationData = {};
    this.createDocumentStore.enableresizeButtons = false;
    this.createDocumentStore_1.resize_per_input = null;
    // should be empty single selection stored array
    this.createDocumentStore.single_select_annotation = [];
    // disable drag scroll
    this.createDocumentStore.disable_drag_scroll = false;
    if (this.createDocumentStore.enablerepointButtons == true) {
      this.createDocumentStore.enablerepointButtons = false;
      this.removeredCirclesSVG();
      this.removesvgAttribute("repointSVG");
      let getSelectedElement = document.getElementById(this.propertiesannotationData["annotation_id"]);
      this.transparentBorderSVG(getSelectedElement);
      this.annotationselectEnableDisable('remove');
      this.removeMoveEvents();
    }
    else if (this.createDocumentStore.enablerotateButtons == true) {
      this.createDocumentStore.enablerotateButtons = false;
      this.createDocumentStore_1.rotate_deg_input = null;
      let getSelectedElement = document.getElementById(this.propertiesannotationData["annotation_id"]);
      this.transparentBorderSVG(getSelectedElement);
    }
    this.createDocumentStore.rotate_previous_value_backup = _.cloneDeep(this.propertiesannotationData);
    if (event != undefined) {
      this.revert_changes();
      this.single_annotation_selection(event);
    }
    else if(this.resizeMove == true){
      this.show = false;
    }
    else {
      this.revert_changes();
      this.show = false;
      // this.getAnnotationForm('rotateresizeend');
    }
  }

  revert_changes(){ // move and resize annotation cancel button click revert back to the data layer and drawing
    if (this.createDocumentStore.backup_annot_Store.length > 0) {
      for(let ab=0;ab<this.createDocumentStore.backup_annot_Store.length;ab++){
        let find_layer = this.layerDatas.findIndex((layer)=>layer.layer_id==this.createDocumentStore.backup_annot_Store[ab].annotation_object.layer_id);
        let annotation_in = this.layerDatas[find_layer].annotations.findIndex((anot)=>anot.annotation_id==this.createDocumentStore.backup_annot_Store[ab].annotation_object.annotation_id);
        if(annotation_in!=-1){
        this.layerDatas[find_layer].annotations[annotation_in].annotation_data = this.createDocumentStore.backup_annot_Store[ab].annotation_object.annotation_data;
        this.layerDatas[find_layer].annotations[annotation_in].initial_position_x = this.createDocumentStore.backup_annot_Store[ab].annotation_object.initial_position_x;
        this.layerDatas[find_layer].annotations[annotation_in].initial_position_y = this.createDocumentStore.backup_annot_Store[ab].annotation_object.initial_position_y;
        this.layerDatas[find_layer].annotations[annotation_in].initial_width = this.createDocumentStore.backup_annot_Store[ab].annotation_object.initial_width;
        this.layerDatas[find_layer].annotations[annotation_in].initial_height = this.createDocumentStore.backup_annot_Store[ab].annotation_object.initial_height;
        this.layerDatas[find_layer].annotations[annotation_in].initial_rotation = this.createDocumentStore.backup_annot_Store[ab].annotation_object.initial_rotation;
        this.layerDatas[find_layer].annotations[annotation_in].text_font_size = this.createDocumentStore.backup_annot_Store[ab].annotation_object.text_font_size;
        if(this.resizedone==false){
        this.replacecurrentChangeInSVG(this.createDocumentStore.backup_annot_Store[ab].annotation_object, false);
        }
      }
    }
    this.createDocumentStore.backup_annot_Store = [];
  }
  }

  revert_changes_resize_rotate(){
    console.log(this.resizeMoveBackUp);
    let find_layer = this.layerDatas.findIndex((layer)=>layer.layer_id==this.resizeMoveBackUp.layer_id);
    let annotation_in = this.layerDatas[find_layer].annotations.findIndex((anot)=>anot.annotation_id==this.resizeMoveBackUp.annotation_id);
        if(annotation_in!=-1){
        this.layerDatas[find_layer].annotations[annotation_in].annotation_data = this.resizeMoveBackUp.annotation_data;
        this.layerDatas[find_layer].annotations[annotation_in].initial_position_x = this.resizeMoveBackUp.initial_position_x;
        this.layerDatas[find_layer].annotations[annotation_in].initial_position_y = this.resizeMoveBackUp.initial_position_y;
        this.layerDatas[find_layer].annotations[annotation_in].initial_width = this.resizeMoveBackUp.initial_width;
        this.layerDatas[find_layer].annotations[annotation_in].initial_height = this.resizeMoveBackUp.initial_height;
        this.layerDatas[find_layer].annotations[annotation_in].initial_rotation = this.resizeMoveBackUp.initial_rotation;
        this.replacecurrentChangeInSVG(this.resizeMoveBackUp, false);
      }
  }
  
  drawEllipse() {
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeDrawEllipseAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    pdfImg.appendChild(newcreatedElement);
    this.drawCanvasContext = newcreatedElement.getContext("2d");
    //Variables
    var scribble_canvasx = $(newcreatedElement).offset().left + ((Number(this.currentSelectedItems.element_data.line_width) / 2) / 2);
    var scribble_canvasy = $(newcreatedElement).offset().top + ((Number(this.currentSelectedItems.element_data.line_width) / 2) / 2);
    var scribble_last_mousex = 0;
    var scribble_last_mousey = 0;
    var scribble_mousex = 0;
    var scribble_mousey = 0;
    var scribble_mousedown = false;
    this.getPositionString = "";
    this.stringPathArray = [];
    //Mousedown
    $(newcreatedElement).on("mousedown", (e: any) => {
      console.log("Mousedown");
      this.stringPathArray = [];
      scribble_last_mousex = e.clientX - scribble_canvasx;
      scribble_last_mousey = e.clientY - scribble_canvasy;
      console.log(scribble_last_mousex, scribble_canvasx);
      console.log(scribble_canvasx, scribble_canvasy)
      scribble_mousedown = true;
      this.getPositionString = "ovalIn" + "-" + (scribble_last_mousex / this.scale) + ":" + (scribble_last_mousey / this.scale);
      this.stringPathArray.push(this.getPositionString);
    });

    //Mouseup
    $(newcreatedElement).on("mouseup", (e: any) => {
      scribble_mousedown = false;
      scribble_mousex = e.clientX - scribble_canvasx;
      scribble_mousey = e.clientY - scribble_canvasy;
      this.getPositionString = ":" + (scribble_mousex / this.scale) + ":" + (scribble_mousey / this.scale);
      this.stringPathArray.push(this.getPositionString);
      console.log("Mouseup", this.stringPathArray);
      this.accessdrawEllipseMenuStop = this.stringPathArray.length <= 1 ? true : false;
      let convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        if (i == 0 || i == this.stringPathArray.length - 1) {
          convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
        }
      }
      convertAnnotationData = convertAnnotationData.trim();
      let getAnnotationWidthandHeight: any = this.getAnnotationWidthandHeightAction(convertAnnotationData);
      console.log(getAnnotationWidthandHeight);
      if (getAnnotationWidthandHeight.width == 0 || getAnnotationWidthandHeight.height == 0) {
        this.accessdrawEllipseMenuStop = true;
        this.drawCanvasContext.clearRect(
          0,
          0,
          newcreatedElement.width,
          newcreatedElement.height
        );
      }
    });

    //Mousemove
    $(newcreatedElement).on("mousemove", (e: any) => {
      if (scribble_mousedown == true) {
        console.log("Mousemove");
        scribble_mousex = e.clientX - scribble_canvasx;
        scribble_mousey = e.clientY - scribble_canvasy;
      }
      if (scribble_mousedown) {
        this.drawCanvasContext.clearRect(
          0,
          0,
          newcreatedElement.width,
          newcreatedElement.height
        ); //clear canvas
        //Save
        this.drawCanvasContext.save();
        this.drawCanvasContext.beginPath();
        //Dynamic scaling
        var scalex = 0.5 * ((scribble_mousex / this.scale) - (scribble_last_mousex / this.scale));
        var scaley = 0.5 * ((scribble_mousey / this.scale) - (scribble_last_mousey / this.scale));
        this.drawCanvasContext.scale(scalex, scaley);
        //Create ellipse
        var centerx = ((scribble_last_mousex / this.scale) / scalex) + 1;
        var centery = ((scribble_last_mousey / this.scale) / scaley) + 1;
        this.drawCanvasContext.arc(centerx, centery, 1, 0, 2 * Math.PI);
        console.log(centerx, centery)
        //Restore and draw
        this.drawCanvasContext.restore();
        this.drawCanvasContext.strokeStyle = this.checkStrokeColor1(this.currentSelectedItems.element_data.stroke_color);
        this.drawCanvasContext.lineWidth = this.currentSelectedItems.element_data.line_width;
        this.drawCanvasContext.stroke();
        var checkFill = this.checkStrokeColor1(this.currentSelectedItems.element_data.fill_color);
        this.drawCanvasContext.fillStyle = checkFill;
        this.drawCanvasContext.fill();
      }
    });

    //MouseLeave
    $(newcreatedElement).on("mouseleave", (e: any) => {
      if (scribble_mousedown == true) {
        scribble_mousedown = false;
        scribble_mousex = e.clientX - scribble_canvasx;
        scribble_mousey = e.clientY - scribble_canvasy;
        this.getPositionString = ":" + (scribble_mousex / this.scale) + ":" + (scribble_mousey / this.scale);
        this.stringPathArray.push(this.getPositionString);
        console.log("mouseleave", this.stringPathArray);
        this.accessdrawEllipseMenuStop = this.stringPathArray.length <= 1 ? true : false;
        let convertAnnotationData = "";
        for (var i = 0; i < this.stringPathArray.length; i++) {
          if (i == 0 || i == this.stringPathArray.length - 1) {
            convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
          }
        }
        convertAnnotationData = convertAnnotationData.trim();
        let getAnnotationWidthandHeight: any = this.getAnnotationWidthandHeightAction(convertAnnotationData);
        console.log(getAnnotationWidthandHeight);
        if (getAnnotationWidthandHeight.width == 0 || getAnnotationWidthandHeight.height == 0) {
          this.accessdrawEllipseMenuStop = true;
          this.canvasElement.clearRect(
            0,
            0,
            newcreatedElement.width,
            newcreatedElement.height
          );
        }
      }
    });
  }

  svg_viewBox = "0 0 500 500";
  drawEllipsesvg() {

    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeDrawEllipseAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    let createellipse = document.createElementNS("http://www.w3.org/2000/svg", 'ellipse');
    createellipse.setAttribute("customeellipseattributepath", "1");
    newcreatedElement.appendChild(createellipse);
    pdfImg.appendChild(newcreatedElement);
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    var scribble_last_mousex = 0;
    var scribble_last_mousey = 0;
    var scribble_mousex = 0;
    var scribble_mousey = 0;
    var scribble_mousedown = false;
    this.getPositionString = "";
    this.stringPathArray = [];
    let svg_left = 0;
    let svg_top = 0;
    //Mousedown
    $(newcreatedElement).on("mousedown", (e: any) => {
      e.preventDefault();
      if(this.showvisible==false || this.isReadonly == true){
        return
      }
      if(this.layerDatas.length==0){
        return
      }
      
      if((this.layerDatas.length!=0)){
var active=this.layerDatas;
active=active.filter(res=>res.layer_id==this.activeLayerIdDraw)
     }
     if(this.layerDatas.length!=0 && active.length==0){
       return
     }
      console.log("Mousedown");
      this.stringPathArray = [];
      // scribble_canvasx = $(newcreatedElement).offset().left;
      // scribble_canvasy = $(newcreatedElement).offset().top;
      scribble_last_mousex = e.offsetX;
      scribble_last_mousey = e.offsetY;
      scribble_mousedown = true;
      this.getPositionString = "ovalIn" + "-" + (scribble_last_mousex) + ":" + (scribble_last_mousey);
      this.stringPathArray.push(this.getPositionString);
    });

    //Mouseup
    $(newcreatedElement).on("mouseup", (e: any) => {
      if (this.layerDatas.length == 0 || this.isReadonly == true) {
        return
      }
      
      if((this.layerDatas.length!=0)){
var active=this.layerDatas;
active=active.filter(res=>res.layer_id==this.activeLayerIdDraw)
     }
     if(this.layerDatas.length!=0 && active.length==0){
       return
     }
      scribble_mousedown = false;
      scribble_mousex = e.offsetX
      scribble_mousey = e.offsetY;
      this.getPositionString = ":" + (scribble_mousex) + ":" + (scribble_mousey);
      this.stringPathArray.push(this.getPositionString);
      console.log("Mouseup", this.stringPathArray);
      this.accessdrawEllipseMenuStop = this.stringPathArray.length <= 1 ? true : false;
      let convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        if (i == 0 || i == this.stringPathArray.length - 1) {
          convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
        }
      }
      convertAnnotationData = convertAnnotationData.trim();
      let getAnnotationWidthandHeight: any = this.getAnnotationWidthandHeightAction(convertAnnotationData);
      console.log(getAnnotationWidthandHeight);
      if (getAnnotationWidthandHeight.width == 0 || getAnnotationWidthandHeight.height == 0) {
        this.accessdrawEllipseMenuStop = true;
      }
    });

    //Mousemove
    $(newcreatedElement).on("mousemove", (e: any) => {
      if(this.layerDatas.length==0){
        return
      }
      
      if((this.layerDatas.length!=0)){
var active=this.layerDatas;
active=active.filter(res=>res.layer_id==this.activeLayerIdDraw)
     }
     if(this.layerDatas.length!=0 && active.length==0){
       return
     }
      if (scribble_mousedown == true) {
        console.log("Mousemove");
        scribble_mousex = e.offsetX;
        scribble_mousey = e.offsetY;
        let getWidth = (scribble_last_mousex) - (scribble_mousex);
        let getHeight = (scribble_last_mousey) - (scribble_mousey);
        let positive_width = getWidth < 0 ? -(getWidth) : getWidth;
        let positive_height = getHeight < 0 ? -(getHeight) : getHeight;
        svg_left = (scribble_last_mousex);
        svg_top = (scribble_last_mousey);
        let ellipse_svg_path_rx = (positive_width / 2);
        let ellipse_svg_path_ry = (positive_height / 2);
        let ellipse_svg_path_cx = svg_left - (getWidth / 2);
        // ellipse_svg_path_cx = Math.round(ellipse_svg_path_cx);
        let ellipse_svg_path_cy = svg_top - (getHeight / 2);
        // ellipse_svg_path_cy = Math.round(ellipse_svg_path_cy);
        createellipse.setAttribute('cx', ellipse_svg_path_cx.toString());
        createellipse.setAttribute('cy', ellipse_svg_path_cy.toString());
        createellipse.setAttribute('rx', ellipse_svg_path_rx.toString());
        createellipse.setAttribute('ry', ellipse_svg_path_ry.toString());
        let fillcolor = this.checkStrokeColor1(this.currentSelectedItems.element_data.fill_color);
        let strokecolor = this.checkStrokeColor1(this.currentSelectedItems.element_data.stroke_color);
        let linewidth = this.currentSelectedItems.element_data.line_width / 2;
        createellipse.setAttribute('fill', fillcolor);
        createellipse.setAttribute('stroke', strokecolor);
        createellipse.setAttribute('stroke-width', linewidth.toString());
      }
    });

    //MouseLeave
    $(newcreatedElement).on("mouseleave", (e: any) => {
      if(this.layerDatas.length==0){
        return
      }
      
      if((this.layerDatas.length!=0)){
var active=this.layerDatas;
active=active.filter(res=>res.layer_id==this.activeLayerIdDraw)
     }
     if(this.layerDatas.length!=0 && active.length==0){
       return
     }
      if (scribble_mousedown == true) {
        console.log("Mousemove");
        scribble_mousex = e.offsetX;
        scribble_mousey = e.offsetY;
        let getWidth = (scribble_last_mousex) - (scribble_mousex);
        let getHeight = (scribble_last_mousey) - (scribble_mousey);
        let positive_width = getWidth < 0 ? -(getWidth) : getWidth;
        let positive_height = getHeight < 0 ? -(getHeight) : getHeight;
        svg_left = (scribble_last_mousex);
        svg_top = (scribble_last_mousey);
        let ellipse_svg_path_rx = (positive_width / 2);
        let ellipse_svg_path_ry = (positive_height / 2);
        let ellipse_svg_path_cx = svg_left - (getWidth / 2);
        let ellipse_svg_path_cy = svg_top - (getHeight / 2);
        createellipse.setAttribute('cx', ellipse_svg_path_cx.toString());
        createellipse.setAttribute('cy', ellipse_svg_path_cy.toString());
        createellipse.setAttribute('rx', ellipse_svg_path_rx.toString());
        createellipse.setAttribute('ry', ellipse_svg_path_ry.toString());
        let fillcolor = this.checkStrokeColor1(this.currentSelectedItems.element_data.fill_color);
        let strokecolor = this.checkStrokeColor1(this.currentSelectedItems.element_data.stroke_color);
        let linewidth = this.currentSelectedItems.element_data.line_width / 2;
        createellipse.setAttribute('fill', fillcolor);
        createellipse.setAttribute('stroke', strokecolor);
        createellipse.setAttribute('stroke-width', linewidth.toString());
      }
    });

  }

  drawRectangle() {
    console.log(this.currentSelectedAnnotationData);
    this.getPositionString = "";
    this.stringPathArray = [];
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeDrawRectangleAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    // newcreatedElement.style.transform= "scale(" + this.scale + ")";
    pdfImg.appendChild(newcreatedElement);
    this.drawCanvasContext = newcreatedElement.getContext("2d");
    // this.canvasElement.scale(this.scale,this.scale);
    var canvasx = $(newcreatedElement).offset().left - ((Number(this.currentSelectedItems.element_data.line_width) / 2) / 2);
    var canvasy = $(newcreatedElement).offset().top - ((Number(this.currentSelectedItems.element_data.line_width) / 2) / 2);;
    console.log(canvasx, canvasy);
    var last_mousex = 0;
    var last_mousey = 0;
    var mousex = 0;
    var mousey = 0;
    var mousedown = false;
    var width = 0;
    var height = 0;
    //Mousedown
    $(newcreatedElement).on("mousedown", (e: any) => {

      this.stringPathArray = [];
      // canvasx = $(newcreatedElement).offset().left-((Number(this.currentSelectedItems.element_data.line_width) / 2) / 2);;
      // canvasy = $(newcreatedElement).offset().top-((Number(this.currentSelectedItems.element_data.line_width) / 2) / 2);;
      last_mousex = e.clientX - canvasx;
      last_mousey = e.clientY - canvasy;
      mousedown = true;
      this.getPositionString = "drawRect" + "-" + last_mousex + ":" + last_mousey;
      this.stringPathArray.push(this.getPositionString);
    });

    //Mouseup
    $(newcreatedElement).on("mouseup", (e: any) => {
      mousedown = false;
      mousex = e.clientX - canvasx;
      mousey = e.clientY - canvasy;
      this.getPositionString = ":" + mousex + ":" + mousey;
      this.stringPathArray.push(this.getPositionString);
      console.log(this.stringPathArray);
      this.accessRectangleMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      let convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        if (i == 0 || i == this.stringPathArray.length - 1) {
          convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
        }
      }
      convertAnnotationData = convertAnnotationData.trim();
      let getAnnotationWidthandHeight: any = this.getAnnotationWidthandHeightAction(convertAnnotationData);
      console.log(getAnnotationWidthandHeight);
      getAnnotationWidthandHeight.width = getAnnotationWidthandHeight.width + (Number(this.currentSelectedItems.element_data.line_width) / 2);
      getAnnotationWidthandHeight.height = getAnnotationWidthandHeight.height + (Number(this.currentSelectedItems.element_data.line_width) / 2);
      if (getAnnotationWidthandHeight.width == 0 || getAnnotationWidthandHeight.height == 0) {
        this.accessRectangleMenuFeatureStop = true;
      }
    });

    //Mousemove
    $(newcreatedElement).on("mousemove", (e: any) => {
      mousex = e.clientX - canvasx;
      mousey = e.clientY - canvasy;
      if (mousedown) {
        this.drawCanvasContext.clearRect(
          0,
          0,
          newcreatedElement.width,
          newcreatedElement.height
        ); //clear canvas
        this.drawCanvasContext.beginPath();
        width = mousex - last_mousex;
        height = mousey - last_mousey;
        width = width;
        height = height;
        console.log('rect', last_mousex, last_mousey, width, height)
        this.drawCanvasContext.rect(last_mousex / this.scale, last_mousey / this.scale, width / this.scale, height / this.scale);
        let drawedArea = [];
        drawedArea.push(mousex, mousey);
        console.log(drawedArea, this.scale);
        this.drawCanvasContext.lineWidth = (this.currentSelectedItems.element_data.line_width) / 2;
        var checkFill = this.currentSelectedItems.element_data.fill_color;
        this.drawCanvasContext.fillStyle = this.checkStrokeColor1(checkFill);
        this.drawCanvasContext.fill();
        var checkStroke = this.currentSelectedItems.element_data.stroke_color;
        this.drawCanvasContext.strokeStyle = this.checkStrokeColor1(checkStroke);
        this.drawCanvasContext.stroke();
      }
    });
  }

  drawRectangleSVG() {
debugger
    console.log(this.layerDatas)
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeDrawRectangleAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";

    // let newcreatedElement = document.getElementById('drawingSVG');
    // console.log(newcreatedElement);
    // newcreatedElement.setAttribute('width', this.realWidth);
    // newcreatedElement.setAttribute('height', this.realHeight);
    // var canvasx = $(newcreatedElement).offset().left - ((Number(this.currentSelectedItems.element_data.line_width) / 2) / 2);
    // var canvasy = $(newcreatedElement).offset().top - ((Number(this.currentSelectedItems.element_data.line_width) / 2) / 2);;
    let createrectangle = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
    createrectangle.setAttribute('customerectangleattributepath', '1');
    newcreatedElement.appendChild(createrectangle);
    pdfImg.appendChild(newcreatedElement);
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    var last_mousex = 0;
    var last_mousey = 0;
    var mousex = 0;
    var mousey = 0;
    var mousedown = false;
    var width = 0;
    var height = 0;
    this.getPositionString = "";
    this.stringPathArray = [];
    let svg_left = 0;
    let svg_top = 0;
    let first_click_capture_points = false;
    let mouse_move_trigger = false;

    //Mousedown
    $(newcreatedElement).on("mousedown", (e: any) => {
      e.preventDefault();
      if (this.showvisible == false || this.isReadonly == true) {
        return
      }
      if (this.layerDatas.length == 0) {
        return
      }

      if ((this.layerDatas.length != 0)) {
        var active = this.layerDatas;
        active = active.filter(res => res.layer_id == this.activeLayerIdDraw)
      }
      if (this.layerDatas.length != 0 && active.length == 0) {
        return
      }
      // canvasx = $(newcreatedElement).offset().left;
      // canvasy = $(newcreatedElement).offset().top;
      mousedown = true;
      // click function implemented
      if (first_click_capture_points == false) {
        this.removeredCirclesSVG();
        this.stringPathArray = [];
        console.log('mousedowninside called');
        last_mousex = e.offsetX;
        last_mousey = e.offsetY;
        let circle = this.addredCirclesSVG(last_mousex, last_mousey);
        newcreatedElement.appendChild(circle);
        this.getPositionString = "drawRect" + "-" + last_mousex + ":" + last_mousey;
        this.stringPathArray.push(this.getPositionString);
      }
      else {

        // second time mousdown click reset the first click capture option
        first_click_capture_points = false;
      }
    });

    //Mouseup
    $(newcreatedElement).on("mouseup", (e: any) => {
      if (this.showvisible == false || this.isReadonly == true) {
        return
      }
      if (this.layerDatas.length == 0) {
        return
      }

      if ((this.layerDatas.length != 0)) {
        var active = this.layerDatas;
        active = active.filter(res => res.layer_id == this.activeLayerIdDraw)
      }
      if (this.layerDatas.length != 0 && active.length == 0) {
        return
      }
      mousedown = false;
      mouse_move_trigger = false // when move happens click action need to disable purpose
      mousex = e.offsetX;
      mousey = e.offsetY;
      width = mousex - last_mousex;
      height = mousey - last_mousey;
      width = width < 0 ? -(width) : width;
      height = height < 0 ? -(height) : height;
      console.log(width, height);
      if (mouse_move_trigger == false && first_click_capture_points == false && width > 0 && height > 0) {
        drawdoubleclickrectangle();
        this.stringPathArray.splice(1, 1);
      }
      else if (mouse_move_trigger == false && first_click_capture_points == false) {
        first_click_capture_points = true;
      }
      this.getPositionString = ":" + mousex + ":" + mousey;
      this.stringPathArray.push(this.getPositionString);
      console.log(this.stringPathArray);
      this.accessRectangleMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      let convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        if (i == 0 || i == this.stringPathArray.length - 1) {
          convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
        }
      }
      convertAnnotationData = convertAnnotationData.trim();
      let getAnnotationWidthandHeight: any = this.getAnnotationWidthandHeightAction(convertAnnotationData);
      console.log(getAnnotationWidthandHeight);
      let clone_width_height = _.cloneDeep(getAnnotationWidthandHeight);
      let allow_width = clone_width_height.width;
      let allow_height = clone_width_height.height;
      getAnnotationWidthandHeight.width = getAnnotationWidthandHeight.width + (Number(this.currentSelectedItems.element_data.line_width) / 2);
      getAnnotationWidthandHeight.height = getAnnotationWidthandHeight.height + (Number(this.currentSelectedItems.element_data.line_width) / 2);
      if (allow_width == 0 || allow_height == 0) {
        console.log('width height 0');
        this.accessRectangleMenuFeatureStop = true;
      }
      else {
        let circle = this.addredCirclesSVG(mousex, mousey);
        circle.style.pointerEvents = "none";
        newcreatedElement.appendChild(circle);
      }
    });

    //Mousemove
    $(newcreatedElement).on("mousemove", (e: any) => {

      mousex = e.offsetX;
      mousey = e.offsetY;
      // first_click_capture_points = false;
      if (mousedown) {
        console.log('move_move');
        mousedown = true;
        if (this.showvisible == false) {
          return
        }
        if (this.layerDatas.length == 0) {
          return
        }

        if ((this.layerDatas.length != 0)) {
          var active = this.layerDatas;
          active = active.filter(res => res.layer_id == this.activeLayerIdDraw)
        }
        if (this.layerDatas.length != 0 && active.length == 0) {
          return
        }
        mouse_move_trigger = true;
        width = mousex - last_mousex;
        height = mousey - last_mousey;
        let getWidth = (last_mousex) - (mousex);
        let getHeight = (last_mousey) - (mousey);
        let positive_width = getWidth < 0 ? -(getWidth) : getWidth;
        let positive_height = getHeight < 0 ? -(getHeight) : getHeight;
        let svg_left = (last_mousex) < (mousex) ? (last_mousex) : (mousex);
        let svg_top = (last_mousey) < (mousey) ? (last_mousey) : (mousey);
        let rectangle_svg_path_x = svg_left;
        let rectangle_svg_path_y = svg_top;
        let rectangle_svg_path_width = positive_width - 1;
        let rectangle_svg_path_height = positive_height - 1;
        if (rectangle_svg_path_width > 0 && rectangle_svg_path_height > 0) {
          createrectangle.setAttribute("x", rectangle_svg_path_x.toString());
          createrectangle.setAttribute("y", rectangle_svg_path_y.toString());
          createrectangle.setAttribute("width", rectangle_svg_path_width.toString());
          createrectangle.setAttribute("height", rectangle_svg_path_height.toString());
          let fillcolor = this.checkStrokeColor1(this.currentSelectedItems.element_data.fill_color);
          let strokecolor = this.checkStrokeColor1(this.currentSelectedItems.element_data.stroke_color);
          let linewidth = this.currentSelectedItems.element_data.line_width / 2;
          createrectangle.setAttribute('fill', fillcolor);
          createrectangle.setAttribute('stroke', strokecolor);
          createrectangle.setAttribute('stroke-width', linewidth.toString());
        }
        // this.drawCanvasContext.rect(last_mousex / this.scale, last_mousey / this.scale, width / this.scale, height / this.scale);
      }
    });

    const drawdoubleclickrectangle = () => {
      width = mousex - last_mousex;
      height = mousey - last_mousey;
      let getWidth = (last_mousex) - (mousex);
      let getHeight = (last_mousey) - (mousey);
      let positive_width = getWidth < 0 ? -(getWidth) : getWidth;
      let positive_height = getHeight < 0 ? -(getHeight) : getHeight;
      let svg_left = (last_mousex) < (mousex) ? (last_mousex) : (mousex);
      let svg_top = (last_mousey) < (mousey) ? (last_mousey) : (mousey);
      let rectangle_svg_path_x = svg_left;
      let rectangle_svg_path_y = svg_top;
      if (positive_width == 1) {
        positive_width = 2;
      }
      if (positive_height == 1) {
        positive_height = 2;
      }
      let rectangle_svg_path_width = positive_width - 1;
      let rectangle_svg_path_height = positive_height - 1;
      createrectangle.setAttribute("x", rectangle_svg_path_x.toString());
      createrectangle.setAttribute("y", rectangle_svg_path_y.toString());
      createrectangle.setAttribute("width", rectangle_svg_path_width.toString());
      createrectangle.setAttribute("height", rectangle_svg_path_height.toString());
      let fillcolor = this.checkStrokeColor1(this.currentSelectedItems.element_data.fill_color);
      let strokecolor = this.checkStrokeColor1(this.currentSelectedItems.element_data.stroke_color);
      let linewidth = this.currentSelectedItems.element_data.line_width / 2;
      createrectangle.setAttribute('fill', fillcolor);
      createrectangle.setAttribute('stroke', strokecolor);
      createrectangle.setAttribute('stroke-width', linewidth.toString());
    };
  }

  clever: number = 1;

  updateDrawEllipse() {
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    this.show = true;
    this.drawEllipseDone = false;
    this.drawCanvasContext = null;
    this.accessdrawEllipseMenuStop = true;
    this.toolbarSet = false;
    let annotationUpdateEllipse = this.stringPathArray;
    var convertAnnotationData = "";
    this.removesvgAttribute("customeDrawEllipseAttribute")
    for (var i = 0; i < annotationUpdateEllipse.length; i++) {
      if (annotationUpdateEllipse.length - 1 == i || i == 0) {
        convertAnnotationData = convertAnnotationData + annotationUpdateEllipse[i];
      }
    }
    convertAnnotationData = convertAnnotationData.trim();
    console.log(convertAnnotationData);
    let getAnnotationWidthandHeight: any = this.getAnnotationWidthandHeightAction(convertAnnotationData);
    getAnnotationWidthandHeight.left = getAnnotationWidthandHeight.left < 0 ? 0 : getAnnotationWidthandHeight.left;
    getAnnotationWidthandHeight.top = getAnnotationWidthandHeight.top < 0 ? 0 : getAnnotationWidthandHeight.top;
    var originalString = "ovalIn-" + (getAnnotationWidthandHeight.left) + ":" + (getAnnotationWidthandHeight.top) + ":" + (getAnnotationWidthandHeight.width) + ":" + (getAnnotationWidthandHeight.height);
    console.log(originalString, this.scale);
    // this.annotationName = "Drawn Ellipse";
    var annontationidDate = new Date().getTime();
    var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
    var MyDateString = new Date().toISOString();
    let label_string = "";
    label_string = this.annotationLabelTemplate();
    this.createJson = {
      annotation_data: originalString,
      annotation_forms: this.selectAnnotationForms,
      annotation_id: uuid,
      annotation_label: label_string,
      annotation_links: [],
      annotation_media: [],
      annotation_name: this.annotationName,
      annotation_stubs: [],
      annotation_tags: "",
      annotation_url: "",
      created_by_user_id: this.su.user_id,
      created_date: MyDateString,
      document_id: this.folderId,
      element_size: 1,
      fill_color: this.currentSelectedItems.element_data.fill_color,
      initial_height: 0,
      initial_position_x: 0,
      initial_position_y: 0,
      initial_rotation: 0,
      initial_width: 0,
      is_removed: false,
      last_updated_date: MyDateString,
      layer_id: this.activeLayerIdDraw,
      line_width: this.currentSelectedItems.element_data.line_width,
      opacity: 1,
      original_property: "",
      page_id: this.currentPageId,
      project_id: this.projectId,
      stroke_color: this.currentSelectedItems.element_data.stroke_color,
      toolbar_element_id: 19,
      updated_by_user_id: this.su.user_id,
      version_number: 1,
    };
    this.annotationUpdate();
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  updateDrawRectangle() {
    this.dataService2.moveAccessfn(false);
    this.shape = false;
    if (this.stringPathArray.length > 0) {
      this.show = true;
      var convertAnnotationData = "";
      this.drawRectangleDone = false;
      this.drawCanvasContext = null;
      this.accessRectangleMenuFeatureStop = true;
      this.toolbarSet = false;
      this.removeredCirclesSVG();
      this.removesvgAttribute("customeDrawRectangleAttribute")
      for (var i = 0; i < this.stringPathArray.length; i++) {
        if (i == 0 || i == this.stringPathArray.length - 1) {
          convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
        }
      }
      convertAnnotationData = convertAnnotationData.trim();
      let getAnnotationWidthandHeight: any = this.getAnnotationWidthandHeightAction(convertAnnotationData);
      convertAnnotationData = 'drawRect' + '-' + getAnnotationWidthandHeight.left + ':' + getAnnotationWidthandHeight.top + ':' + getAnnotationWidthandHeight.width + ':' + getAnnotationWidthandHeight.height;
      console.log(convertAnnotationData);
      // this.annotationName = "Drawn Rectangle";
      var annontationidDate = new Date().getTime();
      var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
      var MyDateString = new Date().toISOString();
      let label_string = "";
      label_string = this.annotationLabelTemplate();
      this.createJson = {
        annotation_data: convertAnnotationData,
        annotation_forms: this.selectAnnotationForms,
        annotation_id: uuid,
        annotation_label: label_string,
        annotation_links: [],
        annotation_media: [],
        annotation_name: this.annotationName,
        annotation_stubs: [],
        annotation_tags: "",
        annotation_url: "",
        created_by_user_id: this.su.user_id,
        created_date: MyDateString,
        document_id: this.folderId,
        element_size: 1,
        fill_color: this.currentSelectedItems.element_data.fill_color,
        initial_height: 0,
        initial_position_x: 0,
        initial_position_y: 0,
        initial_rotation: 0,
        initial_width: 0,
        is_removed: false,
        last_updated_date: MyDateString,
        layer_id: this.activeLayerIdDraw,
        line_width: this.currentSelectedItems.element_data.line_width,
        opacity: 1,
        original_property: "",
        page_id: this.currentPageId,
        project_id: this.projectId,
        stroke_color: this.currentSelectedItems.element_data.stroke_color,
        toolbar_element_id: 20,
        updated_by_user_id: this.su.user_id,
        version_number: 1,
      };
      this.annotationUpdate();
    }
    // if (this.multipleSelectOn == true) {
    //   this.multiselectionList = [];
    //   // multiselection svg drawing empty place
    //   this.multiselectionList_svg_view = [];
    //   this.previousSelectAnnotation = [];
    //   if (this.annotationSelected == true) {
    //     this.multiselectionList.push(this.currentSelectedAnnotationData);

    //     this.multipleAnnotationCall(this.currentSelectedAnnotationData);
    //   }
    //   this.panZoomController.pause();
    //   console.log('multiple selected');
    //   if (this.moveElementValue == true) {
    //     if (this.multiselectionList.length > 0) {
    //       let getElement = document.getElementById(this.multiselectionList[0].annotation_id);
    //       getElement.setAttribute('multimoving', "1");
    //       if (this.multiselectionList[0].annotation_label != "") {
    //         this.getMultipleMovingLabelElement(this.multiselectionList[0].annotation_id);
    //       }
    //       this.createDocumentStore.selectedAnnotations.push(this.multiselectionList[0].annotation_id);
    //       let tempArray = this.createDocumentStore.selectedAnnotations;
    //       this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
    //         return index === self.indexOf(elem);
    //       })
    //       this.multipleAnnotationCallAPI();
    //     }
    //     this.captureEventsMove();
    //   }
    //   else {
    //     this.captureEventsMultiple();
    //   }
    // }
  }

  calculateRectPos(startX, startY, endX, endY) {
    var width = endX - startX;
    var height = endY - startY;
    var posX = startX;
    var posY = startY;

    if (width < 0) {
      width = Math.abs(width);
      posX -= width;
    }

    if (height < 0) {
      height = Math.abs(height);
      posY -= height;
    }
    return {
      left: parseInt(posX),
      top: parseInt(posY),
      width: width,
      height: height,
    };
  }

  checkIconSizeandPages() {
    for (var ak = 0; ak < this.documentDetails.length; ak++) {
      if (this.documentDetails[ak].page_id == this.currentPageId) {
        var getLocalValue = this.encrptdecrpt.getItem("setBaseiconSize");
        if (getLocalValue["setBaseIconPagesAllowed"] != undefined) {
          for (var alok = 0; alok < getLocalValue["setBaseIconPagesAllowed"].length; alok++
          ) {
            if (this.documentDetails[ak].page_id == getLocalValue["setBaseIconPagesAllowed"][alok]) {
              this.setBaseIconSize = this.encrptdecrpt.getItem("setBaseiconSize");
            }
            else {
              this.setBaseIconSize = {
                setBaseIconSizeHeight: "35",
                setBaseIconSizeWidth: "35",
              };
            }
          }
        }
      }
    }
  }

  async getAnnotationForm1(getLayerData) {

    console.log(getLayerData);
    var layerRemovedFilter = getLayerData.filter(
      (data) => data.is_removed == false || data.is_removed == "false"
    );
    var annotations = [];
    for (var i = 0; i < layerRemovedFilter.length; i++) {
      annotations = [];
      for (var j = 0; j < layerRemovedFilter[i].annotations.length; j++) {
        if (layerRemovedFilter[i].annotations[j].is_removed == false ||
          layerRemovedFilter[i].annotations[j].is_removed == "false") {
          annotations.push(layerRemovedFilter[i].annotations[j]);
        } else {
          console.log(layerRemovedFilter[i].annotations[j]);
        }
      }
      layerRemovedFilter[i].annotations = annotations;
    }
    this.layerDatas = layerRemovedFilter;
    console.log(this.layerDatas);
    if (this.layerEnable == true) {
      let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
      let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: this.checkedAnnotationIdsBackup, currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
      console.log(data);

      this.dataService2.layerDatafromnavigation.emit(data);
    }
    this.getActiveLayerId();
  }

  hidesliderArray = [];

  @ViewChild("widgetsContent") widgetsContent: ElementRef;

  hidePrevious() {
    this.widgetsContent.nativeElement.scrollLeft -= 80;
    this.widgetsContent.nativeElement.style.scrollBehaviour = "smooth";
  }

  visibleHideArray: any[] = [];

  hideNext() {
    
    this.widgetsContent.nativeElement.scrollLeft += 80;
    this.widgetsContent.nativeElement.style.scrollBehaviour = "smooth";
  }

  hidePreviousUp() {
    this.widgetsContent.nativeElement.scrollTop -= 86;
    this.widgetsContent.nativeElement.style.scrollBehaviour = "smooth";
  }

  hideNextDown() {
    this.widgetsContent.nativeElement.scrollTop += 86;
    this.widgetsContent.nativeElement.style.scrollBehaviour = "smooth";
  }

  // }

  dragScrollAction() {
    const slider = document.querySelector(".items");
    let isDown = false;
    let startX;
    let scrollLeft;

    slider.addEventListener("mousedown", (e: any) => {
      isDown = true;
      slider.classList.add("active");
      startX = e.pageX - slider.clientLeft;
      scrollLeft = slider.scrollLeft;
      console.log(startX, scrollLeft);
    });
    slider.addEventListener("mouseleave", () => {
      isDown = false;
      slider.classList.remove("active");
    });
    slider.addEventListener("mouseup", () => {
      isDown = false;
      slider.classList.remove("active");
    });
    slider.addEventListener("mousemove", (e: any) => {
      if (!isDown) return;
      e.preventDefault();
      const x = e.pageX - slider.clientLeft;
      const walk = (x - startX) * 5; //scroll-fast
      slider.scrollLeft = scrollLeft - walk;
      console.log(walk);
    });

    slider.addEventListener("touchstart", (e: any) => {
      isDown = true;
      slider.classList.add("active");
      startX = e.pageX - slider.clientLeft;
      scrollLeft = slider.scrollLeft;
      console.log(startX, scrollLeft);
    });
    slider.addEventListener("touchend", () => {
      isDown = false;
      slider.classList.remove("active");
    });
    slider.addEventListener("touchmove", (e: any) => {
      if (!isDown) return;
      e.preventDefault();
      const x = e.pageX - slider.clientLeft;
      const walk = (x - startX) * 5; //scroll-fast
      slider.scrollLeft = scrollLeft - walk;
      console.log(walk);
    });
  }

  shapeDrawingrapidShotMode() {
    console.log(this.createJson);
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("id", this.createJson["annotation_id"]);
    console.log(this.createJson["annotation_id"]);
    newcreatedElement.addEventListener("click", (e: any) => {
      this.canvasClick(e);
    });
    newcreatedElement.setAttribute("width", this.createJson["initial_width"]);
    newcreatedElement.setAttribute("height", this.createJson["initial_height"]);
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = this.createJson["initial_position_y"] + "px";
    newcreatedElement.style.left = this.createJson["initial_position_x"] + "px";
    newcreatedElement.style.marginLeft = "-25px";
    newcreatedElement.style.marginTop = "-25px";
    newcreatedElement.style.backgroundColor = "transparent";
    newcreatedElement.style.border = "2px solid transparent";
    if (this.copyAnnotationCreatePageValue == true) {
      newcreatedElement.style.backgroundColor = "rgba(0,0,255,0.3)";
      newcreatedElement.style.border = "2px dashed blue";
    }
    newcreatedElement.style.zIndex = "99";
    newcreatedElement.style.transform = "scale(" + 0.5 + ")" + " " + "rotate(" + this.createJson["initial_rotation"] + "deg)";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    this.createJson["annotation_data"] = this.createJson["annotation_data"].trim();
    var spaceSplit = this.createJson["annotation_data"].split(" ");

    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");

      for (var j = 0; j < hypenSplit.length; j++) {
        if (hypenSplit[0] == "controlpoint" && j == 1) {
          var colonSplit = hypenSplit[j].split(":");
          var cpx = parseFloat(colonSplit[0]);
          var cpy = parseFloat(colonSplit[1]);
        }
        // "move-10:25 line-22:25 line-22:19 controlpoint-22:16 curveEnd-25:16 line-37:16 controlpoint-40:16 curveEnd-40:19 line-40:31 controlpoint-40:34 curveEnd-37:34 line-25:34 controlpoint-22:34 curveEnd-22:31 line-22:25";

        if (hypenSplit[0] == "curveEnd" && j == 1) {
          var colonSplit = hypenSplit[j].split(":");
          var ex = parseFloat(colonSplit[0]);
          var ey = parseFloat(colonSplit[1]);
        }
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var colonSplit = hypenSplit[j].split(":");
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var h = parseFloat(colonSplit[2]);
          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            // this.canvasElement.drawImage(urlImg,this.coordinateX,this.coordinateX)
            this.canvasElement.moveTo(x, y);
            break;
          case "line":
            this.canvasElement.clearRect(
              0,
              0,
              newcreatedElement.width,
              newcreatedElement.height
            );
            this.canvasElement.lineTo(x, y);
            break;
          case "ovalIn":
            var r = (w * w) / (8 * h) + h / 2;
            this.canvasElement.arc(
              newcreatedElement.clientWidth / 2,
              newcreatedElement.clientHeight / 2.3,
              r,
              0,
              2 * Math.PI
            );
            break;
          case "curveEnd":
            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
            break;
        }
        this.canvasElement.lineWidth = this.createJson["line_width"];
        var checkFill = this.createJson["fill_color"];
        this.canvasElement.fillStyle = this.checkStrokeColor1(checkFill);
        this.canvasElement.fill();
        var checkStroke = this.createJson["stroke_color"];
        this.canvasElement.strokeStyle = this.checkStrokeColor1(checkStroke);
        this.canvasElement.stroke();
      }
    }
    if (this.rapidShotModeOn == true) {
      this.layerUpdaterapidShotModeData();
    }
  }

  layerUpdaterapidShotModeData() {
    let layers = [];
    if (this.layerDatas != undefined) {
      this.layerDatas.forEach((data) => {
        if (data.layer_id === this.activeLayerIdDraw) {
          data.annotations.push(this.createJson);
          layers.push(data);
        } else {
          layers.push(data);
        }
      });
      this.layerDatas = layers;
      console.log(this.createJson);
      console.log(this.layerDatas);



      // console.log(this.layerDatas);
      // this.documentService.annotationUpdateAUC(layers).subscribe((response) => {
      //   this.doSomething();
      //   console.log(response);
      //   this.getAnnotationForm();
      //   this.show = false;
      //   this.getPositionString = "";
      //   this.stringPathArray = [];
      //   this.getPositionSetMove = 1;
      // });
    }
  }

  rapidShotModeUpdateAPI() {
    this.rapidShotModeOn = false;
    this.drawFunctionActive = false;
    this.getPositionActive = false;
    this.receiveString = "";
    // this.documentService
    //   .annotationUpdateAUC(this.layerDatas)
    //   .subscribe((response) => {
    //     console.log(response);
    //   });
  }
  setScaleChange(event) {
    this.setscaleValue = event;
  }

  shapeDrawingcopyAnnotation() {
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("id", this.createJson["annotation_id"]);
    console.log(this.createJson["annotation_id"]);
    newcreatedElement.addEventListener("click", (e: any) => {
      this.canvasClick(e);
    });
    newcreatedElement.setAttribute("width", this.createJson["initial_width"]);
    newcreatedElement.setAttribute("height", this.createJson["initial_height"]);
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = this.createJson["initial_position_y"] + "px";
    newcreatedElement.style.left = this.createJson["initial_position_x"] + "px";
    newcreatedElement.style.marginLeft = "-25px";
    newcreatedElement.style.marginTop = "-25px";
    pdfImg.appendChild(newcreatedElement);
    this.canvasElement = newcreatedElement.getContext("2d");
    this.canvasElement.beginPath();
    this.createJson["annotation_data"] = this.createJson["annotation_data"].trim();
    var spaceSplit = this.createJson["annotation_data"].split(" ");

    for (var i = 0; i < spaceSplit.length; i++) {
      var hypenSplit = spaceSplit[i].split("-");

      for (var j = 0; j < hypenSplit.length; j++) {
        if (hypenSplit[0] == "controlpoint" && j == 1) {
          var colonSplit = hypenSplit[j].split(":");
          var cpx = parseFloat(colonSplit[0]);
          var cpy = parseFloat(colonSplit[1]);
        }
        // "move-10:25 line-22:25 line-22:19 controlpoint-22:16 curveEnd-25:16 line-37:16 controlpoint-40:16 curveEnd-40:19 line-40:31 controlpoint-40:34 curveEnd-37:34 line-25:34 controlpoint-22:34 curveEnd-22:31 line-22:25";

        if (hypenSplit[0] == "curveEnd" && j == 1) {
          var colonSplit = hypenSplit[j].split(":");
          var ex = parseFloat(colonSplit[0]);
          var ey = parseFloat(colonSplit[1]);
        }
        if (
          j == 1 &&
          hypenSplit[0] != "curveEnd" &&
          hypenSplit[0] != "controlpoint"
        ) {
          var colonSplit = hypenSplit[j].split(":");
          var x = parseFloat(colonSplit[0]);
          var y = parseFloat(colonSplit[1]);
          var h = parseFloat(colonSplit[2]);
          var w = parseFloat(colonSplit[3]);
        }
        switch (hypenSplit[0]) {
          case "move":
            // this.canvasElement.drawImage(urlImg,this.coordinateX,this.coordinateX)
            this.canvasElement.moveTo(x, y);
            break;
          case "line":
            this.canvasElement.clearRect(
              0,
              0,
              newcreatedElement.width,
              newcreatedElement.height
            );
            this.canvasElement.lineTo(x, y);
            break;
          case "ovalIn":
            var r = (w * w) / (8 * h) + h / 2;
            this.canvasElement.arc(
              newcreatedElement.clientWidth / 2,
              newcreatedElement.clientHeight / 2.3,
              r,
              0,
              2 * Math.PI
            );
            break;
          case "curveEnd":
            this.canvasElement.quadraticCurveTo(cpx, cpy, ex, ey);
            break;
        }
        this.canvasElement.lineWidth = this.createJson["line_width"];
        var checkFill = this.createJson["fill_color"];
        if (this.createJson["fill_color"] != "clear") {
          this.canvasElement.fillStyle = this.checkStrokeColor1(checkFill);
          this.canvasElement.fill();
        }
        var checkStroke = this.createJson["stroke_color"];
        this.canvasElement.strokeStyle = this.checkStrokeColor1(this.createJson["stroke_color"]);
        this.canvasElement.stroke();
      }
    }
    this.layerUpdateCopyAnnotationData();
  }

  layerUpdateCopyAnnotationData() {
    this.drawFunctionActive = false;
    this.receiveString = "";
    let getCanvasElement = document.querySelectorAll("canvas");
    for (var i = 0; i < getCanvasElement.length; i++) {
      if (
        getCanvasElement[i].getAttribute("customeMultiSelectAttribute") != null
      ) {
        getCanvasElement[i].style.border = "2px solid transparent";
      }
    }
    let layers = [];
    if (this.layerDatas != undefined) {
      this.layerDatas.forEach((data) => {
        if (data.layer_id === this.activeLayerIdDraw) {
          data.annotations.push(this.createJson);
          layers.push(data);
        } else {
          layers.push(data);
        }
      });
      this.layerDatas = layers;
      console.log(this.createJson);
      console.log(this.layerDatas);
    }
  }

  updateMultiselect() {
    this.copyAnnotationStart = false;
    // this.showMultiSelectFooter = false;
    this.singleCopyAnnotation = false;
    this.multipleSelectOn = false;
    this.dataService2.imageChangeDocHeader.emit();
    // this.getAnnotationFormafterMulti();
    this.documentService
      .annotationUpdateAUC(this.layerDatas)
      .subscribe((response) => {
        console.log(response);
      });
  }

  setScaleChecked: boolean = false;

  setScaleMethod() {
    if (this.showvisible == false) {
      const dialogRef = this.dialogBox.open(ClayeralertComponent, {
        data: {
          lock: false
        }
      })
      this.dataService2.setScaleTrigger.emit(false);
      return
    }
    this.setScaleOn = true;
    this.drawShapeDonePolygon = false;
    this.drawFreehandMenu = false;
    this.drawShapeDonePolyline = false;
    this.drawShapeDonePolylineArrow = false;
    this.accessLineAxialMenuFeatureStop = true;
    // disable drag scroll
    this.createDocumentStore.disable_drag_scroll = true;
    // check all page check box true of false
    let get_local_scale = this.encrptdecrpt.getItem("scale_allpages");
    if (get_local_scale != null) {
      this.checkAllPageSetScaleStatus = get_local_scale;
    }
    // local storage does not have scale values yet to store
    else {
      this.checkAllPageSetScaleStatus = true;
    }
    this.panZoomController.pause();
    this.drawLineAxialMethodSVG();
  }

  checkAllPagesSetScale(event) {
    console.log(event.target.checked);
    if (event.target.checked == true) {
      this.checkAllPageSetScaleStatus = true;
      this.encrptdecrpt.setItem("scale_allpages", true);
    } else {
      this.checkAllPageSetScaleStatus = false;
      this.encrptdecrpt.setItem("scale_allpages", false);
    }
  }

  setScaleActivated() {
    //Jose need to add set scale logic here
    if (this.setScaleOn == true) {
      this.setScaleOn = false;
      this.createDocumentStore.disable_drag_scroll = false;
      this.dataService2.setScaleTrigger.emit(false);
      if (this.checkAllPageSetScaleStatus == true) {
        console.log("All Pages");
        let filter_current_page = this.documentDetails.findIndex((page_in) => page_in.page_id == this.currentPageId);
        if (filter_current_page > -1) {
          let pageid = this.documentDetails[filter_current_page].page_id;
          let scalevalue = this.setscaleValue;
          this.getScaleValue = [];
          let scale_instance = new scale_locator(pageid, scalevalue);
          this.getScaleValue.push(scale_instance);
        }
      } else {
        let filter_current_page = this.documentDetails.findIndex((page_in) => page_in.page_id == this.currentPageId);
        if (filter_current_page > -1) {
          let pageid = this.documentDetails[filter_current_page].page_id;
          let scalevalue = this.setscaleValue;
          this.getScaleValue = [];
          let scale_instance = new scale_locator(pageid, scalevalue);
          this.getScaleValue.push(scale_instance);
        }
      }
      this.currentpageid1 = this.currentPageId;
      var annotation_ids = [];
      //Remove 0 from annotation media and other array
      console.log(this.layerDatas);
      for (let i = 0; i < this.layerDatas.length; i++) {
        let annotation_from_layer = this.layerDatas[i].annotations
        annotation_from_layer = annotation_from_layer.filter((data) => data.annotation_id.includes("-scale"));
        let annotation_from_layers = _.cloneDeep(annotation_from_layer);

        for (let j = 0; j < annotation_from_layers.length; j++) {
          if (annotation_from_layers[j].annotation_links == undefined || typeof annotation_from_layers[j].annotation_links == 'number') {
            annotation_from_layers[j].annotation_links = []
          }
          if (annotation_from_layers[j].annotation_media == undefined || typeof annotation_from_layers[j].annotation_media == 'number') {
            annotation_from_layers[j].annotation_media = []
          }
          if (annotation_from_layers[j].annotation_stubs == undefined || typeof annotation_from_layers[j].annotation_stubs == 'number') {
            annotation_from_layers[j].annotation_stubs = []
          }
          if (annotation_from_layers[j].annotation_forms == undefined || typeof annotation_from_layers[j].annotation_forms == 'number') {
            annotation_from_layers[j].annotation_forms = []
          }
          annotation_from_layers[j].is_removed = true;
          annotation_from_layers[j].last_updated_date = new Date();
          annotation_ids.push(annotation_from_layers[j].annotation_id);
        }
        if (this.layerDatas[i].layer_id === this.activeLayerIdDraw) {
          let scaleAnns = this.prepareScaleAnnotationPayload();
          annotation_ids = [...annotation_ids, ...scaleAnns.annotations_to_update]
          annotation_from_layers = [...annotation_from_layers, ...scaleAnns.scale_annotations]
        }
        this.layerDatas[i].annotations = annotation_from_layers;
      }
      this.documentService.anotupdMulAnnotations(this.layerDatas, annotation_ids, this.activeLayerIdDraw).subscribe((response) => {
        this.setscaleValue = 0
        console.log(response);
        this.show = true;
        this.removeCanvasAttribute('customeLineAxialAttribute');
        this.getAnnotationForm();
      })
      // this.updateLineAxialDrawShapes();
    }
    else {
      this.setscaleValue = 0
      this.setScaleOn = false;
      this.dataService2.setScaleTrigger.emit(false);
      this.removeCanvasAttribute('customeLineAxialAttribute');
      this.createDocumentStore.disable_drag_scroll = false;
    }

  }

  clearscale() {
    this.setscaleValue = 0
    this.setScaleOn = false;
    this.dataService2.setScaleTrigger.emit(false);
    this.removeCanvasAttribute('customeLineAxialAttribute');
    this.createDocumentStore.disable_drag_scroll = false;
  }

  prepareScaleAnnotationPayload() {
    let scale_annotations = []
    let annotationsToUpdate = []
    let height = 1
    let width = 1
    if (this.stringPathArray.length > 1) {
      let moveString = this.stringPathArray[0].split("-")[1];
      let lineString = this.stringPathArray[1].split("-")[1];
      width = Number(lineString.split(":")[0]) - Number(moveString.split(":")[0])
      height = Number(lineString.split(":")[1]) - Number(moveString.split(":")[1])
      width = width < 0 ? -(width) : width;
      height = height < 0 ? -(height) : height;
    }
    if (width == null) {
      width = 0;
    }
    if (height == null) {
      height = 0;
    }
    var MyDateString = new Date().toISOString();
    let annotationURL = { "scaleValue": this.setscaleValue.toString(), "scaleAgainst": { "height": height, "width": width } }
    if (this.checkAllPageSetScaleStatus) {
      for (var i = 0; i < this.documentDetails.length; i++) {
        var annontationidDate = new Date().getTime();
        var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate + "-scale";
        let create_scale_Json = {
          annotation_data: this.stringPathArray.join(" "),
          annotation_forms: [],
          annotation_id: uuid,
          annotation_label: "",
          annotation_links: [],
          annotation_media: [],
          annotation_name: "",
          annotation_stubs: [],
          annotation_tags: "",
          annotation_url: annotationURL,
          created_by_user_id: this.su.user_id,
          created_date: MyDateString,
          document_id: this.folderId,
          element_size: this.setscaleValue,
          fill_color: "red",
          initial_height: 0,
          initial_position_x: 0,
          initial_position_y: 0,
          initial_width: 0,
          initial_rotation: 0,
          is_removed: false,
          last_updated_date: MyDateString,
          layer_id: this.activeLayerIdDraw,
          line_width: 2.0,
          opacity: 1,
          page_id: this.documentDetails[i].page_id,
          project_id: this.projectId,
          stroke_color: "red",
          toolbar_element_id: 16,
          version_number: 1,
        };
        annotationsToUpdate.push(uuid)
        scale_annotations.push(create_scale_Json)
      }
    } else {
      var annontationidDate = new Date().getTime();
      var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate + "-scale";
      let create_scale_Json = {
        annotation_data: this.stringPathArray.join(" "),
        annotation_forms: [],
        annotation_id: uuid,
        annotation_label: "",
        annotation_links: [],
        annotation_media: [],
        annotation_name: "",
        annotation_stubs: [],
        annotation_tags: "",
        annotation_url: annotationURL,
        created_by_user_id: this.su.user_id,
        created_date: new Date().getUTCDate(),
        document_id: this.folderId,
        element_size: this.setscaleValue,
        fill_color: "red",
        initial_height: 0,
        initial_position_x: 0,
        initial_position_y: 0,
        initial_width: 0,
        initial_rotation: 0,
        is_removed: false,
        last_updated_date: new Date().getUTCDate(),
        layer_id: this.activeLayerIdDraw,
        line_width: 2.0,
        opacity: 1,
        page_id: this.currentPageId,
        project_id: this.projectId,
        stroke_color: "red",
        toolbar_element_id: 16,
        version_number: 1,
      };
      annotationsToUpdate.push(uuid)
      scale_annotations.push(create_scale_Json)
    }
    return { "scale_annotations": scale_annotations, "annotations_to_update": annotationsToUpdate }
  }

  checkOpacity() {
    this.attribute_change = true;
    this.checkShapeBoxOpen();
    let getlineElement = (<HTMLInputElement>document.getElementById("opacityId"));
    console.log(getlineElement.value);
    if (getlineElement.value != "") {
      var value = Number(getlineElement.value);
    }
    else if (getlineElement.value == "") {
      getlineElement.value = "";
    }
    console.log(value);
    if (value != null && getlineElement.value != "" && value != undefined) {
      if (value < 0) {
        console.log('0 below', value);
        this.opacityValue = 0.1;
        getlineElement.value = "0.1";
        this.changeOpacity(this.opacityValue);
      }
      else if (value > 1) {
        console.log('1 above', value);
        this.opacityValue = 1;
        getlineElement.value = "1";
        this.changeOpacity(this.opacityValue);
      }
      else {
        console.log('between', value);
        getlineElement.value = value.toString();
        this.opacityValue = value;
        this.changeOpacity(this.opacityValue);
      }
    }
  }

  stop(event, value) {
    console.log(event.code, value)
    if (event.code == "KeyE") {
      event.preventDefault();
    }
  }

  checklineWidth() {
    var getlineElement = (<HTMLInputElement>document.getElementById("lineWidthId"));
    console.log(getlineElement.value);
    if (getlineElement.value != "") {
      var value = Number(getlineElement.value);

    }
    else if (getlineElement.value == "") {
      getlineElement.value = "";
    }
    console.log(value);
    if (value != null && getlineElement.value != "" && value != undefined) {
      if (value < 0) {
        console.log('0 below', value);
        this.lineWidth = 1;
        getlineElement.value = "1";
        this.changeLinewidth(this.lineWidth.toFixed(Number, 2));
      }
      else if (value > 50) {
        console.log('50 above', value);
        this.lineWidth = 50;
        getlineElement.value = "50";
        this.changeLinewidth(this.lineWidth.toFixed(Number, 2));
      }
      else {
        console.log('between', value);
        getlineElement.value = value.toString();
        this.lineWidth = value;
        this.changeLinewidth(this.lineWidth.toFixed(Number, 2));
      }
    }
  }

  async deselectAnnotation(event?) {
    //remove movelementvalue condition reason when move option cannot deselect annotation
    console.log("called deselect mousedown");
    if (this.annotationSelected == true && this.optionClick == false && this.layersClick == false
      && this.moreOptionClick == false && this.showcopyAnnotationOption == false &&
      this.deleteOptionClick == false &&
      this.drawFunctionActive == false && this.copyAnnotationCreatePageValue == false
      && this.createDocumentStore.enableresizeButtons == false
      && this.createDocumentStore.enablerepointButtons == false && this.moveElementValue == false) {
      console.log("called second mousedown inside");
     
      let getAllCanvas = document.querySelectorAll("svg.svg-block");
      getAllCanvas.forEach((data) => {
          data.classList.remove('svg-block');
      });
      const components = Array.prototype.filter.call(
        document.querySelectorAll('*'),
        e => e.id.toLowerCase().startsWith('media')
      )
      components.forEach((data) => {
        data.setAttribute("d", "");
      });
      //svg-block-orange
      if(this.alignAnnEnabled == false){
        let getAllCanvas1 = document.querySelectorAll("svg.svg-block-orange");
        getAllCanvas1.forEach((data) => {
          data.classList.remove('svg-block-orange');
        });
      }
      let borderElement = document.querySelectorAll("path.line-border");
      if(borderElement.length > 0){
        this.borderLinePresent = false;
        this.lineDraw = false;
        borderElement.forEach((data) => {
          // data.classList.remove('line-border');
          data.setAttribute("d","");
        });
      }

      this.changeArrow = false;
      this.annotationSelected = false;
      this.showFiller = false;
      this.getId = "";
      let truvalue = { form: this.form, media: this.media, links: this.links, tags: this.tags, properties: this.properties };
      console.log(truvalue);
      this.formContentleft = [];
      this.formContentright = []
      this.formCount = 0;
      this.mediaCount = 0;
      this.linkCount = 0;
      this.tagCount = 0;
      this.useCaseEmptycellIds = []
      this.hideSelectForm = false;
      this.layersClick = false;
      if (this.searchAnnotationAllow == true || this.checkedAnnotationAllow == true) {
        this.dataService.imageChangeDocHeader.emit(false);
      }
      this.previousSelectAnnotation = [];
      //checkbox click action
      this.checkedAnnotationIdsBackup = [];
      this.currentSelectedAnnotationData = {};

      let layerCheckDatas = { option: this.multipleSelectOn, id: "" };
      this.dataService.layerCheckBoxClick.emit(layerCheckDatas);
      if (this.searchOption == true) {
        this.dataService.getannotationid.emit("");
      }
    } else if (this.copyAnnotationCreatePageValue) {
      console.log("called second mousedown inside");

      let getAllCanvas = document.querySelectorAll("svg.svg-block");
      getAllCanvas.forEach((data: HTMLElement) => {
        data.classList.remove('svg-block');
      });

      const components = Array.prototype.filter.call(
        document.querySelectorAll('*'),
        e => e.id.toLowerCase().startsWith('media')
      )
      components.forEach((data) => {
        data.setAttribute("d", "");
      });
      
      this.changeArrow = false;
      this.annotationSelected = false;
      this.showFiller = false;
      let truvalue = { form: this.form, media: this.media, links: this.links, tags: this.tags, properties: this.properties };
      console.log(truvalue);
      this.formCount = 0;
      this.mediaCount = 0;
      this.linkCount = 0;
      this.tagCount = 0;
      this.hideSelectForm = false;
      this.layersClick = false;
      if (this.searchAnnotationAllow == true || this.checkedAnnotationAllow == true) {
        this.dataService.imageChangeDocHeader.emit(false);
      }
      this.previousSelectAnnotation = [];
      //checkbox click action
      this.checkedAnnotationIdsBackup = [];
      let layerCheckDatas = { option: this.multipleSelectOn, id: "" };
      this.dataService.layerCheckBoxClick.emit(layerCheckDatas);
      if (this.searchOption == true) {
        this.dataService.getannotationid.emit("");
      }
    }
    else if (this.annotationSelected == false && this.optionClick == false && this.layersClick == false
      && this.moreOptionClick == false && this.showcopyAnnotationOption == false &&
      this.deleteOptionClick == false &&
      this.drawFunctionActive == false && this.copyAnnotationCreatePageValue == false
      && this.createDocumentStore.enableresizeButtons == false
      && this.createDocumentStore.enablerepointButtons == false && this.moveElementValue == false) {
      console.log("called second mousedown inside");

      let getAllCanvas = document.querySelectorAll("svg.svg-block");
      getAllCanvas.forEach((data) => {
        data.classList.remove('svg-block');
      });

      //svg-block-orange
      if(this.alignAnnEnabled == false){
        let getAllCanvas1 = document.querySelectorAll("svg.svg-block-orange");
        getAllCanvas1.forEach((data) => {
          data.classList.remove('svg-block-orange');
        });
      }

      const components = Array.prototype.filter.call(
        document.querySelectorAll('*'),
        e => e.id.toLowerCase().startsWith('media')
      )
      components.forEach((data) => {
        data.setAttribute("d", "");
      });
      

      this.changeArrow = false;
      this.annotationSelected = false;
      this.showFiller = false;
      this.getId = "";
      let truvalue = { form: this.form, media: this.media, links: this.links, tags: this.tags, properties: this.properties };
      console.log(truvalue);
      this.formCount = 0;
      this.mediaCount = 0;
      this.linkCount = 0;
      this.tagCount = 0;
      this.hideSelectForm = false;
      this.layersClick = false;
      if (this.searchAnnotationAllow == true || this.checkedAnnotationAllow == true) {
        this.dataService.imageChangeDocHeader.emit(false);
      }

      this.previousSelectAnnotation = [];
      //checkbox click action
      this.checkedAnnotationIdsBackup = [];
      this.currentSelectedAnnotationData = {};

      let layerCheckDatas = { option: this.multipleSelectOn, id: "" };
      this.dataService.layerCheckBoxClick.emit(layerCheckDatas);
      if (this.searchOption == true) {
        this.dataService.getannotationid.emit("");
      }
    }
    if(this.copymultiannenabled == true){
      this.selectedAnnotationLength = this.copyAnnotationDatas.length;
    }
  }

  focusOutlinewidth() {
    let getlineElement = (<HTMLInputElement>document.getElementById("lineWidthId"));
    console.log(getlineElement.value);
    if (Number(getlineElement.value) == 0 || getlineElement.value == "") {
      getlineElement.value = this.backupLinewidth;
      this.lineWidth = this.backupLinewidth;
      this.changeLinewidth(this.lineWidth);
    }
  }

  focusOutopacity() {
    let getlineElement = (<HTMLInputElement>document.getElementById("opacityId"));
    console.log(getlineElement.value);
    if (Number(getlineElement.value) == 0 || getlineElement.value == "") {
      getlineElement.value = this.backupOpacity;
      this.opacityValue = this.backupOpacity;
      this.changeOpacity(this.opacityValue);
    }
  }
  checkNumbersOnly(event) {
    console.log(event);
    // prevent: "e", "=", ",", "-",
    if ([69, 187, 188, 189].includes(event.keyCode)) {
      event.preventDefault();
    }
  }
  arrSingleSelectionHistory = []
  async single_annotation_selection(event) {
    
    // if (this.attribute_change == true) {
    //   await this.attribute_value_changes();
    // }
    // // form local changes update to api
    // await this.automatic_update_form();
    let get_mousedown_element = document.getElementById('pdfImg');
    if (get_mousedown_element != null) {
      // const rect = get_mousedown_element.getBoundingClientRect();
      // let initialX = event.clientX;
      // let initialY = event.clientY;
      // let clickPosition = {
      //   x: initialX - rect.left,
      //   y: initialY - rect.top,
      // };
      // let local_scale = this.pngFormat ? this.scale : this.pdfScaleValue > 1 ? this.pdfScaleValue : this.scale;
      // let clickPositionX = clickPosition.x / local_scale;
      // let clickPositionY = clickPosition.y / local_scale;

      // getElement Position of custome shapes plotting
      let local_scale = 1;
      if (this.pngFormat == true) {
        // no need of scaling image formats so will assign 1 value 10/1 = 10 same value;
        local_scale = 1;
      }
      else {
        // scaling only need zoom level of above 1
        local_scale = this.pdfScaleValue >= 1 ? this.pdfScaleValue : 1;
      }
      // scaling calculation divide the click x and y position
      let clickPositionX = event.offsetX;
      let clickPositionY = event.offsetY;
      let getAllCanvasElements = document.querySelectorAll('svg.documentSVG');
      var filterCanvas = [];
      // console.log(getAllCanvasElements);
      let small_width_height = [];
      for (let ma = 0; ma < getAllCanvasElements.length; ma++) {
        let getAllElementsXY: any = getAllCanvasElements[ma];
        let getStyle = getComputedStyle(getAllElementsXY);
        let getLeft: any = getStyle.left;
        getLeft = getLeft.substring(getLeft.length - 2, 0);
        let getTop: any = getStyle.top;
        getTop = getTop.substring(getTop.length - 2, 0);
        let getWidth: any = getStyle.width;
        getWidth = getWidth.substring(getWidth.length - 2, 0);
        let getHeight: any = getStyle.height;
        getHeight = getHeight.substring(getHeight.length - 2, 0);

        let get_margin_left: any = getStyle.marginLeft;
        get_margin_left = get_margin_left.substring(get_margin_left.length - 2, 0);
        let get_margin_top: any = getStyle.marginTop;
        get_margin_top = get_margin_top.substring(get_margin_top.length - 2, 0);
        let checkBoundingBox = false;
        getLeft = Number(getLeft) + Number(get_margin_left);
        getTop = Number(getTop) + Number(get_margin_top);
        getWidth = Number(getWidth);
        getHeight = Number(getHeight);
        let EndPointX = getLeft + getWidth;
        let EndPointY = getTop + getHeight;
        let getatt = getAllCanvasElements[ma].getAttribute('id');
        console.log(getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY)
        if (getatt != null && getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY) {
          let generate_Object = new Object();
          generate_Object['width'] = getWidth;
          generate_Object['height'] = getHeight;
          generate_Object['filterelement'] = getAllCanvasElements[ma];
          filterCanvas.push(generate_Object);
        }
      }
      if ((filterCanvas.length == 1 && event.which == 3) || (filterCanvas.length == 1 && event.which == 1)) {
        let getId = filterCanvas[0].filterelement.getAttribute('id');
        if (getId.includes('GroupAnno-borderbox')) {
          if (filterCanvas.length == 1 && event.which == 1) {
            return
          }
          const dialogRef = this.dialogBox.open(ClayeralertComponent, {
            data: {
              delete: true,
              id: getId
            }
          });
          return
        }
      }
      var copy_filterCanvas = _.cloneDeep(filterCanvas);
      if(filterCanvas.length > 1){
        for(let i = 0; i < filterCanvas.length; i++){
          // let getId = filterCanvas[i].getAttribute('id');
          filterCanvas = filterCanvas.filter(id => !id.filterelement.getAttribute('id').includes('GroupAnno-borderbox'));
          console.log(filterCanvas)
        }
        if(filterCanvas.length == 0){
          filterCanvas.push(copy_filterCanvas[0]);
          let getId = filterCanvas[0].filterelement.getAttribute('id');
          const dialogRef = this.dialogBox.open(ClayeralertComponent, {
            data: {
              delete: true,
              id: getId
            }
          });
          return
        }
      }
      if (filterCanvas.length == 2) {
        for (let i = 0; i < filterCanvas.length; i++) {
          let getId = filterCanvas[i].filterelement.getAttribute('id');
          if (getId.includes('GroupAnno-borderbox')) {
            filterCanvas.splice(i, 1)
          }
        }
      }
      if (filterCanvas.length > 2) {
        let new_filtercanvas = []
        filterCanvas.forEach((canvas) => {
          if (!this.arrSingleSelectionHistory.includes(canvas.filterelement.getAttribute('id'))) {
            new_filtercanvas.push(canvas)
          }
        })
        if (new_filtercanvas.length == 0) {
          this.arrSingleSelectionHistory = [];
        } else {
          filterCanvas = new_filtercanvas
        }
      } else {
        this.arrSingleSelectionHistory = [];
      }
      var alreadyExist_annotation = false;
      if (this.createDocumentStore.single_select_annotation.length == 0 && filterCanvas.length > 0) {
        filterCanvas = filterCanvas.sort((a, b) => (a.width > b.width) ? 1 : ((b.width > a.width) ? -1 : 0));
        let annotId = filterCanvas[0].filterelement.getAttribute('id');
        if (filterCanvas.length > 2) {
          this.arrSingleSelectionHistory.push(annotId)
        }
        // this.getId = annotId;
        this.createDocumentStore.single_select_annotation.push(annotId);
        // this.colorBorder(filterCanvas[0].filterelement);
      }
      // else if(this.createDocumentStore.single_select_annotation.length!=0&&filterCanvas.length==1){
      //   let annotId = filterCanvas[0].getAttribute('id');
      //   this.getId = annotId;
      //   this.createDocumentStore.single_select_annotation = [];
      //   this.createDocumentStore.single_select_annotation.push(annotId);
      //   this.colorBorder(filterCanvas[0]);
      // }
      else if (this.createDocumentStore.single_select_annotation.length != 0 && filterCanvas.length > 0) {
        var canExecute = true;
        filterCanvas = filterCanvas.sort((a, b) => (a.width > b.width) ? 1 : ((b.width > a.width) ? -1 : 0));
        let cloneFilterCVanvas = _.cloneDeep(filterCanvas);
        for (let f = 0; f < filterCanvas.length; f++) {
          if (canExecute == true) {
            if (this.arrSingleSelectionHistory.length == 0) {
              for (let g = 0; g < this.createDocumentStore.single_select_annotation.length; g++) {
                cloneFilterCVanvas = cloneFilterCVanvas.filter((canvas) => canvas.filterelement.getAttribute('id') != this.createDocumentStore.single_select_annotation[g]);
              }
            }
            if (cloneFilterCVanvas.length > 0) {

              let annotId = cloneFilterCVanvas[0].filterelement.getAttribute('id');
              this.createDocumentStore.single_select_annotation = [];
              // this.getId = annotId;
              this.arrSingleSelectionHistory.push(annotId)
              this.createDocumentStore.single_select_annotation.push(annotId);
              // this.colorBorder(cloneFilterCVanvas[0].filterelement);
              break;
            }
            else {
              alreadyExist_annotation = true;
              break;
            }
          }
        }
      }
      else if (filterCanvas.length == 0) {
        this.createDocumentStore.single_select_annotation = [];
      }// different annotation selection calling below condition
      if (this.createDocumentStore.single_select_annotation.length > 0 && alreadyExist_annotation == false) {
        if (this.attribute_change == true) {
          await this.attribute_value_changes();
        }
        // form local changes update to api
        // await this.automatic_update_form();
        // right click option check if condition
        // Is it there any form changes check
        await this.automatic_update_form_rightclick(event, false);
      }// deselect annotation calling below condition
      else if (alreadyExist_annotation == false) {
        // remove right click option because check if condition
        // if(event.which==3){
        //   this.canvasRightClick(event,this.createDocumentStore.single_select_annotation[0]);
        // }
        await this.attribute_value_changes();
        await this.automatic_update_form_rightclick(event, true);
        // this.deselectAnnotation();need
        // this.show = false;need
      }// already selected annotation right click hit calling below condition
      else if (alreadyExist_annotation == true) {
        // Is it there any form changes check
        await this.automatic_update_form_rightclick(event, false);
        // // right click option check if condition
        // if (event.which == 3) {
        //   this.canvasRightClick(event, this.createDocumentStore.single_select_annotation[0]);
        // }
      }
    }
  }



  annotation_selection(event?) {
    // The below boolean is added to hide the weld wmata add form
    this.formShow = false;
    this.createDocumentStore.isSingleClick = true;
    event.preventDefault();
    setTimeout(() => { 
      if(this.layerdata!=undefined && this.layerdata.length==0){
        event.preventDefault()
        return
      }
      if (this.createDocumentStore.isSingleClick) {
        console.log('single click');
        console.log(this.showvisible);
        // added disable method for freehand drawing getPosition and annotation_selection events Unnecessarily trigger
        if (this.drawFreehandMenu == true || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolyline == true ||
          this.drawShapeDoneLine == true || this.drawShapeDoneLineAxial == true || this.drawShapeDonePolygon == true
          || this.drawEllipseDone == true || this.drawRectangleDone == true || this.setScaleOn == true) {
          return;
        }
        this.annotation_click = true;
        if (event != undefined && this.multipleSelectOn == false && this.moveElementValue == false && this.createDocumentStore.enablerepointButtons == false) {
  
          if (this.rotateandresize == true &&  event.which == 3) {
            this.rotateresizewaringpopup(event); // rotate and resize when enable we can call current changes update to api then call select annotation function
          }
          else if(this.rotateandresize == true &&  event.which == 1){

          }
          else  {
            this.single_annotation_selection(event);
          }
          
          
        }
      }
    }, 250);
  }
  selectAnnotationZero() {
    this.annotationSelected = false;
    this.showFiller = false;
    this.formCount = 0;
    this.mediaCount = 0;
    this.linkCount = 0;
    this.tagCount = 0;
    this.selectedAnnotationLength = 0;
    this.hideSelectForm = false;
    // empty stored array values 
    this.checkTempList = [];
    this.sampleFormObject = [];
    this.modelFieldsForm = [];
    this.extend_modelFieldsForm = [];
    this.annotationLinks = [];
  }

  async getSearchAnnotationId(ids) {

    if (this.multipleSelectOn == false && ids.length > 0) {
      if (this.getId != "") {
        let getAllCanvas = document.getElementById(this.getId);
        if (getAllCanvas != null) {
          this.previousSelectAnnotation = [];
          this.previousSelectAnnotation.push(this.getId);
          this.transparentBorderSVG(getAllCanvas);
        }
      }
      let get_check_id = ids[0];
      this.getId = ids[0];
      let get_current_element = document.getElementById(this.getId);
      if (get_current_element != null) {
        this.previousSelectAnnotation = [];
        this.previousSelectAnnotation.push(this.getId);
        this.colorBorderSVG(get_current_element);
        this.canvasClick(this.getId);
      }
    }

    else if (this.multipleSelectOn == true && ids.length > 0) {

      let already_exist = this.createDocumentStore.selectedAnnotations.findIndex((data) => data === ids[0]);
      if (already_exist != -1) {
        this.getId = ids[0];
        let get_current_element = document.getElementById(this.getId);
        if (get_current_element != null) {
          let find_Multi_Removing = this.multiselectionList.filter((dataRes) => dataRes.annotation_id != this.createDocumentStore.selectedAnnotations[already_exist]);
          // need to work svg
          this.multiselectionList = find_Multi_Removing;
          // draw side bar multiple_annotations when local changes happened in the multiselection list 
          await this.drawing_multiple_annotations();
          this.createDocumentStore.selectedAnnotations.splice(already_exist, 1)
          this.transparentBorderSVG(get_current_element);
          this.get_Multiselection_Data_Count();
        }
      }
      else {
        this.getId = ids[0];
        this.createDocumentStore.selectedAnnotations.push(this.getId);
        let get_current_element = document.getElementById(this.getId);
        this.multipleAnnotationCallAPI();
        if (get_current_element != null) {
          this.colorBorderSVG(get_current_element);
        }
      }
    }
    // else if(this.multipleSelectOn==true&&ids.length==0){
    //   let last_count = this.createDocumentStore.selectedAnnotations.length;
    //   if()
    //   let get_last_select_element = document.getElementById(this.previousSelectAnnotation[0]);
    //   if(get_last_select_element!=null){
    //     this.transparentBorder(get_last_select_element);
    //   }
    //   this.previousSelectAnnotation = [];
    //   this.getId = "";
    // }

    // if (ids != '') {

    //   // for (let j = 0; j < getAllCanvas.length; j++) {
    //   // let getelementid = getAllCanvas[j].getAttribute('id');

    //   let searchedOne = document.getElementById(ids);
    //   let searchElementAddStyle = searchedOne as HTMLCanvasElement;
    //   this.colorBorder(searchElementAddStyle);
    //   // }
    // }
    // else {
    //   this.searchAnnotationAllow = false;
    //   console.log(this.searchAnnotationAllow)
    // }

  }

  lockchanges(refresh: any) {
    if (this.multipleSelectOn == true) {
      this.multiselectionList = [];
      this.previousSelectAnnotation = [];
      this.createDocumentStore.selectedAnnotations = [];
      this.selectAnnotationZero();
      if (this.moveElementValue == true) {
        this.moveAnnotationsStore = [];
      }

    }
    else {
      this.previousSelectAnnotation = [];
      this.createDocumentStore.single_select_annotation = [];
      if (this.moveElementValue == true) {
        this.moveAnnotationsStore = [];
      }
      this.createDocumentStore.selectedAnnotations = [];
      this.dataService.getannotationid.emit("");
      this.currentSelectedAnnotationData = {};
      this.annotationSelected = false;
      this.showFiller = false;
      this.formCount = 0;
      this.mediaCount = 0;
      this.linkCount = 0;
      this.tagCount = 0;
      this.getId = "";
      this.hideSelectForm = false;
      //media
      this.sampleFormObject = [];
      //tags
      this.annotationTags = [];
      //forms
      this.modelFieldsForm = [];
      this.extend_modelFieldsForm = [];
      //links
      this.annotationLinks = [];
    }

  }


  checkedAnnotationAllow: boolean = false;
  searchAnnotationAllow: boolean = false;

  getCheckedAnnotationId(ids) {
    let getIdOptionsA = ids;
    if (this.multipleSelectOn == false) {
      let getPreviousElement = document.getElementById(this.getId);
      if (getPreviousElement != null) {
        this.transparentBorderSVG(getPreviousElement);
      }
      let getIds = getIdOptionsA.ids;
      if (getIds != undefined && getIds.length > 0) {
        this.getId = getIds[0];
        debugger
        this.canvasClick(this.getId);
        // this.previousSelectAnnotation = [];
        // this.previousSelectAnnotation.push(getIds[0]);
        // let searchedOne = document.getElementById(getIds[0]);
        // this.colorBorder(searchedOne);
        // searchedOne.classList.remove('transparent-border');
        // searchedOne.classList.add('color-border');
      }
    }
    else {
      let getIds = getIdOptionsA.ids;
      if (getIds != undefined && getIds.length > 0) {
        this.getId = getIds[0];
      }
      let getAllCanvas = document.querySelectorAll('canvas');
      if (getIds != undefined && getIds.length > 0) {
        this.getId = getIds[0];
        this.annotationSelected = true;
        // for (let i = 0; i < ids.length; i++) {
        //   for (let j = 0; j < getAllCanvas.length; j++) {
        //     let getelementid = getAllCanvas[j].getAttribute('id');
        //     console.log(getelementid, ids[i]);
        //     if (getelementid == ids[i]) {
        //       let searchedOne = document.getElementById(getelementid);
        //       let searchElementAddStyle = searchedOne as HTMLCanvasElement;
        //       this.colorBorder(searchElementAddStyle);
        //     }
        //   }
        // }
        if (getIdOptionsA.action == 'add') {
          // let getLyrCheckedAnnot = document.getElementById(getIds[0])
          // this.colorBorder(getLyrCheckedAnnot);
          this.getId = getIds[0];
          this.multipleAnnotationCallAPI();
          let get_current_element = document.getElementById(this.getId);
          if (get_current_element != null) {
            this.colorBorderSVG(get_current_element);
          }
        }
        else if (getIdOptionsA.action == 'remove') {
          this.getId = getIds[0];

          let already_exist = this.createDocumentStore.selectedAnnotations.findIndex((data) => data === this.getId);
          if (already_exist != -1) {
            let get_current_element = document.getElementById(this.getId);
            if (get_current_element != null) {
              let find_Multi_Removing = this.multiselectionList.filter((dataRes) => dataRes.annotation_id != this.createDocumentStore.selectedAnnotations[already_exist]);
              // need to work svg
              this.multiselectionList = find_Multi_Removing;
              // draw side bar multiple_annotations when local changes happened in the multiselection list 
              // The below line is commented because we don't want to draw annotations while removing.
              // this.drawing_multiple_annotations();
              this.createDocumentStore.selectedAnnotations.splice(already_exist, 1)
              this.transparentBorderSVG(get_current_element);
              this.get_Multiselection_Data_Count();
            }
          }

        }
      }
      else {
        this.annotationSelected = false;
        for (let i = 0; i < getAllCanvas.length; i++) {
          // getAllCanvas[i].style.backgroundColor = "transparent";
          // getAllCanvas[i].style.border = "2px solid transparent";
          this.transparentBorder(getAllCanvas[i]);
        }
      }
    }
  }
  footerToolbar1: boolean = true;
  footerToolbar2: boolean = false;

  firstLetterCapital(word) {
    if (word) {
      let firsttypeLetter = word[0].toUpperCase();
      let othertypeletters = word.slice(1);
      let changeUpperCaseProjectName = firsttypeLetter + othertypeletters;
      this.annotationtagsName = changeUpperCaseProjectName;
    }
  }

  firstLetterCapitalName(word) {
    if (word) {
      let firsttypeLetter = word[0].toUpperCase();
      let othertypeletters = word.slice(1);
      let changeUpperCaseProjectName = firsttypeLetter + othertypeletters;
      console.log(changeUpperCaseProjectName);
      this.annotNameAnnotation = changeUpperCaseProjectName;
    }
  }

  firstLetterCapitalShape(word) {
    if (word) {
      let firsttypeLetter = word[0].toUpperCase();
      let othertypeletters = word.slice(1);
      let changeUpperCaseProjectName = firsttypeLetter + othertypeletters;
      console.log(changeUpperCaseProjectName);
      this.annotShapeAnnotation = changeUpperCaseProjectName;
    }
  }

  firstLetterCapitalLabel(word) {
    if (word) {
      let firsttypeLetter = word[0].toUpperCase();
      let othertypeletters = word.slice(1);
      let changeUpperCaseProjectName = firsttypeLetter + othertypeletters;
      this.annotLabelAnnotation = changeUpperCaseProjectName;
    }
  }
  
  toolcopyname(value) {
    switch (value) {
      case 'copy':
        if(this.toolbar_name!="Copy mode Enabled" && this.toolbar_name!="Move mode Enabled")
        {
          this.sub = this.toolbar_name;
        }
        this.toolbar_name = "Copy mode Enabled";
        this.copytoolhead = true;
        this.copydata=true
        break;
      case 'move':
        if(this.toolbar_name!="Copy mode Enabled" && this.toolbar_name!="Move mode Enabled")
        {
          this.sub = this.toolbar_name;
        }
        this.toolbar_name = "Move mode Enabled";
        break;
      case 'remove':
        if(this.sub!=undefined){
          this.toolbar_name = this.sub;
        }
        break;
    }
  }

  toolbarFilterMethod() {
    console.log(this.toolbarFilter);
    let gettempModelFields = _.cloneDeep(this.tempModelFields);
    console.log(this.tempModelFields);
    let filteredModelfields = gettempModelFields.filter((data) => {
      if (this.toolbarFilter.pointsChecked && this.toolbarFilter.freehandChecked && this.toolbarFilter.vertexChecked && this.toolbarFilter.rectangleChecked) {
        return true;
      }
      else if (this.toolbarFilter.pointsChecked && this.toolbarFilter.freehandChecked && this.toolbarFilter.vertexChecked) {
        if (data.element_id != 18 && data.element_id != 19 && data.element_id != 20) {
          return true;
        }
      }
      else if (this.toolbarFilter.pointsChecked && this.toolbarFilter.vertexChecked && this.toolbarFilter.rectangleChecked) {
        if (data.element_id != 12 && data.element_id != 17) {
          return true;
        }
      }
      else if (this.toolbarFilter.pointsChecked && this.toolbarFilter.freehandChecked && this.toolbarFilter.rectangleChecked) {
        if (data.element_id != 13 && data.element_id != 14 && data.element_id != 15 && data.element_id != 16) {
          return true;
        }
      }
      else if (this.toolbarFilter.freehandChecked && this.toolbarFilter.vertexChecked && this.toolbarFilter.rectangleChecked) {
        if (data.element_id >= 12) {
          return true;
        }
      }
      else if (this.toolbarFilter.pointsChecked && this.toolbarFilter.freehandChecked) {
        if (data.element_id != 13 && data.element_id != 14 && data.element_id != 15 && data.element_id != 16 && data.element_id != 18 && data.element_id != 19 && data.element_id != 20) {
          return true;
        }
      }
      else if (this.toolbarFilter.pointsChecked && this.toolbarFilter.vertexChecked) {
        if (data.element_id != 12 && data.element_id != 17 && data.element_id != 18 && data.element_id != 19 && data.element_id != 20) {
          return true;
        }
      }
      else if (this.toolbarFilter.pointsChecked && this.toolbarFilter.rectangleChecked) {
        if (data.element_id != 12 && data.element_id != 17 && data.element_id != 13 && data.element_id != 14 && data.element_id != 15 && data.element_id != 16) {
          return true;
        }
      }
      else if (this.toolbarFilter.freehandChecked && this.toolbarFilter.vertexChecked) {
        if (data.element_id == 12 || data.element_id == 17 || data.element_id == 13 || data.element_id == 14 || data.element_id == 15 || data.element_id == 16) {
          return true;
        }
      }
      else if (this.toolbarFilter.freehandChecked && this.toolbarFilter.rectangleChecked) {
        if (data.element_id == 12 || data.element_id == 17 || data.element_id == 18 || data.element_id == 19 || data.element_id == 20) {
          return true;
        }
      }
      else if (this.toolbarFilter.vertexChecked && this.toolbarFilter.rectangleChecked) {
        if (data.element_id == 13 || data.element_id == 14 || data.element_id == 15 || data.element_id == 16 || data.element_id == 18 || data.element_id == 19 || data.element_id == 20) {
          return true;
        }
      }
      else if (this.toolbarFilter.pointsChecked) {
        if (data.element_id <= 11) {
          return true;
        }
      }
      else if (this.toolbarFilter.freehandChecked) {
        if (data.element_id == 12 || data.element_id == 17) {
          return true;
        }
      }
      else if (this.toolbarFilter.vertexChecked) {
        if (data.element_id == 13 || data.element_id == 14 || data.element_id == 15 || data.element_id == 16) {
          return true;
        }
      }
      else if (this.toolbarFilter.rectangleChecked) {
        if (data.element_id == 18 || data.element_id == 19 || data.element_id == 20) {
          return true;
        }
      }
      else if (this.toolbarFilter.pointsChecked == false && this.toolbarFilter.freehandChecked == false && this.toolbarFilter.vertexChecked == false && this.toolbarFilter.rectangleChecked == false) {
        return true;
      }
    });
    console.log(filteredModelfields);
    this.modelFields = _.cloneDeep(filteredModelfields);
    this.toolbarElements_view_svg = [];
    if (this.modelFields.length > 0) {
      // toolbar svg Drawing
      this.ngForRendred1();
    } else {

    }
    console.log(this.toolbarElements_view_svg)
    // this.toolbarElements_view_svg = _.cloneDeep(filteredModelfields);
  }
  footerShift: boolean = false;

  async getCounts() {
    this.formContentleft = [];
    this.formContentright = [];
    let tempformCount = 0;
    this.useCaseEmptycellIds = []
    let templinkCount = 0;
    let tempmediaCount = 0;
    let temptagCount = 0;
    let status = 1;
    // this.sampleFormObject = [];
    this.checkTempList = [];
    this.multiselectionList_svg_view = [];
    let total_selection_count = this.multiselectionList.length - 1;
    console.log(this.multiselectionList);
    for (var i = 0; i < this.multiselectionList.length; i++) {
      //converting special characters
      let get_db_data = this.multiselectionList[i];
      let filter_forms = get_db_data.annotation_forms.filter((forms) => this.createDocumentStore.data_allow_condition.includes(forms.is_removed));
      get_db_data.annotation_forms = _.cloneDeep(filter_forms);
      this.multiselectionList[i] = this.document_credential.convert_special_char_annot(get_db_data);
      // svg shape drawing start
      let get_svg_multiple = await this.annotation_view_svg(this.multiselectionList[i]);
      //line shapes I have assigned extra 
      let lines = [13, 14, 15, 16];
      if (lines.includes(Number(get_svg_multiple.toolbar_element_id))) {
        get_svg_multiple.linewidth = get_svg_multiple.linewidth * 2;
      }
      // check resize shapes line width increase simple shapes only
      get_svg_multiple = linewidthchanges(get_svg_multiple);
      // multiple selection location value assigning
      if (Array.isArray(get_svg_multiple.annotation_links)) {
        for (let l = 0; l < get_svg_multiple.annotation_links.length; l++) {
          get_svg_multiple.annotation_links[l]["location"] = this.getLocation(get_svg_multiple.annotation_links[l]);
        }
      }
      this.multiselectionList_svg_view.push(get_svg_multiple);
      if(this.multiselectionList_svg_view.length!=0){
        let index=this.multiselectionList_svg_view.length-1;
        this.multiselectionList_svg_view[index].annotation_media=this.multiselectionList_svg_view[index].annotation_media.filter((data) => this.createDocumentStore.data_allow_condition.includes(data.is_removed))
      }
      // after redrawing label attributes gone so adding multimovinglabel
      if (this.multiselectionList[i].annotation_label != null || this.multiselectionList[i].annotation_label != "" || this.multiselectionList[i].annotation_label != undefined) {
        this.getMultipleMovingLabelElement(this.multiselectionList[i].annotation_id);
      }
      // svg shape drawing start end
      var forms_multiselect;
      //total_selection_count == i this condition added for only mapping the data last annotation, dont want to other annotation
      if (this.multiselectionList[i].annotation_forms != undefined && this.multiselectionList[i].annotation_forms.length > 0 && total_selection_count == i) {
        // let annotationformunremoved = this.multiselectionList[i].annotation_forms.filter((data) => { return this.createDocumentStore.data_allow_condition.includes(data.is_removed)})
        // tempformCount = tempformCount + annotationformunremoved.length;
        if (this.multiselectionList[i].annotation_forms.length > 0 ) {
          let sortedForms = this.multiselectionList[i].annotation_forms;
          let curnt_slcted_form_index = this.select_primary_form(sortedForms); // primary form selection function
          let tempFormLength = sortedForms.length;
          this.lastAnnotationId = this.multiselectionList[i].annotation_id;
          this.currentFormId = sortedForms[curnt_slcted_form_index].form_id;
          if (sortedForms[curnt_slcted_form_index].hasOwnProperty('is_extend')) {
            this.is_extend = sortedForms[curnt_slcted_form_index].is_extend;
          } else {
            this.is_extend = false;
          }
          this.currentFormName = sortedForms[curnt_slcted_form_index].form_name;
          forms_multiselect = sortedForms[curnt_slcted_form_index];
          let formvalues = getFormBy_Id(this.layerDatas, this.multiselectionList[i].annotation_id, sortedForms[curnt_slcted_form_index].form_id);
          let hidden_formvalues = this.formListDefaultValues.filter((data) => data.form_id == formvalues.form_id);
          if (this.createDocumentStore.data_allow_condition.includes(this.is_extend)) {
            this.is_extend = false;
          } else {
            this.is_extend = true;
          }
          
          if (hidden_formvalues[0].is_hidden == 1 || hidden_formvalues[0].is_hidden == "1") {
            
            this.colorvalid = true;
          } else {
            this.colorvalid = false;
          }
          if (typeof formvalues["form_data"] === 'string') {
            this.modelFieldsForm = JSON.parse(formvalues["form_data"]);
          } else {
            this.modelFieldsForm = formvalues["form_data"];
          }
          let weldFormIndex =  this.modelFieldsForm.findIndex((id) => id.element_type == "uti-entry-field-WMATA_WELD")
          var weldPresent = false;
          if(weldFormIndex != -1){
            weldPresent = true;
              var weldform = _.cloneDeep(this.modelFieldsForm[weldFormIndex]);
          }
          let check_form_name = this.formListDefaultValues.filter((f_name) => f_name.form_id == this.currentFormId);

          let get_db_data_forms = _.cloneDeep(check_form_name[0]);
          if (get_db_data_forms != undefined) {

            get_db_data_forms.form_name = this.dataService4.changeSpecialtoKeyFormat(get_db_data_forms.form_name);
            let get_cur_formdata = get_db_data_forms.form_data;
            if (Array.isArray(get_cur_formdata)) {
              if (get_cur_formdata.length > 0) {
                get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
              }
            } else {
              get_cur_formdata = JSON.parse(get_cur_formdata);
              if (get_cur_formdata.length > 0) {
                get_db_data_forms.form_data = this.dataService4.formfieldviewcharacter(get_cur_formdata, 'annotationgetformview');
              }
            }
            if (get_db_data_forms.is_extend == true) {
              if (get_db_data_forms.hasOwnProperty('ext_form_data')) {
                if (get_db_data_forms.ext_form_data != null) {
                  let get_cur_ext_formdata = get_db_data_forms.ext_form_data;
                  if (Array.isArray(get_cur_ext_formdata)) {
                    if (get_cur_ext_formdata.length > 0) {
                      get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                    }
                  } else {
                    get_cur_ext_formdata = JSON.parse(get_cur_ext_formdata);
                    if (get_cur_ext_formdata.length > 0) {
                      get_db_data_forms.ext_form_data = this.dataService4.formfieldviewcharacter(get_cur_ext_formdata, 'annotationgetformview');
                    }
                  }
                }
              }
            }

          }
          check_form_name[0] = get_db_data_forms
          // this.modelFieldsForm = this.getUpdatedFormdata(forms_multiselect.form_data, check_form_name[0].form_data)
          let clone_model_fiels = _.cloneDeep(forms_multiselect.form_data)
          if (check_form_name[0].form_data != undefined && check_form_name[0].form_data != null) {
            if (Array.isArray(check_form_name[0].form_data) == false) {
              check_form_name[0].form_data = JSON.parse(check_form_name[0].form_data)
            } else {
              check_form_name[0].form_data = check_form_name[0].form_data
            }
          }
          this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true");
          
          this.modelFieldsForm = this.merge_form_process(clone_model_fiels, check_form_name[0].form_data, 'leftside');
          // this.modelFieldsForm = this.getUpdatedFormdata(forms_multiselect.form_data, check_form_name[0].form_data)
          console.log(this.modelFieldsForm);
          if (this.modelFieldsForm.length > 0) {
            let check_timber_form = this.modelFieldsForm.findIndex((timber) => timber.element_type == "uti-entry-field-TIMBER");
            if (check_timber_form > -1) {
              this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
            }
          }
          if (weldPresent == true) {
            const weldindex =  this.modelFieldsForm.findIndex((id) => id.element_type == "uti-entry-field-WMATA_WELD")
            const copyweldform =_.cloneDeep(this.modelFieldsForm[weldindex]);
           this.copyweldForm = copyweldform;
            let get_default_value = this.modelFieldsForm[weldindex].element_data.default_values;
            const fields = this.modelFieldsForm[weldindex].element_data.fields;
            this.fieldsWeld = fields; 
            let weldArray = this.convertUUIDtoNormal(get_default_value);
            this.splitarray(weldArray);
          }
          if (this.is_extend == true) {
            if (formvalues.hasOwnProperty('ext_form_data')) {
              if (typeof formvalues["ext_form_data"] === 'string') {
                this.extend_modelFieldsForm = JSON.parse(formvalues["ext_form_data"]);
              } else {
                this.extend_modelFieldsForm = formvalues["ext_form_data"];
              }
              this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true");
              let clone_extend_model_fiels = _.cloneDeep(forms_multiselect.ext_form_data);
              if (check_form_name[0].ext_form_data != undefined && check_form_name[0].ext_form_data != null) {
                if (Array.isArray(check_form_name[0].ext_form_data) == false) {
                  check_form_name[0].ext_form_data = JSON.parse(check_form_name[0].ext_form_data)
                } else {
                  check_form_name[0].ext_form_data = check_form_name[0].ext_form_data
                }
              }
              this.extend_modelFieldsForm = this.merge_form_process(clone_extend_model_fiels, check_form_name[0].ext_form_data, 'rightside');
              if(weldPresent == true){
                let weldFormIndex =  this.extend_modelFieldsForm.findIndex((id) => id.element_type == "uti-entry-field-WMATA_WELD");
                if(weldFormIndex == -1){
                  this.extend_modelFieldsForm.push(weldform);
                }
              }
              // this.extend_modelFieldsForm = this.getUpdatedFormdata(forms_multiselect.ext_form_data, check_form_name[0].ext_form_data)]
            }

          }
        }
      }
      else if(total_selection_count == i) {
        let formslist_local = this.formList
        formslist_local = formslist_local.sort((a, b) => b.form_name.localeCompare(a.form_name));
        let sortedForms = formslist_local;
        let curnt_slcted_form_index = this.select_primary_form(sortedForms); // primary form selection function
        this.currentFormId = sortedForms[curnt_slcted_form_index].form_id;
        let check_form_name = this.formListDefaultValues.filter((f_name) => f_name.form_id == this.currentFormId);
        if (check_form_name.length > 0) {
          this.currentFormName = check_form_name[0].form_name;
        }
        else {
          this.currentFormName = sortedForms[curnt_slcted_form_index].form_name;
        }
        this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
        this.currentFormHiddenStatus = JSON.parse(sortedForms[curnt_slcted_form_index].is_hidden);

        if (this.formList.length > 0) {
          // not attached forms showing field if annotation form length 0
          let sortedForms_form_data = sortedForms[curnt_slcted_form_index].form_data;
          sortedForms_form_data = this.document_credential.convertJSON(sortedForms_form_data);
          if (sortedForms_form_data.length > 0) {
            sortedForms_form_data = this.dataService4.formfieldviewcharacter(sortedForms_form_data, 'annotationgetformview');
          }
          let remove_deleted = sortedForms_form_data.filter((delete_field) => this.createDocumentStore.data_allow_condition.includes(delete_field.is_removed));
          this.modelFieldsForm = remove_deleted;
          if('ext_form_data' in sortedForms[curnt_slcted_form_index]){
            let sortedForms_ext_form_data = sortedForms[curnt_slcted_form_index].ext_form_data;
            sortedForms_ext_form_data = this.document_credential.convertJSON(sortedForms_ext_form_data);
            if (sortedForms_ext_form_data.length > 0) {
              sortedForms_ext_form_data = this.dataService4.formfieldviewcharacter(sortedForms_ext_form_data, 'annotationgetformview');
            }
            let remove_deleted_ext = sortedForms_ext_form_data.filter((delete_field) => this.createDocumentStore.data_allow_condition.includes(delete_field.is_removed));
            this.extend_modelFieldsForm = remove_deleted_ext;
          }          
        }
        // if(sortedForms[sortedForms.length - 1].hasOwnProperty('is_extend')){
        //   this.is_extend = sortedForms[sortedForms.length - 1].is_extend;
        // }
        // if(this.createDocumentStore.data_allow_condition.includes(this.is_extend)){
        //  this.is_extend = false;
        // }else{
        // this.is_extend = true;
        // }

        //Jose Modified this below line
        //The below line is commented because JSON parse is getting error
        // this.modelFieldsForm = singleDataReceived.annotation_forms.length == 0 ?  JSON.parse(sortedForms[sortedForms.length - 1].form_data) : getFormById(this.layerDatas, singleDataReceived.annotation_id, sortedForms[sortedForms.length - 1].form_id);

        // if(typeof temp_form_holder.form_data === 'string'){
        //   temp_form_holder.form_data = JSON.parse(temp_form_holder.form_data);
        // }
        // temp_form_holder.form_data = this.dataService4.formfieldviewcharacter(temp_form_holder.form_data, 'annotationgetformview');

        // this.modelFieldsForm =  _.cloneDeep(temp_form_holder.form_data);

        // this.modelFieldsForm = sortedForms[sortedForms.length - 1].form_data;
        // if(typeof this.modelFieldsForm === 'string'){
        // this.modelFieldsForm = JSON.parse(sortedForms[sortedForms.length - 1].form_data);
        // }
        // sortedForms[sortedForms.length - 1].form_data = this.modelFieldsForm;
        //   if(this.is_extend == true){
        //     if(temp_form_holder.hasOwnProperty('ext_form_data')){
        //       if(temp_form_holder.ext_form_data != null && temp_form_holder.ext_form_data != undefined){
        //         if(typeof temp_form_holder.ext_form_data === 'string'){
        //           temp_form_holder.ext_form_data = JSON.parse(temp_form_holder.ext_form_data);
        //         }
        //         temp_form_holder.ext_form_data = this.dataService4.formfieldviewcharacter(temp_form_holder.ext_form_data, 'annotationgetformview');

        //         this.extend_modelFieldsForm = _.cloneDeep(temp_form_holder.ext_form_data);
        //     }
        //   }
        // }
        // forms_multiselect = sortedForms[sortedForms.length - 1];
      }

      if (forms_multiselect != undefined) {
        // form calcualtion field values setup function implemented
        if (this.is_extend == true){
          this.usecaseCopyArray = [...this.modelFieldsForm, ...this.extend_modelFieldsForm];
        }
        else{
          this.usecaseCopyArray = _.cloneDeep(this.modelFieldsForm);
        }
        this.process_use_conditions();
        this.FormulaCalc();
        // for (let j = 0; j < this.modelFieldsForm.length; j++) {
        //   // forms_multiselect contain annotation formdatas
        //   let field_element_value = forms_multiselect.form_data.filter((Mdata) => { return Mdata.element_uuid == this.modelFieldsForm[j].element_uuid })
        //   if (field_element_value.length > 0) {
        //     if (this.modelFieldsForm[j].element_type == "address") {
        //       this.modelFieldsForm[j].element_data.city = field_element_value[0].element_data.city != undefined && field_element_value[0].element_data.city != "" ? field_element_value[0].element_data.city : this.modelFieldsForm[j].element_data.city
        //       this.modelFieldsForm[j].element_data.state = field_element_value[0].element_data.state != undefined && field_element_value[0].element_data.state != "" ? field_element_value[0].element_data.state : this.modelFieldsForm[j].element_data.state
        //       this.modelFieldsForm[j].element_data.street_address1 = field_element_value[0].element_data.street_address1 != undefined && field_element_value[0].element_data.street_address1 != "" ? field_element_value[0].element_data.street_address1 : this.modelFieldsForm[j].element_data.street_address1
        //       this.modelFieldsForm[j].element_data.street_address2 = field_element_value[0].element_data.street_address2 != undefined && field_element_value[0].element_data.street_address2 != "" ? field_element_value[0].element_data.street_address2 : this.modelFieldsForm[j].element_data.street_address2
        //       this.modelFieldsForm[j].element_data.zip = field_element_value[0].element_data.zip != undefined && field_element_value[0].element_data.zip != "" ? field_element_value[0].element_data.zip : this.modelFieldsForm[j].element_data.zip
        //     }
        //     else if (this.modelFieldsForm[j].element_type == "single_choice" || this.modelFieldsForm[j].element_type == "multiple_choice" || this.modelFieldsForm[j].element_type == "checkbox" || this.modelFieldsForm[j].element_type == "dropdown") {
        //       if (this.modelFieldsForm[j].element_data.options != undefined && this.modelFieldsForm[j].element_data.options.length > 0) {
        //         let final_options = this.modelFieldsForm[j].element_data.options
        //         for (let k = 0; k < final_options.length; k++) {
        //           let field_element_options = field_element_value[0].element_data.options.filter((Mdata) => { return Mdata.element_uuid == final_options[k].element_uuid })
        //           if (field_element_options.length > 0 && (field_element_options[0].default === true || field_element_options[0].default === "true")) {
        //             final_options[k].default = field_element_options[0].default
        //           }
        //         }
        //         this.modelFieldsForm[j].element_data.options = final_options
        //       }
        //     }
        //     else if (this.modelFieldsForm[j].element_type == "date") {
        //       this.modelFieldsForm[j].element_data.default_date_time = field_element_value[0].element_data.default_date_time;
        //       // if(this.modelFieldsForm[j].element_data.hasOwnProperty('default_value')){
        //       //   this.modelFieldsForm[j].element_data.default_value = field_element_value[0].element_data.default_value != undefined && field_element_value[0].element_data.default_value != "" ? field_element_value[0].element_data.default_value : this.modelFieldsForm[j].element_data.default_date_time;
        //       // }
        //       // else{
        //       //   this.modelFieldsForm[j].element_data["default_value"] = field_element_value[0].element_data.default_date_time != undefined && field_element_value[0].element_data.default_date_time != "" ? field_element_value[0].element_data.default_date_time : this.modelFieldsForm[j].element_data.default_date_time;
        //       // }
        //     }
        //     else if (this.modelFieldsForm[j].element_type == "calculation") {
        //       let calc = this.modelFieldsForm[j];
        //       if (calc.element_data.calculation.includes('√')) {
        // 				let get_fianl_value = this.dataService4.squareRootCalculation(calc.element_data.calculation);
        // 				if (get_fianl_value != '√' && get_fianl_value != '') {
        // 					get_fianl_value = eval(get_fianl_value);
        // 				}
        // 				this.modelFieldsForm[j].element_data.calculation = get_fianl_value;
        // 				this.modelFieldsForm[j].element_data.calculation = this.modelFieldsForm[j].element_data.calculation.toFixed(Number(this.modelFieldsForm[j].element_data.default_value));
        // 			}
        // 			//square root function implemented end
        // 			//power function implemented start
        // 			else if (calc.element_data.calculation.includes('^')) {
        // 				let get_fianl_value = this.dataService4.powerOfCalculation(calc.element_data.calculation);
        // 				if (get_fianl_value != '^' && get_fianl_value != '') {
        // 					get_fianl_value = eval(get_fianl_value);
        // 				}
        // 				this.modelFieldsForm[j].element_data.calculation = get_fianl_value;
        // 				this.modelFieldsForm[j].element_data.calculation = this.modelFieldsForm[j].element_data.calculation.toFixed(Number(this.modelFieldsForm[j].element_data.default_value));
        // 			}
        // 			//power function implemented end
        // 			else {
        // 				let check_seperators = ["(",")","+","-","*","/"];
        // 				let get_calculation = calc.element_data.calculation;
        // 				let get_fist_value = calc.element_data.calculation[0];
        // 				let get_second_value = calc.element_data.calculation[1];
        // 				let get_last_value = calc.element_data.calculation[calc.element_data.calculation.length-1];
        // 				if(check_seperators.includes(get_fist_value) && check_seperators.includes(get_second_value)){
        // 					this.modelFieldsForm[j].element_data.calculation = calc.element_data.calculation
        // 				}
        // 				else if(check_seperators.includes(get_last_value)){
        // 					this.modelFieldsForm[j].element_data.calculation = calc.element_data.calculation
        // 				}
        // 				else if((get_calculation.includes("(") && !get_calculation.includes(")"))||
        // 				(get_calculation.includes(")") && !get_calculation.includes("(")) ){
        // 					this.modelFieldsForm[j].element_data.calculation = calc.element_data.calculation
        // 				}
        // 				else{
        //           if(calc.element_data.calculation!=undefined && calc.element_data.calculation!=""){
        //             var validcalculation = false;
        //             try {
        //               eval(calc.element_data.calculation); 
        //               validcalculation = true;
        //             } catch (e) {
        //               if (e instanceof SyntaxError) {
        //                 // alert(e.message);
        //                 validcalculation = false;
        //                 this.modelFieldsForm[j].element_data.calculation =calc.element_data.calculation;
        //               }
        //             }
        //           }
        // 					if(validcalculation==true){
        //             this.modelFieldsForm[j].element_data.calculation = eval(calc.element_data.calculation);
        // 					this.modelFieldsForm[j].element_data.calculation = this.modelFieldsForm[j].element_data.default_value == "" ? this.modelFieldsForm[j].element_data.calculation.toFixed(Number(1)) : this.modelFieldsForm[j].element_data.calculation.toFixed(Number(this.modelFieldsForm[j].element_data.default_value));
        //           }
        //           // calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
        // 					let confirmedValue = calc.element_data.calculation;
        // 					console.log(Math.abs(confirmedValue));
        // 					let decimalCheck = Math.abs(confirmedValue);
        // 				}
        // 				console.log(typeof this.modelFieldsForm[j].element_data.calculation);
        // 			}
        //     }
        //     else {
        //       this.modelFieldsForm[j].element_data.default_value = field_element_value[0].element_data.default_value != undefined && field_element_value[0].element_data.default_value != "" ? field_element_value[0].element_data.default_value : this.modelFieldsForm[j].element_data.default_value;
        //     }
        //   }
        // }

        // if (this.is_extend == true && forms_multiselect.hasOwnProperty('ext_form_data')) {
        //   if (this.extend_modelFieldsForm.length) {
        //     for (let j = 0; j < this.extend_modelFieldsForm.length; j++) {
        //       // forms_multiselect contain annotation formdatas
        //       let field_element_value = forms_multiselect.ext_form_data.filter((Mdata) => { return Mdata.element_uuid == this.extend_modelFieldsForm[j].element_uuid });
        //       if (field_element_value.length > 0) {
        //         if (this.extend_modelFieldsForm[j].element_type == "address") {
        //           this.extend_modelFieldsForm[j].element_data.city = field_element_value[0].element_data.city != undefined && field_element_value[0].element_data.city != "" ? field_element_value[0].element_data.city : this.extend_modelFieldsForm[j].element_data.city
        //           this.extend_modelFieldsForm[j].element_data.state = field_element_value[0].element_data.state != undefined && field_element_value[0].element_data.state != "" ? field_element_value[0].element_data.state : this.extend_modelFieldsForm[j].element_data.state
        //           this.extend_modelFieldsForm[j].element_data.street_address1 = field_element_value[0].element_data.street_address1 != undefined && field_element_value[0].element_data.street_address1 != "" ? field_element_value[0].element_data.street_address1 : this.extend_modelFieldsForm[j].element_data.street_address1
        //           this.extend_modelFieldsForm[j].element_data.street_address2 = field_element_value[0].element_data.street_address2 != undefined && field_element_value[0].element_data.street_address2 != "" ? field_element_value[0].element_data.street_address2 : this.extend_modelFieldsForm[j].element_data.street_address2
        //           this.extend_modelFieldsForm[j].element_data.zip = field_element_value[0].element_data.zip != undefined && field_element_value[0].element_data.zip != "" ? field_element_value[0].element_data.zip : this.extend_modelFieldsForm[j].element_data.zip
        //         }
        //         else if (this.extend_modelFieldsForm[j].element_type == "single_choice" || this.extend_modelFieldsForm[j].element_type == "multiple_choice" || this.extend_modelFieldsForm[j].element_type == "checkbox" || this.extend_modelFieldsForm[j].element_type == "dropdown") {
        //           if (this.extend_modelFieldsForm[j].element_data.options != undefined && this.extend_modelFieldsForm[j].element_data.options.length > 0) {
        //             let final_options = this.extend_modelFieldsForm[j].element_data.options
        //             for (let k = 0; k < final_options.length; k++) {
        //               let field_element_options = field_element_value[0].element_data.options.filter((Mdata) => { return Mdata.element_uuid == final_options[k].element_uuid })
        //               if (field_element_options.length > 0 && (field_element_options[0].default === true || field_element_options[0].default === "true")) {
        //                 final_options[k].default = field_element_options[0].default
        //               }
        //             }
        //             this.extend_modelFieldsForm[j].element_data.options = final_options
        //           }
        //         }
        //         else if (this.extend_modelFieldsForm[j].element_type == "date") {
        //           this.extend_modelFieldsForm[j].element_data.default_date_time = field_element_value[0].element_data.default_date_time;
        //           // if(this.extend_modelFieldsForm[j].element_data.hasOwnProperty('default_value')){
        //           //   this.extend_modelFieldsForm[j].element_data.default_value = field_element_value[0].element_data.default_value != undefined && field_element_value[0].element_data.default_value != "" ? field_element_value[0].element_data.default_value : this.extend_modelFieldsForm[j].element_data.default_date_time;
        //           // }
        //           // else{
        //           //   this.extend_modelFieldsForm[j].element_data["default_value"] = field_element_value[0].element_data.default_date_time != undefined && field_element_value[0].element_data.default_date_time != "" ? field_element_value[0].element_data.default_date_time : this.extend_modelFieldsForm[j].element_data.default_date_time;
        //           // }
        //         }
        //         else {
        //           this.extend_modelFieldsForm[j].element_data.default_value = field_element_value[0].element_data.default_value != undefined && field_element_value[0].element_data.default_value != "" ? field_element_value[0].element_data.default_value : this.extend_modelFieldsForm[j].element_data.default_value;
        //         }
        //       }
        //     }
        //   }
        // }

        let find_form_index = this.multiselectionList[i].annotation_forms.findIndex((forms_local) => forms_local.form_id == forms_multiselect.form_id);
        // if (find_form_index != -1) {
        //   this.multiselectionList[i].annotation_forms[find_form_index].form_data = this.modelFieldsForm;
        //   if (this.is_extend == true) {
        //     this.multiselectionList[i].annotation_forms[find_form_index].ext_form_data = this.extend_modelFieldsForm;
        //   }
        // }
      }
      if(this.multiselectionList[i].annotation_forms != undefined && this.multiselectionList[i].annotation_forms.length > 0){
        let annotationformunremoved = this.multiselectionList[i].annotation_forms.filter((data) => { return this.createDocumentStore.data_allow_condition.includes(data.is_removed)})
        tempformCount = tempformCount + annotationformunremoved.length;
      }
      if (this.multiselectionList[i].annotation_links.length > 0) {
        let annotationlink = this.multiselectionList[i].annotation_links.filter((Mdata) => { return Mdata.is_removed == 0 || Mdata.is_removed == "false" });
        templinkCount = templinkCount + annotationlink.length;
      }
      if (this.multiselectionList[i].annotation_media.length > 0) {
        let annotationMedia = this.multiselectionList[i].annotation_media.filter((Mdata) => { return Mdata.is_removed == 0 || Mdata.is_removed == "false" });
        tempmediaCount = tempmediaCount + annotationMedia.length;
        // this.sampleFormObject = [...this.sampleFormObject, ...annotationMedia];
      }
      if (this.multiselectionList[i].annotation_tags != "") {
        let tempTags = this.multiselectionList[i].annotation_tags;
        let converString = tempTags.toString();
        let converttempTags = converString.split(",");
        this.checkTempList = [...this.checkTempList, ...converttempTags];
        temptagCount = temptagCount + converttempTags.length;
      }
      if (this.multiselectionList[i].annotation_tags == "" || this.multiselectionList[i].annotation_tags.length == 0) {
        temptagCount = temptagCount + 0;
      }
    }
    // form validation page ending
    if (this.properties == true) {
      this.propertyIconClick();
    }
    if (this.searchOption == true) {
      let multiple_clone = this.createDocumentStore.selectedAnnotations;
      const myClonedArray_multiple = Object.assign([], multiple_clone);
      this.dataService.getannotationid.emit(myClonedArray_multiple);
    }
    let tempTags = this.checkTempList;
    let removeDuplicate = new Set(tempTags);
    this.checkTempList = [...removeDuplicate];
    for (let tg = 0; tg < this.checkTempList.length; tg++) {
      this.checkTempList[tg] = this.dataService4.changeSpecialtoKeyFormat(this.checkTempList[tg]);

    }
    let myset = [...new Set(this.checkTempList)];
    this.checkTempList = myset
    this.formCount = tempformCount;
    this.needUpdateFormCount = tempformCount;
    this.linkCount = templinkCount;
    this.mediaCount = tempmediaCount;
    this.tagCount = temptagCount;
    this.show = false;
    this.checkAlign_usecase()
  }
  

  getMediaStubList() {
    if (this.multipleSelectOn == false) {
      if (this.layerDatas != undefined) {
        for (var i = 0; i < this.layerDatas.length; i++) {
          var currentAnnotationMediaData = this.layerDatas[i].annotations.filter((ele => ele.annotation_id == this.getId))
          if (currentAnnotationMediaData.length > 0) {
            this.globalMediaCount(currentAnnotationMediaData[0].annotation_media, 'media')
          }
        }
      }
    }
    else if (this.multipleSelectOn == true) {
      let tempmediaList = [];
      if (this.layerDatas != undefined) {
        for (var i = 0; i < this.layerDatas.length; i++) {
          for (var j = 0; j < this.layerDatas[i].annotations.length; j++) {
            for (let k = 0; k < this.multiselectionList.length; k++) {
              if (this.multiselectionList[k].annotation_id == this.layerDatas[i].annotations[j].annotation_id) {
                for (let m = 0; m < this.layerDatas[i].annotations[j].annotation_media.length; m++) {
                  tempmediaList.push(this.layerDatas[i].annotations[j].annotation_media[m]);
                }
              }
            }
          }
        }
        //this.sampleFormObject = tempmediaList;
        this.globalMediaCount(tempmediaList, 'media')
      }
    }
  }



  shiftingAction() {
    console.log(this.enableGrapTop, this.enableGrapBottom, this.enableGrapRight);
    this.enableGrapBorderTop = true;
    this.enableGrapBorderBottom = true;
    this.enableGrapBorderRight = true;
    this.enableGrapTop = true;
    this.enableGrapRight = true;
    this.enableGrapBottom = true;
    this.centerImageHeight = true;
  }

  shiftingActionRemove(ev) {
    if (this.enableGrapBottom == true) {
      this.drag(ev);
      this.dropBottom(ev);
    }
    else if (this.enableGrapRight == true) {
      this.drag(ev);
      this.dropRight(ev);
    }
    else if (this.enableGrapTop == true) {
      this.drag(ev);
      this.dropTop(ev);
    }
    console.log('yes');
  }



  allowDrop(ev) {
    ev.preventDefault();
  }

  drag(ev) {

    console.log('drag start');
    console.log(this.rotateandresize);
    this.enableGrapBorderTop = true;
    this.enableGrapBorderBottom = true;
    this.enableGrapBorderRight = true;
    this.enableGrapTop = true;
    this.enableGrapRight = true;
    this.enableGrapBottom = true;
    this.centerImageHeight = true;
    console.log(this.enableGrapBottom, this.enableGrapTop, this.enableGrapRight);
    ev.dataTransfer.setData("text", document.getElementById('drag1').getAttribute('id'));
  }

  dragEnd(ev) {
    console.log('end');
    if (this.previousDataValue == "bottom") {
      this.dropBottom(ev);
    }
    else if (this.previousDataValue == "right") {
      this.dropRight(ev);
    }
    else if (this.previousDataValue == "top") {
      this.dropTop(ev);
    }
  }

  enableDots(ev) {
    console.log('drag move dots open');
    this.enableGrapRightStyle = false;
    this.enableGrapBottomStyle = false;
    this.enableGrapTopStyle = false;
    this.enablerightChangeHeightValue = true;
    this.rightSideDrop = false;
  }

  removeShifting() {
    this.enableGrapBorderTop = false;
    this.enableGrapBorderBottom = false;
    this.enableGrapBorderRight = false;
  }

  dropRight(ev) {
    console.log('right');
    ev.preventDefault();
    var data = ev.dataTransfer.getData("text");
    console.log(data);
    if (this.previousDataValue != "right") {
      ev.target.appendChild(document.getElementById(data));
      console.log(ev.target);
      this.previousDataValue = "right";
    }
    else {
      this.previousDataValue = "right";
    }
    this.extentToolbarSize = true;
    this.centerImageHeight = false;
    this.rightSideDrop = true;
    this.enableGrapRight = true;
    this.enableGrapRightStyle = true;
    this.enableGrapBorderTop = false;
    this.enableGrapTop = false;
    this.enableGrapBottom = false;
    this.enableGrapTopStyle = false;
    this.enableGrapBottomStyle = false;
    this.enablerightChangeHeightValue = false;
    if (this.toolbarplaceBackup != this.previousDataValue) {
      if (this.pngFormat == true) {
        this.resizeImageDocument();
      }
      else {
        // commented because annotation placing wrong when zooming 27.12.2021.
        // this.resizeImageDocument();
      }
    }
    this.toolbarplaceBackup = "right";
  }

  dropTop(ev) {
    console.log('top');
    ev.preventDefault();
    var data = ev.dataTransfer.getData("text");
    console.log(data);
    if (this.previousDataValue != "top") {
      ev.target.appendChild(document.getElementById(data));
      console.log(ev.target);
      this.previousDataValue = "top";
    }
    else {
      this.previousDataValue = "top";
    }
    this.extentToolbarSize = false;
    this.enableGrapTop = true;
    this.rightSideDrop = false;
    this.enableGrapTopStyle = true;
    this.enableGrapBorderRight = false;
    this.enableGrapRight = false;
    this.enableGrapBottom = false;
    this.centerImageHeight = false;
    this.enableGrapRightStyle = false;
    this.enableGrapBottomStyle = false;
    this.enablerightChangeHeightValue = false;
    if (this.toolbarplaceBackup != this.previousDataValue) {
      if (this.pngFormat == true) {
        this.resizeImageDocument();
      }
      else {
        // commented because annotation placing wrong when zooming 27.12.2021.
        // this.resizeImageDocument();
      }
    }
    this.toolbarplaceBackup = "top";
  }

  dropBottom(ev) {
    ev.preventDefault();
    var data = ev.dataTransfer.getData("text");
    if (this.previousDataValue != "bottom") {
      console.log('bottom');
      ev.target.appendChild(document.getElementById(data));
      console.log(ev.target);
      this.previousDataValue = "bottom";
    }
    else {
      console.log('bottom');
      this.previousDataValue = "bottom";
    }
    this.extentToolbarSize = false;
    this.enableGrapBottom = true;
    this.enableGrapBottomStyle = true;
    this.rightSideDrop = false;
    this.enableGrapBorderBottom = false;
    this.enableGrapTop = false;
    this.enableGrapRight = false;
    this.centerImageHeight = false;
    this.enableGrapTopStyle = false;
    this.enablerightChangeHeightValue = false;
    if (this.toolbarplaceBackup != this.previousDataValue) {
      if (this.pngFormat == true) {
        this.resizeImageDocument();
      }
      else {
        // commented because annotation placing wrong when zooming 27.12.2021.
        // this.resizeImageDocument();
      }
    }
    this.toolbarplaceBackup = "bottom";
  }

  copyAnnotationCreatePage() {
    this.copyAnnotationCreatePageValue = true;
    this.transparentBorderSVGSelected();
  }

  getCurrentCopyData(dataByOne, index) {
    let no_layer = false;
    let no_active_layer = false;
    // current page details get from document pages
    let check_current_Page_active = this.documentDetails.filter((page_data_active) => page_data_active.page_id == this.currentPageId);
    if (check_current_Page_active.length > 0) {
      // active layer id based get data from document pages
      this.value = this.layerDatas.filter(layeritem => layeritem.layer_id == check_current_Page_active[0].active_layer_id);
      if(this.value.length==0){
        let find_layer_active_P2 =  this.layerDatas.filter(layeritem => this.createDocumentStore.data_allow_conditionT.includes(layeritem.is_active_flag));
        if(find_layer_active_P2.length>0){
          this.value = find_layer_active_P2;
        }
    }
      if (this.value.length > 0) {
        this.activeLayerIdDraw = check_current_Page_active[0].active_layer_id;
        if(check_current_Page_active[0].active_layer_id == null){
          this.activeLayerIdDraw = this.value[0].layer_id;
        }
        let associated_pages = this.value[0].associated_pages;
        let page_element1 = associated_pages.filter(ele => ele.page_id == this.currentPageId)
        let get_lock = page_element1[0].is_lock;
        let get_visible = page_element1[0].is_hidden;
        if (this.createDocumentStore.data_allow_condition.includes(get_lock)) {
          this.lockedLayerActive = false;
        }
        else {
          this.lockedLayerActive = true;
        }
        if (this.createDocumentStore.data_allow_condition.includes(get_visible) && this.lockedLayerActive == false) {
          this.showvisible = true;
        }
        else {
          this.showvisible = false;
        }
      }
      else {
        this.value = [];
        this.lockedLayerActive = false;
        this.showvisible = true;
        no_active_layer = true;
      }
    }

    if (this.layerDatas.length == 0) {
      const dialogRef = this.dialogBox.open(ClayeralertComponent, {
        data: {
          active: false
        }
      });
    }
    else if (this.layerDatas.length > 0) {
      if (this.lockedLayerActive == true && no_layer == false) {
        const dialogRef = this.dialogBox.open(ClayeralertComponent, {
          data: {
            lock: true
          }
        }
        )
      }
      else if (this.showvisible == false && no_layer == false) {
        const dialogRef = this.dialogBox.open(ClayeralertComponent, {
          data: {
            lock: false
          }
        })
      }
      else if (this.lockedLayerActive == false && this.showvisible == true && no_layer == false && no_active_layer == false) {
        console.log(dataByOne, index);
        this.toolbarSet = true;
        if(this.copyMultiAnn == false){
          this.toolbarBg = index;
        }
        let find_copy_annotation = this.copyAnnotationDatas.findIndex((copy) => copy.annotation_id == dataByOne.annotation_id);
        if (find_copy_annotation > -1) {
          this.propertiesannotationData = this.copyAnnotationDatas[find_copy_annotation];
          this.createDocumentStore.current_copy_annot_data = this.copyAnnotationDatas[find_copy_annotation];
          console.log(this.propertiesannotationData);
          this.copyAnnotationCreatePageValue = true;
          this.drawFunctionActive = true;
          this.getPositionActive = true;
          this.toolbarElementId = parseInt(this.propertiesannotationData["toolbar_element_id"]);
          // let getAllSVG = document.querySelectorAll("svg.svg-block");
          // getAllSVG.forEach((data) => {
          //   data.classList.remove('svg-block');
          // });
        }
      }
      else {
        const dialogRef = this.dialogBox.open(ClayeralertComponent, {
          data: {
            active: true
          }
        });
      }
    }
  }

  closeCopyFooter() {
    if(this.copyMultiAnn == true){
      this.copyMultiAnn = false;
      this.displayCopyMultiMessage("disabled");
    }
    if(this.copymultiannenabled == true){
      this.dataService2.copyAnnotationMultiple.emit("false")
    }
    this.copymultiannenabled = false;
    this.copydata=false
    this.copytoolhead = false;
    this.toolcopyname('remove');
    this.copyAnnotationCreatePageValue = false;
    this.toolbarSet = false;
    this.copyAnnotationDatas = [];
    this.copyAnnotation_svg_view = [];
    this.newcopyAnnotations = [];
    this.cpyMultiAnnPos = [];
    this.arrNewPosition = [];
    this.toolbarBg = -1;

    // remove the local value if the copy and move another document enable na 
    if (this.createDocumentStore.copy_move_btw_doc == true) {
      this.createDocumentStore.copy_move_btw_doc = false;
      this.encrptdecrpt.removeItem("cpy_mve_btw_doc");
    }
    // this.multiselectionList = [];
  }

  copyAnnotationCreatePageSave(length?) {
    this.show = true;
    this.annotationSelected = false;
    this.showcopyAnnotationOption = false;
    this.toolbarSet = false;
    this.getId = "";
    let layers = [];
    if (this.layerDatas != undefined) {
      if (this.copyMode == "withoutData" && this.createDocumentStore.copy_move_btw_doc == false) {
        this.createJson["annotation_forms"] = [];
        console.log(this.formList);
        const myArray = this.formList;
        const myClonedArray = [];
        myArray.forEach(val => myClonedArray.push(Object.assign({}, val)));
        console.log(myClonedArray);
        for (let j = 0; j < this.propertiesannotationData["annotation_forms"].length; j++) {
          for (let k = 0; k < myClonedArray.length; k++) {
            if (this.propertiesannotationData["annotation_forms"][j].form_id == myClonedArray[k].form_id) {
              console.log(myClonedArray[k].form_data)
              if (Array.isArray(myClonedArray[k].form_data) == false) {
                myClonedArray[k].form_data = JSON.parse(myClonedArray[k].form_data);
              } else {
                myClonedArray[k].form_data = (myClonedArray[k].form_data);
              }

              console.log(myClonedArray[k].form_data)
              this.createJson["annotation_forms"].push(myClonedArray[k]);
            }
          }
        }
        this.createJson["annotation_links"] = [];
        this.createJson["annotation_media"] = [];
        this.createJson["annotation_tags"] = "";
      }
      if(this.copymultiannenabled == true){
        this.annotationUpdate_multiplecopy(length);
      }
      else{
        this.annotationUpdate();
      }
    }
  }

  stampAnnotationCreatePageSave() {
    this.showcopyAnnotationOption = false;
    this.copyAnnotationCreatePageValue = false;
    this.drawFunctionActive = false;
    this.getPositionActive = false;
    this.annotationSelected = false;
    this.optionClick = true;
    let getAllCanvas = document.querySelectorAll("canvas");
    getAllCanvas.forEach((data) => {
      console.log(data)
      data.style.backgroundColor = "transparent";
      data.style.border = "2px solid transparent";
    });
    this.getId = "";
    let layers = [];
    if (this.layerDatas != undefined) {
      this.createJson["annotation_links"] = [];
      this.createJson["annotation_media"] = [];
      this.createJson["annotation_tags"] = "";
      this.layerDatas.forEach((data) => {
        if (data.layer_id === this.activeLayerIdDraw) {
          data.annotations.push(this.createJson);
          layers.push(data);
        } else {
          layers.push(data);
        }
      });
      this.layerDatas = layers;

      //latest comment
      // this.canvasClick(e);
      this.documentService.annotationUpdateAUC(layers).subscribe((response) => {
        console.log(response);
      });
    }
  }


  layersClick: boolean = false;
  moveAnnotationCreatePage() {
    let getElementlayerBox = document.getElementById('layerBox1');
    console.log(getElementlayerBox.getBoundingClientRect());
    let width = getElementlayerBox.getBoundingClientRect().width;
    let height = getElementlayerBox.getBoundingClientRect().height;
    this.optionClick = false;
    this.layersClick = true;
    this.layerBoxPositionY = parseFloat(this.propertiesannotationData["initial_position_y"]) - 85 - height / 2;
    this.layerBoxPositionX = parseFloat(this.propertiesannotationData["initial_position_x"]) + 30;
  }

  closeBox() {
    this.layersClick = false;
  }

  layerSelectAction(layerId) {
    let copyData = "";
    for (let i = 0; i < this.layerDatas.length; i++) {
      for (let j = 0; j < this.layerDatas[i].annotations.length; j++) {
        if (this.getId == this.layerDatas[i].annotations[j].annotation_id && layerId != this.layerDatas[i].layer_id) {
          copyData = this.layerDatas[i].annotations[j];
          this.layerDatas[i].annotations.splice(j, 1);
          for (let l = 0; l < this.layerDatas.length; l++) {
            if (layerId == this.layerDatas[l].layer_id) {
              this.layerDatas[l].annotations.push(copyData);
            }
          }
        }
      }
    }
    console.log(this.layerDatas);
    this.layersClick = false;
  }

  deleteOptionClick: boolean = false;

  deleteAnnotationCreatePage() {
    this.deleteOptionClick = true;
    console.log('deleteAnnotationClick');
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    
    let closeDeleteBox = this.dialogBox.open(AnnotationDeleteComponent, {
      width: "380px",
      data: {
        layerData: this.layerDatas,
        activateIdDraw: this.activeLayerIdDraw,
        annotationId: this.getId,
        multiselectionList: this.multiselectionList,
        multipleSelectOn: this.multipleSelectOn
      },
    });
    closeDeleteBox.afterClosed().subscribe(() => {
      this.deleteOptionClick = false;
    });
  }

  moreOptionCreatePage() {
    this.moreOptionClick = true;
    const dialogConfig = new MatDialogConfig();
    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;
    console.log(this.annotationstring)
    
    let annotationmenudialogBox = this.dialogBox.open(
      AnnotationMenuComponent,
      {
        width: "380px",
        data: {
          annotation_id: this.getId,
          layerData: this.layerDatas,
          activateIdDraw: this.activeLayerIdDraw,
          elementHandW: this.elementHandW,
          multipleSelectOn: this.multipleSelectOn,
          toolbarElementId: this.toolbarElementId,
          toolbarListData: this.toolbar_detail,
          selectAnnotationData: this.propertiesannotationData,
          multiselectionList1: this.multiselectionList,
          singleDataReceived: this.singleDataReceived
        },
      }
    );
    annotationmenudialogBox.afterClosed().subscribe((res) => {
      console.log(res);
      if (res != undefined) {
        this.rapidShotModeOn = true;
        this.receiveString = "";
        this.drawFunctionActive = true;
        this.getPositionActive = true;
        // this.toolbarBg = index;
        this.annotationName = this.annotNameAnnotation;
        this.receiveString = this.propertiesannotationDataString;
      }
    });
    annotationmenudialogBox.afterClosed().subscribe(() => {
      this.moreOptionClick = false;
      // this.deselectAnnotation();
    });
  }

  changeViewWidth: any = "26%";
  changeViewWidth1: any = "74%";
  changeViewWidthNumber = 400;
  // changeViewWidthNumber = 341.5;
  mediaSectionBootCol: any = "col-6";
  mediaSectionBootColPhotos: any = "col-4";
  alignCenterMedia: boolean = false;

  makeResizableDiv() {
    const element = document.getElementById('resizers');
    const resizers = document.querySelectorAll('.resizer');
    const minimum_size = 0;
    let original_width = 0;
    const maximum_size = 75;
    let original_x = 0;
    let original_y = 0;
    let original_mouse_x = 0;
    let original_mouse_y = 0;
    let mousedown = false;
    var parentwidth;
    var div1width;
    var div2width;
    let second_div_width = 0;
    for (let i = 0; i < resizers.length; i++) {
      const currentResizer = resizers[i];
      console.log(i)
      currentResizer.addEventListener('mousedown', (e: any) => {
        // if(this.column==true){
        e.preventDefault();
        parentwidth = document.getElementById("welldone").clientWidth;
        div1width = document.getElementById("resizers").clientWidth;
        div2width = document.getElementById("rightSideDiv").clientWidth;
        let div1percentage = Math.round((div1width / parentwidth) * 100);
        let div2percentage = Math.round((div2width / parentwidth) * 100);
        console.log(parentwidth, div1width, div2width);
        console.log(div1percentage, div2percentage);
        mousedown = true;
        original_width = this.changeViewWidthNumber;
        original_x = element.getBoundingClientRect().left;
        original_y = element.getBoundingClientRect().top;
        original_mouse_x = e.pageX;
        original_mouse_y = e.pageY;
        window.addEventListener('mousemove', (e) => {
          if (mousedown == true) {
            resize(e);
          }
        });
        window.addEventListener('mouseup', (e) => {
          stopResize(e)
        })
        // }
      });

      const resize = (e) => {
        if (currentResizer.classList.contains('top-right')) {
          console.log(e, original_mouse_x,'top right');
          const width = original_width + (e.pageX - original_mouse_x);
          let maximumSize = Math.round((width / parentwidth) * 100);
          if (maximumSize <= 50) {
            // element.style.width = width + 'px';
            this.changeViewWidthNumber = width;
            let convertdiv1percentage = Math.round((width / parentwidth) * 100);
            if (this.changeViewWidthNumber <= 217 && this.screenWidthValue <= 1366) {
              this.alignCenterMedia = true;
            }
            else if (this.changeViewWidthNumber <= 217 && this.screenWidthValue > 1366) {
              this.alignCenterMedia = true;
            }
            else {
              this.alignCenterMedia = false;
            }
            // if (convertdiv1percentage < 18) {
            //   this.mediaSectionBootCol = "col-12";
            // }
            // else {
            //   this.mediaSectionBootCol = "col-6";
            // }
            // if (convertdiv1percentage <= 16) {
            //   this.mediaSectionBootColPhotos = "col-12";
            //   this.alignCenterMedia = true;
            // }
            // else if (convertdiv1percentage <= 24) {
            //   this.mediaSectionBootColPhotos = "col-6";
            //   this.alignCenterMedia = false;
            // }
            // else if (convertdiv1percentage >= 30 && convertdiv1percentage <= 44) {
            //   this.mediaSectionBootColPhotos = "col-3";
            //   this.alignCenterMedia = false;
            // }
            // else if (convertdiv1percentage >= 45 && convertdiv1percentage <= 79) {
            //   this.mediaSectionBootColPhotos = "col-2";
            //   this.alignCenterMedia = false;
            // }
            // else if (convertdiv1percentage >= 80) {
            //   this.mediaSectionBootColPhotos = "col-2";
            //   this.alignCenterMedia = false;
            // }
            // else {
            //   this.mediaSectionBootColPhotos = "col-4";
            //   this.alignCenterMedia = false;
            // }

            this.changeViewWidth = convertdiv1percentage + '%';
            let getDiv2Width = parentwidth - width;

            second_div_width = Math.round((getDiv2Width / parentwidth) * 100);
            // this.changeViewWidth1 = convertdiv2percentage + '%';
          }
        }
        else {
          console.log('empty')
          const width = original_width - (e.pageX - original_mouse_x)
          this.changeViewWidth = width + 'px';
          if (width > minimum_size) {
            // element.style.width = width + 'px'
            element.style.left = original_x + (e.pageX - original_mouse_x) + 'px'
            this.changeViewWidthNumber = width;
            let convertdiv1percentage = Math.round((width / parentwidth) * 100);
            console.log(convertdiv1percentage);
            console.log(this.changeViewWidthNumber);
            if (this.changeViewWidthNumber <= 217 && this.screenWidthValue <= 1366) {
              this.alignCenterMedia = true;
            }
            else if (this.changeViewWidthNumber <= 217 && this.screenWidthValue > 1366) {
              this.alignCenterMedia = true;
            }
            else {
              this.alignCenterMedia = false;
            }
            // if (convertdiv1percentage < 18) {
            //   this.mediaSectionBootCol = "col-12";
            // }
            // else {
            //   this.mediaSectionBootCol = "col-6";
            // }
            // if (convertdiv1percentage <= 16) {
            //   this.mediaSectionBootColPhotos = "col-12";
            //   this.alignCenterMedia = true;
            // }
            // else if (convertdiv1percentage <= 24) {
            //   this.mediaSectionBootColPhotos = "col-6";
            //   this.alignCenterMedia = false;
            // }
            // else if (convertdiv1percentage >= 30 && convertdiv1percentage <= 44) {
            //   this.mediaSectionBootColPhotos = "col-3";
            //   this.alignCenterMedia = false;
            // }
            // else if (convertdiv1percentage >= 45 && convertdiv1percentage <= 79) {
            //   this.mediaSectionBootColPhotos = "col-2";
            //   this.alignCenterMedia = false;
            // }
            // else if (convertdiv1percentage >= 80) {
            //   this.mediaSectionBootColPhotos = "col-2";
            //   this.alignCenterMedia = false;
            // }
            // else {
            //   this.mediaSectionBootColPhotos = "col-4";
            //   this.alignCenterMedia = false;
            // }
            this.changeViewWidth = convertdiv1percentage + '%';
            let getDiv2Width = parentwidth - width;
            let convertdiv2percentage = Math.round((getDiv2Width / parentwidth) * 100);
            console.log(convertdiv2percentage);
            this.changeViewWidth1 = convertdiv2percentage + '%';
          }
          console.log(width);
        }
      }


      const stopResize = (e) => {
        e.preventDefault();
        if (mousedown == true) {
          mousedown = false;
          // this.changeViewWidth1 = second_div_width + '%';
          e.stopPropagation();
          window.removeEventListener('mousemove', resize)
          window.removeEventListener('mouseup', stopResize);
          this.slideAfterScale();
        }

      }
    }
  }

  makeItSimple() {

    // var parentwidth = document.getElementById("welldone").clientWidth;
    // var div1width = document.getElementById("resizers").clientWidth;
    // var div2width = document.getElementById("rightSideDiv").clientWidth;
    // let div1percentage = Math.round((div1width / parentwidth) * 100);
    // let div2percentage = Math.round((div2width / parentwidth) * 100);
    // console.log(parentwidth, div1width, div2width);
    // console.log(div1percentage, div2percentage);
    const slider: any = document.querySelector('.scrollelement');
    let isDown = false;
    let startX;
    let startY;
    let scrollLeft;
    let scrollTop;

    slider.addEventListener('mousedown', (e: any) => {
      isDown = true;
      slider.classList.add('active');
      startX = e.pageX - slider.offsetLeft;
      startY = e.pageY - slider.offsetTop;
      scrollLeft = slider.scrollLeft;
      scrollTop = slider.scrollTop
    });
    slider.addEventListener('mouseleave', () => {
      isDown = false;
      slider.classList.remove('active');
    });
    slider.addEventListener('mouseup', () => {
      isDown = false;
      slider.classList.remove('active');
    });
    slider.addEventListener('mousemove', (e) => {
      if (!isDown) return;
      e.preventDefault();
      const x = e.pageX - slider.offsetLeft;
      const y = e.pageY - slider.offsetTop;
      const walk = (x - startX) * 3; //scroll-fast
      const walk_y = (y - startY) * 3; //scroll-fast
      slider.scrollLeft = scrollLeft - walk;
      slider.scrollTop = scrollTop - walk_y;
      console.log(walk, walk_y);
    });
  }

  //Rename the document page after put new values in documentdetails data

  pageRenameSetup(receivePageData) {
    let pageNumber = 0;
    for (let i = 0; i < this.documentDetails.length; i++) {
      if (receivePageData.page_id == this.documentDetails[i].page_id) {
        this.documentDetails[i].page_name = receivePageData.page_name;
        this.pageName = receivePageData.page_name;
        this.currentPageId = this.documentDetails[i].page_id;
        pageNumber = this.documentDetails[i].page_number;
        this.getAllDocumentPages();
      }
    }
    // let senddata = { data: this.documentDetails, pageno: pageNumber, pdfPath: this.imgUrl, pngFormat: this.pngFormat };
    // this.dataService.sendPageDatawithNumber.emit(senddata);
    // console.log(senddata);
    let document_input = {
      pageNumber: pageNumber, document_details: this.documentDetails,
      pngFormat: this.pngFormat, imgUrl: this.imgUrl, currentPageId: this.currentPageId, pageName: this.pageName
    };
    this.document_credential.update_current_documents_data(document_input);
  }

  imageSize() {
    console.log('zoomfirst');
    var getImageElement = document.getElementById("pdfImg");
    getImageElement.style.transform = "scale(" + this.scale + ")";
    console.log(this.projectId, this.folderId);
  }

  zoomOut(event) {
    event.stopPropagation();
    let getImageElement = document.getElementById('pdfImg'); // get_element_pdf_img instead using getImageElement name
    // getImageElement.style.opacity = "0";
    // this.createDocumentStore_1.zooming_button_disable = true;
    // this.createDocumentStore_1.typeofzoom = "Zooming Out...";
    // setTimeout(() => {

      let getImageContainer = document.getElementById("Imagecontainer");
      getImageElement = document.getElementById("pdfImg");
      this.scaleValue *= this.scaleMultiplier;
      this.scale *= this.scaleMultiplier;
      getImageElement.style.transform = "scale(" + this.scale + ")";
      if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
        || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
        if (this.scale < 1.24049) {
          this.zoomingLineShapeHandle_revert();
        }
        else {
          this.zoomingLineShapeHandle();
        }
      }
      if(this.createDocumentStore.enablerepointButtons == true && this.createDocumentStore.enablerepointButtons == true){
        if (this.scale > 1.24049) {
          this.zoomingLineShapeHandle_revert();
        }
      }
      let getImageContainerSize = getImageContainer.getBoundingClientRect();
      let currentWidthHeight = getImageElement.getBoundingClientRect();
      let currentViewX = this.realWidth * this.scale;
      let currentViewY = this.realHeight * this.scale;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: this.scale,
      });
      let viewImageDiv = document.getElementById("pdfImg");
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      panZoomElement.on('transform', (e: any) => {
        // This event will be called along with events above.
        console.log('Fired when any transformation has happened', e);
        console.log(panZoomElement.getTransform());
        panZoomElement.pause();
        // panZoomElement.getTransform().scale = scale_val;
      });
      // calling Page Zoom maintain function
      this.pagewise_zoom_storage();
    // }, 500);

    // setTimeout(() => {
    //   getImageElement.style.opacity = "1";
    //   this.createDocumentStore_1.zooming_button_disable = false;
    // }, 800);
  }

  zoomingLineShapeHandle() {
    var name = this.annotationName;
    if (name == "Polyline") {
      this.polyline_zoomingpoint('customepolylineattributepath');
    }
    if (name == "Polyline Arrow") {
      // this.undoPolylineArrowDrawing_zoomingpoint();
      this.polyline_zoomingpoint('customepolylinearrowattributepath');
    }
    if (name == "Polygon") {
      // this.undoPolygonDrawing_zoomingpoint();
      this.polyline_zoomingpoint('customepolygonattributepath');
    }
  }
  zoomingLineShapeHandle_Repoint() {
    var name = this.annotationName;
    console.log(name)
    if (name == "Polyline") {
      this.polyline_zoomingpoint('customepolylineattributepath');
    }
    if (name == "Polyline Arrow") {
      // this.undoPolylineArrowDrawing_zoomingpoint();
      this.polyline_zoomingpoint('customerepointattribute');
    }
    if (name == "Polygon") {
      // this.undoPolygonDrawing_zoomingpoint();
      this.polyline_zoomingpoint('customepolygonattributepath');
    }
  }

  zoomingLineShapeHandle_revert() {
    var name = this.annotationName;
    if (name == "Polyline") {
      this.polyline_zoomingpoint_revert('customepolylineattributepath');
    }
    if (name == "Polyline Arrow") {
      // this.undoPolylineArrowDrawing_zoomingpoint();
      this.polyline_zoomingpoint_revert('customepolylinearrowattributepath');
    }
    if (name == "Polygon") {
      // this.undoPolygonDrawing_zoomingpoint();
      this.polyline_zoomingpoint_revert('customepolygonattributepath');
    }
  }
  zoomingLineShapeHandle_revert_repoint() {
    var name = this.annotationName;
    if (name == "Polyline") {
      this.polyline_zoomingpoint_revert('customepolylineattributepath');
    }
    if (name == "Polyline Arrow") {
      // this.undoPolylineArrowDrawing_zoomingpoint();
      this.polyline_zoomingpoint_revert('customerepointattribute');
    }
    if (name == "Polygon") {
      // this.undoPolygonDrawing_zoomingpoint();
      this.polyline_zoomingpoint_revert('customepolygonattributepath');
    }
  }

  zoomIn(event) {
    event.stopPropagation();
    console.log('zoom In');
    let getImageElement = document.getElementById('pdfImg'); // get_element_pdf_img instead using getImageElement name
    // getImageElement.style.opacity = "0";
    // this.createDocumentStore_1.zooming_button_disable = true;
    // this.createDocumentStore_1.typeofzoom = "Zooming In...";
    // setTimeout(() => {
      let getImageContainer = document.getElementById("Imagecontainer");
      console.log(getImageContainer);
      this.scaleValue /= this.scaleMultiplier;
      this.scale /= this.scaleMultiplier;
      getImageElement.style.transform = "scale(" + this.scale + ")";
      console.log(this.scaleValue);
      if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
        || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
        if (this.scale >= 1.24049) {
          this.zoomingLineShapeHandle();
        }
      }
      if (this.createDocumentStore.enablerepointButtons == true && this.createDocumentStore.enablerepointButtons == true) {
        if (this.scale >= 1.24049) {
          this.zoomingLineShapeHandle_Repoint();
        }
      }
      let getImageContainerSize = getImageContainer.getBoundingClientRect();
      console.log(getImageContainerSize);
      let currentWidthHeight = getImageElement.getBoundingClientRect();
      console.log(currentWidthHeight);
      // let currentViewX = currentWidthHeight.width;
      // let currentViewY = currentWidthHeight.height;
      let currentViewX = this.realWidth * this.scale;
      let currentViewY = this.realHeight * this.scale;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      console.log(currentViewX, currentViewY);
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: this.scale,
      });
      let viewImageDiv = document.getElementById("pdfImg");
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      panZoomElement.on('transform', (e: any) => {
        // This event will be called along with events above.
        console.log('Fired when any transformation has happened', e);
        console.log(panZoomElement.getTransform());
        panZoomElement.pause();
        // panZoomElement.getTransform().scale = scale_val;
      });
      // calling Page Zoom maintain function
      this.pagewise_zoom_storage();
    // }, 500);

    // setTimeout(() => {
    //   getImageElement.style.opacity = "1";
    //   this.createDocumentStore_1.zooming_button_disable = false;
    // }, 800);

  }

  annotationPreviousPositions = []

  zoomOutPdf(event) {
    this.pdf_zoom = true
    // if((this.pdfScaleValue * 0.8) >= 1){
    //   let zoom_plus = this.pdfScaleValue * 0.8;
    //   this.pdfScaleValue = zoom_plus;
    // let get_element_pdf_img = document.getElementById('pdfImg');
    // get_element_pdf_img.style.opacity = "0";
    // this.createDocumentStore_1.zooming_button_disable = true;
    // this.createDocumentStore_1.typeofzoom = "Zooming Out...";
    // setTimeout(() => {
      if (this.pdfScaleValue <= 1) {
        this.pdfScaleValue = this.pdfScaleValue - 0.1;
        // zoomin Function calling revert back to the pdf width and height in initial value because of annotation plotting issue fixes
        let get_pdfimg = document.getElementById('pdfImg');
        if (get_pdfimg != null) {
          get_pdfimg.style.width = this.realWidth + 'px';
          get_pdfimg.style.height = this.realHeight + 'px';
        }
        let get_annotationhead = document.getElementById('pdfannotationhead');
        if (get_annotationhead != null) {
          get_annotationhead.style.removeProperty('top');
          get_annotationhead.style.removeProperty('left');
          get_annotationhead.style.removeProperty('transform');
        }
        this.scaleValue = this.pdfScaleValue / this.scaleMultiplier;
        this.scale = this.pdfScaleValue / this.scaleMultiplier;
        this.zoomOut(event)
      } else {
        this.pdfScaleValue = this.pdfScaleValue - 0.1;
        if (this.pdfScaleValue <= 1) {
          // zoomin Function calling revert back to the pdf width and height in initial value because of annotation plotting issue fixes
          let get_pdfimg = document.getElementById('pdfImg');
          if (get_pdfimg != null) {
            get_pdfimg.style.width = this.realWidth + 'px';
            get_pdfimg.style.height = this.realHeight + 'px';
          }
          let get_annotationhead = document.getElementById('pdfannotationhead');
          if (get_annotationhead != null) {
            get_annotationhead.style.removeProperty('top');
            get_annotationhead.style.removeProperty('left');
            get_annotationhead.style.removeProperty('transform');
          }
          this.scaleValue = this.pdfScaleValue / this.scaleMultiplier;
          this.scale = this.pdfScaleValue / this.scaleMultiplier;
          this.zoomOut(event);
        }
        else {
          this.textLayerRenderedTimer();
          if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
            || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
            if (this.pdfScaleValue < 1.24049) {
              this.zoomingLineShapeHandle_revert();
            }
            else {
              this.zoomingLineShapeHandle();
            }
          }
        }
      }
      if(this.createDocumentStore.enablerepointButtons == true && this.createDocumentStore.enablerepointButtons == true){
        // if (this.scale > 1.24049) {
          this.zoomingLineShapeHandle_revert();
        // }
      }
    // }, 500);
    // setTimeout(() => {
    //   get_element_pdf_img.style.opacity = "1";
    //   this.createDocumentStore_1.zooming_button_disable = false;
    // }, 1500);
    // }
  }
pdf_zoom = false
  zoomInPdf(event) {
    this.pdf_zoom = true
    // let get_element_pdf_img = document.getElementById('pdfImg');
    // get_element_pdf_img.style.opacity = "0";
    // this.createDocumentStore_1.zooming_button_disable = true;
    // this.createDocumentStore_1.typeofzoom = "Zooming In...";
    // setTimeout(() => {
      if (this.pdfScaleValue < 0.8) {
        console.log('image type zoom below 0.9');
        this.pdfScaleValue = this.pdfScaleValue + 0.1;

        // zoomin Function calling revert back to the pdf width and height in initial value because of annotation plotting issue fixes
        let get_pdfimg = document.getElementById('pdfImg');
        if (get_pdfimg != null) {
          get_pdfimg.style.width = this.realWidth + 'px';
          get_pdfimg.style.height = this.realHeight + 'px';
        }
        let get_annotationhead = document.getElementById('pdfannotationhead');
        if (get_annotationhead != null) {
          get_annotationhead.style.removeProperty('top');
          get_annotationhead.style.removeProperty('left');
          get_annotationhead.style.removeProperty('transform');
        }
        this.scaleValue = this.pdfScaleValue * this.scaleMultiplier;
        this.scale = this.pdfScaleValue * this.scaleMultiplier;
        this.zoomIn(event);
      } else {
        console.log('image type zoom above 0.9');
        this.pdfScaleValue = +this.pdfScaleValue + 0.3;
        this.textLayerRenderedTimer();
        if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
          || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
          if (this.pdfScaleValue >= 1.24049) {
            this.zoomingLineShapeHandle();
          }
        }
      }

      if (this.createDocumentStore.enablerepointButtons == true && this.createDocumentStore.enablerepointButtons == true) {
        // if (this.scale >= 1.24049) {
          this.zoomingLineShapeHandle_Repoint();
        // }
      }
    // }, 500);

    // setTimeout(() => {
    //   get_element_pdf_img.style.opacity = "1";
    //   this.createDocumentStore_1.zooming_button_disable = false;
    // }, 1500);

    // setTimeout(() => {
    //   this.textLayerRenderedTimer()
    // }, 2000);
    // let get_pdfannotationhead = document.getElementById('pdfannotationhead');
    // let get_element_wh = get_pdfannotationhead.getBoundingClientRect();
    // let store_old_width_height = get_element_wh;

    // let get_canvaswrapper:HTMLElement = document.querySelector('div.canvasWrapper');
    // console.log(get_canvaswrapper);
    // let get_width = get_canvaswrapper.style.width;
    // let get_height = get_canvaswrapper.style.height;
    // console.log(get_width,get_height)
    // let increase_width = this.realWidth * this.pdfScaleValue;
    // let increase_height = this.realHeight * this.pdfScaleValue;

    // let width_difference = (increase_width - store_old_width_height.width)/2;
    // let height_difference = (increase_height - store_old_width_height.height)/2;

    // let get_pdf_viewer = document.getElementById('pdfViewerHead');
    // get_pdf_viewer.style.width = increase_width + 'px';
    // get_pdf_viewer.style.height = increase_height + 'px';
    // // let panZoomElement = panzoom(document.querySelector('#pdfannotationhead'), {
    // //   initialZoom: this.pdfScaleValue,
    // // });
    // // panZoomElement.dispose();
    // // let get_left = get_pdfannotationhead.style.left;
    // // get_left = get_left.substring(get_left.length - 2, 0);
    // // let get_top = get_pdfannotationhead.style.top;
    // // get_top = get_top.substring(get_top.length - 2, 0);
    // // let final_left = Number(get_left) - width_difference;
    // // let final_top = Number(get_top) - height_difference;

    // get_pdfannotationhead.style.left = 0 + 'px';
    // get_pdfannotationhead.style.top = 0 + 'px';

    // // let get_pdf_viewer_svg = document.getElementById('pdfannotationhead');

    // get_pdfannotationhead.style.width = increase_width + 'px';
    // get_pdfannotationhead.style.height = increase_height + 'px';

    // // let getAllCanvas = document.querySelectorAll("svg.svg-block");
    // //   getAllCanvas.forEach((data) => {
    // //     (data as HTMLElement).style.left = ((data as HTMLElement).clientLeft + increase_width) + 'px';
    // //     (data as HTMLElement).style.top = ((data as HTMLElement).clientTop + increase_height) + 'px';
    // //     // data.classList.remove('svg-block');
    // //   });

    // let actual_width_difference = (increase_width - this.realWidth)/2;
    // let actual_height_difference = (increase_height - this.realHeight)/2;

    //   let getAllCanvas = document.querySelectorAll("svg.documentSVG");
    //   getAllCanvas.forEach((data:any) => {

    //     let previousFilter = this.annotationPreviousPositions.filter((filter_ann) => {
    //       if (filter_ann.id == data.id) {
    //         return filter_ann;
    //       }
    //     });

    //     var get_left = data.style.left;
    //     get_left = get_left.substring(get_left.length - 2, 0);
    //     var get_top = data.style.top;
    //     get_top = get_top.substring(get_top.length - 2, 0);

    //     if(previousFilter.length > 0){
    //       get_left = previousFilter[0].left
    //       get_top = previousFilter[0].top
    //     }else{
    //       let previous_ann_val = {left:get_left,top:get_top,id:data.id}
    //       this.annotationPreviousPositions.push(previous_ann_val)
    //     }
    //     data.style.left = ((+get_left * this.pdfScaleValue)+ actual_width_difference+17.5) + 'px';
    //     data.style.top = ((+get_top * this.pdfScaleValue)+ actual_height_difference+17.5) + 'px';
    //     // data.style.transform = "none"
    //     // data.style.transform = "matrix("+this.pdfScaleValue+", 0, 0, "+this.pdfScaleValue+", 0, 0)"
    //     // data.classList.remove('svg-block');
    //   });

    // get_pdfannotationhead.style.transform = "matrix("+this.pdfScaleValue+", 0, 0, "+this.pdfScaleValue+", 0, 0)"

    // get_pdfannotationhead.style.width = increase_width + 'px';
    // get_pdfannotationhead.style.height = increase_height + 'px';
    // check difference 


  }


  

  getAllDocumentPages() {
    var start = new Date().getTime();
    console.log('document pages api' + ' Start time: ' + start);
    let req1 = this.documentService.getAllProjectDocument(this.projectId).subscribe((response) => {
      console.log(response);
      if (response["response_code"] == 200) {
        var end = new Date().getTime();
        var time = end - start;
        console.log('document pages api' + ' end time: ' + end);
        console.log('document pages api' + ' Execution time: ' + time);
        this.getAllDocumentPagesValue = response["response_body"]["project_pages"];
        let filterHiddenRemove = this.getAllDocumentPagesValue.filter((data) => {
          if (data.is_hidden == 0 && data.is_removed == 0) {
            return data;
          }
        });
        this.getAllDocumentPagesValue = filterHiddenRemove;
      }
    });
  }

  getFormList() {
    return new Promise((resolve, reject) => {
      var start = new Date().getTime();
    console.log('get form list' + ' Start time: ' + start);
    let req2 = this.documentService.getformlist(this.projectId).subscribe((response) => {
      console.log(response);
      if (response["response_code"] == 200) {
        var end = new Date().getTime();
        var time = end - start;
        console.log('get form list' + ' end time: ' + end);
        console.log('get form list' + ' Execution time: ' + time);
      }
      if (response["response_code"] == 200) {
        let getresponse_special_character = response["response_body"]["form_listing"];
        if (response["response_body"]["form_listing"].length > 0) {
          let change_character_list = this.dataService4.changeSpecialtokeyformatList(getresponse_special_character, 'formlist');
          console.log(change_character_list);
          response["response_body"]["form_listing"] = change_character_list;
        }
      }
      var dateFilter = response["response_body"]["form_listing"];
      dateFilter = dateFilter.filter((ele => ele.is_hidden == 0 && ele.is_removed == 0))
      if (dateFilter != undefined) {
        var crateDateFilter = dateFilter.filter((createDate) => {
          return (createDate.created_date = this.datePipe.transform(
            createDate.created_date,
            "MM/dd/yyyy HH:mm:ss"
          ));
        });
        this.formList = crateDateFilter.filter((modifiedDate) => {
          return modifiedDate.last_updated_date != undefined
            ? (modifiedDate.last_updated_date = this.datePipe.transform(
              modifiedDate.last_updated_date,
              "MM/dd/yyyy HH:mm:ss"
            ))
            : (modifiedDate.last_updated_date = this.datePipe.transform(
              modifiedDate.created_date,
              "MM/dd/yyyy HH:mm:ss"
            ));
        });
        this.formList = this.formList.sort((a, b) => new Date(b.last_updated_date).getTime() - new Date(a.last_updated_date).getTime())

        // this.formList = this.formList.sort((a,b) => a.form_name.localeCompare(b.form_name));
        // old code
        // this.formList = this.formList.sort((a, b) => new Date(b.last_updated_date).getTime() - new Date(a.last_updated_date).getTime())
        let responseValue = response["response_body"]["form_listing"];
        this.formListDefaultValues = _.cloneDeep(responseValue);
      }
      resolve(200);
    });
    })
  }

  document(documentName, folderId, page_id) {
    let deactivateFilterToolbar = { allChecked: true, pointsChecked: false, freehandChecked: false, vertexChecked: false, rectangleChecked: false };
    // localStorage.setItem("toolbarFilterItem", JSON.stringify(deactivateFilterToolbar));
    this.encrptdecrpt.setItem("toolbarFilterItem", deactivateFilterToolbar);//security
    const queryParams = {
      project_id: this.projectId,
      documentName: documentName,
      folderId: folderId,
      projectName: this.projectName,
      folderlevel: 0,
      pfolderid: this.parentFolderId,
      page_id: page_id,
      openLinkWindow: true,
    };
    const urlTree = this.router.createUrlTree([], { /* Removed unsupported properties by Angular migration: skipLocationChange. */ queryParams: queryParams,
      relativeTo: this.activateRoute
    });
    console.log(queryParams);
    window.open(urlTree.toString());
  }

  // lockLayerCheck() {
  //   if (this.layerDatas != undefined) {

  //     let page_element=this.layerDatas[0].associated_pages.filter(item=>item.page_id==this.currentPageId)
  //     if (page_element[0].is_lock==true||page_element[0].is_lock=="true"||page_element[0].is_lock==1) {
  //       this.lockedLayerActive = true;
  //     }
  //     else {
  //       this.lockedLayerActive = false;
  //     }

  //     console.log( this.lockedLayerActive)
  //     for (let f = 0; f < this.layerDatas.length; f++) {

  //       if (this.layerDatas[f].is_active_flag == true || this.layerDatas[f].is_active_flag == "true" || this.layerDatas[f].is_active_flag == "1") {
  //         this.activeLayerIdDraw = this.layerDatas[f].layer_id;


  //       }
  //     }
  //   }
  // }

  movingCurrentXY: any = { x: 0, y: 0 };
  moveCoordinateArray: any[] = [];

  closeFooterMove() {
    this.moveElementValue = false;
    var div = document.getElementById(this.getId);
    div.style.left = this.currentSelectedAnnotationData.initial_position_x + 'px';
    div.style.top = this.currentSelectedAnnotationData.initial_position_y + 'px';
    this.dataService.moveAccessCancel.emit(false);
    this.annotationSelected = true;
    this.deselectAnnotation();
  }

  changeDateFormat(value, i) {

    let tempDate = value;
    let convertDate = this.datePipe.transform(tempDate, "yyyy-MM-dd");
    console.log(convertDate);
    this.modelFieldsForm[i].element_data.default_value = convertDate;
    console.log(this.modelFieldsForm);
  }

  annotationLabelBackground(getData, id, labelid) {
    let pdfImg = document.getElementById(id);
    let labelElement = document.createElement("p");
    pdfImg.appendChild(labelElement);
    labelElement.setAttribute(labelid, "1");
    labelElement.style.color = this.checkStrokeColor1(getData.stroke_color);
    labelElement.style.fontSize = "13px";
    labelElement.style.fontWeight = "500";
    labelElement.style.position = "absolute";
    labelElement.style.top = "50%";
    labelElement.style.marginBottom = "0px";
    labelElement.innerHTML = getData.annotation_label;
    labelElement.style.lineHeight = "1";
    labelElement.style.textAlign = "center";
    labelElement.style.pointerEvents = "none";
    labelElement.style.zIndex = "9";
    // if (labelid == 'copyannotationLabel') {
    //   // labelElement.style.height = "26px";
    //   labelElement.style.width = "75px";
    // }
    // else {
    //   // labelElement.style.height = "53px";
    // }
    labelElement.style.marginTop = -(labelElement.clientHeight / 2) + 'px';
    labelElement.style.overflow = "hidden";
    console.log(getData.annotation_label);
    var numberOfLineBreaks = (getData.annotation_label.match(/\n/g) || []).length;
    console.log(numberOfLineBreaks, getData.annotation_label);
    if (numberOfLineBreaks != 0) {
      labelElement.style.whiteSpace = "pre-wrap";
    }
    labelElement.style.wordBreak = "break-word";
    if (labelElement.clientHeight >= 50) {
      labelElement.style.marginTop = "0px";
      labelElement.style.top = "0px";
    }
  }

  transparentBorder(data) {

    if (data != null) {
      data.style.backgroundColor = "transparent";
      // data.style.border = "2px solid transparent";
      data.style.backgroundPosition = "0 0, 0 0, 100% 0, 0 100%";
      data.style.backgroundSize = "2px 100%, 100% 2px, 2px 100% , 100% 2px";
      data.style.backgroundRepeat = "no-repeat";
      data.style.backgroundImage = "repeating-linear-gradient(0deg, transparent, transparent 10px, transparent 10px, transparent 20px), repeating-linear-gradient(90deg, transparent, transparent 10px, transparent 10px, transparent 20px), repeating-linear-gradient(180deg, transparent, transparent 10px, transparent 10px, transparent 20px), repeating-linear-gradient(270deg, transparent, transparent 10px, transparent 10px, transparent 20px)";
    }
  }

  colorBorder(getElementSelect) {
    if (getElementSelect != null) {
      let getWidth = getElementSelect.width;
      let getHeight = getElementSelect.height;
      let dotsLength = 6;
      let dotsSpace = 10;
      console.log(getWidth, getHeight);
      if (getWidth > 85) {
        dotsLength = 11;
        dotsSpace = 17;
        getElementSelect.style.backgroundSize = "3px 100%, 100% 3px, 3px 100% , 100% 3px";
      }
      getElementSelect.style.backgroundColor = "rgba(0,0,255,0.3)";
      getElementSelect.style.borderRadius = "2px";
      // getElementSelect.style.backgroundImage = "repeating-linear-gradient(0deg, blue, blue 6px, transparent 6px, transparent 10px), repeating-linear-gradient(90deg, blue, blue 6px, transparent 6px, transparent 10px), repeating-linear-gradient(blue, blue 6px, transparent 6px, transparent 10px), repeating-linear-gradient(270deg, blue, blue 6px, transparent 6px, transparent 10px)";
      getElementSelect.style.backgroundImage = 'repeating-linear-gradient(0deg, blue, blue ' + dotsLength + 'px, transparent 6px, transparent ' + dotsSpace + 'px), repeating-linear-gradient(90deg, blue, blue ' + dotsLength + 'px, transparent 6px, transparent ' + dotsSpace + 'px), repeating-linear-gradient(blue, blue ' + dotsLength + 'px, transparent 6px, transparent ' + dotsSpace + 'px), repeating-linear-gradient(270deg, blue, blue ' + dotsLength + 'px, transparent 6px, transparent ' + dotsSpace + 'px)';
    }
  }

  pdfCallCount: number = 1;
  pageSwitchedForlink = false

  ngForRendredPDF(e) {
    console.log('render')
    if (this.pdfCallCount == 1) {
      this.pdfCallCount += 1;
      this.pageRendered(e);
    }
    this.searchOption = false;
    // this.dataService2.closesearchfromdocument.emit(true);
    // this.Searchpage.disablesearchbutton();
    console.log('pdf', data);
    if (this.pageSwitchedForlink == false) {
      this.checkPageSwitchrequired()
    }
  }

  pdfImgRender() {
    this.pdfPanzoomSample();
  }

  initial_pdf_loaded = false
  document_zoom_top = 0;
  document_zoom_left = 0;

  textLayerRenderedTimer() {
    let get_pdfannotationhead = document.getElementById('pdfannotationhead');

    let get_element_wh = get_pdfannotationhead.getBoundingClientRect();
    let store_old_width_height = get_element_wh;

    let detailed_scale = this.pdfScaleValue;//e.source.viewport.scale
    // let increase_width = +(get_width.substring(get_width.length - 2, 0));
    let increase_width = this.realWidth * this.pdfScaleValue//+(get_width.substring(get_width.length - 2, 0));
    // let increase_height = +(get_height.substring(get_height.length - 2, 0));
    let increase_height = this.realHeight * this.pdfScaleValue
    //  let increase_width =  e.source.viewport.width//this.realWidth * this.pdfScaleValue;
    // let increase_height = e.source.viewport.height//this.realHeight * this.pdfScaleValue;

    let width_difference = (increase_width - this.realWidth) / 2;
    let height_difference = (increase_height - this.realHeight) / 2;


    // if (this.realHeight < this.realWidth && this.pdfScaleValue < 1) {
    //   width_difference = 0;
    // } 
    // else if (this.realHeight > this.realWidth && this.pdfScaleValue < 1) {
    //   height_difference = 0;
    // }
    console.log('width_difference', width_difference);
    console.log('height_difference', height_difference);
    // get_pdfannotationhead.style.top = height_difference + 'px' // original
    // get_pdfannotationhead.style.left = width_difference + 'px' // original

    // get_pdfannotationhead.style.transform = "matrix(" + detailed_scale + ", 0, 0, " + detailed_scale + ", 0, 0)" // original

    let get_pdfImg = document.getElementById('pdfImg');
    if (get_pdfImg != null) {
      get_pdfImg.style.removeProperty('transform');
      get_pdfannotationhead.style.transform = "matrix(" + detailed_scale + ", 0, 0, " + detailed_scale + ", 0, 0)"
      get_pdfImg.style.width = increase_width + 'px';
      get_pdfImg.style.height = increase_height + 'px';
      let getImageContainer = document.getElementById("Imagecontainer");
      let getImageContainerSize = getImageContainer.getBoundingClientRect();
      let currentWidthHeight = get_pdfImg.getBoundingClientRect();
      let currentViewX = increase_width;
      let currentViewY = increase_height;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      get_pdfannotationhead.style.top = height_difference + 'px'
      get_pdfannotationhead.style.left = width_difference + 'px'
      get_pdfImg.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      get_pdfImg.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';

    }

    // zoom in drawing shapes for freehand purpose start
    let getDrawSVG_element: HTMLElement = null;
    if (this.drawFreehandMenu == true) {
      getDrawSVG_element = document.querySelector('svg[customeFreehandAttribute]');
    }
    else if (this.drawShapeDonePolylineArrow == true) {
      getDrawSVG_element = document.querySelector('svg[customepolylinearrowattribute]');
    }
    else if (this.drawShapeDonePolyline == true) {
      getDrawSVG_element = document.querySelector('svg[customepolylineattribute]');
    }
    else if (this.drawShapeDoneLine == true) {
      getDrawSVG_element = document.querySelector('svg[customeLineAttribute]');
    }
    else if (this.drawShapeDoneLineAxial == true) {
      getDrawSVG_element = document.querySelector('svg[customeLineAxialAttribute]');
    }
    else if (this.drawShapeDonePolygon == true) {
      getDrawSVG_element = document.querySelector('svg[customepolygonattribute]');
    }
    else if (this.drawEllipseDone == true) {
      getDrawSVG_element = document.querySelector('svg[customeDrawEllipseAttribute]');
    }
    else if (this.drawRectangleDone == true) {
      getDrawSVG_element = document.querySelector('svg[customeDrawRectangleAttribute]');
    }
    if (getDrawSVG_element != null) {
      getDrawSVG_element.style.left = width_difference + 'px';
      getDrawSVG_element.style.top = height_difference + 'px';
      getDrawSVG_element.style.transform = "matrix(" + detailed_scale + ", 0, 0, " + detailed_scale + ", 0, 0)"
    }
    // zoom in drawing shapes for freehand purpose end
    // multiple selection canvas zooming handle start
    if (this.multipleSelectOn == true) {
      let getmulticanvas_element: HTMLElement = document.querySelector('canvas[customeMultipleAttribute]');
      if (getmulticanvas_element != null) {
        getmulticanvas_element.style.left = width_difference + 'px';
        getmulticanvas_element.style.top = height_difference + 'px';
        getmulticanvas_element.style.transform = "matrix(" + detailed_scale + ", 0, 0, " + detailed_scale + ", 0, 0)"
      }
    }
    // multiple selection canvas zooming handle end
    // repoint svg zooming handle start
    if (this.createDocumentStore.enablerepointButtons == true) {
      let getmulticanvas_element: HTMLElement = document.querySelector('svg[repointSVG]');
      if (getmulticanvas_element != null) {
        getmulticanvas_element.style.left = width_difference + 'px';
        getmulticanvas_element.style.top = height_difference + 'px';
        getmulticanvas_element.style.transform = "matrix(" + detailed_scale + ", 0, 0, " + detailed_scale + ", 0, 0)"
      }
    }
    // repoint svg zooming handle end
    // move canvas zooming handle start
    if (this.moveElementValue == true) {
      let getmulticanvas_element: HTMLElement = document.querySelector('canvas[customeMoveAttribute]');
      if (getmulticanvas_element != null) {
        getmulticanvas_element.style.left = width_difference + 'px';
        getmulticanvas_element.style.top = height_difference + 'px';
        getmulticanvas_element.style.transform = "matrix(" + detailed_scale + ", 0, 0, " + detailed_scale + ", 0, 0)"
      }
    }
    // move canvas zooming handle end
    this.document_zoom_top = height_difference;
    this.document_zoom_left = width_difference;

    // calling Page Zoom maintain function
    this.pagewise_zoom_storage();

    // let get_page_zoom:HTMLElement = document.querySelector('div.page');
    // if(get_page_zoom!=null){
    //   get_page_zoom.style.width = increase_width + 'px';
    //   get_page_zoom.style.height = increase_height + 'px';
    // }
    // }else{
    //   get_pdfannotationhead.style.top = 0 + 'px'
    //   get_pdfannotationhead.style.left = 0 + 'px'
    //   get_pdfannotationhead.style.transform = "matrix("+1+", 0, 0, "+1+", 0, 0)"
    // }

    // let get_pdfannotationhead = document.getElementById('pdfannotationhead');
    // let get_element_wh = get_pdfannotationhead.getBoundingClientRect();
    // let store_old_width_height = get_element_wh;

    // let get_canvaswrapper:HTMLElement = document.querySelector('div.canvasWrapper');
    // console.log(get_canvaswrapper);
    // let get_width = get_canvaswrapper.style.width;
    // let get_height = get_canvaswrapper.style.height;
    // console.log(get_width,get_height)
    // let increase_width =  e.source.viewport.width//this.realWidth * this.pdfScaleValue;
    // let increase_height = e.source.viewport.height//this.realHeight * this.pdfScaleValue;

    // let detailed_scale =  e.source.viewport.scale//this.realWidth * this.pdfScaleValue;

    // let width_difference = (increase_width - store_old_width_height.width)/2;
    // let height_difference = (increase_height - store_old_width_height.height)/2;

    // let get_pdf_viewer = document.getElementById('pdfViewerHead');
    // get_pdf_viewer.style.width = increase_width + 'px';
    // get_pdf_viewer.style.height = increase_height + 'px';
    // // let panZoomElement = panzoom(document.querySelector('#pdfannotationhead'), {
    // //   initialZoom: this.pdfScaleValue,
    // // });
    // // panZoomElement.dispose();
    // // let get_left = get_pdfannotationhead.style.left;
    // // get_left = get_left.substring(get_left.length - 2, 0);
    // // let get_top = get_pdfannotationhead.style.top;
    // // get_top = get_top.substring(get_top.length - 2, 0);
    // // let final_left = Number(get_left) - width_difference;
    // // let final_top = Number(get_top) - height_difference;

    // get_pdfannotationhead.style.left = 0 + 'px';
    // get_pdfannotationhead.style.top = 0 + 'px';

    // // let get_pdf_viewer_svg = document.getElementById('pdfannotationhead');

    // get_pdfannotationhead.style.width = increase_width + 'px';
    // get_pdfannotationhead.style.height = increase_height + 'px';

    // // let getAllCanvas = document.querySelectorAll("svg.svg-block");
    // //   getAllCanvas.forEach((data) => {
    // //     (data as HTMLElement).style.left = ((data as HTMLElement).clientLeft + increase_width) + 'px';
    // //     (data as HTMLElement).style.top = ((data as HTMLElement).clientTop + increase_height) + 'px';
    // //     // data.classList.remove('svg-block');
    // //   });

    // let actual_width_difference = (increase_width - this.realWidth)/2;
    // let actual_height_difference = (increase_height - this.realHeight)/2;

    //   let getAllCanvas = document.querySelectorAll("svg.documentSVG");
    //   getAllCanvas.forEach((data:any) => {

    //     let previousFilter = this.annotationPreviousPositions.filter((filter_ann) => {
    //       if (filter_ann.id == data.id) {
    //         return filter_ann;
    //       }
    //     });

    //     var get_left = data.style.left;
    //     get_left = get_left.substring(get_left.length - 2, 0);
    //     var get_top = data.style.top;
    //     get_top = get_top.substring(get_top.length - 2, 0);

    //     if(previousFilter.length > 0){
    //       get_left = previousFilter[0].left
    //       get_top = previousFilter[0].top
    //     }else{
    //       let previous_ann_val = {left:get_left,top:get_top,id:data.id}
    //       this.annotationPreviousPositions.push(previous_ann_val)
    //     }
    //     data.style.left = get_left * detailed_scale //(+get_left + actual_width_difference - 17.5) + 'px';
    //     data.style.top = get_top * detailed_scale//(+get_top + actual_height_difference - 17.5) + 'px';
    //     data.style.transform = "none"
    //     data.style.transform = "matrix("+detailed_scale+", 0, 0, "+detailed_scale+", 0, 0)"
    //     // data.classList.remove('svg-block');
    //   });

    // e.source.viewport.height = e.source.viewport.height * 72;
    // e.source.viewport.width = e.source.viewport.width * 72;
  }

  async pageRendered(e) {
    // this.realWidth = this.pdfWidthHeight.width;
    // this.realHeight = this.pdfWidthHeight.height;
    // this.documentService.createDocumentStore_values.document_width = this.pdfWidthHeight.width;
    // this.documentService.createDocumentStore_values.document_height = this.pdfWidthHeight.height;
    this.pdfPanzoomSample();
    var end = new Date().getTime();
    console.log('pdf load complete ', end)
    // this.getannotation_list();
  }

  pageRenderedView() {
    // once page view is rendered complete the pdf loading
    console.log('page render view');
    this.createDocumentStore_1.pdf_or_image_load_complete = true;
    if (this.createDocumentStore_1.annotation_draw_complete == true && this.createDocumentStore_1.pdf_or_image_load_complete == true) {
      this.show = false;
      console.log('remainder');
      let get_ramainder_stop_flag = this.encrptdecrpt.getItem("remainderStop");
      if (get_ramainder_stop_flag != true && this.previousRoute != '/index') {
        this.remainder();
      }
    }
  }

  pdfPanzoomSample() {
    let getImageContainer = document.getElementById("Imagecontainer");
    console.log(getImageContainer);
    let getImageContainerSize = getImageContainer.getBoundingClientRect();
    console.log(getImageContainerSize);
    console.log(this.realHeight, this.realWidth);
    if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
      let disableScale = false;
      var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
      console.log(scale_val);
      this.scaleValue = scale_val;
      this.scale = scale_val;
      this.oldScaleValue = scale_val;
      // pdf scale value added.
      this.pdfScaleValue = scale_val;
      let currentViewX = this.realWidth * scale_val;
      let currentViewY = this.realHeight * scale_val;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      const x1 = this.realWidth;
      const y1 = this.realHeight;
      console.log(x1, y1, centerX, centerY);
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: scale_val,
      });
      panZoomElement.pause();
      let viewImageDiv = document.getElementById("pdfImg");
      console.log(viewImageDiv)
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
    }
    else {
      this.scale = 1;
      this.scaleValue = 1;
      this.oldScaleValue = 1;
      // pdf scale value added.
      this.pdfScaleValue = 1;
      let centerX = getImageContainerSize.width - this.realWidth;
      let centerY = getImageContainerSize.height - this.realHeight;
      let viewImageDiv = document.getElementById("pdfImg");
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
    }
  }


  pdfPanzoomSync(scalevalue) {
    let getImageContainer = document.getElementById("Imagecontainer");
    let getImageContainerSize = getImageContainer.getBoundingClientRect();
    if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
      let disableScale = false;
      var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
      console.log(scale_val);
      this.scale = scale_val;
      let currentViewX = this.realWidth * scale_val;
      let currentViewY = this.realHeight * scale_val;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      const x1 = this.realWidth;
      const y1 = this.realHeight;
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: scale_val,
      });
      let viewImageDiv = document.getElementById("pdfImg");

      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      // if (centerY > 0) {
      //   viewImageDiv.style.top = centerY / 2 + 'px';
      // }
      panZoomElement.on('transform', (e: any) => {
        // This event will be called along with events above.
        console.log('Fired when any transformation has happened', e);
        console.log(panZoomElement.getTransform());
        panZoomElement.pause();
        // panZoomElement.getTransform().scale = scale_val;
      });
    }
    else {
      let centerX = getImageContainerSize.width - this.realWidth;
      let centerY = getImageContainerSize.height - this.realHeight;
      let viewImageDiv = document.getElementById("pdfImg");
      this.scaleValue = 1;
      this.getAnnotationForm();
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      this.scaleValue = 1;
      this.scale = 1;
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: this.scaleValue,
      });
      panZoomElement.on('transform', (e: any) => {
        // This event will be called along with events above.
        console.log('Fired when any transformation has happened', e);
        console.log(panZoomElement.getTransform());
        panZoomElement.pause();
        // panZoomElement.getTransform().scale = scale_val;
      });
    }


    // this.getAnnotationForm();
  }

  htmlAddClick() {
    this.showHtmlFields = true;
    this.itemIndexNumber = -1;
  }
  htmlAddClick1() {
    this.showHtmlFields = true;
    //reset the cusotme object
    this.custome_form_object.location = "";
    this.custome_form_object.decibels = "";
    this.custome_form_object.previouscondition = "";
    this.custome_form_object.flagforrReview = "";
    this.custome_form_object.Condition = "";
    this.custome_form_object.Comment = "";
    this.itemIndexNumber = -1;
  }

  obj = {}
  obj1 = {
    "id": "",
    "condition_code": "",
    "cs": "",
    "quantity": undefined,
    "not": false,
    "item_id": 0
  }

  // "quantity": 0 to undefined value changes ganesh,

  htmlFieldValue(id, item, value, checked) {

    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    if (item == "condition_code") {
      this.obj[id] = value
    } else if (item == "cs") {
      this.obj[id] = value
    } else if (item == "quantity") {
      this.obj[id] = Number(value)
    } else {
      if (checked == false) {
        if (this.obj.hasOwnProperty(id)) {
          delete this.obj[id];
        }
      } else {
        this.obj[id] = value
      }

    }
  }

  updateAttributesform(item, value, fields) {
    this.savebuttoncheck = true;
    if (item == "Location") {
      this.custome_form_object.location = value;
    }
    else if (item == "Decibels") {
      this.custome_form_object.decibels = value;
    }
    else if (item == "PC") {
      if (value == true) {
        this.custome_form_object.previouscondition = 'Yes';
      }
      else {
        this.custome_form_object.previouscondition = 'No';
      }
    }
    else if (item == "Flag") {
      if (value == true) {
        this.custome_form_object.flagforrReview = 'Yes';
      }
      else {
        this.custome_form_object.flagforrReview = 'No';
      }
    }
    else if (item == "Condition") {
      // this.custome_form_object.Condition = value;
      let get_field_option = fields.element_data.options;
      let find_name_index = get_field_option.findIndex((uuid) => uuid.element_uuid == value);
      if (find_name_index > -1) {
        this.custome_form_object.Condition = get_field_option[find_name_index].name;
      }
      else {
        this.custome_form_object.Condition = "";
      }
    }
    else if (item == "Comment") {
      this.custome_form_object.Comment = value;
    }
  }

  htmlDoneClick(item, item1, index) {
    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    if (index != -1) {
      this.showHtmlFields = false;
    
      this.formValuesUpdate(item, item.element_uuid, this.finalArray, null)
      this.finalArray1 = [];
      var item = item1.fields;
      this.displayArryChange(item, this.finalArray)
    } else {
      this.showHtmlFields = false;
      this.finalArray.push(this.obj);
      this.finalArray = _.cloneDeep(this.finalArray);
    
      this.formValuesUpdate(item, item.element_uuid, this.finalArray, null)
      //item1.default_values = this.finalArray
      this.finalArray1 = [];
      var item = item1.fields
      this.displayArryChange(item, this.finalArray);
    }
  }



  htmlDoneClick1(item, elementdata) {
    console.log(item);
    console.log(elementdata);
    this.createDocumentStore.forms_changes_status = true;
    this.savebuttoncheck = false;
    this.showHtmlFields = false;
    this.editButton = false;
    let clone_entered_values = _.cloneDeep(this.custome_form_object);
    let convert_uuid_store = _.cloneDeep(this.custome_form_object);
    if (this.itemIndexNumber != -1) {
      // change special characters start
      clone_entered_values.location = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.location);
      clone_entered_values.decibels = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.decibels);
      clone_entered_values.previouscondition = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.previouscondition);
      clone_entered_values.flagforrReview = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.flagforrReview);
      clone_entered_values.Condition = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.Condition);
      clone_entered_values.Comment = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.Comment);
      // change special characters end
      this.finalArray2[this.itemIndexNumber] = clone_entered_values;
    }
    else {
      // change special characters start
      clone_entered_values.location = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.location);
      clone_entered_values.decibels = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.decibels);
      clone_entered_values.previouscondition = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.previouscondition);
      clone_entered_values.flagforrReview = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.flagforrReview);
      clone_entered_values.Condition = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.Condition);
      clone_entered_values.Comment = this.dataService4.changeSpecialtoKeyFormat(clone_entered_values.Comment);
      // change special characters end
      this.finalArray2.push(clone_entered_values);
    }
    // update the local layer data values

    let clone_element_data = _.cloneDeep(elementdata);
    // make json for store layer form datas
    let convert_uuids = this.custom_form_make_uuid(convert_uuid_store, item);
    let send_new_values: any = "";
    if (this.itemIndexNumber != -1) {
      // update layer form main data dont changes anything
      if (clone_element_data.hasOwnProperty('default_values')) {
        clone_element_data.default_values[this.itemIndexNumber] = convert_uuids;
        send_new_values = clone_element_data.default_values;
      }
    }
    else {
      if (clone_element_data.hasOwnProperty('default_values')) {
        if (clone_element_data.default_values == "" || clone_element_data.default_values == undefined) {
          clone_element_data.default_values = [convert_uuids];
          send_new_values = clone_element_data.default_values;
        }
        else if (clone_element_data.default_values.length > 0) {
          clone_element_data.default_values.push(convert_uuids);
          send_new_values = clone_element_data.default_values;
        }
      }
      else if (!clone_element_data.hasOwnProperty('default_values')) {
        clone_element_data["default_values"] = [convert_uuids];
        send_new_values = clone_element_data["default_values"];
      }
    }
  
    this.formValuesUpdate(item, item.element_uuid, send_new_values, null);
    console.log(this.finalArray2);
    // if(index!=0 && index!=undefined && index!=-1 && this.finalArray2!= undefined && this.finalArray2.length!=0){
    // 	var editArray = this.finalArray2.filter((ele => ele.item_id == index))
    // 	editArray[0].Location = this.custome_form_object.location;
    // 	editArray[0].Decibels = this.custome_form_object.decibels;
    // 	editArray[0].PC = this.custome_form_object.previouscondition;
    // 	editArray[0].Flag = this.custome_form_object.flagforrReview;
    // 	editArray[0].Condition = this.custome_form_object.condition;
    // 	editArray[0].Comment = this.custome_form_object.comment;
    // 	this.showHtmlFields = false;
    // }
    // else{
    //     let id_value = this.finalArray2 != undefined ? this.finalArray2.length + 1 : 1
    //     this.object.item_id = id_value;
    //     this.showHtmlFields = false;
    //     var object1=_.cloneDeep(this.object);
    //     this.finalArray2.push(object1);
    // }
    // this.cleardata();
  }

  custom_form_make_uuid(final_enter_values, item) {
    let get_UI_values = final_enter_values;
    for (let single_value in get_UI_values) {

      switch (single_value) {
        case 'location':
          get_UI_values[item.element_data.fields[0].element_uuid] = get_UI_values[single_value];
          delete get_UI_values[single_value];
          break;
        case 'decibels':
          get_UI_values[item.element_data.fields[1].element_uuid] = get_UI_values[single_value];
          delete get_UI_values[single_value];
          break;
        case 'previouscondition':
          get_UI_values[item.element_data.fields[2].element_uuid] = get_UI_values[single_value];

          delete get_UI_values[single_value];
          break;
        case 'flagforrReview':
          get_UI_values[item.element_data.fields[3].element_uuid] = get_UI_values[single_value];
          delete get_UI_values[single_value];
          break;
        case 'Condition':
          get_UI_values[item.element_data.fields[4].element_uuid] = get_UI_values[single_value];
          let get_options = item.element_data.fields[4].element_data.options;
          let find_uuid_basename = get_options.findIndex((name1) => name1.name == get_UI_values[single_value]);
          if (find_uuid_basename > -1) {
            get_UI_values[item.element_data.fields[4].element_uuid] = get_options[find_uuid_basename].element_uuid;
          }
          delete get_UI_values[single_value];
          break;
        case 'Comment':
          get_UI_values[item.element_data.fields[5].element_uuid] = get_UI_values[single_value];
          delete get_UI_values[single_value];
          break;
      }
      console.log(get_UI_values);
    }
    console.log(get_UI_values);
    return get_UI_values
  }

  EditHtml1(item, field, edit_index) {
    console.log(edit_index);
    this.savebuttoncheck = true;
    this.itemIndexNumber = edit_index;
    let find_final_array_obj = Object.assign({}, this.finalArray2[edit_index]);
    this.custome_form_object = find_final_array_obj;
    this.showHtmlFields = true;
    this.editButton = true;
  }

  DeleteHtml1(item, elementdata, delete_index) {
    if (this.finalArray2.length > 0) {
      this.finalArray2.splice(delete_index, 1);
      if (elementdata.hasOwnProperty('default_values') && elementdata.default_values != "" && elementdata.default_values != undefined) {
        elementdata.default_values.splice(delete_index, 1);
      }
      if (!elementdata.hasOwnProperty('default_values')) {
        elementdata["default_values"] = "";
      }
      let clone_element_data = _.cloneDeep(elementdata);
      
      this.formValuesUpdate(item, item.element_uuid, clone_element_data.default_values, null);
    }
    // var abc = this.finalArray2.filter((ele => ele.item_id != item.item_id))
    // this.finalArray2 = abc;
  }

  SaveHtml1(item, field, edit_index) {
    this.editButton = false;
  }

  displayArryChange(item, finalArray) {
    finalArray.forEach(element => {
      for (var key in element) {
        for (var j = 0; j < item.length; j++) {
          if (item[j].element_uuid == key) {
            if (item[j].element_type == "number") {
              this.obj1.quantity = element[key]
            } else {
              item[j].element_data.options.forEach(element1 => {
                if (element1.element_uuid == element[key]) {
                  if (item[j].element_type == "dropdown") {
                    this.obj1.condition_code = element1.name
                  }
                  if (item[j].element_type == "single_choice") {
                    this.obj1.cs = element1.name
                  }
                  if (item[j].element_type == "multiple_choice") {
                    this.obj1.not = true
                  }
                }
              });
            }
          }
        }
      }
      this.obj1.item_id = this.obj1.item_id + 1
      this.finalArray1.push(this.obj1);
      this.finalArray1 = _.cloneDeep(this.finalArray1)
      this.obj1.id = "";
      this.obj1.condition_code = "";
      this.obj1.cs = "";
      this.obj1.quantity = undefined;
      // ganesh changed 0 to undefined 15.05.2021
      // this.obj1.quantity = 0;
      this.obj1.not = false;
      this.obj1.item_id = 0
    });
    this.htmlcalculation()
  }

  htmlcalculation() {
    this.unratedQuantity = 0;
    this.csValue = 0;
    for (var i = 0; i < this.outputArray.length; i++) {
      this.outputArray[i].value = 0
    }
    let chechAarray = this.finalArray1.filter((ele => ele.not == false || ele.cs == "CS1"))
    var fieldSum = 0;
    var cs1Sum = 0;

    chechAarray.forEach(element => {
      // if (element.cs.trim() != "CS1") {
      //   this.unratedQuantity = this.unratedQuantity + Number(element.quantity)
      //   this.csValue = this.csValue + Number(element.quantity)
      //   var cc = this.outputArray.filter((ele => ele.key == element.cs))
      //   cc[0].value = Number(cc[0].value) + Number(element.quantity)
      //   var cc1 = this.outputArray.filter((ele => ele.key.trim() == "CS1"))
      //   cc1[0].value = -this.csValue
      // } else {
      //   this.unratedQuantity = this.unratedQuantity + Number(element.quantity)
      // }

      if (element.cs.trim() != "CS1" && element.cs.trim() != "") {
        var cc = this.outputArray.filter((ele => ele.key == element.cs))
        if (element.quantity != undefined) {
          cc[0].value = Number(cc[0].value) + Number(element.quantity)
        }
      }
      if (element.cs.trim() != "CS1" && element.cs.trim() != "INAC" && element.cs.trim() != "") {
        if (element.quantity != undefined) {
          fieldSum = fieldSum + Number(element.quantity)
        }
      }
      if (element.not == false && element.cs.trim() == "CS1" && element.cs.trim() != "") {
        if (element.quantity != undefined) {
          cs1Sum = cs1Sum + Number(element.quantity)
        }
      }
      this.unratedQuantity = this.totalElementQuantity - cs1Sum - fieldSum
      this.csValue = cs1Sum + this.unratedQuantity
      var cc1 = this.outputArray.filter((ele => ele.key.trim() == "CS1"))
      cc1[0].value = this.csValue
    });
    if (chechAarray.length == 0) {
      // cs1 value added if chechAarray empty 
      let outputArray_copy = this.outputArray.findIndex((datav) => datav.key == "CS1");
      if (outputArray_copy > -1) {
        this.outputArray[outputArray_copy].value = this.totalElementQuantity;
      }
      this.unratedQuantity = this.totalElementQuantity;
    }
  }


  updateAttributes(item, item_value) {
    if (item.element_type == 'single_choice' || item.element_type == 'dropdown') {
      item.element_data.options.forEach(element => {
        element.default = false
      });
      let UCitemDefault = item.element_data.options.filter((ele => ele.element_uuid == item_value))
      UCitemDefault[0].default = true;
      item.element_data.default_value = item_value
    }
    if (item.element_type == 'multiple_choice' || item.element_type == 'checkbox') {
      let UCitemDefault = item.element_data.options.filter((ele => ele.element_uuid == item_value))
      if (UCitemDefault[0].default == true) {
        UCitemDefault[0].default = false;
      } else {
        UCitemDefault[0].default = true;
      }
    }
    if (item.element_type == 'date') {
      item.element_data.default_date_time = new Date(item_value).toISOString();
      item.element_data.default_date_time = new Date(item_value).toISOString();
    }
  }

  DeleteHtml(i, item, index) {
    this.finalArray.splice(index, 1);
    this.finalArray1 = [];
    this.formValuesUpdate(i, i.element_uuid, this.finalArray, null)
    this.displayArryChange(this.elementFields, this.finalArray)
  }
  EditHtml(item, index) {
    // whenever form values changes update the boolean status true. automatic update using instead of submit
    this.createDocumentStore.forms_changes_status = true;
    this.itemIndexNumber = index
    this.obj = this.finalArray[index]
    this.conditionSelected = item.condition_code
    this.csSelected = item.cs
    this.fieldQuantity = Number(item.quantity)
    this.countedCheck = item.not;
    this.showHtmlFields = true;

  }

  resizeImageDocument() {

    this.cdRef.detectChanges();
    let getImageContainer = document.getElementById("Imagecontainer");
    console.log(getImageContainer);
    let getImageContainerSize = getImageContainer.getBoundingClientRect();
    console.log(getImageContainerSize);
    if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
      let disableScale = false;
      var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
      console.log(scale_val);
      this.scaleValue = scale_val;
      //scale after moving toolbar move top and bottom and right
      this.scale = scale_val;
      let currentViewX = this.realWidth * scale_val;
      let currentViewY = this.realHeight * scale_val;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      const x1 = this.realWidth;
      const y1 = this.realHeight;
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: scale_val,
      });
      let viewImageDiv = document.getElementById("pdfImg");
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      // panZoomElement.centerOn('pdfImg');
      panZoomElement.on('transform', (e: any) => {
        // This event will be called along with events above.
        console.log('Fired when any transformation has happened', e);
        console.log(panZoomElement.getTransform());
        panZoomElement.pause();
        // panZoomElement.getTransform().scale = scale_val;
      });
    }
    else {
      let centerX = getImageContainerSize.width - this.realWidth;
      let centerY = getImageContainerSize.height - this.realHeight;
      let viewImageDiv = document.getElementById("pdfImg");
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: 1,
      });
      panZoomElement.pause();
      this.scale = 1;
      this.scaleValue = 1;
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
    }
  }

  resizePdfDocument() {
    let getImageContainer = document.getElementById("Imagecontainer");
    let getImageContainerSize = getImageContainer.getBoundingClientRect();
    console.log(getImageContainerSize, this.realWidth, this.realHeight);
    if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
      let disableScale = false;
      var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
      console.log(scale_val);
    }
  }

  changedateLocal(item, value) {
    item.element_data.default_date_time = value;
    
    this.formValuesUpdate(item, item.element_uuid, item.element_data.default_date_time, null)
  }
  clearDate(item) {
    
    let merge_cell;
    if (this.is_extend == true) {
      merge_cell = [...this.modelFieldsForm, ...this.extend_modelFieldsForm];
    } else {
      merge_cell = this.modelFieldsForm;
    }
    for (let k = 0; k < merge_cell.length; k++) {
      if (merge_cell[k]['element_uuid'] == item.element_uuid) {
        merge_cell[k].element_data.default_date_time = "";
        item.element_data.default_date_time = "";
        merge_cell[k].element_data.default_value = "";
        item.element_data.default_value = "none";
        
        this.formValuesUpdate(item, item.element_uuid, item.element_data.default_date_time, null)
      }
    }

    let dummy_model = [];
    let attribute_model = [];

    if (this.is_extend == true) {
      for (let i = 0; i < this.extend_modelFieldsForm.length; i++) {
        let filter_element = this.usecaseCopyArray.filter(data => data.element_uuid == this.extend_modelFieldsForm[i].element_uuid);
        if (filter_element != null && filter_element.length > 0) {
          dummy_model.push(filter_element[0]);
        }
      }
      this.extend_modelFieldsForm = _.cloneDeep(dummy_model);
      for (let i = 0; i < this.modelFieldsForm.length; i++) {
        let filter_element = this.usecaseCopyArray.filter(data => data.element_uuid == this.modelFieldsForm[i].element_uuid);
        if (filter_element != null && filter_element.length > 0) {
          attribute_model.push(filter_element[0]);
        }
      }
      this.modelFieldsForm = _.cloneDeep(attribute_model);
    }
    else {
      this.modelFieldsForm = merge_cell;
    }


  }
  assignDates(option) {
    if (option == "current") {
      return new Date();
    }
    else if (option == "none" || option == "") {
      return ;
    }
    else {
      if (option != undefined && option.includes("-")) {
        let final = option.split("T")
        let yourDate: Date = new Date(final[0] + " 12:00:00.000Z");
      
        // return yourDate
      }
      return option;
    }
  }
  securityCheck() {
    this.baseUrl = environment.APIBaseUrl + "get_web_singed_file?file=";
    this.sKey1 = "&key1=" + this.imgdataService.securityKey1();
    this.sKey2 = "&key2=" + this.imgdataService.securityKey2();
  }
  // process_use_conditions() {

  //   this.datas = this.modelFieldsForm;
  //   console.log(this.datas)
  //   if (this.datas != null) {
  //     for (let i = 0; i < this.datas.length; i++) {
  //       this.editIndex = i;

  //       this.condition_field_name = this.datas[i].element_data.use_conditions == true && this.datas[i].is_removed == 0 ? this.datas[i].element_data.if_condition : "";
  //       this.current_if_value = this.datas[i].element_data.use_conditions == true && this.datas[i].is_removed == 0 ? this.datas[i].element_data.if_value : "";
  //       this.current_if_do = this.datas[i].element_data.use_conditions == true && this.datas[i].is_removed == 0 ? this.datas[i].element_data.if_do : "";
  //       this.current_if_state = this.datas[i].element_data.use_conditions == true && this.datas[i].is_removed == 0 ? this.datas[i].element_data.if_state : "";
  //       if (this.condition_field_name != "") {
  //         let UCitem = this.usecaseCopyArray.filter((ele => ele['element_uuid'] == this.condition_field_name))
  //         if (UCitem.length > 0) {
  //           if (UCitem[0].element_data.default_value == null) {
  //             UCitem[0].element_data.default_value = ""
  //           }
  //         } else {
  //           this.condition_field_name = ""
  //         }
  //         if (this.current_if_state == 'is equal to') {
  //           if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == 'dropdown' || UCitem[0].element_type == 'single_choice') {
  //             //if (this.current_if_value == UCitem[0].element_data.default_value) {
  //             let multyOpt = UCitem[0].element_data.options.filter((ele => ele.element_uuid == this.current_if_value))
  //             if (multyOpt.length > 0) {
  //               if (this.current_if_do == "hide") {
  //                 if (multyOpt[0].default == true) {
  //                   this.datas[i].is_hidden = "1";
  //                 } else {
  //                   this.datas[i].is_hidden = 0;
  //                 }
  //               }
  //               else {
  //                 if (multyOpt[0].default == false) {
  //                   this.datas[i].is_hidden = "1";
  //                 } else {
  //                   this.datas[i].is_hidden = 0;
  //                 }
  //               }
  //             }
  //           } else {
  //             if (this.current_if_value == UCitem[0].element_data.default_value) {
  //               if (this.current_if_do == "hide") {
  //                 this.datas[i].is_hidden = "1";
  //               }
  //               else {
  //                 this.datas[i].is_hidden = 0;
  //               }
  //             }
  //             else {
  //               if (this.current_if_do == "hide") {
  //                 this.datas[i].is_hidden = 0;
  //               }
  //               else {
  //                 this.datas[i].is_hidden = "1";
  //               }
  //             }
  //           }
  //         } else if (this.current_if_state == 'is not equal to')//  Not equal to 
  //         {
  //           if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == 'dropdown' || UCitem[0].element_type == 'single_choice') {
  //             //if (this.current_if_value == UCitem[0].element_data.default_value) {
  //             let multyOpt = UCitem[0].element_data.options.filter((ele => ele.element_uuid == this.current_if_value))
  //             if (multyOpt.length > 0) {
  //               if (this.current_if_do == "hide") {
  //                 if (multyOpt[0].default != true) {
  //                   this.datas[i].is_hidden = "1";
  //                 } else {
  //                   this.datas[i].is_hidden = 0;
  //                 }
  //               }
  //               else {
  //                 if (multyOpt[0].default != false) {
  //                   this.datas[i].is_hidden = "1";
  //                 } else {
  //                   this.datas[i].is_hidden = 0;
  //                 }
  //               }
  //             }
  //           } else {
  //             if (this.current_if_value != UCitem[0].element_data.default_value) {
  //               if (this.current_if_do == "hide") {
  //                 this.datas[i].is_hidden = "1";
  //               }
  //               else {
  //                 this.datas[i].is_hidden = 0;
  //               }
  //             } else {
  //               if (this.current_if_do == "hide") {
  //                 this.datas[i].is_hidden = 0;
  //               }
  //               else {
  //                 this.datas[i].is_hidden = "1";
  //               }
  //             }
  //           }
  //         }
  //         else if (this.current_if_state == 'is filled') {
  //           if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == 'dropdown') {
  //             //if (this.current_if_value == UCitem[0].element_data.default_value) {
  //             let multyOpt = UCitem[0].element_data.options.filter((ele => ele.default == true))
  //             if (multyOpt.length > 0) {
  //               this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
  //             }//  if option is filled 
  //             else {
  //               this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
  //             }
  //           } else {
  //             if (UCitem[0].element_data.default_value != '') // other fields check if filled
  //             {
  //               this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
  //             } else {
  //               this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
  //             }
  //           }
  //         }// if filled over 
  //         else if (UCitem.length != 0 && this.current_if_state != 'is empty') {
  //           if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == 'dropdown') {
  //             //if (this.current_if_value == UCitem[0].element_data.default_value) {
  //             let multyOpt = UCitem[0].element_data.options.filter((ele => ele.default == true))
  //             if (multyOpt.length == 0) {
  //               this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
  //             }//  if option is filled 
  //             else {
  //               this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
  //             }
  //           } else {
  //             if (UCitem[0].element_data.default_value == '') // other fields check if filled
  //             {
  //               this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
  //             } else {
  //               this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
  //             }
  //           }
  //         }// if empty over 

  //         // else if (this.current_if_state == 'is filled') //  Is filled  
  //         // {

  //         //   if (this.datas[i].element_type == 'single_choice' || this.datas[i].element_type == 'multiple_choice' || this.datas[i].element_type == 'dropdown' || this.datas[i].element_type == 'checkbox') {
  //         //     let UCitem12 = this.datas[i].element_data.options.filter((ele => ele.element_uuid == this.current_if_value))
  //         //     let defaultOptions = this.usecaseCopyArray[i].element_data.options.filter((ele => ele.default == true))
  //         //     this.activeIndex = this.usecaseCopyArray[i].element_data.options.findIndex(data => data.default == true)
  //         //     let redioIndex = this.datas[i].element_data.options.findIndex((ele => ele.element_uuid == this.current_if_value))
  //         //     if (UCitem[0].element_type == 'multiple_choice') {
  //         //       let OptionSelected = UCitem[0].element_data.options.filter((ele => ele.default == true))
  //         //       UCitem12[0].default = false;
  //         //       this.datas[i].element_data.default_value = null
  //         //       if (OptionSelected.length > 0) {
  //         //         this.datas[i].element_data.default_value = UCitem12[0].element_uuid;
  //         //         UCitem12[0].default = true;
  //         //       }
  //         //     } else {
  //         //       if (UCitem[0].element_type == 'address') {
  //         //         if (UCitem[0].element_data['city'] != "" || UCitem[0].element_data.street_address1 != "" || UCitem[0].element_data['state'] != "" || UCitem[0].element_data['zip'] != "" || UCitem[0].element_data.street_address2 != "") {
  //         //           this.datas[i].element_data.options.forEach(element => {
  //         //             element.default = false;
  //         //           });
  //         //           this.datas[i].element_data.default_value = UCitem12[0].element_uuid;
  //         //           UCitem12[0].default = true;
  //         //         } else {
  //         //           if (this.activeIndex != -1) {
  //         //             this.datas[i].element_data.options.forEach(element => {
  //         //               element.default = false;
  //         //             });
  //         //             this.datas[i].element_data.options[this.activeIndex].default = true
  //         //           } else {
  //         //             this.datas[i].element_data.options.forEach(element => {
  //         //               element.default = false;
  //         //             });
  //         //           }
  //         //         }
  //         //       } else {
  //         //         // UCitem12[0].default = false;
  //         //         // this.datas[i].element_data.default_value = null
  //         //         if ((UCitem[0].element_data.default_value != null) && (UCitem[0].element_data.default_value != "")) {
  //         //           this.datas[i].element_data.options.forEach(element => {
  //         //             element.default = false;
  //         //           });
  //         //           this.datas[i].element_data.default_value = UCitem12[0].element_uuid;
  //         //           UCitem12[0].default = true;
  //         //         } else {
  //         //           if (this.activeIndex != -1) {
  //         //             this.datas[i].element_data.options.forEach(element => {
  //         //               element.default = false;
  //         //             });
  //         //             this.datas[i].element_data.options[this.activeIndex].default = true
  //         //           } else {
  //         //             this.datas[i].element_data.options.forEach(element => {
  //         //               element.default = false;
  //         //             });
  //         //           }
  //         //         }
  //         //       }
  //         //     }
  //         //   }
  //         //   else {
  //         //     if (UCitem[0].element_type == 'single_choice' || UCitem[0].element_type == 'multiple_choice' || UCitem[0].element_type == 'dropdown' || UCitem[0].element_type == 'checkbox') {
  //         //       let OptionSelected = UCitem[0].element_data.options.filter((ele => ele.default == true))
  //         //       this.datas[i].element_data.default_value = this.usecaseCopyArray[i].element_data.default_value;
  //         //       if (OptionSelected.length > 0) {
  //         //         this.datas[i].element_data.default_value = this.current_if_value;
  //         //       }
  //         //     }
  //         //     else {

  //         //       this.datas[i].element_data.default_value = this.usecaseCopyArray[i].element_data.default_value;
  //         //       if (UCitem[0].element_type == 'address') {
  //         //         if (UCitem[0].element_data['city'] != "" || UCitem[0].element_data.street_address1 != "" || UCitem[0].element_data['state'] != "" || UCitem[0].element_data['zip'] != "" || UCitem[0].element_data.street_address2 != "") {
  //         //           this.datas[i].element_data.default_value = this.current_if_value;
  //         //         }
  //         //       } else {
  //         //         if (UCitem[0].element_data.default_value != null && UCitem[0].element_data.default_value != "") {
  //         //           this.datas[i].element_data.default_value = this.current_if_value;
  //         //         }
  //         //       }
  //         //     }
  //         //   }
  //         // } else if (this.current_if_state == "is empty")  // Is empty
  //         // {
  //         //   if (this.datas[i].element_type == 'single_choice' || this.datas[i].element_type == 'multiple_choice' || this.datas[i].element_type == 'dropdown') {
  //         //     let UCitem12 = this.datas[i].element_data.options.filter((ele => ele.element_uuid == this.current_if_value))
  //         //     this.activeIndex = this.usecaseCopyArray[i].element_data.options.findIndex(data => data.default == true)
  //         //     if (UCitem[0].element_type == 'multiple_choice') {
  //         //       let OptionSelected = UCitem[0].element_data.options.filter((ele => ele.default == true))
  //         //       if (OptionSelected.length == 0) {
  //         //         UCitem12[0].default = true;
  //         //       }
  //         //     } else {
  //         //       if (UCitem[0].element_type == 'address') {
  //         //         if (UCitem[0].element_data.city == "" || UCitem[0].element_data.street_address1 == "" || UCitem[0].element_data.state == "" || UCitem[0].element_data.zip == "" || UCitem[0].element_data.street_address2 == "") {
  //         //           this.datas[i].element_data.options.forEach(element => {
  //         //             element.default = false;
  //         //           });
  //         //           UCitem12[0].default = true;
  //         //         } else {
  //         //           if (this.activeIndex != -1) {
  //         //             this.datas[i].element_data.options.forEach(element => {
  //         //               element.default = false;
  //         //             });
  //         //             this.datas[i].element_data.options[this.activeIndex].default = true
  //         //           } else {
  //         //             this.datas[i].element_data.options.forEach(element => {
  //         //               element.default = false;
  //         //             });
  //         //           }
  //         //         }
  //         //       } else {
  //         //         if ((UCitem[0].element_data.default_value == null) || (UCitem[0].element_data.default_value == "")) {
  //         //           this.datas[i].element_data.options.forEach(element => {
  //         //             element.default = false;
  //         //           });
  //         //           UCitem12[0].default = true;
  //         //         } else {
  //         //           if (this.activeIndex != -1) {
  //         //             this.datas[i].element_data.options.forEach(element => {
  //         //               element.default = false;
  //         //             });
  //         //             this.datas[i].element_data.options[this.activeIndex].default = true
  //         //           } else {
  //         //             this.datas[i].element_data.options.forEach(element => {
  //         //               element.default = false;
  //         //             });
  //         //           }
  //         //         }
  //         //       }
  //         //     }
  //         //   }
  //         //   else {
  //         //     if (UCitem[0].element_type == 'single_choice' || UCitem[0].element_type == 'multiple_choice' || UCitem[0].element_type == 'dropdown' || UCitem[0].element_type == 'checkbox') {
  //         //       let OptionSelected = UCitem[0].element_data.options.filter((ele => ele.default == true))
  //         //       this.datas[i].element_data.default_value = this.usecaseCopyArray[i].element_data.default_value;
  //         //       if (OptionSelected.length == 0) {
  //         //         this.datas[i].element_data.default_value = this.current_if_value;
  //         //       }
  //         //     }
  //         //     else {
  //         //       this.datas[i].element_data.default_value = this.usecaseCopyArray[i].element_data.default_value;
  //         //       if (UCitem[0].element_type == 'address') {
  //         //         if (UCitem[0].element_data.city == "" && UCitem[0].element_data.street_address1 == "" && UCitem[0].element_data.state == "" && UCitem[0].element_data.zip == "" && UCitem[0].element_data.street_address2 == "") {
  //         //           this.datas[i].element_data.default_value = this.current_if_value;
  //         //         }
  //         //       } else {
  //         //         if ((UCitem[0].element_data.default_value == null) || (UCitem[0].element_data.default_value == "")) {
  //         //           this.datas[i].element_data.default_value = this.current_if_value;
  //         //         }
  //         //       }
  //         //     }
  //         //   }
  //         // }


  //       }
  //     }
  //   }
  //   //this.modelFieldsForm = this.datas
  // }

  process_use_conditions() {
    this.datas = this.usecaseCopyArray;
    console.log(this.datas)
    for (let i = 0; i < this.datas.length; i++) {
      this.editIndex = i;
      //taking the data if any conditions available
      if (this.datas[i].element_data.use_conditions == true) {
        this.condition_field_name = this.datas[i].element_data.if_condition;
        this.current_if_value = this.datas[i].element_data.if_value;
        this.current_if_do = this.datas[i].element_data.if_do;
        this.current_if_state = this.datas[i].element_data.if_state;
      } else {
        this.condition_field_name = ""
        this.current_if_value = ""
        this.current_if_do = ""
        this.current_if_state = ""
      }

      if (this.condition_field_name != "") {

        //taking the current field attached with the use condition
        let UCitem = this.usecaseCopyArray.filter((ele => ele.element_uuid == this.condition_field_name))
        if (UCitem.length > 0) {
          if (UCitem.length > 0) {
            if (UCitem[0].element_data.default_value == null) {
              UCitem[0].element_data.default_value = ""
            }
          } else {
            this.condition_field_name = ""
          }

          if (this.current_if_state == 'is equal to') {
            if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox') {
              //if (this.current_if_value == UCitem[0].element_data.default_value) {
              //if the use condition field is a multi choice 
              let multyOpt = UCitem[0].element_data.options.filter((ele => ele.element_uuid == this.current_if_value))
              if (multyOpt.length > 0) {
                if (this.current_if_do == "hide") {
                  if (multyOpt.length > 0 && multyOpt[0].default == true) {
                    this.datas[i].is_hidden = "1";
                  } else {
                    this.datas[i].is_hidden = 0;
                  }
                }
                else {

                  if (multyOpt.length > 0 && multyOpt[0].default == false) {
                    this.datas[i].is_hidden = "1";
                  } else {
                    this.datas[i].is_hidden = 0;
                  }
                }
              }
            } else {
              if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == 'dropdown' || UCitem[0].element_type == 'group_field') {
                let multyOpt = UCitem[0].element_data.options.filter((ele => ele.default == true))
                if (multyOpt.length > 0) {
                  if (multyOpt.length > 0 && multyOpt[0].default == true) {
                    this.datas[i].is_hidden = "1";
                  } else {
                    this.datas[i].is_hidden = 0;
                  }
                }
                else {
                  if (this.current_if_do == "hide") {
                    this.datas[i].is_hidden = 0;
                  }
                  else {
                    this.datas[i].is_hidden = "1";
                  }
                }
              }
            }
          }
          else if (this.current_if_state == 'is not equal to')//  Not equal to 
          {
            if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox') {
              //if (this.current_if_value == UCitem[0].element_data.default_value) {
              let multyOpt = UCitem[0].element_data.options.filter((ele => ele.element_uuid == this.current_if_value))
              if (this.current_if_do == "hide") {
                if (multyOpt.length > 0 && multyOpt[0].default != true) {
                  this.datas[i].is_hidden = "1";
                } else {
                  this.datas[i].is_hidden = 0;
                }
              }
              else {
                if (multyOpt.length > 0 && multyOpt[0].default != false) {
                  this.datas[i].is_hidden = "1";
                } else {
                  this.datas[i].is_hidden = 0;
                }
              }
            } else {
              if (this.current_if_value != UCitem[0].element_data.default_value) {
                if (this.current_if_do == "hide") {
                  this.datas[i].is_hidden = "1";
                }
                else {
                  this.datas[i].is_hidden = 0;
                }
              } else {
                if (this.current_if_do == "hide") {
                  this.datas[i].is_hidden = 0;
                }
                else {
                  this.datas[i].is_hidden = "1";
                }
              }
            }
          }
          //  Is filled  or empty
          else if (this.current_if_state == 'is filled') {
            if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == 'dropdown' || UCitem[0].element_type == 'group_field') {
              //if (this.current_if_value == UCitem[0].element_data.default_value) {
              let multyOpt = UCitem[0].element_data.options.filter((ele => ele.default == true))
              if (multyOpt.length > 0) {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
              }//  if option is filled 
              else {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
              }
            } else {
              if (UCitem[0].element_data.default_value != '') // other fields check if filled
              {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
              } else {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
              }
            }
          }// if filled over 
          else if (this.current_if_state == 'is empty') {
            if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == 'dropdown' || UCitem[0].element_type == 'group_field') {
              //if (this.current_if_value == UCitem[0].element_data.default_value) {
              let multyOpt = UCitem[0].element_data.options.filter((ele => ele.default == true))
              if (multyOpt.length == 0) {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
              }//  if option is filled 
              else {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
              }
            } else {
              if (UCitem[0].element_data.default_value == '') // other fields check if filled
              {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
              } else {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
              }
            }
          }
          else {

          }
          //this.model.attributes = localdata;
        }
      }
    } // for close 
    var localdata = [];
    localdata = this.datas;
    localdata = localdata.filter((ele => ele.is_hidden != "1"))
    this.datas = [];
    this.datas = localdata;
    this.process_use_conditions1();
  }

  //duplicate odf the use condition function
  process_use_conditions1() {
    this.datas = this.usecaseCopyArray;
    console.log(this.datas)
    for (let i = 0; i < this.datas.length; i++) {
      this.editIndex = i;
      if (this.datas[i].element_data.use_conditions == true) {
        this.condition_field_name = this.datas[i].element_data.if_condition;
        this.current_if_value = this.datas[i].element_data.if_value;
        this.current_if_do = this.datas[i].element_data.if_do;
        this.current_if_state = this.datas[i].element_data.if_state;
      } else {
        this.condition_field_name = ""
        this.current_if_value = ""
        this.current_if_do = ""
        this.current_if_state = ""
      }
      if (this.condition_field_name != "") {
        let UCitem = this.usecaseCopyArray.filter((ele => ele.element_uuid == this.condition_field_name))
        if (UCitem.length > 0) {
          if (this.current_if_state == 'is equal to') {
            if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == "single_choice" || UCitem[0].element_type == "dropdown" || UCitem[0].element_type == 'group_field') {
              let multyOpt = UCitem[0].element_data.options.filter((ele => ele.element_uuid == this.current_if_value))
              if (multyOpt.length > 0) {
                if (this.current_if_do == "hide") {
                  if (multyOpt.length > 0 && multyOpt[0].default == true) {
                    this.datas[i].is_hidden = "1";
                  } else {
                    this.datas[i].is_hidden = 0;
                  }
                }
                else {
                  if (multyOpt.length > 0 && multyOpt[0].default == false) {
                    this.datas[i].is_hidden = "1";
                  } else {
                    this.datas[i].is_hidden = 0;
                  }
                }
              }
            }
            else {
              if (this.current_if_value == UCitem[0].element_data.default_value) {
                if (this.current_if_do == "hide") {
                  this.datas[i].is_hidden = "1";
                }
                else {
                  this.datas[i].is_hidden = 0;
                }
              }
              else {
                if (this.current_if_do == "hide") {
                  this.datas[i].is_hidden = 0;
                }
                else {
                  this.datas[i].is_hidden = "1";
                }
              }
            }
          }
          else if (this.current_if_state == 'is not equal to')//  Not equal to 
          {
            if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == "single_choice" || UCitem[0].element_type == "dropdown" || UCitem[0].element_type == 'group_field') {
              //if (this.current_if_value == UCitem[0].element_data.default_value) {
              let multyOpt = UCitem[0].element_data.options.filter((ele => ele.element_uuid == this.current_if_value))
              if (this.current_if_do == "hide") {
                if (multyOpt.length > 0 && multyOpt[0].default != true) {
                  this.datas[i].is_hidden = "1";
                } else {
                  this.datas[i].is_hidden = 0;
                }
              }
              else {
                if (multyOpt.length > 0 && multyOpt[0].default != false) {
                  this.datas[i].is_hidden = "1";
                } else {
                  this.datas[i].is_hidden = 0;
                }
              }
            } else {
              if (this.current_if_value != UCitem[0].element_data.default_value) {
                if (this.current_if_do == "hide") {
                  this.datas[i].is_hidden = "1";
                }
                else {
                  this.datas[i].is_hidden = 0;
                }
              } else {
                if (this.current_if_do == "hide") {
                  this.datas[i].is_hidden = 0;
                }
                else {
                  this.datas[i].is_hidden = "1";
                }
              }
            }
          }
          //  Is filled  or empty
          else if (this.current_if_state == 'is filled') {
            if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == "single_choice" || UCitem[0].element_type == "dropdown" || UCitem[0].element_type == 'group_field') {
              //if (this.current_if_value == UCitem[0].element_data.default_value) {
              let multyOpt = UCitem[0].element_data.options.filter((ele => ele.default == true))
              if (multyOpt.length > 0) {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
              }//  if option is filled 
              else {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
              }
            } else {
              if (UCitem[0].element_data.default_value != '') // other fields check if filled
              {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
              } else {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
              }
            }
          }// if filled over 
          else if (this.current_if_state == 'is empty') {
            if (UCitem[0].element_type == "multiple_choice" || UCitem[0].element_type == 'checkbox' || UCitem[0].element_type == "single_choice" || UCitem[0].element_type == "dropdown" || UCitem[0].element_type == 'group_field') {
              //if (this.current_if_value == UCitem[0].element_data.default_value) {
              let multyOpt = UCitem[0].element_data.options.filter((ele => ele.default == true))
              if (multyOpt.length == 0) {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
              }//  if option is filled 
              else {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
              }
            } else {
              if (UCitem[0].element_data.default_value == '') // other fields check if filled
              {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "1" : "0";
              } else {
                this.datas[i].is_hidden = this.current_if_do == "hide" ? "0" : "1";
              }
            }
          }
          else {

          }
        }
      }
    }
    var localdata = [];
    localdata = this.datas;
    var emptycell = this.datas.filter(data => data.is_hidden == "1");
    if (emptycell.length > 0) {
      for (var i = 0; i < emptycell.length; i++) {
        var referenceidss = emptycell[i].element_data.reference_id;
        var findingelementid = this.datas.filter(data => data.element_uuid == referenceidss);
        if (findingelementid.length > 0 && findingelementid[0].element_type == "empty_cell") {
          findingelementid[0].is_hidden = "1";
        }
      }
    }
    this.datas = [];
    let dummy_model = [];
    let attribute_model = [];
    localdata = localdata.filter((ele => ele.is_hidden != "1"))
    this.datas = localdata;
    if (this.is_extend == true) {
      for (let i = 0; i < this.extend_modelFieldsForm.length; i++) {
        let filter_element = this.usecaseCopyArray.filter(data => data.element_uuid == this.extend_modelFieldsForm[i].element_uuid);
        if (filter_element != null && filter_element.length > 0) {
          dummy_model.push(filter_element[0]);
        }
      }
      this.extend_modelFieldsForm = _.cloneDeep(dummy_model);
      for (let i = 0; i < this.modelFieldsForm.length; i++) {
        let filter_element = this.usecaseCopyArray.filter(data => data.element_uuid == this.modelFieldsForm[i].element_uuid);
        if (filter_element != null && filter_element.length > 0) {
          attribute_model.push(filter_element[0]);
        }
      }
      this.modelFieldsForm = _.cloneDeep(attribute_model);
      // this.alignmenprocess();
    }
    else {
      this.modelFieldsForm = localdata;
    }
  }

  useConditionChange(item, uuid, value, addressCheck) {
    if (item.element_data.label_text == "Total Element Quantity") {
      this.totalElementQuantity = Number(item.element_data.default_value);
      this.htmlcalculation();
    }
    let check_value_in = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid));
    if (check_value_in.length > 0) {
      if (item.element_type == "uti-entry-field") {
        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid))
        UCItem[0].element_data["default_values"] = value;
      }
      else if (item.element_type == "uti-entry-field-WMATA") {
        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid))
        UCItem[0].element_data["default_values"] = value;
      }
      else if (item.element_type == "uti-entry-field-WMATA_WELD") {
        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid));
        const valuesLength = UCItem[0].element_data["default_values"].length;
        if(valuesLength == 0){
          UCItem[0].element_data["default_values"] = value;
        }
        else{
          UCItem[0].element_data["default_values"].push(value[0]);
        }
      }
      else if (item.element_type == "uti-entry-field-TIMBER") {
        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid))
        UCItem[0].element_data["default_values"] = value;
      }
      else if (item.element_type == 'dropdown' || item.element_type == 'group_field') {
        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid))
        console.log(UCItem);
        console.log(value);
        let selected_or_not = false;
        if (value.default == true) {
          selected_or_not = true;
        }
        UCItem[0].element_data.options.forEach(element => {
          element.default = false;
        });

        let UCitemDefault = UCItem[0].element_data.options.filter((ele => ele.element_uuid == value.element_uuid))
        console.log(UCitemDefault);
        console.log(value);
        if (selected_or_not == true) {
          UCitemDefault[0].default = true;
        }
      }
      else if (item.element_type == 'single_choice') {
        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid))
        // UCItem[0].element_data.options.forEach(element => {
        //   element.default = false
        // });
        if (UCItem.length > 0) {
          let UCitemDefault = UCItem[0].element_data.options.filter((ele => ele.element_uuid == value.element_uuid))
          let findValueAccept = false;
          let getTrueorFalse = UCitemDefault[0].default;
          console.log(getTrueorFalse);
          if (getTrueorFalse == true || getTrueorFalse == "true" || getTrueorFalse == "1") {
            findValueAccept = true;
          }
          // if (UCitemDefault[0].line_width == 0) {
          //   UCitemDefault[0].line_width = this.propertiesannotationDataCopy.line_width
          // }
          // if (findValueAccept == true) {
          //   UCitemDefault[0].default = false;
          // }
          // else {
          //   UCitemDefault[0].default = true;
          // }
          // UCItem[0].element_data.default_value = value.element_uuid
          //this.FormulaCalc(item.element_data.label_text);
        }
      } else if (item.element_type == 'number') {
        let UCitem12 = this.usecaseCopyArray.filter((ele => ele.element_uuid == item.element_uuid))
        UCitem12[0].element_data.default_value = item.element_data.default_value;
        //this.FormulaCalc(item.element_data.label_text);
      } else if (item.element_type == 'multiple_choice' || item.element_type == 'checkbox') {
        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid));
        let options = UCItem[0].element_data.options;
        options.forEach(item_values => {
          let data = item.element_data.options.filter((ele => ele.element_uuid == item_values.element_uuid))
          if (data.length > 0) {
            item_values.default = data[0].default
          }
        })
        UCItem[0].element_data.options = options
        let UCitemDefault = UCItem[0].element_data.options.filter((ele => ele.element_uuid == value.element_uuid))
        // if (UCitemDefault[0].default == true) {
        //   UCitemDefault[0].default = false;
        // } else {
        //   UCitemDefault[0].default = true;
        // }
      } else if (item.element_type == 'address') {

        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid))
        if (addressCheck == "street_address1") {
          UCItem[0].element_data.street_address1 = value;
        } else if (addressCheck == "city") {
          UCItem[0].element_data.city = value;
        } else if (addressCheck == "state") {
          UCItem[0].element_data.state = value;
        } else if (addressCheck == "zip") {
          UCItem[0].element_data.zip = value;
        } else if (addressCheck == "street_address2") {
          UCItem[0].element_data.street_address2 = value;
        }
      }
      else {
        var UCItem = this.usecaseCopyArray.filter((ele => ele.element_uuid == uuid))
        UCItem[0].element_data.default_value = value;
      }
      console.log(UCItem);
      this.process_use_conditions();
      
      this.FormulaCalc();
    }
  }

  FormulaCalc() {

    let merge_forms;
    if (this.is_extend == true) {
      merge_forms = [...this.modelFieldsForm, ...this.extend_modelFieldsForm]
    } else {
      merge_forms = this.modelFieldsForm;
    }

    if (merge_forms != null) {
      var FormulaFieldfind = merge_forms.filter(ele => ele.element_type == "calculation" && ele.is_removed == 0);
      var calculationValueUpdate = merge_forms.filter(ele => ele.element_type == "calculation");
      if (FormulaFieldfind.length != 0) {
        
        //if (FormulaFieldfind[0].element_data['calculation_value'] == "") { } else {
        var i = 0;
        FormulaFieldfind.forEach(calc => {
          
          if (FormulaFieldfind[i].element_data['calculation_value'] != "") {
            if (FormulaFieldfind[i].element_data['default_value'] == "") {
              FormulaFieldfind[i].element_data['default_value'] = "1"
            }
            if (FormulaFieldfind[i].element_data['calculation_value'].includes("AVG")) {
              this.AvarageCalculation(calc, FormulaFieldfind[i], calculationValueUpdate[i])
            } else {
              
              var CalcValue = calc.element_data['calculation_value'];
              var matches = [];
              var pattern = /\[(.*?)\]/g;
              var match;
              while ((match = pattern.exec(CalcValue)) != null) {
                matches.push(match[1]);
              }
              
              this.DummyField = calc.element_data['calculation_value'];
             // calc.element_data['calculation_value'] = calc.element_data['calculation_value']
               calc.element_data['calculation'] = calc.element_data['calculation_value']
              
              matches.forEach(element => {
               
                var FieldFind = this.modelFieldsForm.filter(ele => ele['element_uuid'] == element);
                if(FieldFind.length==0){
                  FieldFind = this.extend_modelFieldsForm.filter(ele => ele['element_uuid'] == element);
                 
                }
                this.FieldResult = FieldFind[0];
                console.log( this.FieldResult )
                this.DummyField = this.DummyField.replace(element, FieldFind[0].element_data.label_text)
                if (FieldFind[0].element_type == "single_choice" || FieldFind[0].element_type == "dropdown") {
                 
                  var CalculatioField1 = FieldFind[0].element_data.options.filter(ele => ele.default == true);
  
                  if (CalculatioField1.length > 0) {
                    if (CalculatioField1[0].calculated_value != "") {
                      
                      if (calc.element_data['calculation'].includes('[' + element + ']')) {

                        calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", CalculatioField1[0].calculated_value)
                      } else {
                        calc.element_data.calculation = calc.element_data.calculation.replace("[" + element + "]", 0)
                      }
                    
                      this.DummyField = calc.element_data['calculation'];
                    }else {
                      //calc.element_data.calculation = this.DummyField
                      calc.element_data.calculation = calc.element_data.calculation.replace("[" + element + "]", 0)
                      }
                    
                  } else {
                   // calc.element_data['calculation'] = this.DummyField
                   calc.element_data.calculation = calc.element_data.calculation.replace("[" + element + "]", 0)
                  }
                } else if (FieldFind[0].element_type == "multiple_choice" || FieldFind[0].element_type == "checkbox") {
                 
                  var calculatedalltotal = 0;
                  var CalculatioField1 = FieldFind[0].element_data.options.filter(ele => ele.default == true);
                  if (CalculatioField1.length > 0) {
                    CalculatioField1.forEach(ele => {
                      if (ele.calculated_value != "") {
                        calculatedalltotal = calculatedalltotal + Number(ele.calculated_value)
                      }
                    });
                    if (calculatedalltotal != 0) {
                      if (calc.element_data['calculation'].includes('[' + element + ']')) {
                        calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", calculatedalltotal)
                      } else {
                        calc.element_data.calculation = calc.element_data.calculation.replace("[" + element + "]", 0)
                      }
                      this.DummyField = calc.element_data['calculation'];
                    }
                    else  if (calculatedalltotal == 0  && FieldFind[0].element_type == "checkbox") {
                      calc.element_data.calculation = calc.element_data.calculation.replace("[" + element + "]", 1)
                    }
                  } 
                  else if(CalculatioField1.length == 0 )
                  {
                    calc.element_data.calculation = calc.element_data.calculation.replace("[" + element + "]", 0)
                  }
                  else {
                    calc.element_data['calculation'] = this.DummyField
                  }
                 
                  console.log(calc.element_data['calculation'])
                }
                //////////////////
                else if (FieldFind[0].element_type == "calculation") {
                  if (FieldFind[0].element_data['calculation'] != "" && FieldFind[0].element_data['calculation'] != undefined) {
                    if (FieldFind[0].element_data['calculation'].includes('[')) {
                      calc.element_data['calculation'] = this.DummyField
                    } else if (calc.element_data['calculation'].includes('[' + element + ']')) {
                      calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", FieldFind[0].element_data['calculation'])
                    } else {
                      calc.element_data['calculation'] = calc.element_data["calculation_value"].replace("[" + element + "]", FieldFind[0].element_data['calculation'])
                    }
                  }
                  if (this.FieldResult.element_data.calculation == "" || this.FieldResult.element_data.calculation == undefined) {
                    calc.element_data['calculation'] = this.DummyField
                  } else {
                    this.DummyField = calc.element_data['calculation']
                  }
                }
                ///////////////////
                else {
                  if (FieldFind[0].element_data.default_value != "" && FieldFind[0].element_data.default_value != null) {
                    if (calc.element_data['calculation'].includes('[' + element + ']')) {
                      calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", FieldFind[0].element_data.default_value)
                    } else {
                      calc.element_data['calculation'] = calc.element_data['calculation_value'].replace("[" + element + "]", FieldFind[0].element_data.default_value)
                    }
                  }
                  if (this.FieldResult.element_data.default_value == "" || this.FieldResult.element_data.default_value == undefined) {
                    calc.element_data['calculation'] = this.DummyField
                  } else {
                    this.DummyField = calc.element_data['calculation']
                  }
                }
              })
              if (calc.element_data['calculation'].includes('[')) {
                calculationValueUpdate[i].element_data['calculation'] = calc.element_data['calculation'];
              } else {
                
                if (calc.element_data['calculation'].includes('.rounded()')) {
                  calc.element_data['calculation'] = calc.element_data['calculation'].split(".rounded()").join("")
                  calculationValueUpdate[i].element_data['calculation'] = eval(
                    calc.element_data['calculation']
                  );
                  calculationValueUpdate[i].element_data['calculation'] = calculationValueUpdate[i].element_data['calculation'] != "" && calculationValueUpdate[i].element_data['calculation'] > 1 ? Math.round(calculationValueUpdate[i].element_data['calculation']) : 1
                  calculationValueUpdate[i].element_data['calculation'] = calculationValueUpdate[i].element_data['calculation'].toFixed(Number(calculationValueUpdate[i].element_data.default_value));
                } 
                //square root function implemented start
                else if (calc.element_data.calculation.includes('√')) {
                  let get_fianl_value = this.dataService4.squareRootCalculation(calc.element_data.calculation);
                  if (get_fianl_value != '√' && get_fianl_value != '') {
                    // get_fianl_value = eval(get_fianl_value);
                    let validcalculation = false;
                    try {
                      eval(get_fianl_value); 
                      validcalculation = true;
                    } catch (e) {
                      if (e instanceof SyntaxError) {
                        // alert(e.message);
                        validcalculation = false;
                        calculationValueUpdate[i].element_data.calculation = get_fianl_value;
                      }
                    }
                    if(validcalculation==true){
                      get_fianl_value = eval(get_fianl_value);	
                      calculationValueUpdate[i].element_data.calculation = get_fianl_value;
                      calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
                    }
                  }
                  // calculationValueUpdate[i].element_data.calculation = get_fianl_value;
                  // calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
                }
                //square root function implemented end
                //power function implemented start
                else if (calc.element_data.calculation.includes('^')) {
                  let get_fianl_value = this.dataService4.powerOfCalculation(calc.element_data.calculation);
                  if (get_fianl_value != '^' && get_fianl_value != '') {
                    // get_fianl_value = eval(get_fianl_value);
                    let validcalculation = false;
                    try {
                      eval(get_fianl_value); 
                      validcalculation = true;
                    } catch (e) {
                      if (e instanceof SyntaxError) {
                        // alert(e.message);
                        validcalculation = false;
                        calculationValueUpdate[i].element_data.calculation = get_fianl_value;
                      }
                    }
                    if(validcalculation==true){
                      get_fianl_value = eval(get_fianl_value);	
                      calculationValueUpdate[i].element_data.calculation = get_fianl_value;
                      calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
                    }
                  }
                  // calculationValueUpdate[i].element_data.calculation = get_fianl_value;
                  // calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
                }
                //power function implemented end
                else {
                  let check_seperators = ["(",")","+","-","*","/"];
                  let get_calculation = calc.element_data.calculation
                  let get_fist_value = calc.element_data.calculation[0];
                  let get_second_value = calc.element_data.calculation[1];
                  let get_last_value = calc.element_data.calculation[calc.element_data.calculation.length-1];
                  if(check_seperators.includes(get_fist_value) && check_seperators.includes(get_second_value)){
                    calculationValueUpdate[i].element_data.calculation = calc.element_data.calculation
                  }
                  else if(check_seperators.includes(get_last_value)){
                    calculationValueUpdate[i].element_data.calculation = calc.element_data.calculation
                  }
                  else if((get_calculation.includes("(") && !get_calculation.includes(")"))||
                  (get_calculation.includes(")") && !get_calculation.includes("(")) ){
                    calculationValueUpdate[i].element_data.calculation = calc.element_data.calculation
                  }
                  else{
                    const calValue = eval(calc.element_data.calculation);
                    let value = calValue;
                    const NaNCheck = isNaN(calValue);
                    if (NaNCheck == true || value == "Infinity") {
                      value = 0;
                    }
                    calculationValueUpdate[i].element_data.calculation = value;
                    calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.default_value == "" ? calculationValueUpdate[i].element_data.calculation.toFixed(Number(1)) : calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
                    let confirmedValue = calc.element_data.calculation;
                    console.log(Math.abs(confirmedValue));
                    let decimalCheck = Math.abs(confirmedValue);
                  }
                  console.log(typeof calculationValueUpdate[i].element_data.calculation);
                  
                }
                // else {
                //   calculationValueUpdate[i].element_data['calculation'] = eval(
                //     calc.element_data['calculation']
                //   );
                //   calculationValueUpdate[i].element_data['calculation'] = calculationValueUpdate[i].element_data['calculation'].toFixed(calculationValueUpdate[i].element_data.default_value);
                //   let confirmedValue = calc.element_data['calculation'];
                //   console.log(Math.abs(confirmedValue));
                //   let decimalCheck = Math.abs(confirmedValue);
                // }
              }
            }
            console.log(calc.element_data['calculation'])
            i++;
          }
        })
        //   if (FormulaFieldfind[i].element_data['calculation_value'] != "") {
        //     if (FormulaFieldfind[i].element_data['calculation_value'].includes("AVG")) {
        //       this.AvarageCalculation(calc, FormulaFieldfind[i], calculationValueUpdate[i])
        //     } else {
        //       var CalcValue = calc.element_data['calculation_value'];
        //       var matches = [];
        //       var pattern = /\[(.*?)\]/g;
        //       var match;
        //       while ((match = pattern.exec(CalcValue)) != null) {
        //         matches.push(match[1]);
        //       }
        //       this.DummyField = calc.element_data['calculation_value'];
        //       // calc.element_data['calculation_value'] = calc.element_data['calculation_value']
        //       calc.element_data['calculation'] = calc.element_data['calculation_value']
        //       matches.forEach(element => {


        //         var FieldFind = this.modelFieldsForm.filter(ele => ele['element_uuid'] == element);
        //         this.FieldResult = FieldFind[0];
        //         this.DummyField = this.DummyField.replace(element, FieldFind[0].element_data.label_text)
        //         if (FieldFind[0].element_type == "single_choice" || FieldFind[0].element_type == "dropdown") {
        //           var CalculatioField1 = FieldFind[0].element_data.options.filter(ele => ele.default == true);
        //           if (CalculatioField1.length > 0) {
        //             if (CalculatioField1[0].calculated_value != "") {
        //               //   if (calc.element_data['calculation'].includes('[' + element + ']')) {
        //               //     calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", CalculatioField1[0].calculated_value)
        //               //   } else {
        //               //     calc.element_data['calculation'] = calc.element_data['calculation_value'].replace("[" + element + "]", CalculatioField1[0].calculated_value)
        //               //   }
        //               // }
        //               // this.DummyField = calc.element_data['calculation'];
        //               if (calc.element_data['calculation'].includes('[' + element + ']')) {
        //                 calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", CalculatioField1[0].calculated_value)
        //               }
        //               else {
        //                 calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", 0)
        //               }
        //               this.DummyField = calc.element_data['calculation']
        //             } else {
        //               //calc.element_data['calculation'] = this.DummyField
        //               calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", 0)

        //             }
        //           } else {
        //             //calc.element_data.calculation = this.DummyField
        //             calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", 0)
        //           }

        //         } else if (FieldFind[0].element_type == "multiple_choice" || FieldFind[0].element_type == "checkbox") {
        //           var calculatedalltotal = 0;
        //           var CalculatioField1 = FieldFind[0].element_data.options.filter(ele => ele.default == true);
        //           if (CalculatioField1.length > 0) {
        //             CalculatioField1.forEach(ele => {
        //               if (ele.calculated_value != "") {
        //                 calculatedalltotal = calculatedalltotal + Number(ele.calculated_value)
        //               }
        //             });
        //             if (calculatedalltotal != 0) {
        //               if (calc.element_data['calculation'].includes('[' + element + ']')) {
        //                 //calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", calculatedalltotal)
        //                 calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", calculatedalltotal)
        //               } else {
        //                 // calc.element_data['calculation'] = calc.element_data['calculation_value'].replace("[" + element + "]", calculatedalltotal)
        //                 calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", 0)
        //               }
        //               this.DummyField = calc.element_data['calculation'];
        //             }
        //             else if (calculatedalltotal == 0) {
        //               calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", 0)
        //             } else {
        //               //calc.element_data.calculation = this.DummyField
        //               calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", 0)
        //             }
        //           }
        //           // else {
        //           //   //calc.element_data['calculation'] = this.DummyField
        //           //   calc.element_data.calculation = calc.element_data.calculation.replace("["+element+"]", 0)
        //           // }
        //           else if (CalculatioField1.length == 0) {
        //             calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", 0)
        //           }
        //         }

        //         //////////////////
        //         else if (FieldFind[0].element_type == "calculation") {
        //           if (FieldFind[0].element_data['calculation'] != "" && FieldFind[0].element_data['calculation'] != undefined) {
        //             if (FieldFind[0].element_data['calculation'].includes('[')) {
        //               calc.element_data['calculation'] = this.DummyField
        //             } else if (calc.element_data['calculation'].includes('[' + element + ']')) {
        //               calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", FieldFind[0].element_data['calculation'])
        //             } else {
        //               calc.element_data['calculation'] = calc.element_data["calculation_value"].replace("[" + element + "]", FieldFind[0].element_data['calculation'])
        //             }
        //           }
        //           if (this.FieldResult.element_data.calculation == "" || this.FieldResult.element_data.calculation == undefined) {
        //             calc.element_data['calculation'] = this.DummyField
        //           } else {
        //             this.DummyField = calc.element_data['calculation']
        //           }
        //         }
        //         ///////////////////
        //         else {
        //           if (FieldFind[0].element_data.default_value != "" && FieldFind[0].element_data.default_value != null) {
        //             if (calc.element_data['calculation'].includes('[' + element + ']')) {
        //               calc.element_data['calculation'] = calc.element_data['calculation'].replace("[" + element + "]", FieldFind[0].element_data.default_value)
        //             } else {
        //               calc.element_data['calculation'] = calc.element_data['calculation_value'].replace("[" + element + "]", FieldFind[0].element_data.default_value)
        //             }
        //           }
        //           if (this.FieldResult.element_data.default_value == "" || this.FieldResult.element_data.default_value == undefined) {
        //             calc.element_data['calculation'] = this.DummyField
        //           } else {
        //             this.DummyField = calc.element_data['calculation']
        //           }
        //         }
        //       })
        //       if (calc.element_data['calculation'].includes('[')) {
        //         calculationValueUpdate[i].element_data['calculation'] = calc.element_data['calculation'];
        //       } else {
        //         if (calc.element_data['calculation'].includes('.rounded()')) {
        //           calc.element_data['calculation'] = calc.element_data['calculation'].split(".rounded()").join("")
        //           calculationValueUpdate[i].element_data['calculation'] = eval(calc.element_data['calculation']);
        //           calculationValueUpdate[i].element_data['calculation'] = calculationValueUpdate[i].element_data['calculation'] != "" && calculationValueUpdate[i].element_data['calculation'] > 1 ? Math.round(calculationValueUpdate[i].element_data['calculation']) : 1
        //           calculationValueUpdate[i].element_data['calculation'] = calculationValueUpdate[i].element_data['calculation'].toFixed(Number(calculationValueUpdate[i].element_data.default_value));
        //         } 
        //         // normal calculation working value convert place
        //         //square root function implemented start
        // 			  else if (calc.element_data.calculation.includes('√')) {
        // 				let get_fianl_value = this.dataService4.squareRootCalculation(calc.element_data.calculation);
        //         if (get_fianl_value != '√' && get_fianl_value != '') {
        // 					// get_fianl_value = eval(get_fianl_value);
        //           let validcalculation = false;
        // 					try {
        // 						eval(get_fianl_value); 
        // 						validcalculation = true;
        // 					} catch (e) {
        // 						if (e instanceof SyntaxError) {
        // 							// alert(e.message);
        // 							validcalculation = false;
        // 							calculationValueUpdate[i].element_data.calculation = get_fianl_value;
        // 						}
        // 					}
        // 					if(validcalculation==true){
        // 						get_fianl_value = eval(get_fianl_value);	
        // 						calculationValueUpdate[i].element_data.calculation = get_fianl_value;
        // 						calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
        // 					}
        // 				}
        //         // console.log(get_fianl_value);
        // 				// calculationValueUpdate[i].element_data.calculation = get_fianl_value;
        // 				// calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
        // 			}
        // 			//square root function implemented end
        // 			//power function implemented start
        // 			else if (calc.element_data.calculation.includes('^')) {
        // 				let get_fianl_value = this.dataService4.powerOfCalculation(calc.element_data.calculation);
        // 				if (get_fianl_value != '^' && get_fianl_value != '') {
        // 					// get_fianl_value = eval(get_fianl_value);
        //           let validcalculation = false;
        // 					try {
        // 						eval(get_fianl_value); 
        // 						validcalculation = true;
        // 					} catch (e) {
        // 						if (e instanceof SyntaxError) {
        // 							// alert(e.message);
        // 							validcalculation = false;
        // 							calculationValueUpdate[i].element_data.calculation = get_fianl_value;
        // 						}
        // 					}
        // 					if(validcalculation==true){
        // 						get_fianl_value = eval(get_fianl_value);	
        // 						calculationValueUpdate[i].element_data.calculation = get_fianl_value;
        // 						calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
        // 					}
        // 				}
        // 				// calculationValueUpdate[i].element_data.calculation = get_fianl_value;
        // 				// calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
        // 			}
        // 			//power function implemented end
        // 			else {
        // 				let check_seperators = ["(",")","+","-","*","/"];
        // 				let get_calculation = calc.element_data.calculation;
        //         console.log(get_calculation,calc.element_data_calculation_value);
        // 				let get_fist_value = calc.element_data.calculation[0];
        // 				let get_second_value = calc.element_data.calculation[1];
        // 				let get_last_value = calc.element_data.calculation[calc.element_data.calculation.length-1];
        // 				if(check_seperators.includes(get_fist_value) && check_seperators.includes(get_second_value)){
        // 					calculationValueUpdate[i].element_data.calculation = calc.element_data.calculation
        // 				}
        // 				else if(check_seperators.includes(get_last_value)){
        // 					calculationValueUpdate[i].element_data.calculation = calc.element_data.calculation
        // 				}
        // 				else if((get_calculation.includes("(") && !get_calculation.includes(")"))||
        // 				(get_calculation.includes(")") && !get_calculation.includes("(")) ){
        // 					calculationValueUpdate[i].element_data.calculation = calc.element_data.calculation
        // 				}
        // 				else{
        // 					calculationValueUpdate[i].element_data.calculation = eval(calc.element_data.calculation);
        // 					calculationValueUpdate[i].element_data.calculation = calculationValueUpdate[i].element_data.default_value == "" ? calculationValueUpdate[i].element_data.calculation.toFixed(Number(1)) : calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
        //           // calculationValueUpdate[i].element_data.calculation.toFixed(Number(calculationValueUpdate[i].element_data.default_value));
        // 					let confirmedValue = calc.element_data.calculation;
        // 					console.log(Math.abs(confirmedValue));
        // 					let decimalCheck = Math.abs(confirmedValue);
        // 				}
        // 				console.log(typeof calculationValueUpdate[i].element_data.calculation);
        // 			}
        //         // else {
        //         //   calculationValueUpdate[i].element_data['calculation'] = eval(
        //         //     calc.element_data['calculation']
        //         //   );
        //         //   //calculationValueUpdate[i].element_data['calculation'] = calculationValueUpdate[i].element_data['calculation'].toFixed(calculationValueUpdate[i].element_data.default_value);
        //         //   calculationValueUpdate[i].element_data['calculation'] = calculationValueUpdate[i].element_data.default_value == "" ? calculationValueUpdate[i].element_data['calculation'].toFixed(Number(1)) : calculationValueUpdate[i].element_data['calculation'].toFixed(Number(calculationValueUpdate[i].element_data.default_value));

        //         //   let confirmedValue = calc.element_data['calculation'];
        //         //   console.log(Math.abs(confirmedValue));
        //         //   let decimalCheck = Math.abs(confirmedValue);
        //         // }
        //       }
        //     }
        //   }
        //   i++;
        // })
        //}

      }
    }

  }
  
  //calcuating the avarage for calculation field
  AvarageCalculation(calc, FormulaFieldfind, calculationValueUpdate) {
    if (FormulaFieldfind.element_data['calculation_value'] != "" && FormulaFieldfind.element_data['calculation_value'] != undefined) {
      var CalcValue = calc.element_data.calculation_value;
      var matches = [];
      var pattern = /\[(.*?)\]/g;
      var match;
      while ((match = pattern.exec(CalcValue)) != null) {
        matches.push(match[1]);
      }
      this.DummyField = calc.element_data.calculation_value;
      calc.element_data.calculation = calc.element_data.calculation_value
      var count = 0;
      var value = 0
      calc.element_data.calculation = ""
      matches.forEach(element => {

        //if (element == key) {
        var FieldFind: any = this.modelFieldsForm.filter(ele => ele["element_uuid"] == element);
        if (FieldFind.length > 0) {
          //if (FieldFind[0].element_data.default_value != "" && FieldFind[0].element_data.default_value != null) {
          if (FieldFind[0].element_type == "single_choice" || FieldFind[0].element_type == "dropdown") {
            var CalculatioField1 = FieldFind[0].element_data.options.filter(ele => ele.default == true);
            if (CalculatioField1.length > 0) {
              if (CalculatioField1[0].calculated_value != "") {
                value = value + Number(CalculatioField1[0].calculated_value)
                count = count + 1;
              }
            }
          } else if (FieldFind[0].element_type == "multiple_choice" || FieldFind[0].element_type == "checkbox") {
            var calculatedalltotal = 0;
            var CalculatioField1 = FieldFind[0].element_data.options.filter(ele => ele.default == true);
            if (CalculatioField1.length > 0) {
              CalculatioField1.forEach(ele => {
                if (ele.calculated_value != "") {
                  calculatedalltotal = calculatedalltotal + Number(ele.calculated_value)
                }
              });
              if (calculatedalltotal != 0) {
                value = value + calculatedalltotal
                count = count + 1;
              }
            }
          }
          else if (CalcValue.includes("AVG") && CalcValue.includes("*")) {
            let default_val = "0"
            if (FieldFind[0].element_data.default_value != "" && FieldFind[0].element_data.default_value != null) {
              default_val = FieldFind[0].element_data.default_value
            }
            if (FieldFind[0].element_type == "calculation") {
              default_val = FieldFind[0].element_data["calculation"];
              if (default_val == '') {
                default_val = "0";
              }
            }
            count = count + 1;
            if (CalcValue.includes(FieldFind[0].element_uuid)) {
              let strToReplace = "[" + FieldFind[0].element_uuid + "]";
              CalcValue = CalcValue.replace(strToReplace, default_val);
            }
            if (count == matches.length) {
              CalcValue = CalcValue.replace("AVG", "");
              console.log(CalcValue);
              value = eval(CalcValue);
              if (isNaN(value)) {
                value = 0;
              }
              count = 1
            }
          } else if (FieldFind[0].element_type == "calculation") {
            if (FieldFind[0].element_data["calculation"] != "" && FieldFind[0].element_data["calculation"] != undefined) {
              if (FieldFind[0].element_data["calculation"].includes('[')) {
                //calc.element_data.calculation = this.DummyField
                console.log("coming", FieldFind[0])
              } else {
                value = value + Number(FieldFind[0].element_data["calculation"])
                count = count + 1;
              }
            }
          }
          else {
            if (FieldFind[0].element_data.default_value != "" && FieldFind[0].element_data.default_value != null) {
              console.log("calculationValue", FieldFind[0].element_data["calculation"])
              value = value + Number(FieldFind[0].element_data.default_value);
              count = count + 1;
            }
          }

          if (value != 0 && count != 0)
            calc.element_data.calculation = value / count;
        }
      })
      if (calc.element_data.calculation == 0) {
        calc.element_data.calculation = ""
      }
      if (calc.element_data.calculation != "") {
        calculationValueUpdate.element_data.calculation = calc.element_data.calculation
        let defaultDigit = calculationValueUpdate.element_data.default_value != "" ? calculationValueUpdate.element_data.default_value : "1"
        // calculationValueUpdate.element_data.calculation = calculationValueUpdate.element_data.calculation.toFixed(Number(defaultDigit));
        let confirmedValue = calc.element_data.calculation;
      } else {
        calculationValueUpdate.element_data.calculation = calc.element_data.calculation
      }
    }
  }

  formsCalculatedValue(element_data) {

    if (element_data.calculation == "" || element_data.calculation == undefined) {
      return ""
    }
    return this.dataService4.getcalculationvalue(element_data);
    // let defaultDigit = element_data.default_value != "" ? element_data.default_value : "1"
    // let value = Number(element_data.calculation)
    // if (value != undefined && !isNaN(value)) {
    //   let convert_decimal = element_data.calculation != "" ? value.toFixed(Number(defaultDigit)) : element_data.calculation;
    //   convert_decimal = Number(convert_decimal);
    //   return convert_decimal = convert_decimal;
    // } else {
    //   return element_data.calculation;
    // }

  }

  changeShapesUpdate() {
    this.changeShapeEnable = !this.changeShapeEnable;
  }

  checkShapeBoxOpen() {
    console.log('hit shape');
    if (this.changeShapeEnable == true) {
      this.changeShapeEnable = !this.changeShapeEnable;
    }
  }

  async selectChangeShape(currentShape) {
    //shape drop down
    this.changeShapeEnable = false;
    this.attribute_change = true;
    if (this.multipleSelectOn == false) {

    }
    console.log(currentShape, Number(this.propertiesannotationData.toolbar_element_id));
    console.log('change shape inside');
    this.annotShapeAnnotation = currentShape.shape;
    let toolbarElementId = currentShape.id;
    var annoDataChange = "";
    if (toolbarElementId == 1) {
      annoDataChange = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
    } else if (toolbarElementId == 2) {
      annoDataChange = "move-15:25 line-18:18 line-25:15 line-32:18 line-35:25 line-32:32 line-25:35 line-18:32 line-15:25 line-18:18";
    } else if (toolbarElementId == 3) {
      annoDataChange = "move-15:15 line-35:15 line-35:35 line-15:35 line-15:15 line-35:15";
    } else if (toolbarElementId == 4) {
      annoDataChange = "move-25:15 line-35:35 line-15:35 line-25:15 line-35:35";
    } else if (toolbarElementId == 5) {
      annoDataChange = "move-25:12 line-30:22 line-38:22 line-32:30 line-35:40 line-25:34 line-15:40 line-18:30 line-12:22 line-20:22 line-25:12 line-30:22";
    } else if (toolbarElementId == 6) {
      annoDataChange = "move-25:15 line-32.5:25 line-25:35 line-17.5:25 line-25:15 line-32.5:25";
    }
    else if (toolbarElementId == 7) {
      annoDataChange = "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-17:25 line-17:40 line-15:40 line-15:15";
    } else if (toolbarElementId == 8) {
      annoDataChange = "move-31:22 controlpoint1-31:25.3137 controlpoint2-28.3137:28 endCurve-25:28 controlpoint1-21.6863:28 controlpoint2-19:25.3137 endCurve-19:22 controlpoint1-19:18.6863 controlpoint2-21.6863:16 endCurve-25:16 controlpoint1-28.3137:16 controlpoint2-31:18.6863 endCurve-31:22 move-17.5:15 line-19.5:12.5 line-30.5:12.5 line-32.5:15 line-36:15 controlpoint-38:15 curveEnd-38:17 line-38:29 controlpoint-38:31 curveEnd-36:31 line-14:31 controlpoint-12:31 curveEnd-12:29 line-12:17 controlpoint-12:15 curveEnd-14:15 line-17.5:15 line-19.5:12.5 move-14:19 line-16:19 line-16:20 line-14:20 move-22:22 controlpoint-22:19 curveEnd-25:19 controlpoint-28:19 curveEnd-28:22 controlpoint-28:25 curveEnd-25:25 controlpoint-22.5:25 curveEnd-22:22";
    } else if (toolbarElementId == 9) {
      annoDataChange = "move-10:22.5 line-25:22.5 line-25:15 line-40:25 line-25:35 line-25:27.5 line-10:27.5 line-10:22.5 line-25:22.5";
    }
    if (this.multipleSelectOn == false) {
      let currentAnnotation = Object.assign({}, this.propertiesannotationData);
      let getWidthHeightRA = this.shapeService1.getCanvaswidthandHeight(currentAnnotation);
      let initial_width_value = Number(currentAnnotation.initial_width);
      let initial_height_value = Number(currentAnnotation.initial_height);
      let initial_position_X_value = Number(currentAnnotation.initial_position_x);
      let initial_position_Y_value = Number(currentAnnotation.initial_position_y);
      let initial_position: boolean = false;
      let move_check: boolean = false;
      let resize_check: boolean = false;
      let simple_shape_resize: boolean = false;
      //freehand shapes only allow if condition
      if (Number(currentAnnotation.toolbar_element_id) > 11) {
        let line_width_value = Number(currentAnnotation.line_width) / 2;
        if (initial_width_value == 0 && initial_height_value == 0 && initial_position_X_value == 0 && initial_position_Y_value == 0) {
          initial_position = true;
          currentAnnotation["initial_width"] = getWidthHeightRA.width;
          currentAnnotation["initial_height"] = getWidthHeightRA.height;
        }
        else if (initial_width_value == 0 && initial_height_value == 0 && initial_position_X_value != 0 && initial_position_Y_value != 0) {
          move_check = true;
          currentAnnotation["initial_width"] = getWidthHeightRA.width;
          currentAnnotation["initial_height"] = getWidthHeightRA.height;
        }
        else {
          resize_check = true;
          if (initial_width_value == 0 && initial_height_value == 0) {
            currentAnnotation["initial_width"] = getWidthHeightRA.width;
            currentAnnotation["initial_height"] = getWidthHeightRA.height;
          }
        }
      }
      else if (initial_width_value != 0 && initial_height_value != 0) {
        simple_shape_resize = true;
      }
      let shapeWidth = currentAnnotation.initial_width;
      let shapeHeight = currentAnnotation.initial_height;
      if (shapeWidth != 0 || shapeHeight != 0) {
        console.log('shapewidth and height', shapeWidth, shapeHeight);
        shapeWidth = shapeWidth == 0 ? 35 : shapeWidth;
        shapeHeight = shapeHeight == 0 ? 35 : shapeHeight;
        let margin_reduces_left: any = 0;
        let margin_reduces_top: any = 0;
        let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
        if (getElementStyle != null) {
          let getStyle = getComputedStyle(getElementStyle);
          margin_reduces_left = getStyle.marginLeft;
          margin_reduces_left = margin_reduces_left.substring(margin_reduces_left.length - 2, 0);
          let margin_reduces_top: any = getStyle.marginTop;
          margin_reduces_top = margin_reduces_top.substring(margin_reduces_top.length - 2, 0);
        }
        let checkRound_width = Math.round(shapeWidth);
        let checkRound_height = Math.round(shapeHeight);

        if (shapeWidth < shapeHeight && (checkRound_height != checkRound_width)) {
          shapeHeight = shapeWidth;
        }
        else if (shapeWidth > shapeHeight && (checkRound_height != checkRound_width)) {
          shapeWidth = shapeHeight;
        }
        // 35 below testing completed working fine all shpaes but this code is important by ganesh
        if ((shapeWidth < 35 || shapeHeight < 35) && (Number(currentAnnotation.toolbar_element_id) > 11)) {
          shapeWidth = 35;
          shapeHeight = 35;
        }
        if (initial_position == true) {
          currentAnnotation.initial_position_x = getWidthHeightRA.left + ((getWidthHeightRA.width - shapeWidth) / 2) + 17.5;
          currentAnnotation.initial_position_y = getWidthHeightRA.top + ((getWidthHeightRA.height - shapeHeight) / 2) + 17.5;
          console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((currentAnnotation.initial_height - shapeHeight) / 2), ((currentAnnotation.initial_width - shapeWidth) / 2))
        }
        else if (move_check == true || resize_check == true || simple_shape_resize == true) {
          let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          if (getElementStyle != null) {
            let getStyle = getComputedStyle(getElementStyle);
            let getLeft_A: any = getStyle.left;
            getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
            let getTop_B: any = getStyle.top;
            getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
            console.log(getLeft_A, getTop_B);
            let get_height: any = getElementStyle.getAttribute("height");
            get_height = Number(get_height);
            let get_width: any = getElementStyle.getAttribute("width");
            get_width = Number(get_width);
            currentAnnotation.initial_position_x = Number(getLeft_A) + ((get_width - shapeWidth) / 2) + 17.5;
            currentAnnotation.initial_position_y = Number(getTop_B) + ((get_height - shapeHeight) / 2) + 17.5;
            console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((currentAnnotation.initial_height - shapeHeight) / 2), ((currentAnnotation.initial_width - shapeWidth) / 2))
          }
        }
        // line shapes features width and height less than 20 
        currentAnnotation.initial_width = shapeWidth;
        currentAnnotation.initial_height = shapeHeight;
        annoDataChange = this.changeShapeStringForBaseicon(toolbarElementId, shapeWidth, shapeHeight, annoDataChange);
      }
      this.propertiesannotationDataCopy = currentAnnotation;
      this.propertiesannotationDataCopy["annotation_data"] = annoDataChange;
      this.propertiesannotationDataCopy["toolbar_element_id"] = currentShape.id;
    }
    else if (this.multipleSelectOn == true) {

      for (let ma = 0; ma < this.multiselectionList.length; ma++) {
        let currentAnnotation = Object.assign({}, this.multiselectionList[ma]);
        let getWidthHeightRA = this.shapeService1.getCanvaswidthandHeight(currentAnnotation);
        let initial_width_value = Number(currentAnnotation.initial_width);
        let initial_height_value = Number(currentAnnotation.initial_height);
        let initial_position_X_value = Number(currentAnnotation.initial_position_x);
        let initial_position_Y_value = Number(currentAnnotation.initial_position_y);
        let initial_position: boolean = false;
        let move_check: boolean = false;
        let resize_check: boolean = false;
        let simple_shape_resize: boolean = false;
        //freehand shapes only allow if condition
        if (Number(currentAnnotation.toolbar_element_id) > 11) {
          let line_width_value = Number(currentAnnotation.line_width) / 2;
          if (initial_width_value == 0 && initial_height_value == 0 && initial_position_X_value == 0 && initial_position_Y_value == 0) {
            initial_position = true;
            currentAnnotation["initial_width"] = getWidthHeightRA.width;
            currentAnnotation["initial_height"] = getWidthHeightRA.height;
          }
          else if (initial_width_value == 0 && initial_height_value == 0 && initial_position_X_value != 0 && initial_position_Y_value != 0) {
            move_check = true;
            currentAnnotation["initial_width"] = getWidthHeightRA.width;
            currentAnnotation["initial_height"] = getWidthHeightRA.height;
          }
          else {
            resize_check = true;
            if (initial_width_value == 0 && initial_height_value == 0) {
              currentAnnotation["initial_width"] = getWidthHeightRA.width;
              currentAnnotation["initial_height"] = getWidthHeightRA.height;
            }
          }
        }
        else if (initial_width_value != 0 && initial_height_value != 0) {
          simple_shape_resize = true;
        }
        let shapeWidth = currentAnnotation.initial_width;
        let shapeHeight = currentAnnotation.initial_height;
        if (shapeWidth != 0 || shapeHeight != 0) {
          console.log('shapewidth and height', shapeWidth, shapeHeight);
          shapeWidth = shapeWidth == 0 ? 35 : shapeWidth;
          shapeHeight = shapeHeight == 0 ? 35 : shapeHeight;
          let margin_reduces_left: any = 0;
          let margin_reduces_top: any = 0;
          let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          if (getElementStyle != null) {
            let getStyle = getComputedStyle(getElementStyle);
            margin_reduces_left = getStyle.marginLeft;
            margin_reduces_left = margin_reduces_left.substring(margin_reduces_left.length - 2, 0);
            let margin_reduces_top: any = getStyle.marginTop;
            margin_reduces_top = margin_reduces_top.substring(margin_reduces_top.length - 2, 0);
          }
          let checkRound_width = Math.round(shapeWidth);
          let checkRound_height = Math.round(shapeHeight);

          if (shapeWidth < shapeHeight && (checkRound_height != checkRound_width)) {
            shapeHeight = shapeWidth;
          }
          else if (shapeWidth > shapeHeight && (checkRound_height != checkRound_width)) {
            shapeWidth = shapeHeight;
          }
          // 35 below testing completed working fine all shpaes but this code is important by ganesh
          if ((shapeWidth < 35 || shapeHeight < 35) && (Number(currentAnnotation.toolbar_element_id) > 11)) {
            shapeWidth = 35;
            shapeHeight = 35;
          }
          if (initial_position == true) {
            currentAnnotation.initial_position_x = getWidthHeightRA.left + ((getWidthHeightRA.width - shapeWidth) / 2) + 17.5;
            currentAnnotation.initial_position_y = getWidthHeightRA.top + ((getWidthHeightRA.height - shapeHeight) / 2) + 17.5;
            console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((currentAnnotation.initial_height - shapeHeight) / 2), ((currentAnnotation.initial_width - shapeWidth) / 2))
          }
          else if (move_check == true || resize_check == true || simple_shape_resize == true) {
            let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
            if (getElementStyle != null) {
              let getStyle = getComputedStyle(getElementStyle);
              let getLeft_A: any = getStyle.left;
              getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
              let getTop_B: any = getStyle.top;
              getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
              console.log(getLeft_A, getTop_B);
              let get_height: any = getElementStyle.getAttribute("height");
              get_height = Number(get_height);
              let get_width: any = getElementStyle.getAttribute("width");
              get_width = Number(get_width);
              currentAnnotation.initial_position_x = Number(getLeft_A) + ((get_width - shapeWidth) / 2) + 17.5;
              currentAnnotation.initial_position_y = Number(getTop_B) + ((get_height - shapeHeight) / 2) + 17.5;
              console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((currentAnnotation.initial_height - shapeHeight) / 2), ((currentAnnotation.initial_width - shapeWidth) / 2))
            }
          }
          // line shapes features width and height less than 20 
          currentAnnotation.initial_width = shapeWidth;
          currentAnnotation.initial_height = shapeHeight;
          annoDataChange = this.changeShapeStringForBaseicon(toolbarElementId, shapeWidth, shapeHeight, annoDataChange);
        }
        this.propertiesannotationDataCopy = currentAnnotation;
        this.propertiesannotationDataCopy["annotation_data"] = annoDataChange;
        this.propertiesannotationDataCopy["toolbar_element_id"] = currentShape.id;
        currentAnnotation["annotation_data"] = annoDataChange;
        currentAnnotation["toolbar_element_id"] = currentShape.id;
        this.multiselectionList[ma] = currentAnnotation;
      }
    }
    this.get_disable_setting(toolbarElementId);
    await this.single_view_Preview_svg_drawing(this.propertiesannotationDataCopy);
    this.annotLabelUpdate1(this.annotLabelAnnotation)
    // this.combindSidebarDrawLogic(this.propertiesannotationDataCopy, 'propertyCanvasPreview', 'annotationLabelPreview');
  }

  ShapeNameGet(toolbarElementId) {
    if (toolbarElementId == 1) {
      return "Circle";
    } else if (toolbarElementId == 2) {
      return "Octagon";
    } else if (toolbarElementId == 3) {
      return "Square";
    } else if (toolbarElementId == 4) {
      return "Triangle";
    } else if (toolbarElementId == 5) {
      return "Star";
    } else if (toolbarElementId == 6) {
      return "Diamond";
    }
    else if (toolbarElementId == 7) {
      return "Flag";
    } else if (toolbarElementId == 8) {
      return "Camera";
    } else if (toolbarElementId == 9) {
      return "Arrow";
    }
    else if (toolbarElementId == 10) {
      return "Arrow";
    }
    else if (toolbarElementId == 11) {
      return "Text";
    }
    else if (toolbarElementId == 12) {
      return "Freehand Line";
    }
    else if (toolbarElementId == 13) {
      return "Polyline Arrow";
    }
    else if (toolbarElementId == 14) {
      return "Polyline";
    }
    else if (toolbarElementId == 15) {
      return "Line";
    }
    else if (toolbarElementId == 16) {
      return "Line Axial";
    }
    else if (toolbarElementId == 17) {
      return "Freehand Area";
    }
    else if (toolbarElementId == 18) {
      return "Polygon";
    }
    else if (toolbarElementId == 19) {
      return "Drawn Ellipse";
    }
    else if (toolbarElementId == 20) {
      return "Drawn Rectangle";
    }
  }

  async getAnnotationFormPageChange() {
    console.log('2222222', this.folderId, this.currentPageId)
    this.documentService
      .getAnnotationFormlist(this.projectId, this.folderId, this.currentPageId).subscribe((response) => {
        this.layerDatas = [];
        let layer_data = response["response_body"]["layer_data"];
        this.show = false;
        if (layer_data != undefined) {
          var layerRemovedFilter = layer_data.filter((data) => data.is_removed == false || data.is_removed == "false");
          let filter_pagewise_Layer_data = [];
          for (let page_check = 0; page_check < layerRemovedFilter.length; page_check++) {
            let get_associate_page = layerRemovedFilter[page_check].associated_pages;
            let filter_page = get_associate_page.find((pages_find) => pages_find.page_id == this.currentPageId);
            if (filter_page != undefined && (filter_page.is_removed == 'false' || filter_page.is_removed == false || filter_page.is_removed == '0')) {
              console.log(layerRemovedFilter[page_check]);
              filter_pagewise_Layer_data.push(layerRemovedFilter[page_check]);
            }
          }
          layerRemovedFilter = filter_pagewise_Layer_data;
          this.layerDatas = layerRemovedFilter;
          var annotations = [];
          for (var i = 0; i < layerRemovedFilter.length; i++) {
            annotations = [];
            for (var j = 0; j < layerRemovedFilter[i].annotations.length; j++) {
              if (layerRemovedFilter[i].annotations[j].is_removed == false ||
                layerRemovedFilter[i].annotations[j].is_removed == "false"
              ) {
                annotations.push(layerRemovedFilter[i].annotations[j]);
              }
            }
            layerRemovedFilter[i].annotations = annotations;
          }
          this.layerDatas = layerRemovedFilter;
          // this.dataService.searchLayerDatas.emit(this.layerDatas);

          if (this.layerEnable == true) {
            this.cdRef.detectChanges();
            let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
            let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: this.checkedAnnotationIdsBackup, currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
            console.log(data);

            this.dataService2.layerDatafromnavigation.emit(data);
          }
          this.documentService.layerDatas = this.layerDatas;
          this.getActiveLayerId();
        }
      });
  }


  globalLineWidth(width) {
    console.log('line width html');
    let linewidth = Number(width);
    let newLineWidth = 0;
    if (linewidth > 30) {
      newLineWidth = linewidth / 5;
    }
    else {
      newLineWidth = linewidth / 3;
    }

    if (newLineWidth < 1) {
      if (this.scaleValue < 0.4) {
        return 6;
      }
      else {
        return 1;
      }

    }
    else {
      if (this.scaleValue < 0.4) {
        return newLineWidth + 3;
      }
      else {
        return newLineWidth;
      }
    }
  }

  globalLineWidthAction(width) {
    console.log('line width 2');
    let linewidth = Number(width);
    let newLineWidth = 0;
    if (linewidth > 30) {
      newLineWidth = linewidth / 3;
    }
    else {
      newLineWidth = linewidth / 3;
    }

    if (newLineWidth < 1) {
      return 1;
    }
    else {
      return newLineWidth;
    }
  }

  globalMediaCount(media, fromMedium) {
    if (fromMedium == 'media') {
      if (this.multipleSelectOn == false) {
        this.sampleFormObject = media.filter((data) => {
          return this.createDocumentStore.data_allow_condition.includes(data.is_removed);
        })
        // this.sampleFormObject.sort((a,b)=>(a.created_date.localeCompare<(b.created_date))?1:-1)
        // this.sampleFormObject.sort((a,b)=>(a.stub_id>b.stub_id)? 1 :-1)
        this.mediaCount = this.sampleFormObject.length;
      }
      else {
        console.log(media);
        let tempmedia = media.filter((data) => {
          return (data.is_removed == 0 || data.is_removed == 'false');
        })
        this.mediaCount = 0;
        var count = 0;
        for (let i = 0; i < tempmedia.length; i++) {
          if (tempmedia[i].hasOwnProperty('annotation_media')) {
            if (tempmedia[i].annotation_media != undefined || tempmedia[i].annotation_media != null) {
              let c = tempmedia[i].annotation_media.filter(data => data.is_removed != true);
              this.sampleFormObject = [...this.sampleFormObject, ...c];
              if (c != null && c.length > 0) {
                this.mediaCount += c.length;
                count++;
              }
            }
          }
        }
        //When adding image on multiselect the about media count is used for calculating global media count.
        //When deleting image on multiselect the below media count is used for calculating global media count.
        if (count == 0) {
          this.mediaCount = tempmedia.length;
        }
      }
    }
    else {
      if (this.multipleSelectOn == false) {
        this.annotationLinks = media.filter((data) => {
          return (data.is_removed == 0);
        });
        if (this.annotationLinks.length > 0) {
          for (let k = 0; k < this.annotationLinks.length; k++) {
            this.annotationLinks[k].location = this.getLocation(this.annotationLinks[k]);
          }
          console.log(this.annotationLinks);
        }
        this.linkCount = this.annotationLinks.length;
        this.linksarray = this.annotationLinks;
      } else {
        this.annotationLinks = media.filter((data) => {
          return (data.is_removed == 0);
        });
        if (this.annotationLinks.length > 0) {
          for (let k = 0; k < this.annotationLinks.length; k++) {

            this.annotationLinks[k].location = this.getLocation(this.annotationLinks[k]);
          }
          console.log(this.annotationLinks);
        }

        this.linkCount += this.annotationLinks.length;
        if (this.annotationLinks.length != 0) {
          this.linksarray.push(this.annotationLinks);
        } else {
          this.linksarray = this.annotationLinks;
        }
      }

    }

  }


  errorMessage() {
    this.show = false;
    this._snackBar.open('Sync is an error', null,
      {
        horizontalPosition: 'center',
        verticalPosition: 'bottom',
      });
  }

  displayCopyMultiMessage(status) {
    this.show = false;
    let message = "";
    if (status == "enabled") {
      message = "Copy Multiple Mode Enabled"
    }
    else if (status == "disabled") {
      message = "Copy Multiple Mode Disabled"
    }

    this._snackBar.open(message, null,
      {
        horizontalPosition: 'center',
        verticalPosition: 'bottom',
      });
  }

  udoArrayChange(data) {
    this.undoArray.push(data)
    var f = "ddfd"
  }
  redoArrayChange(data) {
    this.redoArray.push(data);
  }
  //undo function for annotation
  annotationUndo() {
    var undo_length = this.undoArray.length;
    if (undo_length > 0) {
      var undoingAnnotation = this.undoArray[undo_length - 1];
      this.getId = undoingAnnotation.annotation_id;
      this.formCount = undoingAnnotation.annotation_forms.length
      // if (this.currentFormId != "") {
      var FormData = undoingAnnotation.annotation_forms.filter(item => item.form_id == this.currentFormId);
      FormData = FormData.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
      this.modelFieldsForm = FormData[0].form_data
      // }
      this.globalMediaCount(undoingAnnotation.annotation_media, 'media')
      this.globalMediaCount(undoingAnnotation.annotation_links, 'links')
      this.annotationTags = undoingAnnotation.annotation_tags.split(",");
      this.tagCount = this.annotationTags.length;
      for (var i = 0; i < this.annotationTags.length; i++) {
        if (this.annotationTags[i] == "") {
          this.annotationTags = []
          this.tagCount = 0;
        }
      }
      for (var k = 0; k < this.layerDatas.length; k++) {
        if (this.activeLayerIdDraw == this.layerDatas[k].layer_id) {
          let itemIndex = this.layerDatas[k].annotations.findIndex(item => item.annotation_id == this.getId);
          let CurrentItem = this.layerDatas[k].annotations.filter(item => item.annotation_id == this.getId);
          this.redoArrayChange(_.cloneDeep(CurrentItem[0]))
          this.layerDatas[k].annotations.splice(itemIndex, 1, undoingAnnotation);
        }
      }

      this.undoArray.splice(undo_length - 1, 1)
      var layerData = _.cloneDeep(this.layerDatas)
      this.getAnnotationForm1(_.cloneDeep(this.layerDatas))

      let generateCloneLayer = layerData;
      this.show = true;
      this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw).subscribe((response) => {
      
        if (response["response_code"] == 200) {
          this.show = false;
          // this.canvasClickPreSelect(this.getId);
          if (undo_length == 1) {
            this.annotationSelected = false
            this.hideSelectForm = false;
            this.formCount = 0;
            this.tagCount = 0;
            this.mediaCount = 0;
            this.linkCount = 0;
          }
          else {
            // var previousData = this.undoArray[undo_length - 2]
            // var id = previousData.annotation_id;
            // if (id != this.getId) {
            //   this.canvasClickPreSelect(id);
            // }
          }
        }
        else {
          this.errorMessage();
        }
      });
    }
  }
  //redo function for annotation
  annotationRedo() {
    var redo_length = this.redoArray.length;
    if (redo_length > 0) {
      var redoingAnnotation = this.redoArray[redo_length - 1];
      this.getId = redoingAnnotation.annotation_id;
      this.formCount = redoingAnnotation.annotation_forms.length
      var FormData = redoingAnnotation.annotation_forms.filter(item => item.form_id == this.currentFormId);
      FormData = FormData.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
      this.modelFieldsForm = FormData[0].form_data
      // }
      this.globalMediaCount(redoingAnnotation.annotation_media, 'media')
      this.globalMediaCount(redoingAnnotation.annotation_links, 'links')
      this.annotationTags = redoingAnnotation.annotation_tags.split(",");
      this.tagCount = this.annotationTags.length;
      for (var i = 0; i < this.annotationTags.length; i++) {
        if (this.annotationTags[i] == "") {
          this.annotationTags = []
          this.tagCount = 0;
        }
      }

      for (var k = 0; k < this.layerDatas.length; k++) {
        if (this.activeLayerIdDraw == this.layerDatas[k].layer_id) {
          let itemIndex = this.layerDatas[k].annotations.findIndex(item => item.annotation_id == this.getId);
          if (itemIndex == -1) {
            this.layerDatas[k].annotations.push(redoingAnnotation)
            var undoData = _.cloneDeep(redoingAnnotation)
            undoData.is_removed = true;
            this.udoArrayChange(undoData)
          } else {
            let CurrentItem = this.layerDatas[k].annotations.filter(item => item.annotation_id == this.getId);
            this.udoArrayChange(_.cloneDeep(CurrentItem[0]))
            this.layerDatas[k].annotations.splice(itemIndex, 1, redoingAnnotation);
          }
        }
      }
      this.redoArray.splice(redo_length - 1, 1)
      var layerData = _.cloneDeep(this.layerDatas)
      this.getAnnotationForm1(_.cloneDeep(this.layerDatas))
      this.show = true;
      let generateCloneLayer = layerData;
      this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw).subscribe((response) => {
       
        if (response["response_code"] == 200) {
          this.show = false;
          // this.canvasClickPreSelect(this.getId);
        }
        else {
          this.errorMessage();
        }
      });
    }
  }


  refreshToolbarList() {
  
    this.toolbarlistService.gettoolbarlist(this.projectId).subscribe((res) => {
      console.log(res);
      if (res["response_code"] == 200 && res["response_body"]["toolbar_listing"] != null) {
        this.show = false;
        var toolData = res["response_body"]["toolbar_listing"];
        let removeHiddenNum = toolData.filter((data) => { return data.is_hidden != 1 });
        let removeHiddenBoolean = removeHiddenNum.filter((data) => {
          data.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(data.toolbar_name);
          return data.is_hidden != true
        });
        this.toolbarListData = removeHiddenBoolean;
      }
      else {
        this.errorMessage();
      }
    });
  }

  @Output() layerCheckBox = new EventEmitter();

  repointEnable() {
    var coords = [];
    this.stringPathArray = [];
    this.createDocumentStore.enablerepointButtons = true;
    this.rotateresizeButtonHandles('repoint');
    this.annotationselectEnableDisable('enable');
    let newShapeString = "";
    this.propertiesannotationData["toolbar_element_id"] = Number(this.propertiesannotationData["toolbar_element_id"]);
    this.annotationName = this.propertiesannotationData["annotation_name"];
    let elementIdFind = this.propertiesannotationData["toolbar_element_id"];
    let cloneRepointAnnotation = _.cloneDeep(this.propertiesannotationData);
    let isnegativeCoordinates = false;
    if (cloneRepointAnnotation.initial_position_x < 0 && cloneRepointAnnotation.initial_position_y < 0) {
      isnegativeCoordinates = true;
      cloneRepointAnnotation.initial_position_x = -(cloneRepointAnnotation.initial_position_x);
      cloneRepointAnnotation.initial_position_y = -(cloneRepointAnnotation.initial_position_y);
    }
    if ((cloneRepointAnnotation.toolbar_element_id == 13 || cloneRepointAnnotation.toolbar_element_id == 14 || cloneRepointAnnotation.toolbar_element_id == 18 || cloneRepointAnnotation.toolbar_element_id == 15 || cloneRepointAnnotation.toolbar_element_id == 16) && cloneRepointAnnotation.initial_position_x != 0 && isnegativeCoordinates == false) {
      if (cloneRepointAnnotation.initial_position_x != 0) {
        let getChangedString = this.changeStringValue(cloneRepointAnnotation);
        cloneRepointAnnotation.annotation_data = getChangedString;
        this.propertiesannotationData["annotation_data"] = getChangedString;
        var getShapeStringWidthHeight = this.shapeService1.getCanvaswidthandHeight(cloneRepointAnnotation);
        console.log(getShapeStringWidthHeight);
      }
    }
    if ((cloneRepointAnnotation.toolbar_element_id == 19 || cloneRepointAnnotation.toolbar_element_id == 20) && (cloneRepointAnnotation.annotation_data.includes("ovalIn") || cloneRepointAnnotation.annotation_data.includes("drawRect"))) {
      let splitString_value = cloneRepointAnnotation.annotation_data;
      // rotation shape we need change shape string only below if condition run ellipse and rectangle
      if (cloneRepointAnnotation.annotation_data.includes('ovalIn') || cloneRepointAnnotation.annotation_data.includes('drawRect')) {
        //sent x y position to below method and made all x and y as 0 to fix P3X-1226
        splitString_value = this.repointStringForRectandElipse(cloneRepointAnnotation.annotation_data, cloneRepointAnnotation.toolbar_element_id, cloneRepointAnnotation.initial_position_x, cloneRepointAnnotation.initial_position_y);
        cloneRepointAnnotation.initial_position_x = 0;
        this.propertiesannotationData.initial_position_x = 0;
        cloneRepointAnnotation.initial_position_y = 0;
        this.propertiesannotationData.initial_position_y = 0;
      }
      console.log("cloneRepointAnnotation", cloneRepointAnnotation["annotation_data"], splitString_value)
      // let get_rotation_value =   (this.propertiesannotationData["initial_rotation"]) * (Math.PI / 25);
      // let again_changes =  (get_rotation_value) * (Math.PI / 22.5);
      // let annotationData_rotate = this.rotateShape(splitString_value, this.propertiesannotationData["toolbar_element_id"], 88)
      cloneRepointAnnotation["annotation_data"] = splitString_value;
      this.propertiesannotationData["annotation_data"] = splitString_value;
    }
    else if ((cloneRepointAnnotation.toolbar_element_id == 19 || cloneRepointAnnotation.toolbar_element_id == 20) && (cloneRepointAnnotation.annotation_data.includes('move'))) {
      let splitString_value = cloneRepointAnnotation.annotation_data;
      if (cloneRepointAnnotation.initial_position_x != 0) {
        let getChangedString = this.changeStringValue(cloneRepointAnnotation);
        cloneRepointAnnotation.annotation_data = getChangedString;
        this.propertiesannotationData["annotation_data"] = getChangedString;
        var getShapeStringWidthHeight = this.shapeService1.getCanvaswidthandHeight(cloneRepointAnnotation);
        console.log(getShapeStringWidthHeight);
      }
    }
    let spaceSplit = cloneRepointAnnotation["annotation_data"].split(' ');
    if (this.propertiesannotationData["toolbar_element_id"] == 13) {
      spaceSplit.splice(spaceSplit.length - 3, 3);
      // spaceSplit = spaceSplit.replaceAll(':-', ':n');
      // var hypenSplit_value = spaceSplit.split("-");
      // if (hypenSplit.length > 2) {
      //   let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
      //   hypenSplit = [hypenSplit[0], localString1];
      // }
      // var colonSplit = hypenSplit_value[1].replaceAll('n', '-').split(":");
    }
    // Ellipse Shape drawing
    let cp1x = 0, cp1y = 0, cp2x = 0, cp2y = 0, cx = 0, cy = 0, e_x = 0, e_y = 0;
    let path_value = "";
    let ellipse_path = "";
    // draw SVG element and create new path
    let getParent = document.getElementById('pdfImg');
    var svg_polyline = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg_polyline.setAttribute("width", this.realWidth);
    svg_polyline.setAttribute("height", this.realHeight);
    svg_polyline.setAttribute("repointSVG", "1");
    svg_polyline.style.position = "absolute";
    svg_polyline.style.top = "0px";
    svg_polyline.style.left = "0px";
    svg_polyline.style.zIndex = "99";
    getParent.appendChild(svg_polyline);
    let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    create_path.setAttribute("customerepointattribute", "1");
    svg_polyline.appendChild(create_path);
    create_path.setAttribute('stroke', "#00FF00");
    create_path.setAttribute('stroke-width', "5");
    create_path.setAttribute('fill', "none");
    // add transform on svg If zoomin 1 above
    // disable drag scroll
    this.createDocumentStore.disable_drag_scroll = true;
    this.addZoom(svg_polyline);
    this.checkZoomInorOut_repoint();
    for (var i = 0; i < spaceSplit.length; i++) {
      var splitString = spaceSplit[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      var hypenSplit = splitString.split("-");
      if (hypenSplit.length > 2) {
        let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
        hypenSplit = [hypenSplit[0], localString1];
      }
      if (hypenSplit != '') {
        var colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
        colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
        colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));
        if (getShapeStringWidthHeight != undefined) {
          let line_width_value = Number(cloneRepointAnnotation.line_width) / 2;
          colonSplit[0] = colonSplit[0] - (getShapeStringWidthHeight.width / 2) - line_width_value;
          colonSplit[1] = colonSplit[1] - (getShapeStringWidthHeight.height / 2) - line_width_value;
        }
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
        let line_reducer = Number(cloneRepointAnnotation.line_width) / 30;
        console.log("line_reducer",line_reducer)
        path_value = i == 0 ? 'M' + (coord.x-line_reducer) + ' ' + (coord.y-line_reducer) : (path_value + ' L' + (coord.x-line_reducer) + ' ' + (coord.y-line_reducer));
        if ((getShapeStringWidthHeight != undefined && this.propertiesannotationData["toolbar_element_id"] != 19) || this.propertiesannotationData["toolbar_element_id"] == 13) {
          switch (hypenSplit[0]) {
            case "move":
              if (elementIdFind == 13) {
                this.stringPathArray.push('move-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer));
              }
              newShapeString = newShapeString != '' ? (newShapeString + ' move-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer)) : ('move-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer))
              break;
            case "line":
              if (elementIdFind == 13) {
                this.stringPathArray.push(' line-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer));
              }
              newShapeString = newShapeString != '' ? (newShapeString + ' line-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer)) : ('line-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer));
              break;
            case "controlpoint1":
              newShapeString = newShapeString != '' ? (newShapeString + ' controlpoint1-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer)) : ('controlpoint1-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer));
              break;
            case "controlpoint2":
              newShapeString = newShapeString != '' ? (newShapeString + ' controlpoint2-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer)) : ('controlpoint2-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer));
              break;
            case "endCurve":
              newShapeString = newShapeString != '' ? (newShapeString + ' endCurve-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer)) : ('endCurve-' + (colonSplit[0]-line_reducer) + ':' + (colonSplit[1]-line_reducer));
              break;
          }
        }
        else if (this.propertiesannotationData["toolbar_element_id"] == 19) {
          // if (getShapeStringWidthHeight_ellipse != undefined) {
          //   let line_width_value = Number(cloneRepointAnnotation.line_width) / 2;
          //   colonSplit[0] = colonSplit[0] - (getShapeStringWidthHeight_ellipse.width / 2) - line_width_value;
          //   colonSplit[1] = colonSplit[1] - (getShapeStringWidthHeight_ellipse.height / 2) - line_width_value;
          // }
          if (hypenSplit[0] == "move") {
            e_x = Math.round(parseFloat(colonSplit[0]));
            e_y = Math.round(parseFloat(colonSplit[1]));
            // let circle = this.addredCircles(e_x, e_y);
            // circle.setAttribute('count', 'circle' + i);
            // circle.style.pointerEvents = "auto";
            // pdfImg.appendChild(circle);
            // this.initDragRepoint(circle);
            ellipse_path = ellipse_path == '' ? `M${e_x} ${e_y}` : (ellipse_path + ` M${e_x} ${e_y}`);
            newShapeString = newShapeString != '' ? (newShapeString + ' move-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('move-' + (colonSplit[0]) + ':' + (colonSplit[1]))
            // this.canvasElement.moveTo(e_x,e_y);
          }
          if (hypenSplit[0] == "line") {
            e_x = Math.round(parseFloat(colonSplit[0]));
            e_y = Math.round(parseFloat(colonSplit[1]));
            let circle = this.addredCirclesSVG(e_x, e_y);
            circle.setAttribute('count', 'circle' + i);
            circle.style.pointerEvents = "auto";
            svg_polyline.appendChild(circle);
            this.initDragRepoint(circle);
            ellipse_path = ellipse_path == '' ? `L${e_x} ${e_y}` : (ellipse_path + ` L${e_x} ${e_y}`);
            newShapeString = newShapeString != '' ? (newShapeString + ' line-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('line-' + (colonSplit[0]) + ':' + (colonSplit[1]));
            // this.canvasElement.lineTo(e_x,e_y);
          }
          else if ((hypenSplit[0] == "controlpoint1" || hypenSplit[0] == "controlpoint2" || hypenSplit[0] == "endCurve")) {
            if (hypenSplit[0] == "controlpoint1") {
              cp1x = parseFloat(colonSplit[0]);
              cp1y = parseFloat(colonSplit[1]);
              newShapeString = newShapeString != '' ? (newShapeString + ' controlpoint1-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('controlpoint1-' + (colonSplit[0]) + ':' + (colonSplit[1]));
            }
            else if (hypenSplit[0] == "controlpoint2") {
              cp2x = parseFloat(colonSplit[0]);
              cp2y = parseFloat(colonSplit[1]);
              newShapeString = newShapeString != '' ? (newShapeString + ' controlpoint2-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('controlpoint2-' + (colonSplit[0]) + ':' + (colonSplit[1]));
            }
            else if (hypenSplit[0] == "endCurve") {
              cx = parseFloat(colonSplit[0]);
              cy = parseFloat(colonSplit[1]);
              let circle = this.addredCirclesSVG(cx, cy);
              circle.setAttribute('count', 'circle' + i);
              circle.style.pointerEvents = "auto";
              svg_polyline.appendChild(circle);
              this.initDragRepoint(circle);
              ellipse_path = ellipse_path == '' ? `C${cp1x} ${cp1y} ${cp2x} ${cp2y} ${cx} ${cy}` : (ellipse_path + ` C${cp1x} ${cp1y} ${cp2x} ${cp2y} ${cx} ${cy}`);
              newShapeString = newShapeString != '' ? (newShapeString + ' endCurve-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('endCurve-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              // this.canvasElement.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, cx, cy);
            }
          }
        }
      }
    }

    // assigned x and y position already there mean changed current annotation data based on x and y position
    // replace the annotationdata to new shapestring 
    if (getShapeStringWidthHeight != undefined || this.propertiesannotationData["toolbar_element_id"] == 13) {
      this.propertiesannotationData["annotation_data"] = newShapeString;
    }

    //  if ellipse 
    //  else if polyline and polyline arrow and polygon and rectangle
    if (this.propertiesannotationData["toolbar_element_id"] == 19) {
      if (ellipse_path != undefined && ellipse_path != '') {
        console.log(ellipse_path);
        create_path.setAttribute("d", ellipse_path);
      }
    }
    else if (this.propertiesannotationData["toolbar_element_id"] != 19) {
      var max = coords.length - 1;
      let isAccess_first_point = [13, 14, 15, 16];
      let isdenied_first_point = [18, 19, 20];
      for (var l = 0; l < coords.length; l++) {
        if (isAccess_first_point.includes(elementIdFind) || (isdenied_first_point.includes(elementIdFind) && l != 0)) {
          let circle = this.addredCirclesSVG(coords[l].x, coords[l].y);
          circle.setAttribute('count', 'circle' + l);
          circle.style.pointerEvents = "auto";
          svg_polyline.appendChild(circle);
          this.initDragRepoint(circle);
        }
        // if((elementIdFind==13 || elementIdFind==14) ||((elementIdFind == 19 || elementIdFind == 20 || elementIdFind == 18) && l!=0)){
        //   let circle = this.addredCirclesSVG(coords[l].x, coords[l].y);
        //   circle.setAttribute('count', 'circle' + l);
        //   circle.style.pointerEvents = "auto";
        //   svg_polyline.appendChild(circle);
        //   this.initDragRepoint(circle);
        // }

      }
      if (typeof coords[max - 1] !== "undefined") {
        create_path.setAttribute("d", path_value);
      }
    }
  }

  getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
  }

  updateMoveAPI(annotationid, finalMoveleft, finalMovetop) {
    for (let ma = 0; ma < this.layerDatas.length; ma++) {
      let findAnnotationIndex = this.layerDatas[ma].annotations.findIndex((Mdata) => Mdata.annotation_id === annotationid);
      if (findAnnotationIndex != -1) {
        if(this.rotateandresize==true){
          this.resizeMove = true;
          this.layerDatas[ma].annotations[findAnnotationIndex].annotation_data = this.propertiesannotationData.annotation_data;
          this.layerDatas[ma].annotations[findAnnotationIndex].initial_height = this.propertiesannotationData.initial_height;
          this.layerDatas[ma].annotations[findAnnotationIndex].initial_width = this.propertiesannotationData.initial_width;
        }
        console.log(this.propertiesannotationData);
        let singleDataMoved = this.layerDatas[ma].annotations[findAnnotationIndex];
        let newclone = Object.assign({}, singleDataMoved);
        this.layerDatas[ma].annotations[findAnnotationIndex] = singleDataMoved;
        if (this.layerDatas[ma].annotations[findAnnotationIndex].toolbar_element_id <= 11) {
          let addedValueX = Number(this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_x) + finalMoveleft;
          addedValueX = addedValueX < 0 ? -(addedValueX) : addedValueX;
          this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_x = addedValueX;
          let addedValueY = Number(this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_y) + finalMovetop;
          addedValueY = addedValueY < 0 ? -(addedValueY) : addedValueY;
          this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_y = addedValueY;
          // this.moveCurrentSelectedItem = this.layerDatas[ma].annotations[findAnnotationIndex];
          console.log('old value', newclone.initial_position_x, newclone.initial_position_y);
          console.log('difference', finalMoveleft, finalMovetop);
          console.log('new value', addedValueX, addedValueY);
          //Duplicate checking start
          let annotation_id_check = this.layerDatas[ma].annotations[findAnnotationIndex].annotation_id;
          let existingIdCheck = this.moveAnnotationsStore.findIndex((annotData) => annotData.annotation_id == annotation_id_check)
          if (existingIdCheck == -1) {
            this.moveAnnotationsStore.push(this.layerDatas[ma].annotations[findAnnotationIndex]);
          }
          //Duplicate checking end
        }
        else if (this.layerDatas[ma].annotations[findAnnotationIndex].toolbar_element_id >= 12) {
          var shapeLeft = 0;
          var shapeTop = 0;
          if (Number(this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_x) == 0 && Number(this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_y == 0)) {
            var getStringTopLeft = this.shapeService1.getCanvaswidthandHeight(this.layerDatas[ma].annotations[findAnnotationIndex]);
            shapeLeft = getStringTopLeft.left + (getStringTopLeft.width / 2);
            shapeTop = getStringTopLeft.top + (getStringTopLeft.height / 2);
          }
          else {
            shapeLeft = Number(this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_x);
            shapeTop = Number(this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_y);
          }
          let addedValueX = shapeLeft + finalMoveleft;
          addedValueX = addedValueX < 0 ? -(addedValueX) : addedValueX;
          this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_x = addedValueX
          let addedValueY = shapeTop + finalMovetop;

          addedValueY = addedValueY < 0 ? -(addedValueY) : addedValueY;
          this.layerDatas[ma].annotations[findAnnotationIndex].initial_position_y = addedValueY;
          // this.moveCurrentSelectedItem = this.layerDatas[ma].annotations[findAnnotationIndex];
          console.log('old value', newclone.initial_position_x, newclone.initial_position_y);
          console.log('difference', finalMoveleft, finalMovetop);
          console.log('new value', addedValueX, addedValueY);
          //Duplicate checking start
          let annotation_id_check = this.layerDatas[ma].annotations[findAnnotationIndex].annotation_id;
          let existingIdCheck = this.moveAnnotationsStore.findIndex((annotData) => annotData.annotation_id == annotation_id_check)
          if (existingIdCheck == -1) {
            this.moveAnnotationsStore.push(this.layerDatas[ma].annotations[findAnnotationIndex]);
          }
          //Duplicate checking end
        }
      }
    }
  }
  
  async updateMoveComplete() {
    let start_1 = this.functionstarttime("move update function");
    this.show = true;
    let cloneLayerDataMove = _.cloneDeep(this.layerDatas);
    this.moveElementValue = false;
    this.dataService2.moveAccessRemove.emit();
    this.createDocumentStore.selectedAnnotations = [];
    this.createDocumentStore.single_select_annotation = [];
    //remove currentannotation data
    this.currentSelectedAnnotationData = {};
    this.getSelectedElements = null;
    this.getId = "";
    this.annotationSelected = false;
    this.selectAnnotationZero();
    console.log(this.moveAnnotationsStore);
    // if(this.moveAnnotationsStore!=null && this.moveAnnotationsStore.length!=0){
    //   for(let i=0;i<this.moveAnnotationsStore.length;i++){
    //     this.moveAnnotationsStore[i].original_property.initial_position_x=this.moveAnnotationsStore[i].initial_position_x;
    //     this.moveAnnotationsStore[i].original_property.initial_position_y=this.moveAnnotationsStore[i].initial_position_y;
    //   }
    // }
    let start = this.functionstarttime("move api start");
    if(this.resizeMove == true){
      // await this.rotateResizeupdateAPI();
      this.resizeMove = false;
      this.resizedone=true
      this.show = true;
      this.rotateandresize = false;
      this.createDocumentStore.enableresizeButtons = false;
      this.resizebutton = false;
      console.log("cloneLayerDataMove",this.moveAnnotationsStore)
      
      if(this.moveAnnotationsStore.length == 1){
        let getanntation_width = this.shapeService1.getCanvaswidthandHeight(this.moveAnnotationsStore[0]);
        console.log("getanntation_width",getanntation_width)
        let change_axis = 0
        if(this.moveAnnotationsStore[0].toolbar_element_id > 11){
          change_axis = 0
        }else{
          change_axis = (5)+this.moveAnnotationsStore[0].line_width+(this.moveAnnotationsStore[0].line_width/6)
        }
          if(this.moveAnnotationsStore[0].initial_width > this.resizeMoveBackUp.initial_width && this.moveAnnotationsStore[0].initial_height > this.resizeMoveBackUp.initial_height){
            console.log("adeeeiii",this.moveAnnotationsStore[0].initial_position_x,this.moveAnnotationsStore[0].initial_position_y)
            this.moveAnnotationsStore[0].initial_position_x = this.moveAnnotationsStore[0].initial_position_x-change_axis
            this.moveAnnotationsStore[0].initial_position_y = this.moveAnnotationsStore[0].initial_position_y-change_axis
            console.log("cloneLayerDataMove2")
            console.log("adeeeiii 222",this.moveAnnotationsStore[0].initial_position_x,this.moveAnnotationsStore[0].initial_position_y)
          }else{
            this.moveAnnotationsStore[0].initial_position_x = this.moveAnnotationsStore[0].initial_position_x+change_axis
            this.moveAnnotationsStore[0].initial_position_y = this.moveAnnotationsStore[0].initial_position_y+change_axis
            console.log("cloneLayerDataMove3")
          }
          console.log(this.moveAnnotationsStore[0])
      }
    }
    //else{
      console.log("this.moveAnnotationsStore",this.moveAnnotationsStore)
      this.documentService.annotationMRRUpdate(cloneLayerDataMove, this.moveAnnotationsStore).subscribe((response) => {
        console.log(response);
        this.functionendtime("move api", start);
        this.removeCanvasAttribute('customeMoveAttribute');
        if (response["response_code"] == 200) {
          // this.removeElement123();
          this.removeMoveEvents();
          for (let k = 0; k < this.moveAnnotationsStore.length; k++) {
            this.replacecurrentChangeInSVG(this.moveAnnotationsStore[k], false);
          }
          if (this.multipleSelectOn == true) {
            this.createDocumentStore.selectedAnnotations = [];
            let removeAttribute = document.querySelectorAll('canvas[multiMoving]');
  
            removeAttribute.forEach((element) => element.removeAttribute("multiMoving"));
            this.dataService2.imageChangeDocHeader.emit();
          }
          this.show = false;
          this.toolcopyname('remove');
          console.log(this.createDocumentStore.backup_annot_Store);
          this.createDocumentStore.backup_annot_Store=[];
          if (this.multipleSelectOn == true) {
            for (let k = 0;k < this.moveAnnotationsStore.length;k++) {
              let findCurGroupIndex = this.findGroupindex(this.moveAnnotationsStore[k].annotation_id);
              console.log(findCurGroupIndex);
              if (findCurGroupIndex != -1) {
                let groupDatas = this.createJSON_grpAnnts.group_data[findCurGroupIndex];
                let getGroupAnnList = groupDatas.annotation_ids;
                let getGroupId = groupDatas.group_annotation_id;
                let cloneGrpAnnList = _.cloneDeep(getGroupAnnList);
                let filterlist = this.checkAnnIDfromDOM(cloneGrpAnnList, getGroupAnnList);
                let pathBox = this.calcMinandMaxforGrpAnnts_getAnns(filterlist);
                console.log(pathBox);
                let getBorderBoxWidthandHeight: any = this.getAnnotationWidthandHeightAction(pathBox);
                let borderGroupIndex = this.createDocumentStore.view_annotation_array.findIndex(id => id.hasOwnProperty("grouping_border_id") && id.grouping_border_id == getGroupId);
                if (borderGroupIndex != -1) {
                  this.createDocumentStore.view_annotation_array[borderGroupIndex].annotation_data = pathBox;
                  this.createDocumentStore.view_annotation_array[borderGroupIndex].width = getBorderBoxWidthandHeight.width;
                  this.createDocumentStore.view_annotation_array[borderGroupIndex].height = getBorderBoxWidthandHeight.height;
                  this.createDocumentStore.view_annotation_array[borderGroupIndex].left = getBorderBoxWidthandHeight.left;
                  this.createDocumentStore.view_annotation_array[borderGroupIndex].top = getBorderBoxWidthandHeight.top;
                }
                let dropDownColorPresent = this.dropDownColorDetails != undefined ? true : false;
                let groupColorCode = groupDatas.group_state;
                let filter_colorDetails = groupDatas.color_details.filter(id => id.is_removed == false);
                let filter_colorDetails_basedonDOM = filter_colorDetails.filter(id => document.getElementById(id.annotation_id) != null);
                this.changeAnnColorbasedOnstate(groupColorCode,filter_colorDetails_basedonDOM,dropDownColorPresent,groupDatas);
              }
            }
          }
          else {
            let findCurGroupIndex = this.findGroupindex(this.moveAnnotationsStore[0].annotation_id);
            console.log(findCurGroupIndex);
            if (findCurGroupIndex != -1) {
              let groupDatas = this.createJSON_grpAnnts.group_data[findCurGroupIndex];
              let getGroupAnnList = groupDatas.annotation_ids;
              let getGroupId = groupDatas.group_annotation_id;
              let cloneGrpAnnList = _.cloneDeep(getGroupAnnList);
              let filterlist = this.checkAnnIDfromDOM(cloneGrpAnnList, getGroupAnnList);
              let pathBox = this.calcMinandMaxforGrpAnnts_getAnns(filterlist);
              console.log(pathBox);
              let getBorderBoxWidthandHeight: any = this.getAnnotationWidthandHeightAction(pathBox);
              let borderGroupIndex = this.createDocumentStore.view_annotation_array.findIndex(id => id.hasOwnProperty("grouping_border_id") && id.grouping_border_id == getGroupId);
              if (borderGroupIndex != -1) {
                this.createDocumentStore.view_annotation_array[borderGroupIndex].annotation_data = pathBox;
                this.createDocumentStore.view_annotation_array[borderGroupIndex].width = getBorderBoxWidthandHeight.width;
                this.createDocumentStore.view_annotation_array[borderGroupIndex].height = getBorderBoxWidthandHeight.height;
                this.createDocumentStore.view_annotation_array[borderGroupIndex].left = getBorderBoxWidthandHeight.left;
                this.createDocumentStore.view_annotation_array[borderGroupIndex].top = getBorderBoxWidthandHeight.top;
              }
              let filter_colorDetails = groupDatas.color_details.filter(id => id.is_removed == false);
              let groupColorCode = groupDatas.group_state;
              let dropDownColorPresent = this.dropDownColorDetails != undefined ? true : false;
              let filter_colorDetails_basedonDOM = filter_colorDetails.filter(id => document.getElementById(id.annotation_id) != null);
              this.changeAnnColorbasedOnstate(groupColorCode,filter_colorDetails_basedonDOM,dropDownColorPresent,groupDatas);
            }
          }
          this.moveAnnotationsStore = [];
        }
        else {
          this.errorMessage();
          this.toolcopyname('remove');
          // this.removeElement123();
          this.removeMoveEvents();
          if (this.multipleSelectOn == true) {
            this.createDocumentStore.selectedAnnotations = [];
            this.dataService2.imageChangeDocHeader.emit();
          }
        }
        this.functionendtime("move update function", start_1);
      });
    // }
  }
  
  cancelMoveElements() {
    this.moveElementValue = false;
    this.resizedone = false;
    this.createDocumentStore.selectedAnnotations = [];
    this.createDocumentStore.single_select_annotation = [];
    //remove currentannotation data
    this.currentSelectedAnnotationData = {};
    this.getSelectedElements = null;
    var copymoveAnnotationsStore=this.moveAnnotationsStore;
    this.moveAnnotationsStore = [];
    // remove subscriptions method
    if (this.multipleSelectOn == true) {
      this.deselectAnnotation();
      this.dataService2.imageChangeDocHeader.emit();
    }
    else if (this.multipleSelectOn == false) {
      this.deselectAnnotation();
    }
    this.dataService2.moveAccessRemove.emit();
    this.removeMoveEvents();
    this.removeCanvasAttribute('customeMoveAttribute');
    // this.show = true;
    // redraw the annotations
    // this.getAnnotationForm();
    console.log(this.resizeMove)
    if(this.resizeMove == true){
      this.revert_changes_resize_rotate();
    }
    else if(copymoveAnnotationsStore!=null && copymoveAnnotationsStore!=undefined && copymoveAnnotationsStore.length!=0){
      this.revert_changes();
    }
    this.show = false;
    this.toolcopyname('remove');
    if(this.resizeMove == true){
      this.closeRotateFooter();
    }
  }
  

  removeElement123() {

    let getAllCanvas = document.querySelectorAll("canvas");
    getAllCanvas.forEach((data) => {
      this.transparentBorder(data);
    });

    console.log('deselect called');
  }
  doc2() {
    this.dataService.imageChangeDocHeader.emit(false);
    var show = true
    console.log(show)
    var documentnames = this.route.snapshot.queryParamMap.get("documentName")
    var data_image = document.getElementById("pdfImg")
    var data = document.getElementById("pdfViewerHead")
    let oldWidth = data_image.style.width
    let oldHeight = data_image.style.height
    let oldTransform = getComputedStyle(data_image).transform
    if (!this.pngFormat) {
      data_image.style.transform = "matrix(2.0, 0, 0, 2.0, 0, 0)"
    }
    // data.style.width = (this.realWidth*4)+"px"
    // data.style.height = (this.realHeight*4)+"px"
    let l_realWidth = this.realWidth
    let l_realHeight = this.realHeight
    html2canvas((data), {
      allowTaint: true,
      useCORS: true
    }).then(function (canvas) {
      console.log(self)
      var width = canvas.width;
      var height = canvas.height;
      var orientationMode: any;
      if (width > height) {
        orientationMode = 'l';
      }
      else {
        orientationMode = 'p';
      }

      const pdf = new jsPDF(orientationMode, 'pt', [l_realWidth, l_realHeight])
      const contentDataURL = canvas.toDataURL('image/jpeg', 1.0)

      // var hwidth = pdf.internal.pageSize.getWidth();
      // var hheight = pdf.internal.pageSize.getHeight();
      // // var imgHeight = canvas.height * hwidth / canvas.width;

      pdf.addImage(contentDataURL, 'JPEG', 0, 0, l_realWidth, l_realHeight)
      pdf.save(documentnames + '-Export.pdf'); // Generated PDF

      data_image.style.width = oldWidth
      data_image.style.height = oldHeight
      data_image.style.transform = oldTransform
    });
  }

  doc1() {
    this.dataService.imageChangeDocHeader.emit(false);
    var documentnames = this.route.snapshot.queryParamMap.get("documentName")
    var data = document.getElementById("pdfImg")
    // var new_canvas = _.cloneDeep(data)
    let oldWidth = data.style.width
    let oldHeight = data.style.height
    let oldTransform = getComputedStyle(data).transform
    if (!this.pngFormat) {
      data.style.transform = "matrix(2.0, 0, 0, 2.0, 0, 0)"
    }
    // data.style.width = (this.realWidth*4)+"px"
    // data.style.height = (this.realHeight*4)+"px"
    let l_realWidth = this.realWidth
    let l_realHeight = this.realHeight
    html2canvas((data), {
      allowTaint: true,
      useCORS: true
    }).then(function (canvas) {
      console.log(self)
      var width = canvas.width;
      var height = canvas.height;
      var orientationMode: any;
      if (width > height) {
        orientationMode = 'l';
      }
      else {
        orientationMode = 'p';
      }

      const pdf = new jsPDF(orientationMode, 'pt', [l_realWidth, l_realHeight])
      const contentDataURL = canvas.toDataURL('image/jpeg', 1.0)

      // var hwidth = pdf.internal.pageSize.getWidth();
      // var hheight = pdf.internal.pageSize.getHeight();
      // // var imgHeight = canvas.height * hwidth / canvas.width;

      pdf.addImage(contentDataURL, 'JPEG', 0, 0, l_realWidth, l_realHeight)
      pdf.save(documentnames + '-Export.pdf'); // Generated PDF

      data.style.width = oldWidth
      data.style.height = oldHeight
      data.style.transform = oldTransform
    });


  }


  removeMoveEvents() {
    console.log(this.subscriptions);
    this.subscriptions.forEach((s) => {
      if (s != undefined) {
        s.unsubscribe();
      }
    });
  }

  addredCircles(coordsx, coordsy) {
    console.log(this.scale);
    let circle = document.createElement("span");
    circle.setAttribute("class", "tempcircle");
    circle.style.position = "absolute";
    circle.style.borderRadius = "50%";
    circle.style.border = "5px solid rgba(255,0,0,0.8)";
    // circle.style.background = "rgba(255,0,0,0.8)";
    circle.style.width = "12px";
    circle.style.height = "12px";
    if (this.scale >= 1.24049 && this.createDocumentStore.enablerepointButtons == false) {
      circle.style.opacity = "0.5";
      let reduce_size = (12 / this.scale);
      if (reduce_size < 4) {
        reduce_size = 4;
      }
      circle.style.width = reduce_size + 'px';
      circle.style.height = reduce_size + 'px';
      circle.style.marginTop = -(reduce_size / 2) + 'px';
      circle.style.marginLeft = -(reduce_size / 2) + 'px';
      if (this.scale < 1.5) {
        circle.style.border = "5px solid rgba(255,0,0,0.8)";
      }
      else if (reduce_size == 4) {
        circle.style.border = "2px solid rgba(255,0,0,0.8)";
      }
      else {
        circle.style.border = "3px solid rgba(255,0,0,0.8)";
      }
    }
    else {
      circle.style.opacity = "0.7";
      circle.style.marginTop = "-6px";
      circle.style.marginLeft = "-6px";
    }
    circle.style.pointerEvents = "none";
    circle.style.top = coordsy + "px";
    circle.style.left = coordsx + "px";
    circle.style.zIndex = "9999";
    return circle;
  }

  alignmenprocess() {
    if (this.is_extend == true) {
      let check_condition = ["false", false, 0, "0"];
      let column_one = _.cloneDeep(this.modelFieldsForm);
      let column_two = _.cloneDeep(this.extend_modelFieldsForm);
      var annontationidDate = new Date().getTime();
      this.su = this.encrptdecrpt.getItem("loggedIn") || "{}";

      column_one = column_one.filter((data) => check_condition.includes(data.is_removed));
      column_two = column_two.filter((data) => check_condition.includes(data.is_removed));

      let elements_height = _.cloneDeep(this.element_details);

      if (column_one.length == column_two.length) {
        for (let i = 0; i < column_one.length; i++) {

          let temp_extend_holder = column_two.filter(ele => ele["element_data"].reference_id == column_one[i].element_uuid);
          let index = column_two.indexOf(temp_extend_holder[0]);
          if (index > -1) {
            let ele_one = this.element_details.filter(data => data.element_name == column_one[i].element_type);
            let ele_two = elements_height.filter(data => data.element_name == column_two[index].element_type);

            if (column_one[i].element_type == "multiple_choice" || column_one[i].element_type == "single_choice") {
              let option_list = column_one[i].element_data.options.filter(ele => check_condition.includes(ele.is_removed));
              let option_list_length = option_list.length;
              let Option_to_add = 28 * option_list_length;
              if (ele_one[0].element_name == "multiple_choice" || ele_one[0].element_name == "single_choice") {
                ele_one[0].height = 40;
                ele_one[0].height += Option_to_add;
              }
            }
            if (column_two[index].element_type == "multiple_choice" || column_two[index].element_type == "single_choice") {
              let option_list = column_two[index].element_data.options.filter(ele => check_condition.includes(ele.is_removed));
              let option_list_length = option_list.length;
              let Option_to_add = 28 * option_list_length;
              if (ele_two[0].element_name == "multiple_choice" || ele_two[0].element_name == "single_choice") {
                ele_two[0].height = 40;
                ele_two[0].height += Option_to_add;
              }
            }

            if (ele_one[0].height >= ele_two[0].height) {
              column_one[i].height = ele_one[0].height;
              column_two[index].height = ele_one[0].height;
            } else {
              column_one[i].height = ele_two[0].height;
              column_two[index].height = ele_two[0].height;
            }
          }

        }
        console.log(column_one)
        console.log(column_two)
        this.modelFieldsForm = column_one;
        this.extend_modelFieldsForm = column_two;
        
      }

    }
  }


  addredCirclesSVG(coordsx, coordsy) {
    let red_circle = document.createElementNS('http://www.w3.org/2000/svg', "circle");
    red_circle.setAttribute('cx', coordsx.toString());
    red_circle.setAttribute('cy', coordsy.toString());
    red_circle.setAttribute('r', "6");
    red_circle.setAttribute('stroke-width', "2");
    red_circle.setAttribute('fill', "red");
    red_circle.setAttribute('fill-opacity', "0.5");
    red_circle.setAttribute("class", "tempcircle");
    let local_scale = this.pngFormat ? this.scale : this.pdfScaleValue > 1 ? this.pdfScaleValue : this.scale;
    if (local_scale >= 1.24049 && this.createDocumentStore.enablerepointButtons == false) {
      let default_radius = 6;
      let calculate_scaling = 6 / local_scale;
      calculate_scaling = calculate_scaling <= 1 ? 1 : calculate_scaling;
      red_circle.setAttribute('r', calculate_scaling.toString());
    }else if(local_scale >= 1.24049 && this.createDocumentStore.enablerepointButtons == true){
      let default_radius = 6;
      let calculate_scaling = 6 / local_scale;
      calculate_scaling = calculate_scaling <= 1 ? 1 : calculate_scaling;
      red_circle.setAttribute('r', calculate_scaling.toString());
    }
    return red_circle;
  }
  removeredCirclesSVG() {
    let get_circles = document.querySelectorAll('circle.tempcircle');
    if (get_circles != null && get_circles.length > 0) {
      get_circles.forEach((circle) => circle.remove());
    }
  }

  // normal shape drawing
  drawUpdatedShapes(annotationIds) {
    if (this.layerDatas != undefined) {
      let findLayerIndexD = this.layerDatas.findIndex((LData) => LData.layer_id === this.activeLayerIdDraw);
      if (findLayerIndexD != -1) {
        for (let j = 0; j < annotationIds.length; j++) {
          let drawShape = this.layerDatas[findLayerIndexD].annotations.filter((AData) => AData.annotation_id === annotationIds[j]);
          console.log(drawShape[0].toolbar_element_id)
          this.get_disable_setting(drawShape[0].toolbar_element_id);
          if (drawShape.length > 0) {

            // this.coordinateX = drawShape[0].initial_position_x;
            // this.coordinateY = drawShape[0].initial_position_y;
            // let isnegativeCoordinates = false;
            // if (this.coordinateX < 0 && this.coordinateY < 0) {
            //   this.coordinateX = -this.coordinateX;
            //   this.coordinateY = -this.coordinateY;
            //   isnegativeCoordinates = true;
            // }
            let annotationClear = document.getElementById(annotationIds[j]);
            if (annotationClear != null) {
              annotationClear.remove();
            }
            let annotationLabelClear = document.getElementById('label' + annotationIds[j]);
            if (annotationLabelClear != null) {
              annotationLabelClear.remove();
            }
            let cloneDeepShapeData = _.cloneDeep(drawShape)

            let getChangesString = this.shapeStringChanges(cloneDeepShapeData[0]);
            let annotationJSON = getChangesString.annotationData;
            let p2p3Checking = getChangesString.p2p3;
            this.getshapeDrawing(annotationJSON, p2p3Checking);
            // freehand shape as many all shapes selected selection issue purpose commented
            // let get_new_generate_element = document.getElementById(annotationIds[j]);
            // if (get_new_generate_element != null) {
            //   this.colorBorder(get_new_generate_element);
            // }
          }
        }
      }
    }
  }
  // svg normal shape drawing
  async drawUpdatedShapesSVG(annotationData: any) {
    let generateannotation = _.cloneDeep(annotationData);
    let svg_changes = await this.annotation_view_svg(generateannotation);
    console.log(svg_changes);
    console.log(this.createDocumentStore.view_annotation_array);
    if(svg_changes.annotation_name=="Text"){
      this.textsize=svg_changes.textfontSize;
      let x=svg_changes.textshapetextx;
      let y=svg_changes.textshapetexty;
      this.backUpTextProperties={'size':this.textsize,'xPosition':x,'yPosition':y}
    }
    // if(svg_changes.toolbar_element_id == 15){
    //   svg_changes.line_border = this.borderLine;
    // }
    this.createDocumentStore.view_annotation_array.push(svg_changes);
    console.log(this.createDocumentStore.view_annotation_array);
    return 1
  }

  async annotationClearDraw(annodationDetails: any) {
    // let annotationClear = document.getElementById(annodationDetails.annotation_id);
    // if (annotationClear != null) {
    //   annotationClear.remove();
    // }
    // let annotationLabelClear = document.getElementById('label' + annodationDetails.annotation_id);
    // if (annotationLabelClear != null) {
    //   annotationLabelClear.remove();
    // }
    // let cloneDeepShapeData = _.cloneDeep(annodationDetails)
    // let getChangesString = this.shapeStringChanges(cloneDeepShapeData);
    // let annotationJSON = getChangesString.annotationData;
    // let p2p3Checking = getChangesString.p2p3;
    // this.getshapeDrawing(annotationJSON, p2p3Checking);
    await this.replacecurrentChangeInSVG(annodationDetails, true);
  }

  shapeStringChanges(cloneDisplayAnnotation) {

    this.coordinateX = cloneDisplayAnnotation.initial_position_x;
    this.coordinateY = cloneDisplayAnnotation.initial_position_y;
    let isnegativeCoordinates = false;
    if (this.coordinateX < 0 && this.coordinateY < 0) {
      this.coordinateX = -this.coordinateX;
      this.coordinateY = -this.coordinateY;
      isnegativeCoordinates = true;
    }
    if (cloneDisplayAnnotation.toolbar_element_id < 19 || cloneDisplayAnnotation.annotation_data.includes('move')) {
      if (Number(cloneDisplayAnnotation.initial_height) != 0 && Number(cloneDisplayAnnotation.initial_width) != 0) {
        let getresizeShapeString = this.shapeService1.resizeFunctionNew(cloneDisplayAnnotation, isnegativeCoordinates);
        cloneDisplayAnnotation.annotation_data = getresizeShapeString.shapeString;
        let cloneObject = Object.assign({}, cloneDisplayAnnotation);

        this.dbxposition = Number(cloneObject.initial_position_x);
        this.dbyposition = Number(cloneObject.initial_position_y);
        if ((cloneDisplayAnnotation.toolbar_element_id < 11)) {
          cloneDisplayAnnotation.initial_position_x = getresizeShapeString.initialX;
          cloneDisplayAnnotation.initial_position_y = getresizeShapeString.initialY;
        }
      }
      else if ((cloneDisplayAnnotation.toolbar_element_id == 13 || cloneDisplayAnnotation.toolbar_element_id == 14) && cloneDisplayAnnotation.initial_position_x != 0 && isnegativeCoordinates == false) {
        let getresizeShapeString = this.shapeService1.resizeFunctionNew(cloneDisplayAnnotation, isnegativeCoordinates);
        cloneDisplayAnnotation.annotation_data = getresizeShapeString.shapeString;
      }
    }
    let convertedshapes = { annotationData: cloneDisplayAnnotation, p2p3: isnegativeCoordinates };
    return convertedshapes;
  }

  sidebarDrawCalculation(displayAnnotations) {
    console.log(displayAnnotations.length);
    // if (displayAnnotations.toolbar_element_id < 19) {
    //   if (Number(displayAnnotations.initial_height) != 0 && Number(displayAnnotations.initial_width) != 0) {
    //     let getresizeShapeString = this.shapeService1.resizeFunctionNew(displayAnnotations, false);
    //     displayAnnotations.annotation_data = getresizeShapeString.shapeString;
    //   }
    // }


    let isnegativeCoordinates = false;
    let coordinateX = Number(displayAnnotations.initial_position_x);
    let coordinateY = Number(displayAnnotations.initial_position_y);
    if (coordinateX < 0 && coordinateY < 0) {
      coordinateX = -this.coordinateX;
      coordinateY = -this.coordinateY;
      isnegativeCoordinates = true;
    }
    if ((displayAnnotations.toolbar_element_id < 19 || displayAnnotations.annotation_data.includes('move')) && isnegativeCoordinates == false) {
      if (Number(displayAnnotations.initial_height) != 0 && Number(displayAnnotations.initial_width) != 0) {
        let getresizeShapeString = this.shapeService1.resizeFunctionNew(displayAnnotations, isnegativeCoordinates);
        displayAnnotations.annotation_data = getresizeShapeString.shapeString;
        if (displayAnnotations.toolbar_element_id < 11) {
          // displayAnnotations.initial_position_x = getresizeShapeString.initialX;
          // displayAnnotations.initial_position_y = getresizeShapeString.initialY;
        }
      }
      else if ((displayAnnotations.toolbar_element_id == 13 || displayAnnotations.toolbar_element_id == 14) && displayAnnotations.initial_position_x != 0) {
        let getresizeShapeString = this.shapeService1.resizeFunctionNew(displayAnnotations, isnegativeCoordinates);
        displayAnnotations.annotation_data = getresizeShapeString.shapeString;
      }
    }
    // if (isnegativeCoordinates == true) {
    //   this.shapeService1.getshapeDrawingP2P3(displayAnnotations, 'headerCanvasForms', 'sidebarheaderlabel', 'DocPage');
    //   this.shapeService1.canvasToImageConvert('headerCanvasForms', 'DocPage', displayAnnotations);
    // }
    // else {
    //   this.shapeService1.getshapeDrawing(displayAnnotations, isnegativeCoordinates, 'headerCanvasForms', 'sidebarheaderlabel', 'DocPage');
    //   this.shapeService1.canvasToImageConvert('headerCanvasForms', 'DocPage', displayAnnotations);
    // }
    // return displayAnnotations;
    let convertedshapes = { annotationData: displayAnnotations, p2p3: isnegativeCoordinates };
    return convertedshapes;
  }

  rotateResizeCheckCommon(annotationJSON) {
    let isnegativeCoordinates = false;
    let annotData = annotationJSON;
    if (annotData.toolbar_element_id < 19 || annotData.annotation_data.includes('move')) {
      if (Number(annotData.initial_height) != 0 && Number(annotData.initial_width) != 0) {
        let getresizeShapeString = this.shapeService1.resizeFunctionNew(annotData, isnegativeCoordinates);
        annotData.annotation_data = getresizeShapeString.shapeString;
      }
      else if ((annotData.toolbar_element_id == 13 || annotData.toolbar_element_id == 14) && annotData.initial_position_x != 0) {
        let getresizeShapeString = this.shapeService1.resizeFunctionNew(annotData, isnegativeCoordinates);
        annotData.annotation_data = getresizeShapeString.shapeString;
      }
    }
    return annotData;
  }

  combindSidebarDrawLogic(getDrawData, id, labelString) {
    console.log(getDrawData);
    // let resizeCheck = this.sidebarDrawCalculation(getDrawData);
    // this.shapeService1.formsheaderCanvas(id, resizeCheck, labelString, 'DocPage');
    // this.shapeService1.canvasToImageConvert(id, 'DocPage', resizeCheck);
    let cloneDrawData = _.cloneDeep(getDrawData);
    let getChangesString = this.sidebarDrawCalculation(cloneDrawData);
    let annotationJSON = getChangesString.annotationData;
    let p2p3Checking = getChangesString.p2p3;

    if (p2p3Checking == true) {
      this.shapeService1.getshapeDrawingP2P3(annotationJSON, id, labelString, 'DocPage');
      this.shapeService1.canvasToImageConvert(id, 'DocPage', annotationJSON);
    }
    else {

      this.shapeService1.getshapeDrawing(annotationJSON, p2p3Checking, id, labelString, 'DocPage');
      this.shapeService1.canvasToImageConvert(id, 'DocPage', annotationJSON);
    }
  }

  changeStringValue(data) {
    let getnewString = this.shapeService1.xyPositionDiff(data);
    let getStringValue = getnewString.shapeString;
    return getStringValue;
  }

  slideAfterScale() {
    console.log('stop resizer');
    // let getImageContainer = document.getElementById("Imagecontainer");
    // let getImageDivHeightWidth = document.getElementById("pdfImg");
    // let currentWidthHeight = getImageDivHeightWidth.getBoundingClientRect();
    // if (getImageContainer != null) {
    //   let getImageContainerSize = getImageContainer.getBoundingClientRect();
    //   if (currentWidthHeight.width < getImageContainerSize.width) {
    //     let centerX = getImageContainerSize.width - currentWidthHeight.width;
    //     let centerY = getImageContainerSize.height - currentWidthHeight.height;
    //     // this.scaleValue = 1;
    //     if (centerX > 0) {
    //       getImageDivHeightWidth.style.left = centerX / 2 + 'px';
    //     }
    //     if (centerY > 0) {
    //       getImageDivHeightWidth.style.top = centerY / 2 + 'px';
    //     }
    //   }
    // }
  }

  getLocation(linkdetails) {

    console.log(this.projectFolderList, linkdetails)
    if (this.projectFolderList != undefined) {
      var filterDocumentDetails = this.projectFolderList.filter((folderList) => {
        if (folderList.folder_id == linkdetails.document_id) {
          return folderList;
        }

      });
    }
    if (filterDocumentDetails != undefined) {
      let mergeFinalSearchArray = [];
      for (let v = 0; v < filterDocumentDetails.length; v++) {
        let searchFolderId = filterDocumentDetails[v].folder_id;
        let searchLevel = filterDocumentDetails[v].folder_level;
        let searchDisplayFolder = [];
        let folderIdArray = [];
        searchDisplayFolder.push(searchFolderId);
        for (let count = searchLevel; count > 0; count--) {
          let filterSearchArray = this.projectFolderList.filter((data) => { return searchFolderId == data.folder_id });
          searchDisplayFolder.push(filterSearchArray[0].parent_folder_id);
          searchFolderId = filterSearchArray[0].parent_folder_id;
        }
        let finalArray = [];
        for (let j = 0; j < searchDisplayFolder.length; j++) {
          let filterIdPick = this.projectFolderList.filter((data) => { return searchDisplayFolder[j] == data.folder_id });
          finalArray.push(filterIdPick[0]);
        }
        finalArray.forEach((sValue) => mergeFinalSearchArray.push(sValue));
      }

      mergeFinalSearchArray = mergeFinalSearchArray.filter((value, index) => mergeFinalSearchArray.indexOf(value) === index);
      let sortFolderLevel = mergeFinalSearchArray.sort((a, b) => a.folder_level - b.folder_level);
      let generateLocation = 'Location: ' + this.projectName + ' > ';

      for (let j = 0; j < sortFolderLevel.length; j++) {
        if (j != sortFolderLevel.length - 1) {
          generateLocation = generateLocation + sortFolderLevel[j].folder_name + ' > ';
        }
        else {
          generateLocation = generateLocation + sortFolderLevel[j].folder_name;
        }
      }
      generateLocation = this.dataService4.changeSpecialtoKeyFormat(generateLocation);
      return generateLocation;
    }
  }

  getdropdownvalue(dropdown) {
    console.log(dropdown)
    if (dropdown == '') {
      this.colorchange = true

    } else {
      this.colorchange = false;
    }
  }
  newplotannotationSelection(annotationData) {
    //convert json special characters
    // convert special characters
    let get_db_data = annotationData;
    annotationData = this.document_credential.convert_special_char_annot(get_db_data);
    this.getId = annotationData.annotation_id;
    let multiUnselect: boolean = false;
    var getElementSelect = document.getElementById(this.getId);
    var heightC: any = getElementSelect.getAttribute("height");
    var widthC: any = getElementSelect.getAttribute("width");
    if (this.multipleSelectOn == false) {
      // getElementSelect.classList.add('svg-block');
      // svg changes border disabled
      this.currentSelectedCanvas(annotationData,undefined);
      if (this.searchOption == true) {
        this.idss = annotationData.annotation_id;
        this.dataService.getannotationid.emit(this.idss);
      }
    }
    else {
      if (getElementSelect != null) {
        this.colorBorderSVG(getElementSelect);
        getElementSelect.setAttribute('multimoving', '1');
      }
      if (get_db_data.annotation_tags != "") {
        let itemIndex = this.multiselectionList.findIndex(item => item.annotation_id == annotationData.annotation_id);
        if (itemIndex != -1) {
          this.multiselectionList.splice(itemIndex, 1, annotationData);
          console.log(this.multiselectionList)
        } else {
          this.multiselectionList.push(annotationData);
        }
        let itemsIndex = this.createDocumentStore.selectedAnnotations.findIndex(item => item == annotationData.annotation_id);
        if (itemsIndex != -1) {
          this.createDocumentStore.selectedAnnotations.splice(itemIndex, 1, annotationData.annotation_id);
        } else {
          this.createDocumentStore.selectedAnnotations.push(annotationData.annotation_id);
        }
      }
      this.multiselectionList.push(annotationData);
      this.createDocumentStore.selectedAnnotations.push(annotationData.annotation_id);
      this.get_Multiselection_Data_Count();
    }
    if (this.moveElementValue == false) {
      this.optionClick = false;
      this.hideSelectForm = true;
      this.sampleFormObject = [];
      this.modelFieldsForm = [];
      this.extend_modelFieldsForm = [];
    }
    else{
      // The moveAnnotationsStore variable is used to store the size of multiple annotations locally.
      this.backup_annot_storage(annotationData);
    }
    var singleDataReceived;
    this.annotationSelected = true;
    singleDataReceived = annotationData;
    let clone_original_anotationdata = _.cloneDeep(annotationData);
    for (var k = 0; k < this.layerDatas.length; k++) {
      let itemIndex = this.layerDatas[k].annotations.findIndex(item => item.annotation_id == singleDataReceived.annotation_id);
      //this.layerDatas[k].annotations[itemIndex] = singleDataReceived;
      if (itemIndex != -1) {
        this.layerDatas[k].annotations.splice(itemIndex, 1, clone_original_anotationdata);
        this.currentSelectedAnnotationData = singleDataReceived;
        this.getId = singleDataReceived.annotation_id;
        //   for (var l = 0; l < this.layerDatas[k].annotations.length; l++) {
        //     if (this.getId == this.layerDatas[k].annotations[l].annotation_id) {
        let currentData: any = _.cloneDeep(singleDataReceived);
        this.currentSelectedAnnotationData = singleDataReceived;
        // header svg drawing
        this.single_view_svg_drawing(singleDataReceived);
        this.propertiesannotationData = currentData;
        this.propertiesannotationDataCopy = _.cloneDeep(currentData);
        // this.toolbarElementId = singleDataReceived.toolbar_element_id;
        if (singleDataReceived.annotation_media.length > 0) {
          //this.sampleFormObject = singleDataReceived.annotation_media;
          this.globalMediaCount(singleDataReceived.annotation_media, 'media');
        }
        else if (singleDataReceived.annotation_media.length == 0) {
          this.sampleFormObject = [];
        }
        singleDataReceived.annotation_forms = singleDataReceived.annotation_forms.filter((ele => ele.is_removed == 0 || ele.is_removed == "0" || ele.is_removed == false))

        //Jose Comment the below if condition
        // if (singleDataReceived.annotation_forms.length > 0) {

        //taking the current form details from api
        let formlength = singleDataReceived.annotation_forms.length;
        let formslist_local = this.formList;
        formslist_local = formslist_local.sort((a, b) => new Date(a.last_updated_date).getTime() - new Date(b.last_updated_date).getTime())
        let sortedForms = singleDataReceived.annotation_forms.length == 0 ? formslist_local : singleDataReceived.annotation_forms//singleDataReceived.annotation_forms.sort((a,b) => a.form_name.localeCompare(b.form_name));
        this.isAnnotationDefaultForm = singleDataReceived.annotation_forms.length == 0 ? false : true
        if (sortedForms != null && sortedForms != undefined && sortedForms.length > 0) {
          let curnt_slcted_form_index = this.select_primary_form(sortedForms); // primary form selection function
          this.currentFormId = sortedForms[curnt_slcted_form_index].form_id;
          let check_form_name = this.formListDefaultValues.filter((f_name) => f_name.form_id == this.currentFormId);
          if (check_form_name.length > 0) {
            this.currentFormName = check_form_name[0].form_name;
          }
          else {
            this.currentFormName = sortedForms[curnt_slcted_form_index].form_name;
          }
          this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
          this.currentFormHiddenStatus = JSON.parse(sortedForms[curnt_slcted_form_index].is_hidden);
          if (sortedForms[curnt_slcted_form_index].hasOwnProperty('is_extend')) {
            this.is_extend = sortedForms[curnt_slcted_form_index].is_extend;
          } else {
            this.is_extend = false;
          }
          if (this.createDocumentStore.data_allow_condition.includes(this.is_extend)) {
            this.is_extend = false;
          } else {
            this.is_extend = true;
          }
          if (sortedForms[curnt_slcted_form_index].form_data != null && typeof sortedForms[curnt_slcted_form_index].form_data == 'string') {
            this.modelFieldsForm = JSON.parse(sortedForms[curnt_slcted_form_index].form_data);
          }
          else if (sortedForms[curnt_slcted_form_index].form_data != null && typeof sortedForms[curnt_slcted_form_index].form_data != 'string') {
            this.modelFieldsForm = sortedForms[curnt_slcted_form_index].form_data;
          }
          if (this.is_extend == true) {
            if (sortedForms[curnt_slcted_form_index].hasOwnProperty('ext_form_data') &&
              sortedForms[curnt_slcted_form_index].ext_form_data != null &&
              typeof sortedForms[curnt_slcted_form_index].ext_form_data == 'string') {
              if (sortedForms[curnt_slcted_form_index].ext_form_data != null && sortedForms[curnt_slcted_form_index].ext_form_data != undefined) {
                this.extend_modelFieldsForm = JSON.parse(sortedForms[curnt_slcted_form_index].ext_form_data);
              }
            }
            else if (sortedForms[curnt_slcted_form_index].hasOwnProperty('ext_form_data') &&
              sortedForms[curnt_slcted_form_index].ext_form_data != null &&
              typeof sortedForms[curnt_slcted_form_index].ext_form_data != 'string') {
              this.extend_modelFieldsForm = sortedForms[curnt_slcted_form_index].ext_form_data;
            }
            // if (this.extend_modelFieldsForm != null) {
            //   if (typeof this.extend_modelFieldsForm === 'string') {
            //     this.extend_modelFieldsForm = JSON.parse(this.extend_modelFieldsForm);
            //   }
            //   this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
            // }
          }
          if (this.modelFieldsForm.length > 0) {
            this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => this.createDocumentStore.data_allow_condition.includes(formdata.is_removed));
          }
          if (this.extend_modelFieldsForm.length > 0) {
            this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => this.createDocumentStore.data_allow_condition.includes(formdata.is_removed));
          }
          //taking the defult form details from Form builder for the current form
          var editedForm1 = this.formListDefaultValues.filter((ele => ele.form_id == this.currentFormId))
          var editedForm = _.cloneDeep(editedForm1);
          if (editedForm.length > 0) {
            
            let filterCurrentForm = this.formListDefaultValues.filter((ele123 => ele123.form_id == this.currentFormId));
            this.colorvalid = false;
            
            if (filterCurrentForm.length > 0) {
              let formvalue1 = filterCurrentForm[0];
              if (formvalue1.is_hidden == 1 || formvalue1.is_hidden == "true" || formvalue1.is_hidden == "1") {
                this.colorvalid = true;
              } else {
                this.colorvalid = false;
              }
            }
            this.formList = this.formList.sort((a, b) => a.form_name.localeCompare(b.form_name))
            if (editedForm1.length > 0) {
              var newFormDataFelds;
              var ext_newFormDataFelds;
              console.log(this.formList)
              console.log(editedForm)
              editedForm[0].is_hidden = sortedForms[curnt_slcted_form_index].is_hidden
              editedForm[0].is_removed = sortedForms[curnt_slcted_form_index].is_removed
              editedForm[0].is_default_flag = sortedForms[curnt_slcted_form_index].is_default_flag
              if (Array.isArray(editedForm[0].form_data) == false) {
                newFormDataFelds = JSON.parse(editedForm[0].form_data)
              } else {
                newFormDataFelds = editedForm[0].form_data
              }
              if (editedForm[0].hasOwnProperty('ext_form_data') && editedForm[0].ext_form_data != null) {
                if (Array.isArray(editedForm[0].ext_form_data) == false) {
                  ext_newFormDataFelds = JSON.parse(editedForm[0].ext_form_data)
                } else {
                  ext_newFormDataFelds = editedForm[0].ext_form_data
                }
              }
            }
            //var formjsonStringyfy = JSON.stringify(editedForm[0].form_data)
            //checking the form builder form and current form for any new fields are added to that purticular form
            //if any attach that field to the current form

            this.createDocumentStore.backupFormData = _.cloneDeep(this.modelFieldsForm);
            this.createDocumentStore.backupExtendFormData = _.cloneDeep(this.extend_modelFieldsForm);
            // remove deleted fields
            if (newFormDataFelds != null && newFormDataFelds.length > 0) {
              newFormDataFelds = newFormDataFelds.filter((remove_deleted) => this.createDocumentStore.data_allow_condition.includes(remove_deleted.is_removed));
            }
            if (ext_newFormDataFelds != null && ext_newFormDataFelds.length > 0) {
              ext_newFormDataFelds = ext_newFormDataFelds.filter((remove_deleted) => this.createDocumentStore.data_allow_condition.includes(remove_deleted.is_removed));
            }
            let clone_model_fields = this.modelFieldsForm;
            
            newFormDataFelds = this.merge_form_process(clone_model_fields, newFormDataFelds, 'leftside');
            let weldFormIndex =  newFormDataFelds.findIndex((id) => id.element_type == "uti-entry-field-WMATA_WELD");
            var weldPresent = false;
            if(weldFormIndex != -1){
              weldPresent = true;
                var weldformdata = _.cloneDeep(newFormDataFelds[weldFormIndex]);
            }

            // this.modelFieldsForm.forEach(element => {
            //   var FieldFind = newFormDataFelds.filter(ele => ele['element_uuid'] == element['element_uuid']);
            //   // var find_model_field = ext_newFormDataFelds.filter((ele) => ele['element_uuid'] == element['element_uuid']);
            //   //Fieldfind ==> overall form fields from form builder
            //   //element ==> edited form fields for the annotation 
            //   // if (FieldFind.length == 0 && find_model_field.length > 0) {
            //   //   FieldFind = find_model_field;
            //   // }
            //   if (FieldFind.length > 0) {
            //     if (FieldFind[0].is_removed == true || FieldFind[0].is_removed == "true") {
            //       newFormDataFelds = newFormDataFelds.filter(ele => ele['element_uuid'] != FieldFind[0]['element_uuid']);
            //     }
            //     // ganesh changed this line FieldFind.length > 0 && FieldFind.is_removed != true && FieldFind.is_removed != "true"
            //     // added line FieldFind.length > 0 && FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true" for this if condition
            //     if (FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true") {
            //       if (FieldFind[0].element_type == 'single_choice' || FieldFind[0].element_type == 'dropdown') {
            //         this.cdRef.detectChanges();
            //         FieldFind[0].element_data.options.forEach(element1 => {
            //           element1.default = false
            //         });
            //         var defaultOptionValue:any;
            //         if(element.element_data.hasOwnProperty('options'))
            //             {
            //                defaultOptionValue = element.element_data.options.filter((ele => ele.default == true))
            //             }
            //         if (defaultOptionValue!=undefined && defaultOptionValue.length > 0) {
            //           var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == defaultOptionValue[0].element_uuid))
            //           currentOption[0].default = true;
            //         }
            //       } else if (FieldFind[0].element_type == 'multiple_choice' || FieldFind[0].element_type == 'checkbox') {

            //         FieldFind[0].element_data.options.forEach(element1 => {
            //           element1.default = false
            //         });
            //         var UCitemDefault:any;
            //         if(element.element_data.hasOwnProperty('options'))
            //          {
            //              UCitemDefault = element.element_data.options.filter((ele => ele.default == true))
            //          }
            //          if(UCitemDefault!=undefined){
            //           UCitemDefault.forEach(element2 => {
            //             var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == element2.element_uuid))
            //             currentOption[0].default = true;
            //           });
            //         }
            //       }
            //       else if (FieldFind[0].element_type == 'date') {
            //         if (element.element_data.default_date_time != "" && element.element_data.default_date_time != "none" && element.element_data.default_date_time != "current" && element.element_data.default_date_time != undefined) {
            //           //  FieldFind[0].element_data.default_value = new Date(element.element_data.default_date_time).toISOString();
            //           FieldFind[0].element_data.default_date_time = new Date(element.element_data.default_date_time).toISOString();
            //         }
            //         else if (element.element_data.default_date_time != "") {
            //           if (element.element_data.default_date_time == "current") {
            //             FieldFind[0].element_data.default_date_time = element.element_data.default_date_time
            //           }
            //           else if (element.element_data.default_date_time == "none" || element.element_data.default_date_time == "") {
            //             FieldFind[0].element_data.default_date_time = element.element_data.default_date_time;
            //           }
            //         }
            //       }
            //       else if (FieldFind[0].element_type == 'uti-entry-field') {
            //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
            //       }
            //       else if (FieldFind[0].element_type == "uti-entry-field-WMATA") {
            //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
            //       }
            //       else if(FieldFind[0].element_type == "uti-entry-field-TIMBER"){
            //         // element_data replacing changes new 16.02.2022
            //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
            //       }
            //       else if (FieldFind[0].element_type == 'address') {

            //         FieldFind[0].element_data.street_address1 = element.element_data.street_address1
            //         FieldFind[0].element_data.city = element.element_data["city"]
            //         FieldFind[0].element_data.state = element.element_data["state"]
            //         FieldFind[0].element_data.zip = element.element_data["zip"]
            //         FieldFind[0].element_data.street_address2 = element.element_data.street_address2
            //       } else {
            //         if (element.element_data.default_value != undefined && element.element_data.default_value != "") {
            //           FieldFind[0].element_data.default_value = element.element_data.default_value
            //         }
            //       }
            //     }
            //   }
            // })
            if (this.is_extend == true) {
              if (this.extend_modelFieldsForm != null && this.extend_modelFieldsForm.length > 0) {
                
                // this.extend_modelFieldsForm.forEach(element => {
                //   var FieldFind = ext_newFormDataFelds.filter(ele => ele['element_uuid'] == element['element_uuid']);
                //   // var find_model_field = newFormDataFelds.filter((ele)=>ele['element_uuid'] == element['element_uuid']);
                //   //Fieldfind ==> overall form fields from form builder
                //   //element ==> edited form fields for the annotation 
                //   //ganesh added fieldfind.length>0 if condition seperately
                //   // if(FieldFind.length == 0 && find_model_field.length>0){
                //   //   FieldFind = find_model_field;
                //   // }
                //   if (FieldFind.length > 0) {
                //     if (FieldFind[0].is_removed == true || FieldFind[0].is_removed == "true") {
                //       ext_newFormDataFelds = ext_newFormDataFelds.filter(ele => ele['element_uuid'] != FieldFind[0]['element_uuid']);
                //     }
                //     // ganesh changed this line FieldFind.length > 0 && FieldFind.is_removed != true && FieldFind.is_removed != "true"
                //     // added line FieldFind.length > 0 && FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true" for this if condition
                //     if (FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true") {
                //       if (FieldFind[0].element_type == 'single_choice' || FieldFind[0].element_type == 'dropdown') {
                //         this.cdRef.detectChanges();
                //         FieldFind[0].element_data.options.forEach(element1 => {
                //           element1.default = false
                //         });
                //         var defaultOptionValue:any;
                //         if(element.element_data.hasOwnProperty('options'))
                //             {
                //                defaultOptionValue = element.element_data.options.filter((ele => ele.default == true))
                //             }
                //         if (defaultOptionValue!=undefined && defaultOptionValue.length > 0) {
                //           var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == defaultOptionValue[0].element_uuid))
                //           currentOption[0].default = true;
                //         }
                //       } else if (FieldFind[0].element_type == 'multiple_choice' || FieldFind[0].element_type == 'checkbox') {

                //         FieldFind[0].element_data.options.forEach(element1 => {
                //           element1.default = false
                //         });
                //         var UCitemDefault:any;
                //         if(element.element_data.hasOwnProperty('options'))
                //          {
                //              UCitemDefault = element.element_data.options.filter((ele => ele.default == true))
                //          }
                //          if(UCitemDefault!=undefined){
                //           UCitemDefault.forEach(element2 => {
                //             var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == element2.element_uuid))
                //             currentOption[0].default = true;
                //           });
                //         }
                //       }
                //       else if (FieldFind[0].element_type == 'date') {
                //         if (element.element_data.default_date_time != "" && element.element_data.default_date_time != "none" && element.element_data.default_date_time != "current" && element.element_data.default_date_time != undefined) {
                //           //  FieldFind[0].element_data.default_value = new Date(element.element_data.default_date_time).toISOString();
                //           FieldFind[0].element_data.default_date_time = new Date(element.element_data.default_date_time).toISOString();
                //         }
                //         else if (element.element_data.default_date_time != "") {
                //           if (element.element_data.default_date_time == "current") {
                //             FieldFind[0].element_data.default_date_time = element.element_data.default_date_time
                //           }
                //           else if (element.element_data.default_date_time == "none" || element.element_data.default_date_time == "") {
                //             FieldFind[0].element_data.default_date_time = element.element_data.default_date_time;
                //           }
                //         }
                //       }
                //       else if (FieldFind[0].element_type == 'uti-entry-field') {
                //         FieldFind[0].element_data.default_values = element.element_data['default_values']
                //       }
                //       else if (FieldFind[0].element_type == 'uti-entry-field-WMATA') {
                //         FieldFind[0].element_data.default_values = element.element_data['default_values']
                //       }
                //       else if (FieldFind[0].element_type == 'uti-entry-field-TIMBER') {
                //         FieldFind[0].element_data.default_values = element.element_data['default_values']
                //       }
                //       else if (FieldFind[0].element_type == 'address') {

                //         FieldFind[0].element_data.street_address1 = element.element_data.street_address1
                //         FieldFind[0].element_data.city = element.element_data["city"]
                //         FieldFind[0].element_data.state = element.element_data["state"]
                //         FieldFind[0].element_data.zip = element.element_data["zip"]
                //         FieldFind[0].element_data.street_address2 = element.element_data.street_address2
                //       } else {
                //         FieldFind[0].element_data.default_value = element.element_data.default_value
                //       }
                //     }
                //   }
                // })
                let clone_extend_model_fields = this.extend_modelFieldsForm;
                let find_number_field = clone_extend_model_fields.filter((number_fi) => number_fi.element_type == 'number');
                console.log(find_number_field);
              
                ext_newFormDataFelds = this.merge_form_process(clone_extend_model_fields, ext_newFormDataFelds, 'rightside');
                editedForm[0].ext_form_data = ext_newFormDataFelds;
                if(weldPresent == true){
                  let weldFormIndex =  ext_newFormDataFelds.findIndex((id) => id.element_type == "uti-entry-field-WMATA_WELD");
                  if(weldFormIndex == -1){
                    ext_newFormDataFelds.push(weldformdata);
                  }
                }
                let getforms = editedForm[0].ext_form_data;
                if (getforms != undefined && getforms.length > 0) {
                  //start converting
                  let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
                  editedForm[0].ext_form_data = change_character_res;
                }
                this.extend_modelFieldsForm = editedForm[0].ext_form_data
                this.extend_modelFieldsForm = this.extend_modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
              } else {
                this.extend_modelFieldsForm = [];
              }
            }
            //after assigning the chnges new form data add to the current form
            editedForm[0].form_data = newFormDataFelds
            //ganesh added this logic
            // if (newFormDataFelds != null && newFormDataFelds.length > 0) {
            //   let remove_items_filter = newFormDataFelds.filter((r_data) => {
            //     if (this.createDocumentStore.data_allow_condition.includes(r_data.is_removed)) {
            //       return true;
            //     }
            //     else {
            //       return false;
            //     }
            //   })
            //   console.log(remove_items_filter);
            // }
            var formfieldIndex = singleDataReceived.annotation_forms.findIndex((ele => ele.form_id == this.currentFormId))
            if(formfieldIndex != -1){
              singleDataReceived.annotation_forms.splice(formfieldIndex, 1, editedForm[0]);  
            }
            // let generateCloneLayer = _.cloneDeep(this.layerDatas);
            // this.documentService.annotationUpdateForm1(generateCloneLayer, this.getId, this.activeLayerIdDraw).subscribe((response) => {
            //   console.log(response);
            // });

            let getforms = editedForm[0].form_data;
            if (getforms != undefined && getforms.length > 0) {
              //start converting
              let change_character_res = this.dataService4.formfieldviewcharacter(getforms, 'annotationformfieldsview');
              editedForm[0].form_data = change_character_res;
            }
            editedForm[0].form_data = editedForm[0].form_data == null ? [] : editedForm[0].form_data;
            this.modelFieldsForm = editedForm[0].form_data
            this.modelFieldsForm = this.modelFieldsForm.filter((formdata) => formdata.is_removed != true && formdata.is_removed != "true")
            if (this.is_extend == true) {
              let merge_forms = [...this.modelFieldsForm, ...this.extend_modelFieldsForm];
              //taking the current form copy for  undoing and redoing
              this.undoDatataForForms = _.cloneDeep(merge_forms)
              //taking the current form copy for use condition
              this.usecaseCopyArray = _.cloneDeep(merge_forms);
            }
            else {
              //taking the current form copy for  undoing and redoing
              this.undoDatataForForms = _.cloneDeep(this.modelFieldsForm)
              //taking the current form copy for use condition
              this.usecaseCopyArray = _.cloneDeep(this.modelFieldsForm);
            }
            //function call for use condition
            this.process_use_conditions();
            //function call for calculation
            this.FormulaCalc();
            var weldform = false;
            //default data setting by clickin the annotation for forms
            if (this.modelFieldsForm.length > 0) {
              for (let v = 0; v < this.modelFieldsForm.length; v++) {
                // if it is a html form  need to set the out put array
                if (this.modelFieldsForm[v].element_type == "uti-entry-field") {
                  this.outputArray = []
                  this.finalArray1 = []
                  var fff = this.modelFieldsForm[v].element_data["fields"];
                  for (let k = 0; k < this.modelFieldsForm[v].element_data['fields'].length; k++) {
                    //making the calculation array for displaying the  output array field
                    if (this.modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                      for (let j = 0; j < this.modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                        this.outputArray.push({ 'id': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                      }
                    }
                  }
                  this.elementFields = this.modelFieldsForm[v].element_data['fields']

                  //if the pay load containg a default values in the html form retriving and assigning for calculation
                  if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                    if (this.modelFieldsForm[v].element_data['default_values'] != "" && this.modelFieldsForm[v].element_data['default_values'] != undefined) {
                      this.finalArray = this.modelFieldsForm[v].element_data['default_values']
                      this.displayArryChange(this.modelFieldsForm[v].element_data['fields'], this.modelFieldsForm[v].element_data['default_values'])
                    }
                  }
                }
                else if (this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA") {
                  // make default values array of json

                  if (this.modelFieldsForm[v].element_data.hasOwnProperty('default_values') && this.modelFieldsForm[v].element_data.default_values != undefined && this.modelFieldsForm[v].element_data.default_values != "") {
                    let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                    let get_element_fields = this.modelFieldsForm[v].element_data['fields'];
                    this.UTIEntry_field_Wmata(get_element_fields, get_default_value);
                  }
                  else {
                    // if default values is empty purpose
                    this.finalArray2 = [];
                  }
                }
                else if (this.modelFieldsForm[v].element_type == "uti-entry-field-TIMBER") {
                  // make default values array of json
                  this.createDocumentStore.custom_form_datas = this.modelFieldsForm;
                }
                else if(this.modelFieldsForm[v].element_type == "uti-entry-field-WMATA_WELD"){
                  weldform = true;
                  const copyweldform =_.cloneDeep(this.modelFieldsForm[v]);
                  this.copyweldForm = copyweldform;
                  let get_default_value = this.modelFieldsForm[v].element_data.default_values;
                    const fields = this.modelFieldsForm[v].element_data.fields;
                    this.fieldsWeld = fields; 
                    let weldArray = this.convertUUIDtoNormal(get_default_value);
                    this.splitarray(weldArray);
               }
                //retriving the value from Total elemnat quantity and checking for calculation
                if (this.modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                  this.totalElementQuantity = Number(this.modelFieldsForm[v].element_data.default_value);
                  this.htmlcalculation();
                }
                //according to the form builder value date is assigning to the  annotation forms
                if (this.modelFieldsForm[v].element_type == "date") {
                  if (this.modelFieldsForm[v].element_data.default_date_time != "") {
                    if (this.modelFieldsForm[v].element_data.default_date_time == ""||this.modelFieldsForm[v].element_data.default_date_time == "none" || this.modelFieldsForm[v].element_data.default_date_time == "current") {
                      this.modelFieldsForm[v].element_data.default_value = this.assignDates(this.modelFieldsForm[v].element_data.default_date_time)
                    } else {
                      this.modelFieldsForm[v].element_data.default_value = new Date(this.modelFieldsForm[v].element_data.default_date_time).toISOString();
                    }
                  }
                }
              }
              // sorting formdatas based on the element order
              let tempcopyforms = this.modelFieldsForm;
              this.modelFieldsForm = tempcopyforms.sort((a, b) => (a.element_order > b.element_order) ? 1 : -1);
              console.log(this.modelFieldsForm);
            }
            //default data setting by clickin the annotation for forms
            if (this.extend_modelFieldsForm != null) {
              if (this.extend_modelFieldsForm.length > 0) {
                for (let v = 0; v < this.extend_modelFieldsForm.length; v++) {
                  // if it is a html form  need to set the out put array
                  if (this.extend_modelFieldsForm[v].element_type == "uti-entry-field") {
                    this.outputArray = []
                    this.finalArray1 = []
                    var fff = this.extend_modelFieldsForm[v].element_data["fields"];
                    for (let k = 0; k < this.extend_modelFieldsForm[v].element_data['fields'].length; k++) {
                      //making the calculation array for displaying the  output array field
                      if (this.extend_modelFieldsForm[v].element_data['fields'][k].element_type == "single_choice") {
                        for (let j = 0; j < this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options.length; j++) {
                          this.outputArray.push({ 'id': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].element_uuid, 'key': this.extend_modelFieldsForm[v].element_data['fields'][k].element_data.options[j].name, 'value': 0 })
                        }
                      }
                    }
                    this.elementFields = this.extend_modelFieldsForm[v].element_data['fields']
                    //if the pay load containg a default values in the html form retriving and assigning for calculation

                    if (this.extend_modelFieldsForm[v].element_data.hasOwnProperty('default_values')) {
                      if (this.extend_modelFieldsForm[v].element_data['default_values'] != "" && this.extend_modelFieldsForm[v].element_data['default_values'] != undefined) {
                        this.finalArray = this.extend_modelFieldsForm[v].element_data['default_values']
                        this.displayArryChange(this.extend_modelFieldsForm[v].element_data['fields'], this.extend_modelFieldsForm[v].element_data['default_values'])
                      }
                    }
                  }
                  //retriving the value from Total elemnat quantity and checking for calculation
                  if (this.extend_modelFieldsForm[v].element_data.label_text == "Total Element Quantity") {
                    this.totalElementQuantity = Number(this.extend_modelFieldsForm[v].element_data.default_value);
                    this.htmlcalculation();
                  }
                  console.log(this.outputArray);
                  //according to the form builder value date is assigning to the  annotation forms
                  if (this.extend_modelFieldsForm[v].element_type == "date") {
                    if (this.extend_modelFieldsForm[v].element_data.default_date_time != "") {
                      if (this.extend_modelFieldsForm[v].element_data.default_date_time == ""||this.extend_modelFieldsForm[v].element_data.default_date_time == "none" || this.extend_modelFieldsForm[v].element_data.default_date_time == "current") {
                        //  this.extend_modelFieldsForm[v].element_data.default_date_time = this.assignDates(this.extend_modelFieldsForm[v].element_data.default_date_time)
                      } else {
                        this.extend_modelFieldsForm[v].element_data.default_date_time = new Date(this.extend_modelFieldsForm[v].element_data.default_date_time).toISOString();
                      }
                    }
                  }
                  else if (this.modelFieldsForm[v].element_type == "uti-entry-field-TIMBER") {
                    // make default values array of json
                    this.createDocumentStore.custom_form_datas = this.extend_modelFieldsForm;
                  }
                }
                if(weldform == true){
                  let copyextendform = _.cloneDeep(this.extend_modelFieldsForm);
                  let index = copyextendform.findIndex((type) => type.element_type == "uti-entry-field-WMATA_WELD");
                  if (index == -1) {
                    this.extend_modelFieldsForm.push(this.copyweldForm);
                  }
                }
                // sorting formdatas based on the element order
                let tempcopyforms = this.extend_modelFieldsForm;
                this.extend_modelFieldsForm = tempcopyforms.sort((a, b) => (a.element_order > b.element_order) ? 1 : -1);
                console.log(this.extend_modelFieldsForm);
              }
            }
            this.currentFormName = editedForm[0].form_name
            this.currentFormName = this.dataService4.changeSpecialtoKeyFormat(this.currentFormName);
          }
        }
        else {
          // empty forms logic
          this.modelFieldsForm = [];
          this.extend_modelFieldsForm = [];
        }

        //Jose Comment the below else condition
        // }
        // else if (singleDataReceived.annotation_forms.length == 0) {
        //   this.currentFormName = "";
        // }
        if (this.annotationstring == undefined) {
          this.annotationstring = this.propertiesannotationData.annotation_data

        }
        this.formCount = singleDataReceived.annotation_forms.length;
        console.log(this.formCount, singleDataReceived.annotation_forms);
        //this.mediaCount = singleDataReceived.annotation_media.length;
        //media count function for count and filter the media links 
        this.globalMediaCount(singleDataReceived.annotation_media, 'media')
        this.globalMediaCount(singleDataReceived.annotation_links, 'links')
        //this.linkCount = singleDataReceived.annotation_links.length;
        if (singleDataReceived.annotation_tags.toString() != "") {
          let tempAnnotationtags = singleDataReceived.annotation_tags.toString();
          this.tagCount = tempAnnotationtags.split(",").length;
          console.log(this.tagCount);
        }
        else if (singleDataReceived.annotation_tags.toString() == "") {
          this.tagCount = 0;
        }
        this.annotNameAnnotation = this.propertiesannotationData["annotation_name"];
        this.propertiesannotationDataString = this.propertiesannotationData["annotation_data"];
        this.annotLabelAnnotation = this.propertiesannotationData["annotation_label"];
        this.degree = singleDataReceived.initial_rotation;
        this.opacityValue = this.propertiesannotationData["opacity"];
        this.backupOpacity = _.cloneDeep(this.propertiesannotationData["opacity"]);
        this.annotShapeAnnotation = this.ShapeNameGet(this.propertiesannotationData["toolbar_element_id"]);
        this.lineWidth = Number(this.propertiesannotationData["Line_width"]).toFixed(2);
        this.backupLinewidth = _.cloneDeep(this.propertiesannotationData["line_width"]);
        let elementId = parseInt(this.propertiesannotationData["toolbar_element_id"]);
        if (elementId < 12) {
          let x = parseFloat(this.propertiesannotationData["initial_position_x"]);
          let lessBoxWidth = x - 119;
          this.optionPositionX = lessBoxWidth;
          console.log(lessBoxWidth);
          let y = parseFloat(this.propertiesannotationData["initial_position_y"]);
          let lessBoxHeight = y - 52;
          this.optionPositionY = lessBoxHeight;
          console.log(lessBoxHeight);
        }
        else if (elementId > 11) {
          let x = parseFloat(this.propertiesannotationData["initial_position_x"]);
          let lessBoxWidth: any = x - 119;
          let addWidth = lessBoxWidth + widthC / 2;
          this.optionPositionX = addWidth;
          this.optionPositionY = parseFloat(this.propertiesannotationData["initial_position_y"]);
          let y = parseFloat(this.propertiesannotationData["initial_position_y"]);
          let lessBoxHeight = y - 42;
          this.optionPositionY = lessBoxHeight;
        }
        // initial height for area
        this.initialHeight = this.propertiesannotationData["initial_height"];
        if (this.initialHeight == "" || this.initialWidth == 0) {
          this.initialHeight = 50;
        }
        //initial width for length
        this.initialWidth = this.propertiesannotationData["initial_width"];
        if (this.initialWidth == "" || this.initialWidth == 0) {
          this.initialWidth = 50;
        }
        var checkActiveorNot = 0;
        if (this.getScaleValue != undefined && this.getScaleValue.length > 0) {
          for (var i = 0; i < this.getScaleValue.length; i++) {
            if (
              this.currentPageId == this.getScaleValue[i].page_id
            ) {
              this.initialWidth =
                (this.getScaleValue[i].scaleValue * 10) /
                this.initialWidth;
              this.initialHeight =
                (this.getScaleValue[i].scaleValue * 10) /
                this.initialHeight;
              this.areaValue = this.checkShapes(
                this.propertiesannotationData["toolbar_element_id"],
                this.initialWidth,
                this.initialHeight
              );
              this.areaValue = parseInt(this.areaValue);
              checkActiveorNot = 1;
            }
          }
        }
        if (checkActiveorNot != 1) {
          this.initialHeight = this.propertiesannotationData[
            "initial_height"
          ];
          if (this.initialHeight == "" || this.initialWidth == 0) {
            this.initialHeight = 50;
          }
          //initial width for length
          this.initialWidth = this.propertiesannotationData[
            "initial_width"
          ];
          if (this.initialWidth == "" || this.initialWidth == 0) {
            this.initialWidth = 50;
          }
          this.areaValue = this.checkShapes(
            this.propertiesannotationData["toolbar_element_id"],
            this.initialWidth,
            this.initialHeight
          );
          this.areaValue = parseInt(this.areaValue);
        }
        if (this.media == true) {
          this.mediaIconClick();
        }
        else if (this.links == true) {
          this.linkIconClick();
        }
        else if (this.tags == true) {
          this.tagIconClick();
        }
        else if (this.properties == true) {
          this.propertyIconClick();
        }

      }
    }
    this.updateduserid = (annotationData.updated_by_user_id);
    this.createduserid = (annotationData.created_by_user_id);
    this.userdetail = this.encrptdecrpt.getItem("userdetail")
    this.list = this.userdetail;
    this.list2 = this.userdetail;
    this.list2 = this.list2.filter(ele => ele.user_id == this.createduserid)
    console.log(this.createduserid, this.updateduserid)
    if (this.list2.length != 0) {
      console.log(this.list2)

      this.firstname = this.list2[0].first_name
      this.lastname = this.list2[0].last_name
    }
    this.list = this.list.filter(ele => ele.user_id == this.updateduserid)
    if (this.list.length != 0) {
      console.log(this.list)

      this.firstname1 = this.list[0].first_name
      this.lastname1 = this.list[0].last_name
    }
    else {
      this.firstname1 = this.firstname
      this.lastname1 = this.lastname
    }
    if(this.multipleSelectOn == false){
      this.checkAlign_usecase();
    }
    
  }

  textShapeDrawing(inputData, event) {
    let receiveText = inputData.textname;
    let staticValue = "move-0:10 line-20:10 line-20:5 controlpoint-20:0 curveEnd-25:0 line-44:0 controlpoint-49:0 curveEnd-49:5 line-49:15 controlpoint-49:20 curveEnd-44:20 line-25:20 controlpoint-20:20 curveEnd-20:15 line-20:10";
    let get_width_height = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id: 11, annotation_data: staticValue });
    var getText = receiveText;
    let textheight = 16;
    getText = getText.replaceAll(" ", "`~");
    getText = getText.replaceAll("-", "~`");
    getText = getText.replaceAll(":", "~~~");
    let canvas12 = document.createElement("canvas");
    canvas12.style.width = "200px";
    let context = canvas12.getContext("2d");
    context.font = "13px Roboto";
    let measure_text = receiveText;
    let breaktexts = receiveText.split('\n');
    if (breaktexts.length > 1) {
      let check_text_count = 0;
      for (let c = 0; c < breaktexts.length; c++) {
        if (check_text_count < breaktexts[c].length) {
          check_text_count = breaktexts[c].length;
          measure_text = breaktexts[c];
        }
      }
    }
    context.fillText(measure_text, 0, 0);
    let widthget = context.measureText(measure_text).width;
    // let width_custom_element = this.measureWidth(measure_text,"times new roman");
    // let formattedWidth_input = inputData.widthHeight.width;
    let formattedWidth = Math.round(widthget);
    let numberOfLineBreaks = (receiveText.match(/\n/g) || []).length;
    if (numberOfLineBreaks > 0) {
      numberOfLineBreaks = numberOfLineBreaks + 1;
      textheight = numberOfLineBreaks * 15;
    }
    formattedWidth = formattedWidth + 25;
    formattedWidth = formattedWidth < 28 ? 28 : formattedWidth;
    textheight = textheight + 5;
    canvas12.innerHTML = receiveText;
    // canvas12.style.fontWeight = "500";
    // canvas12.style.fontSize = "13px";
    var textWidth = formattedWidth;
    let total_height = textheight;
    let widthCount = formattedWidth;
    "move-0:\(total_height/2) line-20:\(total_height/2) line-20:5 controlpoint-20:0 curveEnd-25:0 line-\(widthCount!-5):0 controlpoint-\(widthCount!):0 curveEnd-\(widthCount!):5 line-\(widthCount!):\(total_height-5) controlpoint-\(widthCount!):\(total_height) curveEnd-\(widthCount!-5):\(total_height) line-25:\(total_height) controlpoint-20:\(total_height) curveEnd-20:\(total_height-5) line-20:\(total_height/2) text-Text"
    // let currentAnnotationData = "move-0:10 line-20:10 line-20:5 controlpoint-20:0 curveEnd-25:0 line-" + Number(textWidth) + ":0 controlpoint-" + Number(textWidth + 5) + ":0 curveEnd-" + Number(textWidth + 5) + ":5 line-" + Number(textWidth + 5) + ":15 controlpoint-" + Number(textWidth + 5) + ":20 curveEnd-" + Number(textWidth) + ":20 line-25:20 controlpoint-20:20 curveEnd-20:15 line-20:10 text-" + getText + "";
    let currentAnnotationData = "move-0:" + (total_height / 2) + " line-20:" + (total_height / 2) + " line-20:5 controlpoint-20:0 curveEnd-25:0 line-" + Number(textWidth - 5) + ":0 controlpoint-" + Number(textWidth) + ":0 curveEnd-" + Number(textWidth) + ":5 line-" + Number(textWidth) + ":" + (total_height - 5) + " controlpoint-" + Number(textWidth) + ":" + (total_height) + " curveEnd-" + Number(textWidth - 5) + ":" + (total_height) + " line-25:" + (total_height) + " controlpoint-20:" + (total_height) + " curveEnd-20:" + (total_height - 5) + " line-20:" + (total_height / 2) + " text-" + getText + "";
    let widththerom = "move-0:10 line-20:10 line-20:5 controlpoint-20:0 curveEnd-25:0 line-" + Number(textWidth) + ":0 controlpoint-" + Number(textWidth + 5) + ":0 curveEnd-" + Number(textWidth + 5) + ":5 line-" + Number(textWidth + 5) + ":15 controlpoint-" + Number(textWidth + 5) + ":20 curveEnd-" + Number(textWidth) + ":20 line-25:20 controlpoint-20:20 curveEnd-20:15 line-20:10";
    this.receiveString = currentAnnotationData;
    this.generateAnnotation(event, receiveText);
  }


  textShapeDrawingLabelChanging(labelvalue: any) {
    let receiveText = labelvalue;
    // receiveText = this.dataService4.changeFormat(receiveText);
    let staticValue = "move-0:10 line-20:10 line-20:5 controlpoint-20:0 curveEnd-25:0 line-44:0 controlpoint-49:0 curveEnd-49:5 line-49:15 controlpoint-49:20 curveEnd-44:20 line-25:20 controlpoint-20:20 curveEnd-20:15 line-20:10";
    var getText = receiveText;
    let textheight = 16;
    getText = getText.replaceAll(" ", "`~");
    getText = getText.replaceAll("-", "~`");
    getText = getText.replaceAll(":", "~~~");
    let canvas12 = document.createElement("canvas");
    canvas12.style.width = "200px";
    let context = canvas12.getContext("2d");
    context.font = "14px times new roman";
    context.fillText(receiveText, 0, 0);
    let widthget = context.measureText(receiveText).width;
    let createElement_text = document.getElementById('dummytext_doc');
    createElement_text.innerHTML = receiveText.trim();
    let element_bounding_wh = createElement_text.getBoundingClientRect();
    let formattedWidth = element_bounding_wh.width;
    console.log('width context', widthget, 'elementwidth', element_bounding_wh);
    let numberOfLineBreaks = (receiveText.match(/\n/g) || []).length;
    if (numberOfLineBreaks > 0) {
      numberOfLineBreaks = numberOfLineBreaks + 1;
      textheight = numberOfLineBreaks * 16;
    }
    formattedWidth = formattedWidth + 25;
    formattedWidth = formattedWidth < 28 ? 28 : formattedWidth;
    textheight = textheight + 5;
    canvas12.innerHTML = receiveText;
    canvas12.style.fontWeight = "500";
    canvas12.style.fontSize = "14px";
    var textWidth = formattedWidth;
    let total_height = textheight;
    let widthCount = formattedWidth;
    console.log(formattedWidth, textheight, textWidth, total_height);

    "move-0:\(total_height/2) line-20:\(total_height/2) line-20:5 controlpoint-20:0 curveEnd-25:0 line-\(widthCount!-5):0 controlpoint-\(widthCount!):0 curveEnd-\(widthCount!):5 line-\(widthCount!):\(total_height-5) controlpoint-\(widthCount!):\(total_height) curveEnd-\(widthCount!-5):\(total_height) line-25:\(total_height) controlpoint-20:\(total_height) curveEnd-20:\(total_height-5) line-20:\(total_height/2) text-Text"

    // let currentAnnotationData = "move-0:10 line-20:10 line-20:5 controlpoint-20:0 curveEnd-25:0 line-" + Number(textWidth) + ":0 controlpoint-" + Number(textWidth + 5) + ":0 curveEnd-" + Number(textWidth + 5) + ":5 line-" + Number(textWidth + 5) + ":15 controlpoint-" + Number(textWidth + 5) + ":20 curveEnd-" + Number(textWidth) + ":20 line-25:20 controlpoint-20:20 curveEnd-20:15 line-20:10 text-" + getText + "";
    let currentAnnotationData = "move-0:" + (total_height / 2) + " line-20:" + (total_height / 2) + " line-20:5 controlpoint-20:0 curveEnd-25:0 line-" + Number(textWidth - 5) + ":0 controlpoint-" + Number(textWidth) + ":0 curveEnd-" + Number(textWidth) + ":5 line-" + Number(textWidth) + ":" + (total_height - 5) + " controlpoint-" + Number(textWidth) + ":" + (total_height) + " curveEnd-" + Number(textWidth - 5) + ":" + (total_height) + " line-25:" + (total_height) + " controlpoint-20:" + (total_height) + " curveEnd-20:" + (total_height - 5) + " line-20:" + (total_height / 2) + " text-" + getText + "";
    this.receiveString = currentAnnotationData;
    // createElement_text.style.display = "none";
    return currentAnnotationData;
  }

  // changeShapeStringForBaseicon(shapeString:string, changeWidth:Number, changeHeight:Number){
  //   let changedString = ""
  //     //move-0:10 line-20:10 line-20:10 line-20:10 line-20:10
  //     let splitSpace = shapeString.split(" ");
  //     for(let i = 0; i<splitSpace.length ; i++){
  //       let splitString : any = splitSpace[i]
  //       splitString = splitString.replaceAll('--', '-n');
  //       splitString = splitString.replaceAll(':-', ':n');
  //       let hypenSplit = splitString.split("-");
  //       if(hypenSplit.length>2){
  //         let localString1 = hypenSplit[1]+'-'+hypenSplit[2];
  //         hypenSplit = [hypenSplit[0],localString1];
  //       }
  //       console.log("hypenSplit",hypenSplit)
  //       let cordinates = hypenSplit[1].replaceAll('n', '-').split(":");
  //       let posX=Number(cordinates[0])+Number(changeWidth)
  //       let posY=Number(cordinates[1])+Number(changeHeight)
  //       let shapeSring = hypenSplit[0]+"-"+posX+":"+posY
  //       console.log("shapeSring",shapeSring)
  //       changedString = changedString != "" ? changedString + " " + shapeSring : shapeSring
  //     }
  //   return changedString
  // }

  changeShapeForWidthAndHeight(strShape: string, widthToChange: number, heightToChange: number, toolbar_element_id: number) {
    
    var getshapedimensions = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id, annotation_data: strShape })
    // if(widthToChange <= 20 || heightToChange <= 20){
    //   widthToChange = 35;
    //   heightToChange = 35;
    // }
    // widthToChange = widthToChange <= 20 ? 50 : widthToChange;
    // heightToChange = heightToChange <= 20 ? 50 : heightToChange;
    var widthDifference = widthToChange / (getshapedimensions.width)
    var heightDifference = heightToChange / (getshapedimensions.height)
    var scaleFactorValue = widthDifference > heightDifference ? heightDifference : widthDifference

    var xDiff = 0;
    var yDiff = 0;
    if (toolbar_element_id < 11) {
      let commonValue = widthToChange > heightToChange ? heightToChange : widthToChange
      widthDifference = commonValue / (getshapedimensions.width)
      heightDifference = commonValue / (getshapedimensions.height)
      scaleFactorValue = widthDifference > heightDifference ? heightDifference : widthDifference
    } else if (toolbar_element_id != 100) {

      xDiff = ((getshapedimensions.left * scaleFactorValue) - getshapedimensions.left)
      yDiff = ((getshapedimensions.top * scaleFactorValue) - getshapedimensions.top)

      //Jose Added -- Previous code before resize fix for normal shape

      // xDiff = xDiff + (xDiff/4)//((widthToChange - getshapedimensions.width)/2)
      // yDiff = yDiff + (yDiff/4)//((heightToChange - getshapedimensions.height)/2)

      ////////

      xDiff = xDiff + ((widthToChange - getshapedimensions.width) / 2)
      yDiff = yDiff + ((heightToChange - getshapedimensions.height) / 2)
    }
    let finalString = "";
    let splitData: any = strShape.split(" ");
    for (var i = 0; i < splitData.length; i++) {
      var splitString = splitData[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      let hypenSplit = splitString.split("-");
      if (hypenSplit.length > 2) {
        let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
        hypenSplit = [hypenSplit[0], localString1];
      }
      if (hypenSplit != '') {
        let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
        colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
        colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));

        if (hypenSplit[0] != "text" && (toolbar_element_id == 19 || toolbar_element_id == 20) && (strShape.includes("ovalIn-") || strShape.includes("drawRect-"))) {
          colonSplit[2] = this.shapeService1.scientificToDecimal(Number(colonSplit[2]));
          colonSplit[3] = this.shapeService1.scientificToDecimal(Number(colonSplit[3]));

          let widthDiff = widthToChange - getshapedimensions.width
          let heightDiff = heightToChange - getshapedimensions.height
          colonSplit[0] = colonSplit[0] - (widthDiff / 2)
          colonSplit[1] = colonSplit[1] - (heightDiff / 2)
          colonSplit[2] = colonSplit[2] + (widthDiff)
          colonSplit[3] = colonSplit[3] + (heightDiff)

          let localstring = hypenSplit[0] + "-" + colonSplit[0] + ":" + colonSplit[1] + ":" + colonSplit[2] + ":" + colonSplit[3]
          finalString = finalString != "" ? finalString + " " + localstring : localstring
        } else if (hypenSplit[0] != "text") {
          // if ((toolbar_element_id == 19 || toolbar_element_id == 20) && (strShape.includes("line-") || strShape.includes("controlpoint"))) {
          //   colonSplit[0] = (colonSplit[0] * scaleFactorValue) - (xDiff)// + (xDiff/4)
          //   colonSplit[1] = (colonSplit[1] * scaleFactorValue) - (yDiff)//+ (xDiff/4)
          // }else{
          colonSplit[0] = (colonSplit[0] * scaleFactorValue) - xDiff
          colonSplit[1] = (colonSplit[1] * scaleFactorValue) - yDiff
          // }


          let localstring = hypenSplit[0] + "-" + colonSplit[0] + ":" + colonSplit[1]
          finalString = finalString != "" ? finalString + " " + localstring : localstring
        } else if (hypenSplit[0] == "text") {
          finalString = finalString != "" ? finalString + " " + hypenSplit.join("-") : hypenSplit.join("-")
        }
      }
    }
    console.log("shape for base icon", finalString)

    let value = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id, annotation_data: finalString })
    console.log("old", getshapedimensions, "new ", value, (widthToChange - getshapedimensions.width))
    // if(finalString.includes(" text-")){
    //   let string_remove_text = finalString.split("text-")[0]
    //   let string_include_text = 

    // }

    return finalString
  }

  changeShapePositionsInsideCanvas(strShape: string, toolbar_element_id: number, oldShapeDimentions: any) {
    
    var getshapedimensions = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id, annotation_data: strShape })
    var xDiff = getshapedimensions.left
    var yDiff = getshapedimensions.top
    let finalString = ""
    let splitData: any = strShape.split(" ");
    for (var i = 0; i < splitData.length; i++) {
      var splitString = splitData[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      let hypenSplit = splitString.split("-");
      if (hypenSplit.length > 2) {
        let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
        hypenSplit = [hypenSplit[0], localString1];
      }
      if (hypenSplit != '' && hypenSplit[0] != "text") {
        let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
        colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
        colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));

        colonSplit[0] = colonSplit[0] - xDiff
        colonSplit[1] = colonSplit[1] - yDiff

        let localstring = hypenSplit[0] + "-" + colonSplit[0] + ":" + colonSplit[1]
        finalString = finalString != "" ? finalString + " " + localstring : localstring
      } else if (hypenSplit != '' && hypenSplit[0] == "text") {
        finalString = finalString != "" ? finalString + " " + hypenSplit.join("-") : hypenSplit.join("-")
      }
    }
    console.log("shape for base icon", finalString)

    let value = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id, annotation_data: finalString })
    console.log("old", getshapedimensions, "new ", value)
    let xDiff_final = getshapedimensions.left > 0 ? getshapedimensions.left - (value.width / 2) : (oldShapeDimentions.width - value.width) / 2
    let yDiff_final = getshapedimensions.top > 0 ? getshapedimensions.top - (value.height / 2) : (oldShapeDimentions.height - value.height) / 2
    return { annotationData: finalString, left: xDiff_final, top: yDiff_final, width: value.width, height: value.height,X:xDiff,Y:yDiff}
  }



  changeShapeStringForBaseicon(elementId: number, changeWidth: number, changeHeight: number, shapeString: string) {
    return this.changeShapeForWidthAndHeight(shapeString, changeWidth, changeHeight, elementId);
  }

  generateAnnotation(event, textValue?: any) {
    let get_mousedown_element = null;
    if (this.pngFormat == true) {
      get_mousedown_element = document.getElementById('pdfImg');
    }
    else {
      get_mousedown_element = document.getElementById('pdfannotationhead');
    }
    // if (get_mousedown_element != null) {
    //   const rect = get_mousedown_element.getBoundingClientRect();
    //   let initialX = event.clientX;
    //   let initialY = event.clientY;
    //   let clickPosition = {
    //     x: initialX - rect.left,
    //     y: initialY - rect.top,
    //   };
    //   let local_scale = this.pngFormat ? this.scale : this.pdfScaleValue > 1 ? this.pdfScaleValue : this.scale;

    //   if (this.pngFormat != true) {
    //     this.coordinateX = clickPosition.x / local_scale;
    //     this.coordinateY = clickPosition.y / local_scale;
    //   }
    //   else {
    //     this.coordinateX = event.offsetX;
    //     this.coordinateY = event.offsetY;
    //   }
    // }

    // getElement Position of custome shapes plotting
    let local_scale = 1;
    if (this.pngFormat == true) {
      // no need of scaling image formats so will assign 1 value 10/1 = 10 same value;
      local_scale = 1;
    }
    else {
      // scaling only need zoom level of above 1
      local_scale = this.pdfScaleValue >= 1 ? this.pdfScaleValue : 1;
    }
    // scaling calculation divide the click x and y position

    this.coordinateX = event.offsetX;
    this.coordinateY = event.offsetY;
    var getdate = new Date();
    var annontationidDate = new Date().getTime();
    var strokeValue = this.currentSelectedItems.element_data.stroke_color;
    var fillColor = this.currentSelectedItems.element_data.fill_color;
    let labelValue = "";
    if (this.toolbarElementId == 11) {
      fillColor = '#FFFFFF';
      labelValue = textValue;
    }
    //Set Base Icon Height and Width values handled area start
    var setBaseIconHeightChanges = 0;
    var setBaseIconWidthChanges = 0;
    let resize_mode_value = 0;
    //Set Base Icon Height and Width values handled area end 
    var uuid = this.su.user_id + "-" + uuidv1().toUpperCase() + "-" + annontationidDate;
    var MyDateString = new Date().toISOString();
    if (this.toolbarElementId < 11) {
      setBaseIconHeightChanges = this.seticonheight == 0 ? setBaseIconHeightChanges : this.seticonheight;
      setBaseIconWidthChanges = this.seticonwidth == 0 ? setBaseIconWidthChanges : this.seticonwidth;
      console.log(setBaseIconHeightChanges,setBaseIconWidthChanges);
      if ((setBaseIconWidthChanges > 0 || setBaseIconHeightChanges > 0)) {
        let current_string = JSON.parse(JSON.stringify(this.receiveString));
        let annotationData = this.changeShapeStringForBaseicon(100, setBaseIconWidthChanges, setBaseIconHeightChanges, current_string);
        let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id: this.toolbarElementId, annotation_data: annotationData });
        let changed_shape_data = this.changeShapePositionsInsideCanvas(annotationData, 100, getShapeStringWidth)
        this.receiveString = changed_shape_data.annotationData;
        console.log(this.receiveString)
        resize_mode_value = 17.5;
      }
    }
    console.log(this.coordinateX - (setBaseIconWidthChanges / 2), this.coordinateY - (setBaseIconHeightChanges / 2))
    this.createJson = {
      annotation_data: this.receiveString,
      annotation_forms: this.selectAnnotationForms,
      annotation_id: uuid,
      annotation_label: labelValue,
      annotation_links: [],
      annotation_media: [],
      annotation_name: this.annotationName,
      annotation_stubs: [],
      annotation_tags: "",
      annotation_url: "",
      created_by_user_id: this.su.user_id,
      created_date: MyDateString,
      document_id: this.folderId,
      element_size: 1,
      fill_color: fillColor,
      initial_height: setBaseIconHeightChanges,
      initial_position_x: this.coordinateX - (setBaseIconWidthChanges / 2) + resize_mode_value,
      initial_position_y: this.coordinateY - (setBaseIconHeightChanges / 2) + resize_mode_value,
      initial_width: setBaseIconWidthChanges,
      initial_rotation: 0,
      is_removed: false,
      last_updated_date: MyDateString,
      layer_id: this.activeLayerIdDraw,
      line_width: this.currentSelectedItems.element_data.line_width,
      opacity: this.currentSelectedItems.element_data.opacity,
      original_property: "",
      page_id: this.currentPageId,
      project_id: this.projectId,
      stroke_color: strokeValue,
      toolbar_element_id: this.toolbarElementId,
      updated_by_user_id: this.su.user_id,
      version_number: 1,
      text_font_size: "13",
    };
    console.log(this.selectAnnotationForms);
    if (this.currentSelectedItems.element_data.hasOwnProperty('shape')) {
      let enableDataCopyMode = this.currentSelectedItems.element_data.shape.is_stamp;
      if (enableDataCopyMode == '0' || enableDataCopyMode == 0) {

        if (this.currentSelectedItems.element_data.forms_list_data == undefined) {
          this.createJson.annotation_forms = [];
        }
        else if (this.currentSelectedItems.element_data.forms_list_data != undefined) {
          this.createJson.annotation_forms = this.currentSelectedItems.element_data.forms_list_data;
        }
        if (Number(this.toolbarElementId) != 11) {
          this.createJson.annotation_label = this.currentSelectedItems.element_data.shape.annotation_label;
        }
        this.createJson.annotation_links = this.currentSelectedItems.element_data.shape.annotation_links;
        this.createJson.annotation_media = this.currentSelectedItems.element_data.shape.annotation_media;
        this.createJson.annotation_tags = this.currentSelectedItems.element_data.shape.annotation_tags;
        this.createJson.fill_color = this.currentSelectedItems.element_data.fill_color;
        this.createJson.line_width = this.currentSelectedItems.element_data.line_width;
        this.createJson.opacity = this.currentSelectedItems.element_data.opacity;
        this.createJson.stroke_color = this.currentSelectedItems.element_data.stroke_color;
      }
    }
    var annotationUndoData = [];
    annotationUndoData.push(_.cloneDeep(this.createJson));
    annotationUndoData[0].is_removed = true;
    this.udoArrayChange(annotationUndoData[0]);
    console.log(this.createJson);
    this.annotationUpdate();
  }

  updatelastmodified(item) {
    item.last_modified_date = new Date().toISOString();
  }

  deleteAnnotationRemove(currentLayerData, id) {
    console.log(currentLayerData, this.deleteannotationId)
    if (this.deleteannotationId != undefined) {
      this.getId = this.deleteannotationId
    } else {
      this.getId = id
    }
    console.log(this.getId)
    if (this.getId == '' && this.multipleSelectOn == false) {

    }
    let getElementDelete = document.getElementById(this.getId);
    console.log(getElementDelete)
    let lebelElement = document.getElementById('label' + this.getId);
    console.log(lebelElement)

    let itemindex = this.search_displayannotation.findIndex(item => item.annotation_id == this.getId);
    console.log(itemindex)
    this.search_displayannotation.splice(itemindex, 1);
    this.dataService.search_annotation.emit(this.getId);
    if (getElementDelete != null) {
      getElementDelete.remove();
      if (lebelElement != null) {
        lebelElement.remove();
      }

      this.layerDatas = currentLayerData;
      this.getId = "";

      this.previousSelectAnnotation = [];

      if (this.layerEnable == true) {
        let page_data = this.documentDetails.filter((document_page) => document_page.page_id === this.currentPageId)
        let data = { layerDatas: this.layerDatas, checkedAnnotationIdsBackup: this.checkedAnnotationIdsBackup, currentPageId: this.currentPageId, selection_type: this.multipleSelectOn, page_data: page_data, scaleFactor: this.scaleFactor };
        console.log(data);

        this.dataService2.layerDatafromnavigation.emit(data);
      }
    }
  }

  resizeFunctionHit() {
    this.resizeMoveBackUp = _.cloneDeep(this.propertiesannotationData);
    console.log(this.propertiesannotationData);
    this.resizebutton = true;
    console.log(this.createDocumentStore.enableresizeButtons);
    this.createDocumentStore.enableresizeButtons = true;
    this.createDocumentStore_1.resize_per_input = null;
    this.rotateresizeButtonHandles('resize');
  }
  //input field should accept only numbers excluding alphabet 'e'
  number() {
    let inputBox = document.getElementById("inputBox");

    let invalidChars = [
      "-",
      "+",
      "e",
      "E",
    ];

    inputBox.addEventListener("keydown", function (e) {
      if (invalidChars.includes(e.key)) {
        e.preventDefault();
      }
    });
  }

  //postal code should accept only numbers excluding alphabet 'e'
  numberpostal() {
    let inputBox = document.getElementById("inputBoxpostal");

    let invalidChars = [
      "-",
      "+",
      "e",
      "E",
    ];

    inputBox.addEventListener("keydown", function (e) {
      if (invalidChars.includes(e.key)) {
        e.preventDefault();
      }
    });
  }

  sizedecrease() {
    console.log(this.moveAnnotationsStore);
    if(this.moveAnnotationsStore.length!=0){
      this.propertiesannotationData = this.moveAnnotationsStore[0];
    }
    this.resizedone=false
    if (this.multipleSelectOn == false) {
      let getElementRemove = document.getElementById(this.propertiesannotationData["annotation_id"]);
      let getlabelRemove = document.getElementById('label' + this.propertiesannotationData["annotation_id"]);
      let currentelementWidth = getElementRemove.getBoundingClientRect();
      console.log(currentelementWidth);
      let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      // very first time ipad resize annotation width and height same that changewidth and changeheight. so it is changing width and height
      // add one more time +5 then increase the shape width and height what we expect in first time. 
      let width_adjust = getShapeStringWidth.width;
      let height_adjust = getShapeStringWidth.height;
      if (width_adjust != Number(this.propertiesannotationData["initial_width"]) && height_adjust != Number(this.propertiesannotationData["initial_height"])) {
        if (Number(this.propertiesannotationData["initial_width"]) != 0 && Number(this.propertiesannotationData["initial_height"]) != 0) {
          // width_adjust = width_adjust + 5;
          // height_adjust = height_adjust + 5;
          //Comment blelow and uncomment above code if resize not working -- Jose
          if(width_adjust < height_adjust){
            width_adjust = (width_adjust * (height_adjust+5)) / height_adjust;
            height_adjust = height_adjust + 5;
          }else{
            height_adjust = (height_adjust * (width_adjust+5)) / width_adjust;
            width_adjust = width_adjust + 5;
          }
          // height_adjust = (height_adjust * (width_adjust+5)) / width_adjust;
          // width_adjust = width_adjust + 5;
          
          if (width_adjust == Number(this.propertiesannotationData["initial_width"]) && height_adjust == Number(this.propertiesannotationData["initial_height"])) {
            getShapeStringWidth.width = width_adjust;
            getShapeStringWidth.height = height_adjust;
          }
        }
      }
      let changeWidth = 0
      let changeHeight = 0
      if(getShapeStringWidth.width < getShapeStringWidth.height){
        changeHeight = getShapeStringWidth.height - 2.5;
        changeWidth = (getShapeStringWidth.width * changeHeight) / getShapeStringWidth.height;
      }else{
        changeWidth = getShapeStringWidth.width - 2.5;
        changeHeight = (getShapeStringWidth.height * changeWidth) / getShapeStringWidth.width;
      }

      // let changeWidth = getShapeStringWidth.width - 2.5;
      // let changeHeight = (getShapeStringWidth.height * changeWidth) / getShapeStringWidth.width;
      //Comment above and uncomment below code if resize not working -- Jose
      // let changeHeight = getShapeStringWidth.height - 2.5;
      // text annotation height or width 7px below resize restrict
      if (this.propertiesannotationData["toolbar_element_id"] == 11 && (changeWidth < 5 || changeHeight < 5)) {
        return
      }
      else if (changeWidth < 5 && changeHeight < 5) {
        return;
      }
      else if ((this.propertiesannotationData["toolbar_element_id"] > 11 && this.propertiesannotationData["toolbar_element_id"] != 15 && this.propertiesannotationData["toolbar_element_id"] != 16)
        && (changeWidth < 5 || changeHeight < 5)) {
        return;
      }
      let changeelementId = Number(this.propertiesannotationData["toolbar_element_id"]) > 10 ? Number(this.propertiesannotationData["toolbar_element_id"]) : 100//this.propertiesannotationData["toolbar_element_id"];
      let annotationData = this.propertiesannotationData["annotation_data"];

      if (this.propertiesannotationData.toolbar_element_id == 15 || this.propertiesannotationData.toolbar_element_id == 16) {
        console.log(annotationData)
        let splitData: any = annotationData.split(" ");
        let moveX = 0
        let moveY = 0
        let lineX = 0
        let lineY = 0;
        let height_add = 0, width_add = 0;
        for (var i = 0; i < splitData.length; i++) {
          var splitString = splitData[i].replaceAll('--', '-n');
          splitString = splitString.replaceAll(':-', ':n');
          let hypenSplit = splitString.split("-");
          if (hypenSplit.length > 2) {
            let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
            hypenSplit = [hypenSplit[0], localString1];
          }
          if (hypenSplit != '') {
            let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
            colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
            colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));

            if (hypenSplit[0] == "line") {
              lineX = colonSplit[0]
              lineY = colonSplit[1]
            } else {
              moveX = colonSplit[0]
              moveY = colonSplit[1]
            }

            // if(getShapeStringWidth.height<getShapeStringWidth.width){
            //   //sleeping line
            //   let local_value = hypenSplit[0] == "line" ? colonSplit[0] + difference_value : colonSplit[0] - difference_value
            //   if(colonSplit[0] < this.realWidth && colonSplit[0] > 0){
            //     colonSplit[0] = local_value
            //   }else{
            //     escape = true
            //   }
            // }else{
            //   //standing line
            //   let local_value = hypenSplit[0] == "line" ? colonSplit[1] + difference_value : colonSplit[1] - difference_value
            //   if(colonSplit[1] < this.realHeight && colonSplit[1] > 0){
            //     colonSplit[1] = local_value
            //   }else{
            //     escape = true
            //   }
            // }

            // let localstring = hypenSplit[0] + "-" + colonSplit[0] + ":" + colonSplit[1]
            // finalString = finalString != "" ? finalString + " " + localstring : localstring
          }
        }

        // After rotate and resize line get mismatch commended. ramkumar
        // if (moveY > lineY) {
        //   let tempY = moveY
        //   moveY = lineY
        //   lineY = tempY
        // }
        // if (moveX > lineX) {
        //   let tempX = moveX
        //   moveX = lineX
        //   lineX = tempX
        // }
        let moveXdiff = (moveX - lineX) < 0 ? -(moveX - lineX) : (moveX - lineX)
        let moveYdiff = (moveY - lineY) < 0 ? -(moveY - lineY) : (moveY - lineY)
        let default_percentage = -2;
        let percentage_divide_value_w = (getShapeStringWidth.width / 100) * default_percentage;
        let percentage_divide_value_h = (getShapeStringWidth.height / 100) * default_percentage;
        // if (getShapeStringWidth.width < 10) {
        //   moveY = (moveY - 2.5)
        //   lineY = (lineY + 2.5)
        // } else if (getShapeStringWidth.height < 10) {
        //   moveX = (moveX - 2.5)
        //   lineX = (lineX + 2.5)
        // } else if (moveXdiff < 50) {
        //   moveY = (moveY - 2.5)
        //   lineY = (lineY + 2.5)
        // } else if (moveYdiff < 50) {
        //   moveX = (moveX - 2.5)
        //   lineX = (lineX + 2.5)
        // } else {
        //   if (moveX < lineX) {
        //     moveX = moveX - 2.5
        //     lineX = lineX + 2.5
        //   } else if (moveX > lineX) {
        //     moveX = moveX + 2.5
        //     lineX = lineX - 2.5
        //   }
        //   if (moveY < lineY) {
        //     moveY = moveY - 2.5
        //     lineY = lineY + 2.5
        //   } else if (moveY > lineY) {
        //     moveY = moveY + 2.5
        //     lineY = lineY - 2.5
        //   }
        // }
        moveX = moveX - percentage_divide_value_w;
        lineX = lineX + percentage_divide_value_w;
        moveY = (moveY - percentage_divide_value_h);
        lineY = (lineY + percentage_divide_value_h);
        if (false) {
          if (getShapeStringWidth.width)
            if (getShapeStringWidth.width < 10) {
              moveY = (moveY + 2.5)
              lineY = (lineY - 2.5)
            } else if (getShapeStringWidth.height < 10) {
              moveX = (moveX + 2.5)
              lineX = (lineX - 2.5)
            } else if (moveXdiff < 50) {
              moveY = (moveY + 2.5)
              lineY = (lineY - 2.5)
              // annotationData = "move-"+moveX+":"+(moveY-2.5)+" line-"+lineX+":"+(lineY+2.5)
            } else if (moveYdiff < 50) {
              moveX = (moveX + 2.5)
              lineX = (lineX - 2.5)
              // annotationData = "move-"+(moveX-2.5)+":"+moveY+" line-"+(lineX+2.5)+":"+lineY
            } else {
              if (moveX < lineX) {
                moveX = moveX + 2.5
                lineX = lineX - 2.5
              } else if (moveX > lineX) {
                moveX = moveX - 2.5
                lineX = lineX + 2.5
              }
              if (moveY < lineY) {
                moveY = moveY + 2.5
                lineY = lineY - 2.5
              } else if (moveY > lineY) {
                moveY = moveY - 2.5
                lineY = lineY + 2.5
              }
            }
        }

        annotationData = "move-" + moveX + ":" + moveY + " line-" + lineX + ":" + lineY
        this.propertiesannotationData["annotation_data"] = annotationData;
        this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]);
        this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]);
        // if (getlabelRemove != null) {
        //   getlabelRemove.remove();
        // }
        // getElementRemove.remove();
        // this.getshapeDrawing(this.propertiesannotationData, false);
        this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
      }
      else {
        if ((this.propertiesannotationData.toolbar_element_id == 19 || this.propertiesannotationData.toolbar_element_id == 20) && (this.propertiesannotationData.annotation_data.includes("line-") || this.propertiesannotationData.annotation_data.includes("controlpoint"))) {
          // changeWidth = getShapeStringWidth.width - 5;
          // changeHeight = getShapeStringWidth.height - 5;
        }

        annotationData = this.changeShapeStringForBaseicon(changeelementId, changeWidth, changeHeight, annotationData)
        let getShapeStringWidthAB = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
        if (getShapeStringWidthAB.width > 5 || getShapeStringWidthAB.height > 5) {
          // if (getShapeStringWidthAB.width > 36 || getShapeStringWidthAB.height > 36) {
          //   // this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 12 ? this.propertiesannotationData["initial_position_x"] : this.dbxposition 
          //   // this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 12 ? this.propertiesannotationData["initial_position_y"] : this.dbyposition 
          //   this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 12 ? 0 : getShapeStringWidthAB.width;
          //   this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 12 ? 0 : getShapeStringWidthAB.height;
          // } else {
          //   this.propertiesannotationData["initial_width"] = 0
          //   this.propertiesannotationData["initial_height"] = 0
          // }
          if (Number(this.propertiesannotationData["toolbar_element_id"]) <= 11) {
            // let getresizeShapeString = this.shapeService1.resizeFunctionNew(data, false);
            // annotationData = getresizeShapeString.shapeString

            // this.propertiesannotationData["initial_position_x"] = getresizeShapeString.initialX-(2.5/2)
            // this.propertiesannotationData["initial_position_y"] = getresizeShapeString.initialY-(2.5/2)
            // annotationData = this.propertiesannotationData["annotation_data"]
            // // if((Number(this.propertiesannotationData["initial_width"]) == 0 || Number(this.propertiesannotationData["initial_width"]) > 35) && (Number(this.propertiesannotationData["initial_height"]) == 0 || Number(this.propertiesannotationData["initial_height"]) > 35)){
            //   this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_position_x"])+(2.5) : Number(this.propertiesannotationData["initial_position_x"])
            //   this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_position_y"])+(2.5) : Number(this.propertiesannotationData["initial_position_y"])
            //   this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_width"]) - 5 : 0
            //   this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_height"]) - 5 : 0
            annotationData = this.changeShapeStringForBaseicon(changeelementId, changeWidth, changeHeight, annotationData)
            let data = _.cloneDeep(this.propertiesannotationData)
            data.annotation_data = annotationData
            let changed_shape_data = this.changeShapePositionsInsideCanvas(annotationData, changeelementId, getShapeStringWidth)
            annotationData = changed_shape_data.annotationData
            // ganesh changed the x and y value already resize shape having position mismatch
            if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11) {
              this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + ((getShapeStringWidth.width - changed_shape_data.width) / 2);
              this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + ((getShapeStringWidth.height - changed_shape_data.height) / 2);
            } else {
              if(this.propertiesannotationData["initial_width"] == 0 && this.propertiesannotationData["initial_height"]==0){
                // 1.5 + 3.5 + 1.5 addition initial time adjustments happening so it is added initial time don't remove the value
                this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + 8.5;
                this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + 8.5;  
              }
              else{
                this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + 1.5;
                this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + 1.5;
              }
            }

            this.propertiesannotationData["initial_width"] = changed_shape_data.width//Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_width"]) + 5 : 35
            this.propertiesannotationData["initial_height"] = changed_shape_data.height//Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_height"]) + 5 : 35
            // }

          } else {
            let data = _.cloneDeep(this.propertiesannotationData)
            data.annotation_data = annotationData
            let correctedShapeWidth = this.shapeService1.getCanvaswidthandHeight(data);
            this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 11 ? 0 : correctedShapeWidth.width;
            this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 11 ? 0 : correctedShapeWidth.height;
            // if(Number(this.propertiesannotationData["toolbar_element_id"]) < 11){

            //   let getresizeShapeString = this.shapeService1.resizeFunctionNew(data, false);
            //   annotationData = getresizeShapeString.shapeString
            //   this.propertiesannotationData["initial_position_x"] = getresizeShapeString.initialX
            //   this.propertiesannotationData["initial_position_y"] = getresizeShapeString.initialY
            // }
          }
          this.propertiesannotationData["annotation_data"] = annotationData;

          let getnew_one = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
          console.log('data resize ', annotationData, getnew_one);
          // add original property 
          if (this.propertiesannotationData["toolbar_element_id"] > 10) {
            if (typeof this.propertiesannotationData["original_property"] == 'object') {
              this.propertiesannotationData["original_property"].annotation_data = this.propertiesannotationData["annotation_data"];
            }
          }
          this.dbxposition = Number(this.propertiesannotationData["initial_position_x"])
          this.dbyposition = Number(this.propertiesannotationData["initial_position_y"])
          this.coordinateX = Number(this.propertiesannotationData["initial_position_x"])
          this.coordinateY = Number(this.propertiesannotationData["initial_position_y"])
          // if (getlabelRemove != null) {
          //   getlabelRemove.remove();
          // }
          // getElementRemove.remove();
          // if (this.createDocumentStore.view_annotation_array.length > 0) {
          //   let findIndex = this.createDocumentStore.view_annotation_array.findIndex((delete1) => delete1.annotation_id == this.propertiesannotationData["annotation_id"]);
          //   if (findIndex > -1) {
          //     this.createDocumentStore.view_annotation_array.splice(findIndex,1);
          //   }
          // }
          // this.getshapeDrawing(this.propertiesannotationData, false);
          // this.getActiveLayerId()
          this.replacecurrentChangeInSVG(this.propertiesannotationData, true);
          console.log('size decrease', this.propertiesannotationData);
        }
      }
    }
  }
  

  sizeincreaseSVG() {
    this.sizeincreaseChangeStringSVG();

    let get_current_width_height = this.getCanvaswidthandHeight(this.propertiesannotationData);
    let getElementRemove = document.getElementById(this.propertiesannotationData["annotation_id"]);
    let get_current_width = get_current_width_height.width;
    let get_current_height = get_current_width_height.height;
    let get_element_Width = Number(getElementRemove.getAttribute('width')) + 5;
    let get_element_Height = Number(getElementRemove.getAttribute('height')) + 5;
    let width_difference = get_element_Width - get_current_width;
    let height_difference = get_element_Height - get_current_height;
    width_difference = width_difference < 0 ? -(width_difference) : width_difference;
    height_difference = height_difference < 0 ? -(height_difference) : height_difference;
    getElementRemove.setAttribute('width', get_element_Width.toString());
    getElementRemove.setAttribute('height', get_element_Height.toString());
    getElementRemove.style.transition = "all .2s linear";
    let getStyle_element_top = getElementRemove.style.top;
    getStyle_element_top = getStyle_element_top.substring(getStyle_element_top.length - 2, 0);
    let getStyle_element_left = getElementRemove.style.left;
    getStyle_element_left = getStyle_element_left.substring(getStyle_element_left.length - 2, 0);
    getElementRemove.style.left = Number(getStyle_element_left) - (width_difference / 2) + 'px';
    getElementRemove.style.top = Number(getStyle_element_top) - (height_difference / 2) + 'px';
    // this.propertiesannotationData["initial_position_x"] = Number(getStyle_element_left) - (width_difference/2) + 17.5;
    // this.propertiesannotationData["initial_position_y"] = Number(getStyle_element_top) - (height_difference/2) + 17.5;
    this.resizeactionpending = true;

  }

  sizedecreaseSVG() {
    let getElementRemove = document.getElementById(this.propertiesannotationData["annotation_id"]);
    let get_current_width = Number(getElementRemove.getAttribute('width'));
    let get_current_height = Number(getElementRemove.getAttribute('height'));
    let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
    console.log(getShapeStringWidth);
    get_current_width = get_current_width - 2.5;
    get_current_height = get_current_height - 2.5;
    getElementRemove.setAttribute('width', get_current_width.toString());
    getElementRemove.setAttribute('height', get_current_height.toString());
    getElementRemove.style.transition = "all .2s linear";
    let getStyle_element_top = getElementRemove.style.top;
    getStyle_element_top = getStyle_element_top.substring(getStyle_element_top.length - 2, 0);
    let getStyle_element_left = getElementRemove.style.left;
    getStyle_element_left = getStyle_element_left.substring(getStyle_element_left.length - 2, 0);
    getElementRemove.style.left = Number(getStyle_element_left) + 1.25 + 'px';
    getElementRemove.style.top = Number(getStyle_element_top) + 1.25 + 'px';
    this.resizeactionpending = true;
    this.sizedecreaseChangeStringSVG();

  }

  async sizeincreaseChangeStringSVG() {
    if (this.multipleSelectOn == false) {
      let backupproperytData = _.cloneDeep(this.propertiesannotationData)
      console.log(_.cloneDeep(this.propertiesannotationData));
      let getElementRemove = document.getElementById(this.propertiesannotationData["annotation_id"]);
      // let currentelementWidth = getElementRemove.getBoundingClientRect();
      // console.log(currentelementWidth);
      let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      let changeWidth = getShapeStringWidth.width + 5;
      let changeHeight = getShapeStringWidth.height + 5;
      let changeelementId = Number(this.propertiesannotationData["toolbar_element_id"]) > 10 ? Number(this.propertiesannotationData["toolbar_element_id"]) : 100//this.propertiesannotationData["toolbar_element_id"];
      let annotationData = this.propertiesannotationData["annotation_data"];
      let getShapeStringWidthAB = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      if (this.propertiesannotationData.toolbar_element_id == 15 || this.propertiesannotationData.toolbar_element_id == 16) {
        let escape = false;
        let difference_value = 2.5;
        let finalString = "";
        let splitData: any = annotationData.split(" ");
        let moveX = 0;
        let moveY = 0;
        let lineX = 0;
        let lineY = 0;

        for (var i = 0; i < splitData.length; i++) {
          var splitString = splitData[i].replaceAll('--', '-n');
          splitString = splitString.replaceAll(':-', ':n');
          let hypenSplit = splitString.split("-");
          if (hypenSplit.length > 2) {
            let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
            hypenSplit = [hypenSplit[0], localString1];
          }
          if (hypenSplit != '') {
            let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
            colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
            colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));

            if (hypenSplit[0] == "line") {
              lineX = colonSplit[0];
              lineY = colonSplit[1];
            } else {
              moveX = colonSplit[0];
              moveY = colonSplit[1];
            }

          }
        }
        if (moveY > lineY) {
          let tempY = moveY
          moveY = lineY
          lineY = tempY
        }
        if (moveX > lineX) {
          let tempX = moveX
          moveX = lineX
          lineX = tempX
        }
        let moveXdiff = (moveX - lineX) < 0 ? -(moveX - lineX) : (moveX - lineX)
        let moveYdiff = (moveY - lineY) < 0 ? -(moveY - lineY) : (moveY - lineY)
        if (getShapeStringWidth.width < 10) {
          moveY = (moveY - 2.5)
          lineY = (lineY + 2.5)
        } else if (getShapeStringWidth.height < 10) {
          moveX = (moveX - 2.5)
          lineX = (lineX + 2.5)
        } else if (moveXdiff < 50 && moveXdiff != getShapeStringWidth.width) {
          moveY = (moveY - 2.5)
          lineY = (lineY + 2.5)
        } else if (moveYdiff < 50 && moveYdiff != getShapeStringWidth.height) {
          moveX = (moveX - 2.5)
          lineX = (lineX + 2.5)
        } else {
          if (moveX < lineX) {
            moveX = moveX - 2.5
            lineX = lineX + 2.5
          } else if (moveX > lineX) {
            moveX = moveX + 2.5
            lineX = lineX - 2.5
          }
          if (moveY < lineY) {
            moveY = moveY - 2.5
            lineY = lineY + 2.5
          } else if (moveY > lineY) {
            moveY = moveY + 2.5
            lineY = lineY - 2.5
          }
        }
        annotationData = "move-" + moveX + ":" + moveY + " line-" + lineX + ":" + lineY
      }
      // else if(this.propertiesannotationData.toolbar_element_id == 11){
      //   
      //   let correctedShapeWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      //   if (Number(this.propertiesannotationData["initial_width"]) != 0 && Number(this.propertiesannotationData["initial_height"] != 0)){
      //     this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["initial_width"]) + 10
      //     this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["initial_height"]) + 5
      //   }else{
      //     this.propertiesannotationData["initial_width"] = correctedShapeWidth.width + 10
      //     this.propertiesannotationData["initial_height"] = correctedShapeWidth.height + 5
      //   }

      //   this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"])-5
      //   this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"])-2.5
      // }
      else {

        if (Number(this.propertiesannotationData["toolbar_element_id"]) <= 11) {
          // let getresizeShapeString = this.shapeService1.resizeFunctionNew(data, false);
          // annotationData = getresizeShapeString.shapeString

          // this.propertiesannotationData["initial_position_x"] = getresizeShapeString.initialX-(2.5/2)
          // this.propertiesannotationData["initial_position_y"] = getresizeShapeString.initialY-(2.5/2)
          // annotationData = this.propertiesannotationData["annotation_data"]
          // this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_position_x"]) - (2.5) : Number(this.propertiesannotationData["initial_position_x"])
          // this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_position_y"]) - (2.5) : Number(this.propertiesannotationData["initial_position_y"])
          // this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_width"]) + 5 : 35
          // this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_height"]) + 5 : 35

          annotationData = this.changeShapeStringForBaseicon(changeelementId, changeWidth, changeHeight, annotationData)
          let data = _.cloneDeep(this.propertiesannotationData)
          data.annotation_data = annotationData;
          let changed_shape_data = this.changeShapePositionsInsideCanvas(annotationData, changeelementId, getShapeStringWidth)
          annotationData = changed_shape_data.annotationData

          // this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + changed_shape_data.left
          // this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + changed_shape_data.top
          // resize shape position mismatch issue solved below x and y changes
          if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11 && this.propertiesannotationData["initial_width"] == 0 && this.propertiesannotationData["initial_height"] == 0) {
            this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + (getElementRemove.offsetLeft - Number(this.propertiesannotationData["initial_position_x"])) + ((getElementRemove.clientWidth - changed_shape_data.width)) + 2.5;
            this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + (getElementRemove.offsetTop - Number(this.propertiesannotationData["initial_position_y"])) + ((getElementRemove.clientHeight - changed_shape_data.height)) + 2.5;
          } else if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11) {
            this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + changed_shape_data.left;
            this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + changed_shape_data.top;
          } else if (this.propertiesannotationData["initial_width"] == 0 && this.propertiesannotationData["initial_height"] == 0) {
            this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + ((getElementRemove.clientWidth - changed_shape_data.width) / 2) //- 2.5;
            this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + ((getElementRemove.clientHeight - changed_shape_data.height) / 2) //- 2.5;
          } else {
            this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) - 2.5;
            this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) - 2.5;
          }

          this.propertiesannotationData["initial_width"] = changed_shape_data.width//Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_width"]) + 5 : 35
          this.propertiesannotationData["initial_height"] = changed_shape_data.height//Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_height"]) + 5 : 35

        } else {
          annotationData = this.changeShapeStringForBaseicon(changeelementId, changeWidth, changeHeight, annotationData)
          let data = _.cloneDeep(this.propertiesannotationData)
          data.annotation_data = annotationData
          let correctedShapeWidth = this.shapeService1.getCanvaswidthandHeight(data);
          // if (correctedShapeWidth.width > 36 || correctedShapeWidth.height > 36) {
          // this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 12 ? this.propertiesannotationData["initial_position_y"] : this.dbyposition-2.5
          this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 11 ? 0 : correctedShapeWidth.width;
          this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 11 ? 0 : correctedShapeWidth.height;
        }
        // }
      }
      this.propertiesannotationData["annotation_data"] = annotationData;
      console.log("this.propertiesannotationData", this.propertiesannotationData["initial_position_x"], this.propertiesannotationData["initial_position_y"])
      console.log("this.dbxposition", this.dbxposition, this.dbyposition)
      let verifyXY = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      if ((getElementRemove.offsetLeft - 5) <= 0 || (getElementRemove.offsetTop - 5) <= 0 || (getElementRemove.offsetLeft + getElementRemove.offsetWidth + 5) >= this.realWidth || (getElementRemove.offsetTop + getElementRemove.offsetHeight + 5) >= this.realHeight) {
        this.propertiesannotationData = backupproperytData
      }
      // this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]) + (2.5 / 2)
      // this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]) + (2.5 / 2)
      // this.coordinateX = Number(this.propertiesannotationData["initial_position_x"]) + (2.5 / 2)
      // this.coordinateY = Number(this.propertiesannotationData["initial_position_y"]) + (2.5 / 2)
      // getElementRemove.remove();
      // this.isforResize = true
      // this.getActiveLayerId()
      // this.isforResize = false

      // await this.replacecurrentChangeInSVG(this.propertiesannotationData);
      console.log('size increase', this.propertiesannotationData)
    }
  }

  async sizedecreaseChangeStringSVG() {
    if (this.multipleSelectOn == false) {
      let getElementRemove = document.getElementById(this.propertiesannotationData["annotation_id"]);
      // let getlabelRemove = document.getElementById('label' + this.propertiesannotationData["annotation_id"]);
      // let currentelementWidth = getElementRemove.getBoundingClientRect();
      // console.log(currentelementWidth);
      let getShapeStringWidth = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
      let changeWidth = getShapeStringWidth.width - 2.5;
      let changeHeight = getShapeStringWidth.height - 2.5;
      let changeelementId = Number(this.propertiesannotationData["toolbar_element_id"]) > 10 ? Number(this.propertiesannotationData["toolbar_element_id"]) : 100//this.propertiesannotationData["toolbar_element_id"];
      let annotationData = this.propertiesannotationData["annotation_data"];

      if (this.propertiesannotationData.toolbar_element_id == 15 || this.propertiesannotationData.toolbar_element_id == 16) {
        console.log(annotationData)
        let escape = false;
        let difference_value = 2.5;
        let finalString = "";
        let splitData: any = annotationData.split(" ");
        let moveX = 0;
        let moveY = 0;
        let lineX = 0;
        let lineY = 0;
        for (var i = 0; i < splitData.length; i++) {
          var splitString = splitData[i].replaceAll('--', '-n');
          splitString = splitString.replaceAll(':-', ':n');
          let hypenSplit = splitString.split("-");
          if (hypenSplit.length > 2) {
            let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
            hypenSplit = [hypenSplit[0], localString1];
          }
          if (hypenSplit != '') {
            let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
            colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
            colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));

            if (hypenSplit[0] == "line") {
              lineX = colonSplit[0]
              lineY = colonSplit[1]
            } else {
              moveX = colonSplit[0]
              moveY = colonSplit[1]
            }
          }
        }
        if (moveY > lineY) {
          let tempY = moveY
          moveY = lineY
          lineY = tempY
        }
        if (moveX > lineX) {
          let tempX = moveX
          moveX = lineX
          lineX = tempX
        }
        let moveXdiff = (moveX - lineX) < 0 ? -(moveX - lineX) : (moveX - lineX)
        let moveYdiff = (moveY - lineY) < 0 ? -(moveY - lineY) : (moveY - lineY)
        if (getShapeStringWidth.width < 10) {
          moveY = (moveY + 2.5)
          lineY = (lineY - 2.5)
        } else if (getShapeStringWidth.height < 10) {
          moveX = (moveX + 2.5)
          lineX = (lineX - 2.5)
        } else if (moveXdiff < 50) {
          moveY = (moveY + 2.5)
          lineY = (lineY - 2.5)
          // annotationData = "move-"+moveX+":"+(moveY-2.5)+" line-"+lineX+":"+(lineY+2.5)
        } else if (moveYdiff < 50) {
          moveY = (moveY + 2.5)
          lineY = (lineY - 2.5)
          // annotationData = "move-"+(moveX-2.5)+":"+moveY+" line-"+(lineX+2.5)+":"+lineY
        } else {
          if (moveX < lineX) {
            moveX = moveX + 2.5
            lineX = lineX - 2.5
          } else if (moveX > lineX) {
            moveX = moveX - 2.5
            lineX = lineX + 2.5
          }
          if (moveY < lineY) {
            moveY = moveY + 2.5
            lineY = lineY - 2.5
          } else if (moveY > lineY) {
            moveY = moveY - 2.5
            lineY = lineY + 2.5
          }
        }
        annotationData = "move-" + moveX + ":" + moveY + " line-" + lineX + ":" + lineY
        this.propertiesannotationData["annotation_data"] = annotationData;
        this.dbxposition = Number(this.propertiesannotationData["initial_position_x"]);
        this.dbyposition = Number(this.propertiesannotationData["initial_position_y"]);
        // if (getlabelRemove != null) {
        //   getlabelRemove.remove();
        // }
        // getElementRemove.remove();
        this.getshapeDrawing(this.propertiesannotationData, false);
      } else {
        if ((this.propertiesannotationData.toolbar_element_id == 19 || this.propertiesannotationData.toolbar_element_id == 20) && (this.propertiesannotationData.annotation_data.includes("line-") || this.propertiesannotationData.annotation_data.includes("controlpoint"))) {
          // changeWidth = getShapeStringWidth.width - 5;
          // changeHeight = getShapeStringWidth.height - 5;
        }

        annotationData = this.changeShapeStringForBaseicon(changeelementId, changeWidth, changeHeight, annotationData)
        let getShapeStringWidthAB = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
        if (getShapeStringWidthAB.width > 15 || getShapeStringWidthAB.height > 15) {
          if (Number(this.propertiesannotationData["toolbar_element_id"]) <= 11) {
            annotationData = this.changeShapeStringForBaseicon(changeelementId, changeWidth, changeHeight, annotationData)
            let data = _.cloneDeep(this.propertiesannotationData)
            data.annotation_data = annotationData
            let changed_shape_data = this.changeShapePositionsInsideCanvas(annotationData, changeelementId, getShapeStringWidth)
            annotationData = changed_shape_data.annotationData
            // ganesh changed the x and y value already resize shape having position mismatch
            if (Number(this.propertiesannotationData["toolbar_element_id"]) == 11) {
              this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + ((getShapeStringWidth.width - changed_shape_data.width) / 2);
              this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + ((getShapeStringWidth.height - changed_shape_data.height) / 2);
            } else {
              this.propertiesannotationData["initial_position_x"] = Number(this.propertiesannotationData["initial_position_x"]) + 1.25;
              this.propertiesannotationData["initial_position_y"] = Number(this.propertiesannotationData["initial_position_y"]) + 1.25;
            }

            this.propertiesannotationData["initial_width"] = changed_shape_data.width//Number(this.propertiesannotationData["initial_width"]) > 0 ? Number(this.propertiesannotationData["initial_width"]) + 5 : 35
            this.propertiesannotationData["initial_height"] = changed_shape_data.height//Number(this.propertiesannotationData["initial_height"]) > 0 ? Number(this.propertiesannotationData["initial_height"]) + 5 : 35
            // }
          } else {
            let data = _.cloneDeep(this.propertiesannotationData)
            data.annotation_data = annotationData
            let correctedShapeWidth = this.shapeService1.getCanvaswidthandHeight(data);
            this.propertiesannotationData["initial_width"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 11 ? 0 : correctedShapeWidth.width;
            this.propertiesannotationData["initial_height"] = Number(this.propertiesannotationData["toolbar_element_id"]) > 11 ? 0 : correctedShapeWidth.height;
            // if(Number(this.propertiesannotationData["toolbar_element_id"]) < 11){

            //   let getresizeShapeString = this.shapeService1.resizeFunctionNew(data, false);
            //   annotationData = getresizeShapeString.shapeString
            //   this.propertiesannotationData["initial_position_x"] = getresizeShapeString.initialX
            //   this.propertiesannotationData["initial_position_y"] = getresizeShapeString.initialY
            // }
          }
          this.propertiesannotationData["annotation_data"] = annotationData;

          // let getnew_one = this.shapeService1.getCanvaswidthandHeight(this.propertiesannotationData);
          // console.log('data resize ', annotationData, getnew_one);
          // this.dbxposition = Number(this.propertiesannotationData["initial_position_x"])
          // this.dbyposition = Number(this.propertiesannotationData["initial_position_y"])
          // this.coordinateX = Number(this.propertiesannotationData["initial_position_x"])
          // this.coordinateY = Number(this.propertiesannotationData["initial_position_y"])
          // if (getlabelRemove != null) {
          //   getlabelRemove.remove();
          // }
          // getElementRemove.remove();
          // this.getshapeDrawing(this.propertiesannotationData, false);
          // this.isforResize = true;
          // this.getActiveLayerId();
          // this.isforResize = false;
          // console.log('size decrease',this.propertiesannotationData)
        }
      }
    }
  }

  lineToAngle(x1, y1, width, height, angle) {
    angle *= Math.PI / 180;
    var x2 = x1 + width * Math.cos(angle), y2 = y1 + height * Math.sin(angle);
    return { x: x2, y: y2 };
  }

  repointStringForRectandElipse(strShape, toolbar_element_id, initial_position_x, initial_position_y) {
    var getshapedimensions = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id, annotation_data: strShape })

    let finalString = ""
    let splitData: any = strShape.split(" ");
    for (var i = 0; i < splitData.length; i++) {
      var splitString = splitData[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      let hypenSplit = splitString.split("-");
      if (hypenSplit.length > 2) {
        let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
        hypenSplit = [hypenSplit[0], localString1];
      }
      if (hypenSplit != '') {
        let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
        colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
        colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));
        colonSplit[2] = this.shapeService1.scientificToDecimal(Number(colonSplit[2]));
        colonSplit[3] = this.shapeService1.scientificToDecimal(Number(colonSplit[3]));
        console.log(colonSplit);
        let x = colonSplit[0];
        let y = colonSplit[1];
        let width = colonSplit[2]// < colonSplit[0] ? colonSplit[0] - colonSplit[2] : colonSplit[2] - colonSplit[0]
        let height = colonSplit[3]// < colonSplit[1] ? colonSplit[1] - colonSplit[3] : colonSplit[3] - colonSplit[1]
        //below code to fix P3X-1226
        if (initial_position_x != undefined && initial_position_x > 0) {
          x = (initial_position_x - (width / 2)) //- x 
        }

        if (initial_position_y != undefined && initial_position_y > 0) {
          y = (initial_position_y - (height / 2)) //- y
        }

        if (toolbar_element_id == 20) {
          finalString = "move-" + x + ":" + y + " " + "line-" + (x + width) + ":" + (y) + " " + "line-" + (x + width) + ":" + (y + height) + " " + "line-" + x + ":" + (y + height) + " " + "line-" + x + ":" + y
        } else {
          // var kappa = .5522848,
          //   ox = (width / 2) * kappa, // control point offset horizontal
          //   oy = (height / 2) * kappa, // control point offset vertical
          //   xe = x + width,           // x-end
          //   ye = y + height,           // y-end
          //   xm = x + width / 2,       // x-middle
          //   ym = y + height / 2;       // y-middle

          // // ctx.moveTo(x, ym);
          // // context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
          // // ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
          // // ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
          // // ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
          // // //ctx.closePath(); // not used correctly, see comments (use to close off open path)
          // // ctx.stroke();
          // x = colonSplit[0] + (width / 2)
          // y = colonSplit[1] + (height / 2)

          // let move = "move-" + x + ":" + ym
          // let firstLevel = "controlpoint1-" + x + ":" + (ym - oy) + " " + "controlpoint2-" + (xm - ox) + ":" + y + " " + "endCurve-" + xm + ":" + y
          // let secondLevel = "controlpoint1-" + (xm + ox) + ":" + y + " " + "controlpoint2-" + xe + ":" + (ym - oy) + " " + "endCurve-" + xe + ":" + ym
          // let thirdLevel = "controlpoint1-" + xe + ":" + (ym + oy) + " " + "controlpoint2-" + (xm + ox) + ":" + ye + " " + "endCurve-" + xm + ":" + ye
          // let fourthLevel = "controlpoint1-" + (xm - ox) + ":" + ye + " " + "controlpoint2-" + x + ":" + (ym + oy) + " " + "endCurve-" + x + ":" + ym
          // finalString = move + " " + firstLevel + " " + secondLevel + " " + thirdLevel + " " + fourthLevel
          finalString = this.ellipseDrawing(x + (width / 2), y + (height / 2), width / 2, height / 2)
        }

      }
    }
    console.log("shape for base icon", finalString)

    return finalString
  }

  ellipseDrawing(x, y, xDis, yDis) {
    var kappa = 0.5522847498, // 4 * ((√(2) - 1) / 3)
      ox = xDis * kappa,  // control point offset horizontal
      oy = yDis * kappa,  // control point offset vertical
      xe = x + xDis,      // x-end
      ye = y + yDis;      // y-end

    // this.moveTo(x - xDis, y);
    // this.bezierCurveTo(x - xDis, y - oy, x - ox, y - yDis, x, y - yDis);
    // this.bezierCurveTo(x + ox, y - yDis, xe, y - oy, xe, y);
    // this.bezierCurveTo(xe, y + oy, x + ox, ye, x, ye);
    // this.bezierCurveTo(x - ox, ye, x - xDis, y + oy, x - xDis, y);
    // let move = "move-" + (x - xDis) + ":" + y
    // let firstLevel = "controlpoint1-" + (x - xDis) + ":" + (y - oy) + " " + "controlpoint2-" + (x - ox) + ":" + (y - yDis) + " " + "endCurve-" + x + ":" + (y - yDis)
    // let secondLevel = "controlpoint1-" + (x + ox) + ":" + (y - yDis) + " " + "controlpoint2-" + xe + ":" + (y - oy) + " " + "endCurve-" + xe + ":" + y
    // let thirdLevel = "controlpoint1-" + xe + ":" + (y + oy) + " " + "controlpoint2-" + (x + ox) + ":" + ye + " " + "endCurve-" + x + ":" + ye
    // let fourthLevel = "controlpoint1-" + (x - ox) + ":" + ye + " " + "controlpoint2-" + x + ":" + (y + oy) + " " + "endCurve-" + (x - xDis) + ":" + y
    let move = "move-" + (x - xDis) + ":" + y
    let firstLevel = "controlpoint1-" + (x - xDis) + ":" + (y - oy) + " " + "controlpoint2-" + (x - ox) + ":" + (y - yDis) + " " + "endCurve-" + x + ":" + (y - yDis)
    let secondLevel = "controlpoint1-" + (x + ox) + ":" + (y - yDis) + " " + "controlpoint2-" + (x + xDis) + ":" + (y - oy) + " " + "endCurve-" + (x + xDis) + ":" + y
    let thirdLevel = "controlpoint1-" + (x + xDis) + ":" + (y + oy) + " " + "controlpoint2-" + (x + ox) + ":" + (y + yDis) + " " + "endCurve-" + x + ":" + (y + yDis)
    let fourthLevel = "controlpoint1-" + (x - ox) + ":" + (y + yDis) + " " + "controlpoint2-" + (x - xDis) + ":" + (y + oy) + " " + "endCurve-" + (x - xDis) + ":" + y
    return move + " " + firstLevel + " " + secondLevel + " " + thirdLevel + " " + fourthLevel
  }


  repoint_xy_changes(receive_cloneRepointAnnotation) {
    let get_clone_data_repoint = receive_cloneRepointAnnotation;
    let isnegativeCoordinates = false;
    if (get_clone_data_repoint.initial_position_x < 0 && get_clone_data_repoint.initial_position_y < 0) {
      isnegativeCoordinates = true;
      get_clone_data_repoint.initial_position_x = -(get_clone_data_repoint.initial_position_x);
      get_clone_data_repoint.initial_position_y = -(get_clone_data_repoint.initial_position_y);
    }
    if ((get_clone_data_repoint.toolbar_element_id == 13 || get_clone_data_repoint.toolbar_element_id == 14 || get_clone_data_repoint.toolbar_element_id == 18) && get_clone_data_repoint.initial_position_x != 0 && isnegativeCoordinates == false) {

      let getresizeShapeString = this.shapeService1.resizeFunctionNew(get_clone_data_repoint, isnegativeCoordinates);
      get_clone_data_repoint.annotation_data = getresizeShapeString.shapeString;
      if (get_clone_data_repoint.initial_position_x != 0) {
        let getChangedString = this.changeStringValue(get_clone_data_repoint);
        get_clone_data_repoint.annotation_data = getChangedString;
        this.propertiesannotationData["annotation_data"] = getChangedString;
        var getShapeStringWidthHeight = this.shapeService1.getCanvaswidthandHeight(get_clone_data_repoint);
        console.log(getShapeStringWidthHeight);
      }
    }
  }

  initDragRepoint(element): void {
    // main logic will come here
    // 1
    let existingtransform = element.style.transform;
    this.document123 = document.getElementById("pdfImg");
    const dragStart$ = fromEvent<MouseEvent>(element, "mousedown");
    const dragEnd$ = fromEvent<MouseEvent>(this.document123, "mouseup");
    const dragOut$ = fromEvent<MouseEvent>(this.document123, "mouseleave");
    const drag$ = fromEvent<MouseEvent>(this.document123, "mousemove").pipe(takeUntil(dragEnd$));
    // 2
    let initialX: number, initialY: number, currentX = 0, currentY = 0;
    var finalOriginalTop;
    var finalOriginalLeft;
    let dragSub: Subscription;
    let dragenable = false;
    // let dragEndSub: Subscription;
    // 3
    const dragStartSub = dragStart$.subscribe((event: MouseEvent) => {
      initialX = (event.offsetX);
      initialY = (event.offsetY);
      console.log("start", initialX, initialY, "clientInformation", event.clientX, event.clientY, currentX, currentY, "topand left", element)
      element.classList.add('free-dragging');
      dragenable = true;
      // 4
      dragSub = drag$.subscribe((event: MouseEvent) => {
        event.preventDefault();
        currentX = (event.offsetX) - initialX;
        currentY = (event.offsetY) - initialY;
        console.log("dragg", currentX, currentY)
        element.style.transform = "translate3d(" + currentX + "px, " + currentY + "px, 0)";
      });

    });

    // 5
    const dragEndSub = dragEnd$.subscribe((event: MouseEvent) => {
      console.log('drag end trig')
      if (this.annotationSelected == true && this.dragmovenenable == true) {
        console.log('drag end trig inside')
        initialX = currentX;
        initialY = currentY;
        console.log(element);
        // element.classList.remove('free-dragging');
        if (dragSub) {
          console.log(element);
          dragSub.unsubscribe();
          dragStartSub.unsubscribe();
          dragEndSub.unsubscribe();
          element.style.transform = "translate3d(" + 0 + "px, " + 0 + "px, 0)";
          // var rect = element.getBoundingClientRect();
          // let ElementId = this.moveCurrentSelectedItem.toolbar_element_id;
          // if (ElementId >= 11) {
          //   element.style.left = element.offsetLeft + currentX + "px";
          //   element.style.top = element.offsetTop + currentY + "px";
          // }
          // else {
          //   element.style.left = element.offsetLeft + currentX + (element.clientWidth / 2) + "px";
          //   element.style.top = element.offsetTop + currentY + (element.clientHeight / 2) + "px";
          // }
          var rect = element.getBoundingClientRect();
          element.style.left = element.offsetLeft + currentX + (element.clientWidth / 2) + "px";
          element.style.top = element.offsetTop + currentY + (element.clientHeight / 2) + "px";
          let currentLeftValue = currentX;
          let currentTopValue = currentY;
          currentX = 0;
          currentY = 0;
          initialY = 0;
          initialX = 0;
          console.log(currentLeftValue, currentTopValue);
          var getdragElementId = element.getAttribute("count");
          console.log(getdragElementId);
          this.updateRepointDrawing(getdragElementId, currentLeftValue, currentTopValue, element);
        }
        else {
          this.removeMoveEvents();
        }
      }
      if (dragenable == true) {
        dragenable = false;
        let currentLeftValue = currentX;
        let currentTopValue = currentY;
        currentX = 0;
        currentY = 0;
        // var rect = element.getBoundingClientRect();
        // element.style.left = element.offsetLeft + currentX + (element.clientWidth / 2) + "px";
        // element.style.top = element.offsetTop + currentY + (element.clientHeight / 2) + "px";
        var getdragElementId = element.getAttribute("count");
        console.log(getdragElementId);
        this.updateRepointDrawing(getdragElementId, currentLeftValue, currentTopValue, element);
      }
    });
    // 6

    this.subscriptions.push.apply(this.subscriptions, [
      dragStartSub,
      dragSub,
      dragEndSub,
    ]);
  }

  updateRepointDrawing(getdragElementId, left, top, element) {
    this.stringPathArray = [];
    var coords = [];
    let newShapeString = "";
    let numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
    let getElement_attribute = getdragElementId;
    let changeIndex: any = "";
    // repoint last circle moving or not checking varibable = check_moving_index
    let check_moving_index = -1;
    this.propertiesannotationData["toolbar_element_id"] = Number(this.propertiesannotationData["toolbar_element_id"]);
    if (this.propertiesannotationData["toolbar_element_id"] == 19 || this.propertiesannotationData["toolbar_element_id"] == 20 || this.propertiesannotationData["toolbar_element_id"] == 18) {
      let get_red_circle_elements = document.querySelectorAll('circle.tempcircle');
      if (get_red_circle_elements != null && get_red_circle_elements.length > 0) {
        for (let g = 0; g < get_red_circle_elements.length; g++) {
          if (getElement_attribute != undefined && get_red_circle_elements[g].getAttribute('count') == getElement_attribute) {
            check_moving_index = g;
          }
          else {
            if (check_moving_index != -1) {
              check_moving_index = -1;
            }
          }
        }
      }
    }
    // find current redcircle index changeIndex variable 
    if (getElement_attribute != undefined) {
      for (let ak = 0; ak < getElement_attribute.length; ak++) {
        if (numbers.includes(getElement_attribute[ak])) {
          changeIndex = changeIndex + getElement_attribute[ak];
        }
      }
    }
    changeIndex = Number(changeIndex);
    let annotationData = this.propertiesannotationData["annotation_data"];
    let elementIdFind = this.propertiesannotationData["toolbar_element_id"];
    let spaceSplit = this.propertiesannotationData["annotation_data"].split(' ');
    //this line commented by ganesh because toolbar element id affected polyline shapes
    // this.propertiesannotationData.toolbar_element_id = 17;
    // if (this.propertiesannotationData["toolbar_element_id"] == 13) {
    //   spaceSplit.splice(spaceSplit.length - 3, 3);
    // }
    let cp1x = 0, cp1y = 0, cp2x = 0, cp2y = 0, cx = 0, cy = 0, e_x = 0, e_y = 0;
    let circle: any = "";
    let reduce_level: boolean = false;
    let ellipse_level: number = 3;
    // svg drawing started 
    this.removeredCirclesSVG();
    let svg_polyline = document.querySelector('svg[repointSVG]');
    let create_path = document.querySelector('path[customerepointattribute]');
    let path_value = "";
    let ellipse_path = "";
    console.log(spaceSplit);
    for (var i = 0; i < spaceSplit.length; i++) {
      console.log(changeIndex, i, spaceSplit[i]);
      var splitString = spaceSplit[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      var hypenSplit = splitString.split("-");
      if (hypenSplit.length > 2) {
        let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
        hypenSplit = [hypenSplit[0], localString1];
      }
      if (hypenSplit != '') {
        var colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
        if ((changeIndex == i) || (hypenSplit[0] == 'move' && check_moving_index != -1 && (elementIdFind == 19 || elementIdFind == 20 || elementIdFind == 18))) {
          colonSplit[0] = Number(colonSplit[0]) + left;
          colonSplit[1] = Number(colonSplit[1]) + top;
        }
        else if (hypenSplit[0] == 'line' && i == (spaceSplit.length - 1) && check_moving_index != -1 && elementIdFind == 19) {
          colonSplit[0] = Number(colonSplit[0]) + left;
          colonSplit[1] = Number(colonSplit[1]) + top;
        }
        colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
        colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));
        if ((changeIndex == i) || (hypenSplit[0] == 'move' && check_moving_index != -1 && (elementIdFind == 19 || elementIdFind == 20 || elementIdFind == 18))) {
          element.style.left = colonSplit[0] + 'px';
          element.style.top = colonSplit[1] + 'px';
          element.style.transform = "translate3d(" + 0 + "px, " + 0 + "px, 0)";
          if (elementIdFind == 19 && hypenSplit[0] != 'move') {
            hypenSplit[0] = "line";
          }
          console.log(i, hypenSplit[0], colonSplit[0], colonSplit[1]);
        }
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
        // convert the svg path polyline and polyline arrow and polygon
        path_value = i == 0 ? 'M' + coord.x + ' ' + coord.y : (path_value + ' L' + coord.x + ' ' + coord.y);
        if (elementIdFind != 19) {
          switch (hypenSplit[0]) {
            case "move":
              if (elementIdFind == 13) {
                this.stringPathArray.push('move-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              }
              newShapeString = newShapeString != '' ? (newShapeString + ' move-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('move-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
            case "line":
              if (elementIdFind == 13) {
                this.stringPathArray.push(' line-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              }
              newShapeString = newShapeString != '' ? (newShapeString + ' line-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('line-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
            case "controlpoint1":
              newShapeString = newShapeString != '' ? (newShapeString + ' controlpoint1-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('controlpoint1-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
            case "controlpoint2":
              newShapeString = newShapeString != '' ? (newShapeString + ' controlpoint2-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('controlpoint2-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
            case "endCurve":
              newShapeString = newShapeString != '' ? (newShapeString + ' endCurve-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('endCurve-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
          }
        }
        else if (elementIdFind == 19) {
          switch (hypenSplit[0]) {
            case "move":
              e_x = Math.round(parseFloat(colonSplit[0]));
              e_y = Math.round(parseFloat(colonSplit[1]));
              // circle = this.addredCircles(e_x, e_y);
              // circle.setAttribute('count', 'circle' + i);
              // circle.style.pointerEvents = "auto";
              // pdfImg.appendChild(circle);
              // this.initDragRepoint(circle);
              // this.canvasElement.moveTo(e_x, e_y);
              ellipse_path = ellipse_path == '' ? `M${e_x} ${e_y}` : (ellipse_path + ` M${e_x} ${e_y}`);
              newShapeString = newShapeString != '' ? (newShapeString + ' move-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('move-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
            case "line":
              newShapeString = newShapeString != '' ? (newShapeString + ' line-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('line-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              if (changeIndex == i) {
                let split_new_string = _.cloneDeep(newShapeString);
                split_new_string = split_new_string.trim();
                let split_space = split_new_string.split(' ');
                let control_point_1 = split_space[i - 2];
                let control_point_2 = split_space[i - 1];
                if (control_point_1 != undefined && control_point_2 != undefined && control_point_1.includes('controlpoint1') && control_point_2.includes('controlpoint2')) {
                  reduce_level = true;
                  let remove_string_after = "";
                  for (let k = 0; k < split_space.length; k++) {
                    if ((i - 2) != k && (i - 1) != k)
                      remove_string_after = remove_string_after + " " + split_space[k];
                  }
                  newShapeString = remove_string_after;
                  let cp1x_l = parseFloat(colonSplit[0]);
                  let cp1y_l = parseFloat(colonSplit[1]);
                  circle = this.addredCirclesSVG(cp1x_l, cp1y_l);
                  circle.setAttribute('count', 'circle' + (i - 2));
                  circle.style.pointerEvents = "auto";
                  svg_polyline.appendChild(circle);
                  this.initDragRepoint(circle);
                  // this.canvasElement.lineTo(cp1x_l, cp1y_l);
                  ellipse_path = ellipse_path == '' ? `L${cp1x_l} ${cp1y_l}` : (ellipse_path + ` L${cp1x_l} ${cp1y_l}`);
                } else {
                  let cp1x_l = parseFloat(colonSplit[0]);
                  let cp1y_l = parseFloat(colonSplit[1]);
                  circle = this.addredCirclesSVG(cp1x_l, cp1y_l);
                  circle.setAttribute('count', 'circle' + (i));
                  circle.style.pointerEvents = "auto";
                  svg_polyline.appendChild(circle);
                  this.initDragRepoint(circle);
                  // this.canvasElement.lineTo(cp1x_l, cp1y_l);
                  ellipse_path = ellipse_path == '' ? `L${cp1x_l} ${cp1y_l}` : (ellipse_path + ` L${cp1x_l} ${cp1y_l}`);
                }
                console.log(control_point_1, control_point_2, split_new_string, split_space);
              }
              else {
                let cp1x_l = parseFloat(colonSplit[0]);
                let cp1y_l = parseFloat(colonSplit[1]);
                circle = this.addredCirclesSVG(cp1x_l, cp1y_l);
                circle.setAttribute('count', 'circle' + (i));
                circle.style.pointerEvents = "auto";
                svg_polyline.appendChild(circle);
                this.initDragRepoint(circle);
                // this.canvasElement.lineTo(cp1x_l, cp1y_l);
                ellipse_path = ellipse_path == '' ? `L${cp1x_l} ${cp1y_l}` : (ellipse_path + ` L${cp1x_l} ${cp1y_l}`);
              }
              break;
            case "controlpoint1":
              cp1x = parseFloat(colonSplit[0]);
              cp1y = parseFloat(colonSplit[1]);
              newShapeString = newShapeString != '' ? (newShapeString + ' controlpoint1-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('controlpoint1-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
            case "controlpoint2":
              cp2x = parseFloat(colonSplit[0]);
              cp2y = parseFloat(colonSplit[1]);
              newShapeString = newShapeString != '' ? (newShapeString + ' controlpoint2-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('controlpoint2-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
            case "endCurve":
              cx = parseFloat(colonSplit[0]);
              cy = parseFloat(colonSplit[1]);
              circle = this.addredCirclesSVG(cx, cy);
              if (reduce_level == true) {
                circle.setAttribute('count', 'circle' + (i - 2));
              }
              else {
                circle.setAttribute('count', 'circle' + i);
              }
              circle.style.pointerEvents = "auto";
              svg_polyline.appendChild(circle);
              this.initDragRepoint(circle);
              // this.canvasElement.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);
              console.log(cp1x, cp1y, cp2x, cp2y, cx, cy);
              // this.canvasElement.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, cx, cy);
              ellipse_path = ellipse_path == '' ? `C${cp1x} ${cp1y} ${cp2x} ${cp2y} ${cx} ${cy}` : (ellipse_path + ` C${cp1x} ${cp1y} ${cp2x} ${cp2y} ${cx} ${cy}`);
              newShapeString = newShapeString != '' ? (newShapeString + ' endCurve-' + (colonSplit[0]) + ':' + (colonSplit[1])) : ('endCurve-' + (colonSplit[0]) + ':' + (colonSplit[1]));
              break;
          }
        }
      }
    }
    newShapeString = newShapeString.trim();
    this.propertiesannotationData["annotation_data"] = newShapeString;
    console.log(newShapeString);
    //  if ellipse 
    //  else if polyline and polyline arrow and polygon and rectangle and line and lineaxial
    if (elementIdFind == 19) {
      if (ellipse_path != undefined && ellipse_path != '') {
        create_path.setAttribute("d", ellipse_path);
      }
    }
    else if (elementIdFind != 19) {
      var max = coords.length - 1;
      let isAccess_first_point = [13, 14, 15, 16];
      let isdenied_first_point = [18, 19, 20];
      for (var l = 0; l < coords.length; l++) {
        if (isAccess_first_point.includes(elementIdFind) || (isdenied_first_point.includes(elementIdFind) && l != 0)) {
          let circle = this.addredCirclesSVG(coords[l].x, coords[l].y);
          circle.setAttribute('count', 'circle' + l);
          circle.style.pointerEvents = "auto";
          svg_polyline.appendChild(circle);
          this.initDragRepoint(circle);
        }
      }
      if (typeof coords[max - 1] !== "undefined") {
        create_path.setAttribute("d", path_value);
      }
    }
    // svg drawing end
  }

  rotateShape(strShape, toolbar_element_id, rotateAngle) {
    console.log(rotateAngle);
    var getshapedimensions = this.shapeService1.getCanvaswidthandHeight({ toolbar_element_id, annotation_data: strShape })
    let finalString = ""
    let splitData: any = strShape.split(" ");
    for (var i = 0; i < splitData.length; i++) {
      var splitString = splitData[i].replaceAll('--', '-n');
      splitString = splitString.replaceAll(':-', ':n');
      let hypenSplit = splitString.split("-");
      if (hypenSplit.length > 2) {
        let localString1 = hypenSplit[1] + '-' + hypenSplit[2];
        hypenSplit = [hypenSplit[0], localString1];
      }
      if (hypenSplit != '') {
        let colonSplit = hypenSplit[1].replaceAll('n', '-').split(":");
        colonSplit[0] = this.shapeService1.scientificToDecimal(Number(colonSplit[0]));
        colonSplit[1] = this.shapeService1.scientificToDecimal(Number(colonSplit[1]));

        if (toolbar_element_id == 19 && toolbar_element_id == 20 && false) {
          console.log(colonSplit)
          let centerX = 0
          let centerY = 0
          let rotatevaluesX = Number(colonSplit[0]) + Number(colonSplit[2]) / 2
          let rotatevaluesY = Number(colonSplit[1]) + Number(colonSplit[3]) / 2
          let localstring = hypenSplit[0] + "-" + rotatevaluesX + ":" + rotatevaluesY + ":" + colonSplit[3] + ":" + colonSplit[2]
          finalString = finalString != "" ? finalString + " " + localstring : localstring
        } else {
          let centerX = (getshapedimensions.left) + (getshapedimensions.width / 2)
          let centerY = (getshapedimensions.top) + (getshapedimensions.height / 2)
          let rotatevalues = this.rotateByCoordinates(centerX, centerY, colonSplit[0], colonSplit[1], rotateAngle)
          let localstring = hypenSplit[0] + "-" + rotatevalues[0] + ":" + rotatevalues[1]
          finalString = finalString != "" ? finalString + " " + localstring : localstring
        }
      }
    }
    console.log("shape for base icon", finalString)
    return finalString
  }

  rotateByCoordinates(cx, cy, x, y, angle) {
    console.log('angle', angle);
    var radians = (Math.PI / 180) * angle,
      cos = Math.cos(radians),
      sin = Math.sin(radians),
      nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
      ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
    return [nx, ny];
  }

  getStrokeColor(checkStroke) {
    if (checkStroke.includes("#")) {
      if (checkStroke == "#NNNNNN00") {
        return "transparent";
      } else {
        return checkStroke;
      }
    }
    else {
      switch (checkStroke) {
        case "blue":
          return "#002F5F";
        case "red":
          return "#BC0900";
        case "orange":
          return "#F48F00";
        case "yellow":
          return "#FFFF00";
        case "green":
          return "#98D133";
        case "default_blue":
          return "#015ECD";
        case "purple":
          return "#6C2EA7";
        case "pink":
          return "#DF1ED3";
        case "dark_pink":
          return "#C832B1";
        case "magenta":
          return "#C832B1";
        case "light_blue":
          return "#80F1FE";
        case "cyan":
          return "#80F1FE";
        case "brown":
          return "#7C4E40";
        case "grey":
          return "#949494";
        case "medium_grey":
          return "#CCCCCC";
        case "light_grey":
          return "#000000";
        case "white":
          return "#FFFFFF";
        case "clear":
          return "#NNNNNN00";
        default:
          return "#002F5F";
      }
    }
  }

  annotationClear(dataValue) {
    let annotationClear = document.getElementById(dataValue["annotation_id"]);
    if (annotationClear != null) {
      annotationClear.remove();
    }
    let annotationLabelClear = document.getElementById('label' + dataValue["annotation_id"]);
    if (annotationLabelClear != null) {
      annotationLabelClear.remove();
    }
  }

  moveMultipleAnnotation() {
    var pdfImg = document.getElementById("pdfImg");
    var canvas = document.createElement("canvas");
    canvas.setAttribute("width", this.realWidth);
    canvas.setAttribute("height", this.realHeight);
    canvas.setAttribute("customemoveattribute", "1");
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.style.zIndex = "9999";
    pdfImg.appendChild(canvas);

  }

  getSelectedElements: any = "";

  async captureEventsMove() {
    console.log(this.multiselectionList);
    var pdfImg = document.getElementById("pdfImg");
    let newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeMoveAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    pdfImg.appendChild(newcreatedElement);

    var previousPosition: any = "";
    var currentPosition: any = "";
    // var canvasEl: HTMLCanvasElement = this.createElementChanged;

    // set attributes for moving by ramkumar
    // after adding attributes shape change multimoving get removed so for added.
    if (this.multipleSelectOn == true) {
      for (let j = 0; j < this.multiselectionList.length; j++) {
        let getElement = document.getElementById(this.multiselectionList[j].annotation_id);
        this.backup_annot_storage(this.multiselectionList[j]); // call backup annotation function
        if (getElement != null && !getElement.hasAttribute('multimoving')) {
          getElement.setAttribute('multimoving', '1');
        }
        if (this.multiselectionList[j].annotation_label != null || this.multiselectionList[j].annotation_label != "" || this.multiselectionList[j].annotation_label != undefined) {
          this.getMultipleMovingLabelElement(this.multiselectionList[j].annotation_id);
        }
      }
    }

    this.createDocumentStore.multipleDragSelectCanvas = newcreatedElement.getContext("2d");
    this.createDocumentStore.multipleMoveCanvas = newcreatedElement.getContext("2d");
    let initialX: number, initialY: number, currentX = 0, currentY = 0;
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    fromEvent(newcreatedElement, "mousedown")
      .pipe(
        switchMap((e: MouseEvent) => {
          if (this.isReadonly != true) {
            e.preventDefault();
            console.log(e);
            let mousedowntrigger = true;
            let mousedrag = false;
            this.annotationselectEnableDisable('enable');
            initialX = (e.offsetX);
            initialY = (e.offsetY);
            previousPosition = "";
            currentPosition = "";

            this.getSelectedElements = document.querySelectorAll('svg[multiMoving]');
            this.createDocumentStore.movelabelElement = document.querySelectorAll('p[multiMovinglabel]');
            console.log(this.getSelectedElements);
            console.log(this.createDocumentStore.movelabelElement);
            // disable drag scroll
            this.createDocumentStore.disable_drag_scroll = true;
            // after a mouse down, we'll record all mouse moves
            return fromEvent(newcreatedElement, "mousemove").do(() => {
              mousedrag = true;
            }).pipe(
              // we'll stop (and unsubscribe) once the user releases the mouse
              // this will trigger a 'mouseup' event
              takeUntil(
                fromEvent(newcreatedElement, "mouseup").do(async () => {
                  // disable drag scroll
                  this.createDocumentStore.disable_drag_scroll = false;
                  if (mousedowntrigger == true && mousedrag == true && this.getSelectedElements != null && this.getSelectedElements.length != 0) {
                    mousedowntrigger = false;
                    this.moveOverBoundary = false;
                    console.log('mouse_up');
                    for (let i = 0; i < this.getSelectedElements.length; i++) {
                      let getAttribute_element = this.getSelectedElements[i].getAttribute('id');
                      console.log('id', getAttribute_element);
                      let filter_element_data = this.multiselectionList.filter((rData) => rData.annotation_id == getAttribute_element);
                      if (filter_element_data.length > 0) {
                        if (filter_element_data[0].initial_rotation != undefined && filter_element_data[0].initial_rotation != 0 && filter_element_data[0].toolbar_element_id <= 11) {
                          this.getSelectedElements[i].style.transform = 'matrix(' + Math.cos(filter_element_data[0].initial_rotation) + ',' + Math.sin(filter_element_data[0].initial_rotation) + ',' + -(Math.sin(filter_element_data[0].initial_rotation)) + ',' + Math.cos(filter_element_data[0].initial_rotation) + ',' + 0 + ',' + 0 + ')';
                        }
                        else {
                          this.getSelectedElements[i].style.transform = "translate3d(" + 0 + "px, " + 0 + "px, 0)";
                        }
                      }
                      let elementId = this.getSelectedElements[i].getAttribute("multimoving");
                      let getStyle = getComputedStyle(this.getSelectedElements[i]);
                      let getMarginLeft = getStyle.marginLeft;
                      getMarginLeft = getMarginLeft.substring(getMarginLeft.length - 2, 0);
                      let getMarginTop = getStyle.marginTop;
                      getMarginTop = getMarginTop.substring(getMarginTop.length - 2, 0);
                      console.log(getMarginLeft, getMarginTop);
                      let get_element_left = getStyle.left;
                      get_element_left = get_element_left.substring(get_element_left.length - 2, 0);
                      let get_element_top = getStyle.top;
                      get_element_top = get_element_top.substring(get_element_top.length - 2, 0);
                      this.getSelectedElements[i].style.left = currentX < this.realWidth - this.getSelectedElements[i].clientWidth ? Number(get_element_left) + currentX + "px" : this.realWidth - this.getSelectedElements[i].clientWidth + "px";
                      this.getSelectedElements[i].style.top = currentY < this.realHeight - this.getSelectedElements[i].clientHeight ? Number(get_element_top) + currentY + "px" : this.realHeight - this.getSelectedElements[i].clientHeight + "px";

                      this.getSelectedElements[i].style.zIndex = "1";
                    }
                    for (let j = 0; j < this.createDocumentStore.movelabelElement.length; j++) {
                      let getAttribute_element = this.createDocumentStore.movelabelElement[j].getAttribute('id');
                      let split_value = getAttribute_element.replace('label', '');
                      console.log('labelid', getAttribute_element, split_value);
                      let filter_label_element_data = this.multiselectionList.filter((rData) => rData.annotation_id == split_value);
                      if (filter_label_element_data.length > 0) {
                        if (filter_label_element_data[0].initial_rotation != undefined && filter_label_element_data[0].initial_rotation != 0 && filter_label_element_data[0].toolbar_element_id <= 11) {
                          this.createDocumentStore.movelabelElement[j].style.transform = 'matrix(' + Math.cos(filter_label_element_data[0].initial_rotation) + ',' + Math.sin(filter_label_element_data[0].initial_rotation) + ',' + -(Math.sin(filter_label_element_data[0].initial_rotation)) + ',' + Math.cos(filter_label_element_data[0].initial_rotation) + ',' + 0 + ',' + 0 + ')';
                        } else {
                          this.createDocumentStore.movelabelElement[j].style.transform = "translate3d(" + 0 + "px, " + 0 + "px, 0)";
                        }
                      }
                      let elementId = this.createDocumentStore.movelabelElement[j].getAttribute("multimovinglabel");
                      let getStyle_label = getComputedStyle(this.createDocumentStore.movelabelElement[j]);
                      let getMarginLeft_label = getStyle_label.marginLeft;
                      getMarginLeft_label = getMarginLeft_label.substring(getMarginLeft_label.length - 2, 0);
                      let getMarginTop_label = getStyle_label.marginTop;
                      getMarginTop_label = getMarginTop_label.substring(getMarginTop_label.length - 2, 0);
                      console.log(getMarginLeft_label, getMarginTop_label);

                      let get_label_element_left = getStyle_label.left;
                      get_label_element_left = get_label_element_left.substring(get_label_element_left.length - 2, 0);
                      let get_label_element_top = getStyle_label.top;
                      get_label_element_top = get_label_element_top.substring(get_label_element_top.length - 2, 0);

                      this.createDocumentStore.movelabelElement[j].style.left = currentX < this.realWidth - this.createDocumentStore.movelabelElement[j].clientWidth ? Number(get_label_element_left) + currentX + "px" : this.realWidth - this.createDocumentStore.movelabelElement[j].clientWidth + "px";
                      this.createDocumentStore.movelabelElement[j].style.top = currentY < this.realHeight - this.createDocumentStore.movelabelElement[j].clientHeight ? Number(get_label_element_top) + currentY + "px" : this.realHeight - this.createDocumentStore.movelabelElement[j].clientHeight + "px";
                      this.createDocumentStore.movelabelElement[j].style.zIndex = "2";
                    }
                    let currentLeftValue = currentX;
                    let currentTopValue = currentY;
                    currentX = 0;
                    currentY = 0;
                    initialY = 0;
                    initialX = 0;

                    console.log(currentLeftValue, currentTopValue);
                    for (let k = 0; k < this.multiselectionList.length; k++) {
                      this.updateMoveAPI(this.multiselectionList[k].annotation_id, currentLeftValue, currentTopValue);
                    }
                    this.annotationselectEnableDisable('remove');
                  }
                  else if (mousedrag == false) {

                    let clickPosition = {
                      x: initialX,
                      y: initialY,
                    };
                    let clickPositionX = clickPosition.x;
                    clickPositionX = clickPositionX + 10;
                    let clickPositionY = clickPosition.y;
                    clickPositionY = clickPositionY + 10;
                    console.log(clickPositionX, clickPositionY, e);
                    let getAllCanvasElements = document.querySelectorAll('svg.documentSVG');
                    var filterCanvas = [];
                    // console.log(getAllCanvasElements);
                    for (let ma = 0; ma < getAllCanvasElements.length; ma++) {
                      let getAllElementsXY: any = getAllCanvasElements[ma];
                      let getStyle = getComputedStyle(getAllElementsXY);
                      let getLeft: any = getStyle.left;
                      getLeft = getLeft.substring(getLeft.length - 2, 0);
                      let getTop: any = getStyle.top;
                      getTop = getTop.substring(getTop.length - 2, 0);
                      let getWidth: any = getStyle.width;
                      getWidth = getWidth.substring(getWidth.length - 2, 0);
                      let getHeight: any = getStyle.height;
                      getHeight = getHeight.substring(getHeight.length - 2, 0);
                      let checkBoundingBox = false;
                      getLeft = Number(getLeft);
                      getTop = Number(getTop);
                      getWidth = Number(getWidth);
                      getHeight = Number(getHeight);
                      let EndPointX = getLeft + getWidth;
                      let EndPointY = getTop + getHeight;
                      // let annotId = getAllElementsXY.getAttribute('id');
                      // let alreadySelected = this.createDocumentStore.selectedAnnotations.some((ids)=>ids===annotId);
                      console.log(getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY)
                      if (getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY) {
                        // console.log('X:'+getLeft+'Y:'+getTop + '----' + 'width:' + getWidth + 'height:' + getHeight);
                        // let markback:any = getAllCanvasElements[ma];
                        // this.colorBorder(markback);
                        // // markback.style.backgroundColor = "red";
                        // this.createDocumentStore.selectedAnnotations.push(annotId);
                        filterCanvas.push(getAllCanvasElements[ma]);
                      }
                      // else if(getLeft<=clickPositionX && EndPointX>=clickPositionX && getTop<=clickPositionY && EndPointY>=clickPositionY && alreadySelected==true){
                      //   let removeIndex = this.createDocumentStore.selectedAnnotations.findIndex((ids)=>ids===annotId);
                      //   this.createDocumentStore.selectedAnnotations.splice(removeIndex,1);
                      //   let markback:any = getAllCanvasElements[ma];
                      //   this.transparentBorder(markback);
                      //   break;
                      // }
                    }
                    let callAPIEnable = false;
                    let filter_canvas_anno = _.cloneDeep(filterCanvas);
                    if (filter_canvas_anno.length > 0) {
                      let is_locked_flag_value;
                      for (let r = 0; r < filterCanvas.length; r++) {
                        let annot_id_ = filterCanvas[r].getAttribute('id');
                        for (let i = 0; i < this.layerDatas.length; i++) {
                          let annotations = this.layerDatas[i]["annotations"].filter(annotation => annotation.annotation_id == annot_id_)
                          if (annotations.length > 0) {
                            let associated_pages = this.layerDatas[i].associated_pages
                            let page_element = associated_pages.filter(ele => ele.page_id == this.currentPageId)
                            this.activeLayerIdDraw = page_element[0].layer_id;
                            is_locked_flag_value = page_element.length > 0 ? page_element[0].is_lock : "false"
                          }
                        }
                        console.log(is_locked_flag_value)
                        if (is_locked_flag_value == "true" || is_locked_flag_value == true || is_locked_flag_value == "1") {
                          let itemIndex = filter_canvas_anno.findIndex(data => data.getAttribute('id') == annot_id_);
                          if (itemIndex != -1) {
                            filter_canvas_anno.splice(itemIndex, 1);
                          }
                        }
                      }
                    }
                    filterCanvas = filter_canvas_anno;
                    if (this.createDocumentStore.selectedAnnotations.length == 0 && filterCanvas.length > 0) {
                      let annotId = filterCanvas[0].getAttribute('id');
                      this.createDocumentStore.selectedAnnotations.push(annotId);
                      filterCanvas[0].setAttribute('multimoving', '1');
                      this.colorBorderSVG(filterCanvas[0]);
                      callAPIEnable = true;
                      this.getMultipleMovingLabelElement(annotId);
                    }
                    else if (this.createDocumentStore.selectedAnnotations.length != 0 && filterCanvas.length > 0) {
                      var canExecute = true;
                      let cloneFilterCVanvas = _.cloneDeep(filterCanvas)
                      for (let f = 0; f < filterCanvas.length; f++) {
                        if (canExecute == true) {
                          for (let g = 0; g < this.createDocumentStore.selectedAnnotations.length; g++) {
                            cloneFilterCVanvas = cloneFilterCVanvas.filter((canvas) => canvas.getAttribute('id') != this.createDocumentStore.selectedAnnotations[g])
                          }
                          if (cloneFilterCVanvas.length > 0) {
                            let annotId = cloneFilterCVanvas[0].getAttribute('id');
                            this.createDocumentStore.selectedAnnotations.push(annotId);
                            cloneFilterCVanvas[f].setAttribute('multimoving', '1');
                            this.colorBorderSVG(cloneFilterCVanvas[f]);
                            callAPIEnable = true;
                            canExecute = false;
                            this.getMultipleMovingLabelElement(annotId);
                          } else {
                            var iVal = 0;
                            do {
                              if (this.createDocumentStore.selectedAnnotations.length > iVal) {
                                let canvasfiltered = filterCanvas.filter((element) => element.getAttribute('id') === this.createDocumentStore.selectedAnnotations[iVal]);
                                if (canvasfiltered.length > 0) {
                                  console.log(this.multiselectionList);
                                  let findMultiRemoving = this.multiselectionList.filter((dataRes) => dataRes.annotation_id != this.createDocumentStore.selectedAnnotations[iVal]);
                                  // need to work svg
                                  this.multiselectionList = findMultiRemoving;
                                  // draw side bar multiple_annotations when local changes happened in the multiselection list 
                                  await this.drawing_multiple_annotations();
                                  this.getMultipleMovingLabelElementRemove(this.createDocumentStore.selectedAnnotations[iVal]);
                                  this.createDocumentStore.selectedAnnotations.splice(iVal, 1);
                                  canvasfiltered[0].removeAttribute('multimoving');
                                  this.transparentBorderSVG(canvasfiltered[0]);
                                  callAPIEnable = false;
                                  //this.createDocumentStore.selectedAnnotations
                                  canExecute = false;
                                }
                                else {
                                  iVal += 1
                                }
                              } else {
                                canExecute = false;
                              }
                            } while (canExecute)
                            // this.createDocumentStore.selectedAnnotations.splice(f, 1);
                            // this.transparentBorder(filterCanvas[f]);
                            //this.createDocumentStore.selectedAnnotations
                          }
                        }
                      }
                      // let alreadySelected = this.createDocumentStore.selectedAnnotations.some((ids) => ids === annotId);
                      // if (alreadySelected == true) {
                      //   this.createDocumentStore.selectedAnnotations.splice(f, 1);
                      //   this.transparentBorder(filterCanvas[f]);
                      //   break;
                      // }
                      // else {
                      //   this.createDocumentStore.selectedAnnotations.push(annotId);
                      //   this.colorBorder(filterCanvas[f]);
                      //   break;
                      // }
                    }
                    if (this.createDocumentStore.selectedAnnotations.length > 0 && callAPIEnable == true) {
                      this.multipleAnnotationCallAPI();
                    }
                    else if (callAPIEnable == false) {
                      this.get_Multiselection_Data_Count();
                    }
                    else {
                      this.selectAnnotationZero();
                    }
                    currentX = 0;
                    currentY = 0;
                    initialY = 0;
                    initialX = 0;
                  }
                  else if (mousedowntrigger == true && mousedrag == true && (this.getSelectedElements.length == 0 || this.getSelectedElements == null || this.createDocumentStore.selectedAnnotations.length == 0)) {
                    //jose drag select    
                    mousedrag = false;
                    mousedowntrigger = false;
                    console.log('mouse_up');
                    const rect = newcreatedElement.getBoundingClientRect();
                    if (previousPosition.x > currentPosition.x) {
                      let cloneCurrentX = previousPosition.x;
                      previousPosition.x = currentPosition.x;
                      currentPosition.x = cloneCurrentX;
                    }
                    if (previousPosition.y > currentPosition.y) {
                      let cloneCurrentY = previousPosition.y;
                      previousPosition.y = currentPosition.y;
                      currentPosition.y = cloneCurrentY;
                    }
                    let startPositionX = previousPosition.x;
                    let startPositionY = previousPosition.y;
                    console.log(startPositionX, startPositionY, e);
                    let getAllCanvasElements = document.querySelectorAll('svg.documentSVG');
                    var filterCanvas = [];
                    // console.log(getAllCanvasElements);
                    for (let ma = 0; ma < getAllCanvasElements.length; ma++) {
                      let getAllElementsXY: any = getAllCanvasElements[ma];
                      let getStyle = getComputedStyle(getAllElementsXY);
                      let getLeft: any = getStyle.left;
                      getLeft = getLeft.substring(getLeft.length - 2, 0);
                      let getTop: any = getStyle.top;
                      getTop = getTop.substring(getTop.length - 2, 0);
                      let getWidth: any = getStyle.width;
                      getWidth = getWidth.substring(getWidth.length - 2, 0);
                      let getHeight: any = getStyle.height;
                      getHeight = getHeight.substring(getHeight.length - 2, 0);
                      let checkBoundingBox = false;
                      getLeft = Number(getLeft);
                      getTop = Number(getTop);
                      getWidth = Number(getWidth);
                      getHeight = Number(getHeight);
                      let EndPointX = currentPosition.x;
                      let EndPointY = currentPosition.y;
                      let get_full_width = getLeft + getWidth;
                      let get_full_height = getTop + getHeight;
                      let inside_bound_values = (getLeft >= startPositionX && EndPointX >= getLeft && getTop >= startPositionY && EndPointY >= getTop) || (getLeft >= startPositionX && EndPointX >= getLeft && getTop >= startPositionY && EndPointY >= getTop)
                      //if ((getLeft >= startPositionX && EndPointX >= getLeft && getTop >= startPositionY && EndPointY >= getTop)) {
                      if ((getLeft > startPositionX && getLeft < EndPointX && getTop > startPositionY && getTop < EndPointY) || (getLeft < startPositionX && get_full_width > EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && getTop > startPositionY && getTop < EndPointY) || (getLeft > startPositionX && getLeft < EndPointX && get_full_height > startPositionY && get_full_height < EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && get_full_height > startPositionY && get_full_height < EndPointY) || (getLeft > startPositionX && getLeft < EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (getTop > startPositionY && getTop < EndPointY && getLeft < startPositionX && get_full_width > EndPointX) || (get_full_height > startPositionY && get_full_height < EndPointY && getLeft < startPositionX && get_full_width > EndPointX)) {
                        filterCanvas.push(getAllCanvasElements[ma]);
                      }
                    }
                    let filter_canvas_anno = _.cloneDeep(filterCanvas);
                    if (filter_canvas_anno.length > 0) {
                      let is_locked_flag_value;
                      for (let r = 0; r < filterCanvas.length; r++) {
                        let annot_id_ = filterCanvas[r].getAttribute('id');
                        for (let i = 0; i < this.layerDatas.length; i++) {
                          let annotations = this.layerDatas[i]["annotations"].filter(annotation => annotation.annotation_id == annot_id_)
                          if (annotations.length > 0) {
                            let associated_pages = this.layerDatas[i].associated_pages
                            let page_element = associated_pages.filter(ele => ele.page_id == this.currentPageId)
                            this.activeLayerIdDraw = page_element[0].layer_id;
                            is_locked_flag_value = page_element.length > 0 ? page_element[0].is_lock : "false"
                          }
                        }
                        console.log(is_locked_flag_value)
                        if (is_locked_flag_value == "true" || is_locked_flag_value == true || is_locked_flag_value == "1") {
                          let itemIndex = filter_canvas_anno.findIndex(data => data.getAttribute('id') == annot_id_);
                          if (itemIndex != -1) {
                            filter_canvas_anno.splice(itemIndex, 1);
                          }
                        }
                      }
                    }
                    filterCanvas = filter_canvas_anno;

                    if (this.createDocumentStore.selectedAnnotations.length == 0 && filterCanvas.length > 0) {
                      for (let fc = 0; fc < filterCanvas.length; fc++) {
                        let annotId = filterCanvas[fc].getAttribute('id');
                        filterCanvas[fc].setAttribute('multimoving', '1');
                        this.createDocumentStore.selectedAnnotations.push(annotId);
                        this.colorBorderSVG(filterCanvas[fc]);
                        this.getMultipleMovingLabelElement(annotId);
                      }
                    }
                    else if (this.createDocumentStore.selectedAnnotations.length != 0 && filterCanvas.length > 0) {
                      for (let f = 0; f < filterCanvas.length; f++) {
                        let annotId = filterCanvas[f].getAttribute('id');
                        let alreadySelected = this.createDocumentStore.selectedAnnotations.some((ids) => ids === annotId);
                        if (alreadySelected == false) {
                          this.createDocumentStore.selectedAnnotations.push(annotId);
                          filterCanvas[f].setAttribute('multimoving', '1');
                          this.colorBorderSVG(filterCanvas[f]);
                          this.getMultipleMovingLabelElement(annotId);
                        }
                      }
                    } else if (filterCanvas.length == 0) {
                      this.createDocumentStore.selectedAnnotations = [];
                    }

                    console.log(this.createDocumentStore.selectedAnnotations);
                    if (this.createDocumentStore.selectedAnnotations.length > 0) {
                      let tempArray = this.createDocumentStore.selectedAnnotations;
                      this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
                        return index === self.indexOf(elem);
                      });
                      // need to add multiple api calling
                      this.multiple_annotation_api_calling();
                    }
                    this.createDocumentStore.multipleDragSelectCanvas.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);

                    currentX = 0;
                    currentY = 0;
                    initialY = 0;
                    initialX = 0;
                  }
                })
              ),
              // we'll also stop (and unsubscribe) once the mouse leaves the canvas (mouseleave event)
              takeUntil(fromEvent(newcreatedElement, "mouseleave").do(async () => {
                // disable drag scroll
                this.createDocumentStore.disable_drag_scroll = false;
                if (mousedowntrigger == true && mousedrag == true && this.getSelectedElements != null && this.getSelectedElements.length != 0) {
                  mousedowntrigger = false;
                  console.log('mouse_up');

                  for (let i = 0; i < this.getSelectedElements.length; i++) {
                    let getAttribute_element = this.getSelectedElements[i].getAttribute('id');
                    console.log('id', getAttribute_element);
                    let filter_element_data = this.multiselectionList.filter((rData) => rData.annotation_id == getAttribute_element);
                    if (filter_element_data.length > 0) {
                      if (filter_element_data[0].initial_rotation != undefined && filter_element_data[0].initial_rotation != 0 && filter_element_data[0].toolbar_element_id <= 11) {
                        this.getSelectedElements[i].style.transform = 'matrix(' + Math.cos(filter_element_data[0].initial_rotation) + ',' + Math.sin(filter_element_data[0].initial_rotation) + ',' + -(Math.sin(filter_element_data[0].initial_rotation)) + ',' + Math.cos(filter_element_data[0].initial_rotation) + ',' + 0 + ',' + 0 + ')';
                      }
                      else {
                        this.getSelectedElements[i].style.transform = "translate3d(" + 0 + "px, " + 0 + "px, 0)";
                      }
                    }
                    let elementId = this.getSelectedElements[i].getAttribute("multimoving");
                    let getStyle = getComputedStyle(this.getSelectedElements[i]);
                    let getMarginLeft = getStyle.marginLeft;
                    getMarginLeft = getMarginLeft.substring(getMarginLeft.length - 2, 0);
                    let getMarginTop = getStyle.marginTop;
                    getMarginTop = getMarginTop.substring(getMarginTop.length - 2, 0);
                    console.log(getMarginLeft, getMarginTop);
                    let get_element_left = getStyle.left;
                    get_element_left = get_element_left.substring(get_element_left.length - 2, 0);
                    let get_element_top = getStyle.top;
                    get_element_top = get_element_top.substring(get_element_top.length - 2, 0);
                    this.getSelectedElements[i].style.left = currentX < this.realWidth - this.getSelectedElements[i].clientWidth ? Number(get_element_left) + currentX + "px" : this.realWidth - this.getSelectedElements[i].clientWidth + "px";
                    this.getSelectedElements[i].style.top = currentY < this.realHeight - this.getSelectedElements[i].clientHeight ? Number(get_element_top) + currentY + "px" : this.realHeight - this.getSelectedElements[i].clientHeight + "px";

                    this.getSelectedElements[i].style.zIndex = "1";
                  }
                  for (let j = 0; j < this.createDocumentStore.movelabelElement.length; j++) {
                    let getAttribute_element = this.createDocumentStore.movelabelElement[j].getAttribute('id');
                    let split_value = getAttribute_element.replace('label', '');
                    console.log('labelid', getAttribute_element, split_value);
                    let filter_label_element_data = this.multiselectionList.filter((rData) => rData.annotation_id == split_value);
                    if (filter_label_element_data.length > 0) {
                      if (filter_label_element_data[0].initial_rotation != undefined && filter_label_element_data[0].initial_rotation != 0 && filter_label_element_data[0].toolbar_element_id <= 11) {
                        this.createDocumentStore.movelabelElement[j].style.transform = 'matrix(' + Math.cos(filter_label_element_data[0].initial_rotation) + ',' + Math.sin(filter_label_element_data[0].initial_rotation) + ',' + -(Math.sin(filter_label_element_data[0].initial_rotation)) + ',' + Math.cos(filter_label_element_data[0].initial_rotation) + ',' + 0 + ',' + 0 + ')';
                      } else {
                        this.createDocumentStore.movelabelElement[j].style.transform = "translate3d(" + 0 + "px, " + 0 + "px, 0)";
                      }
                    }
                    let elementId = this.createDocumentStore.movelabelElement[j].getAttribute("multimovinglabel");
                    let getStyle_label = getComputedStyle(this.createDocumentStore.movelabelElement[j]);
                    let getMarginLeft_label = getStyle_label.marginLeft;
                    getMarginLeft_label = getMarginLeft_label.substring(getMarginLeft_label.length - 2, 0);
                    let getMarginTop_label = getStyle_label.marginTop;
                    getMarginTop_label = getMarginTop_label.substring(getMarginTop_label.length - 2, 0);
                    console.log(getMarginLeft_label, getMarginTop_label);

                    let get_label_element_left = getStyle_label.left;
                    get_label_element_left = get_label_element_left.substring(get_label_element_left.length - 2, 0);
                    let get_label_element_top = getStyle_label.top;
                    get_label_element_top = get_label_element_top.substring(get_label_element_top.length - 2, 0);

                    this.createDocumentStore.movelabelElement[j].style.left = currentX < this.realWidth - this.createDocumentStore.movelabelElement[j].clientWidth ? Number(get_label_element_left) + currentX + "px" : this.realWidth - this.createDocumentStore.movelabelElement[j].clientWidth + "px";
                    this.createDocumentStore.movelabelElement[j].style.top = currentY < this.realHeight - this.createDocumentStore.movelabelElement[j].clientHeight ? Number(get_label_element_top) + currentY + "px" : this.realHeight - this.createDocumentStore.movelabelElement[j].clientHeight + "px";
                    this.createDocumentStore.movelabelElement[j].style.zIndex = "2";
                  }

                  let currentLeftValue = currentX;
                  let currentTopValue = currentY;
                  currentX = 0;
                  currentY = 0;
                  initialY = 0;
                  initialX = 0;

                  console.log(currentLeftValue, currentTopValue);
                  for (let k = 0; k < this.multiselectionList.length; k++) {
                    this.updateMoveAPI(this.multiselectionList[k].annotation_id, currentLeftValue, currentTopValue);
                  }
                  this.annotationselectEnableDisable('remove');
                }
                else if (mousedrag == false) {
                  let clickPosition = {
                    x: initialX,
                    y: initialY,
                  };
                  let clickPositionX = clickPosition.x;
                  clickPositionX = clickPositionX + 10;
                  let clickPositionY = clickPosition.y;
                  clickPositionY = clickPositionY + 10;
                  console.log(clickPositionX, clickPositionY, e);
                  let getAllCanvasElements = document.querySelectorAll('svg.documentSVG');
                  var filterCanvas = [];
                  // console.log(getAllCanvasElements);
                  for (let ma = 0; ma < getAllCanvasElements.length; ma++) {
                    let getAllElementsXY: any = getAllCanvasElements[ma];
                    let getStyle = getComputedStyle(getAllElementsXY);
                    let getLeft: any = getStyle.left;
                    getLeft = getLeft.substring(getLeft.length - 2, 0);
                    let getTop: any = getStyle.top;
                    getTop = getTop.substring(getTop.length - 2, 0);
                    let getWidth: any = getStyle.width;
                    getWidth = getWidth.substring(getWidth.length - 2, 0);
                    let getHeight: any = getStyle.height;
                    getHeight = getHeight.substring(getHeight.length - 2, 0);
                    let checkBoundingBox = false;
                    getLeft = Number(getLeft);
                    getTop = Number(getTop);
                    getWidth = Number(getWidth);
                    getHeight = Number(getHeight);
                    let EndPointX = getLeft + getWidth;
                    let EndPointY = getTop + getHeight;
                    // let annotId = getAllElementsXY.getAttribute('id');
                    // let alreadySelected = this.createDocumentStore.selectedAnnotations.some((ids)=>ids===annotId);
                    console.log(getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY)
                    if (getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY) {
                      // console.log('X:'+getLeft+'Y:'+getTop + '----' + 'width:' + getWidth + 'height:' + getHeight);
                      // let markback:any = getAllCanvasElements[ma];
                      // this.colorBorder(markback);
                      // // markback.style.backgroundColor = "red";
                      // this.createDocumentStore.selectedAnnotations.push(annotId);
                      filterCanvas.push(getAllCanvasElements[ma]);
                    }
                    // else if(getLeft<=clickPositionX && EndPointX>=clickPositionX && getTop<=clickPositionY && EndPointY>=clickPositionY && alreadySelected==true){
                    //   let removeIndex = this.createDocumentStore.selectedAnnotations.findIndex((ids)=>ids===annotId);
                    //   this.createDocumentStore.selectedAnnotations.splice(removeIndex,1);
                    //   let markback:any = getAllCanvasElements[ma];
                    //   this.transparentBorder(markback);
                    //   break;
                    // }
                  }
                  let callAPIEnable = false;

                  if (this.createDocumentStore.selectedAnnotations.length == 0 && filterCanvas.length > 0) {
                    let annotId = filterCanvas[0].getAttribute('id');
                    this.createDocumentStore.selectedAnnotations.push(annotId);
                    filterCanvas[0].setAttribute('multimoving', '1');
                    this.colorBorderSVG(filterCanvas[0]);
                    callAPIEnable = true;
                    this.getMultipleMovingLabelElement(annotId);
                  }
                  else if (this.createDocumentStore.selectedAnnotations.length != 0 && filterCanvas.length > 0) {
                    var canExecute = true;
                    let cloneFilterCVanvas = _.cloneDeep(filterCanvas)
                    for (let f = 0; f < filterCanvas.length; f++) {
                      if (canExecute == true) {
                        for (let g = 0; g < this.createDocumentStore.selectedAnnotations.length; g++) {
                          cloneFilterCVanvas = cloneFilterCVanvas.filter((canvas) => canvas.getAttribute('id') != this.createDocumentStore.selectedAnnotations[g])
                        }
                        if (cloneFilterCVanvas.length > 0) {
                          let annotId = cloneFilterCVanvas[0].getAttribute('id');
                          this.createDocumentStore.selectedAnnotations.push(annotId);
                          cloneFilterCVanvas[f].setAttribute('multimoving', '1');
                          this.colorBorderSVG(cloneFilterCVanvas[f]);
                          callAPIEnable = true;
                          canExecute = false;
                          this.getMultipleMovingLabelElement(annotId);
                        } else {
                          var iVal = 0;
                          do {
                            if (this.createDocumentStore.selectedAnnotations.length > iVal) {
                              let canvasfiltered = filterCanvas.filter((element) => element.getAttribute('id') === this.createDocumentStore.selectedAnnotations[iVal]);
                              if (canvasfiltered.length > 0) {
                                console.log(this.multiselectionList);
                                let findMultiRemoving = this.multiselectionList.filter((dataRes) => dataRes.annotation_id != this.createDocumentStore.selectedAnnotations[iVal]);
                                // need to work svg
                                this.multiselectionList = findMultiRemoving;
                                // draw side bar multiple_annotations when local changes happened in the multiselection list 
                                await this.drawing_multiple_annotations();
                                this.getMultipleMovingLabelElementRemove(this.createDocumentStore.selectedAnnotations[iVal]);
                                this.createDocumentStore.selectedAnnotations.splice(iVal, 1);


                                canvasfiltered[0].removeAttribute('multimoving');
                                this.transparentBorderSVG(canvasfiltered[0]);
                                callAPIEnable = false;
                                //this.createDocumentStore.selectedAnnotations
                                canExecute = false;
                              }
                              else {
                                iVal += 1
                              }
                            } else {
                              canExecute = false;
                            }
                          } while (canExecute)
                          // this.createDocumentStore.selectedAnnotations.splice(f, 1);
                          // this.transparentBorder(filterCanvas[f]);
                          //this.createDocumentStore.selectedAnnotations
                        }
                      }
                    }
                    // let alreadySelected = this.createDocumentStore.selectedAnnotations.some((ids) => ids === annotId);
                    // if (alreadySelected == true) {
                    //   this.createDocumentStore.selectedAnnotations.splice(f, 1);
                    //   this.transparentBorder(filterCanvas[f]);
                    //   break;
                    // }
                    // else {
                    //   this.createDocumentStore.selectedAnnotations.push(annotId);
                    //   this.colorBorder(filterCanvas[f]);
                    //   break;
                    // }
                  }
                  if (this.createDocumentStore.selectedAnnotations.length > 0 && callAPIEnable == true) {
                    this.multipleAnnotationCallAPI();
                  }
                  else if (callAPIEnable == false) {
                    this.get_Multiselection_Data_Count();
                  }
                  else {
                    this.selectAnnotationZero();
                  }
                  currentX = 0;
                  currentY = 0;
                  initialY = 0;
                  initialX = 0;
                }
                else if (mousedowntrigger == true && mousedrag == true && (this.getSelectedElements.length == 0 || this.getSelectedElements == null || this.createDocumentStore.selectedAnnotations.length == 0)) {
                  //jose drag select    
                  mousedrag = false;
                  mousedowntrigger = false;
                  console.log('mouse_up');
                  const rect = newcreatedElement.getBoundingClientRect();
                  if (previousPosition.x > currentPosition.x) {
                    let cloneCurrentX = previousPosition.x;
                    previousPosition.x = currentPosition.x;
                    currentPosition.x = cloneCurrentX;
                  }
                  if (previousPosition.y > currentPosition.y) {
                    let cloneCurrentY = previousPosition.y;
                    previousPosition.y = currentPosition.y;
                    currentPosition.y = cloneCurrentY;
                  }
                  let startPositionX = previousPosition.x;
                  let startPositionY = previousPosition.y;
                  console.log(startPositionX, startPositionY, e);
                  let getAllCanvasElements = document.querySelectorAll('svg.documentSVG');
                  var filterCanvas = [];
                  // console.log(getAllCanvasElements);
                  for (let ma = 0; ma < getAllCanvasElements.length; ma++) {
                    let getAllElementsXY: any = getAllCanvasElements[ma];
                    let getStyle = getComputedStyle(getAllElementsXY);
                    let getLeft: any = getStyle.left;
                    getLeft = getLeft.substring(getLeft.length - 2, 0);
                    let getTop: any = getStyle.top;
                    getTop = getTop.substring(getTop.length - 2, 0);
                    let getWidth: any = getStyle.width;
                    getWidth = getWidth.substring(getWidth.length - 2, 0);
                    let getHeight: any = getStyle.height;
                    getHeight = getHeight.substring(getHeight.length - 2, 0);
                    let checkBoundingBox = false;
                    getLeft = Number(getLeft);
                    getTop = Number(getTop);
                    getWidth = Number(getWidth);
                    getHeight = Number(getHeight);
                    let EndPointX = currentPosition.x;
                    let EndPointY = currentPosition.y;
                    let get_full_width = getLeft + getWidth;
                    let get_full_height = getTop + getHeight;
                    let inside_bound_values = (getLeft >= startPositionX && EndPointX >= getLeft && getTop >= startPositionY && EndPointY >= getTop) || (getLeft >= startPositionX && EndPointX >= getLeft && getTop >= startPositionY && EndPointY >= getTop)
                    //if ((getLeft >= startPositionX && EndPointX >= getLeft && getTop >= startPositionY && EndPointY >= getTop)) {
                    if ((getLeft > startPositionX && getLeft < EndPointX && getTop > startPositionY && getTop < EndPointY) || (getLeft < startPositionX && get_full_width > EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && getTop > startPositionY && getTop < EndPointY) || (getLeft > startPositionX && getLeft < EndPointX && get_full_height > startPositionY && get_full_height < EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && get_full_height > startPositionY && get_full_height < EndPointY) || (getLeft > startPositionX && getLeft < EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (getTop > startPositionY && getTop < EndPointY && getLeft < startPositionX && get_full_width > EndPointX) || (get_full_height > startPositionY && get_full_height < EndPointY && getLeft < startPositionX && get_full_width > EndPointX)) {
                      filterCanvas.push(getAllCanvasElements[ma]);
                    }
                  }
                  if (this.createDocumentStore.selectedAnnotations.length == 0 && filterCanvas.length > 0) {
                    for (let fc = 0; fc < filterCanvas.length; fc++) {
                      let annotId = filterCanvas[fc].getAttribute('id');
                      filterCanvas[fc].setAttribute('multimoving', '1');
                      this.createDocumentStore.selectedAnnotations.push(annotId);
                      this.colorBorderSVG(filterCanvas[fc]);
                      this.getMultipleMovingLabelElement(annotId);
                    }
                  }
                  else if (this.createDocumentStore.selectedAnnotations.length != 0 && filterCanvas.length > 0) {
                    for (let f = 0; f < filterCanvas.length; f++) {
                      let annotId = filterCanvas[f].getAttribute('id');
                      let alreadySelected = this.createDocumentStore.selectedAnnotations.some((ids) => ids === annotId);
                      if (alreadySelected == false) {
                        this.createDocumentStore.selectedAnnotations.push(annotId);
                        filterCanvas[f].setAttribute('multimoving', '1');
                        this.colorBorderSVG(filterCanvas[f]);
                        this.getMultipleMovingLabelElement(annotId);
                      }
                    }
                  }
                  console.log(this.createDocumentStore.selectedAnnotations);
                  let tempArray = this.createDocumentStore.selectedAnnotations;
                  this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
                    return index === self.indexOf(elem);
                  });
                  this.createDocumentStore.multipleDragSelectCanvas.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);
                  // need to add multiple api calling
                  if (this.createDocumentStore.selectedAnnotations.length > 0) {
                    this.multiple_annotation_api_calling();
                  }
                  currentX = 0;
                  currentY = 0;
                  initialY = 0;
                  initialX = 0;
                }
              })),
              // pairwise lets us get the previous value to draw a line from
              // the previous point to the current point
              pairwise()
            );

          }
        })
      )
      .subscribe((res: [MouseEvent, MouseEvent]) => {

        if (this.moveOverBoundary == true) {
          return
        }

        const prevPos = {
          x: initialX,
          y: initialY,
        };

        const currentPos = {
          x: res[1].offsetX,
          y: res[1].offsetY,
        };
        // this method we'll implement soon to do the actual drawing
        console.log('condition', this.createDocumentStore.selectedAnnotations.length == 0, this.getSelectedElements == null, this.getSelectedElements.length == 0);
        if (this.createDocumentStore.selectedAnnotations.length == 0 || this.getSelectedElements == null || this.getSelectedElements.length == 0) {
          this.createDocumentStore.multipleDragSelectCanvas.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height); //clear canvas
          this.createDocumentStore.multipleDragSelectCanvas.beginPath();
          let currentValue = this.drawOnCanvasMultiRectangle(prevPos, currentPos);
          previousPosition = currentValue.prevPosition;
          console.log(previousPosition);
          currentPosition = currentValue.currPosition;
        }
        else {
          let currentValue = this.drawOnCanvasMove(prevPos, currentPos);
          currentX = currentValue.x;
          currentY = currentValue.y;
        }
      });
  }

  private drawOnCanvasMove(
    prevPos: { x: number; y: number },
    currentPos: { x: number; y: number },
  ) {
    prevPos.x = prevPos.x;
    prevPos.y = prevPos.y;
    currentPos.x = currentPos.x;
    currentPos.y = currentPos.y;
    let newPointX = currentPos.x - prevPos.x;
    let newPointY = currentPos.y - prevPos.y;
    for (let i = 0; i < this.getSelectedElements.length; i++) {
      let getAttribute_element = this.getSelectedElements[i].getAttribute('id');
      let filter_element_data = this.multiselectionList.filter((rData) => rData.annotation_id == getAttribute_element);
      if (filter_element_data.length > 0) {
        if (filter_element_data[0].initial_rotation != undefined && filter_element_data[0].initial_rotation != 0 && filter_element_data[0].toolbar_element_id <= 11) {
          let dx = filter_element_data[0].initial_rotation > 0 ? (this.getSelectedElements[i].width / 2) : (-15);
          let dy = filter_element_data[0].initial_rotation > 0 ? (-15) : this.getSelectedElements[i].height / 2;
          let get_points = this.checkBoundsMoving(this.getSelectedElements[i], newPointX, newPointY);
          console.log(get_points);
          newPointX = get_points.newPointX;
          newPointY = get_points.newPointY;
          this.getSelectedElements[i].style.transform = 'matrix(' + Math.cos(filter_element_data[0].initial_rotation) + ',' + Math.sin(filter_element_data[0].initial_rotation) + ',' + -(Math.sin(filter_element_data[0].initial_rotation)) + ',' + Math.cos(filter_element_data[0].initial_rotation) + ',' + newPointX + ',' + newPointY + ')';
        }
        else {
          let get_points = this.checkBoundsMoving(this.getSelectedElements[i], newPointX, newPointY);
          console.log(get_points);
          newPointX = get_points.newPointX;
          newPointY = get_points.newPointY;
          this.getSelectedElements[i].style.transform = "translate3d(" + newPointX + "px, " + newPointY + "px, 0)";
        }
      }
      // this.getSelectedElements[i].style.transform = "translate3d(" + newPointX + "px, " + newPointY + "px, 0)";
      this.getSelectedElements[i].style.zIndex = "2";
    }
    for (let j = 0; j < this.createDocumentStore.movelabelElement.length; j++) {
      let getAttribute_element = this.createDocumentStore.movelabelElement[j].getAttribute('id');
      let split_value = getAttribute_element.replace('label', '');
      console.log('labelid', getAttribute_element, split_value);
      let filter_label_element_data = this.multiselectionList.filter((rData) => rData.annotation_id == split_value);
      if (filter_label_element_data.length > 0) {
        if (filter_label_element_data[0].initial_rotation != undefined && filter_label_element_data[0].initial_rotation != 0 && filter_label_element_data[0].toolbar_element_id <= 11) {
          let dx = filter_label_element_data[0].initial_rotation > 0 ? (this.createDocumentStore.movelabelElement[j].width / 2) : (-15);
          let dy = filter_label_element_data[0].initial_rotation > 0 ? (-15) : this.createDocumentStore.movelabelElement[j].height / 2;
          this.createDocumentStore.movelabelElement[j].style.transform = 'matrix(' + Math.cos(filter_label_element_data[0].initial_rotation) + ',' + Math.sin(filter_label_element_data[0].initial_rotation) + ',' + -(Math.sin(filter_label_element_data[0].initial_rotation)) + ',' + Math.cos(filter_label_element_data[0].initial_rotation) + ',' + newPointX + ',' + newPointY + ')';
        } else {
          this.createDocumentStore.movelabelElement[j].style.transform = "translate3d(" + newPointX + "px, " + newPointY + "px, 0)";
        }
      }
      // this.createDocumentStore.movelabelElement[j].style.transform = "translate3d(" + newPointX + "px, " + newPointY + "px, 0)";
      this.createDocumentStore.movelabelElement[j].style.zIndex = "3";
    }
    return { x: newPointX, y: newPointY };
  }

  multiple_annotation_api_calling(from_source?: string) {
    this.show = true;
    this.documentService.getMultipleAnnotationData(this.createDocumentStore.selectedAnnotations).subscribe((response) => {
      console.log(response);
      if (response["response_code"] == 200) {
        // this.multiselectionList = response["response_body"]["annotation_data"];
        this.multiselectionList = response["response_body"];
        this.selectedAnnotationLength = this.multiselectionList.length;
        this.optionClick = false;
        this.hideSelectForm = true;
        this.sampleFormObject = [];
        this.modelFieldsForm = [];
        this.extend_modelFieldsForm = [];
        this.annotationSelected = true;
        for (let ma = 0; ma < this.multiselectionList.length; ma++) {
          let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.multiselectionList[ma].layer_id);
          if (findLayerIndex != -1) {
            let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == this.multiselectionList[ma].annotation_id);
            if (findAnnotationIndexS != -1) {
              this.multiselectionList[ma].initial_position_x = this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS].initial_position_x;
              this.multiselectionList[ma].initial_position_y = this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS].initial_position_y;
              this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS] = this.multiselectionList[ma];
              this.backup_annot_storage(this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS]); // call backup annotation function
            }
          }
        }
        this.getCounts();
        if (this.form == true) {
          this.formiconClick();
        }
        else if (this.media == true) {
          this.mediaIconClick();
        }
        else if (this.links == true) {
          this.linkIconClick();
        }
        else if (this.tags == true) {
          this.tagIconClick();
        }
        else if (this.properties == true) {
          this.propertyIconClick();
        }
      }
    })
  }

  get_Multiselection_Data_Count() {

    if (this.multiselectionList.length > 0) {
      this.selectedAnnotationLength = this.multiselectionList.length;
      this.optionClick = false;
      this.hideSelectForm = true;
      this.sampleFormObject = [];
      this.modelFieldsForm = [];
      this.extend_modelFieldsForm = [];
      this.annotationSelected = true;
      this.getCounts();
      if (this.form == true) {
        this.formiconClick();
      }
      else if (this.media == true) {
        this.mediaIconClick();
      }
      else if (this.links == true) {
        this.linkIconClick();
      }
      else if (this.tags == true) {
        this.tagIconClick();
      }
      else if (this.properties == true) {
        this.propertyIconClick();
      }
    }
    else {
      this.selectAnnotationZero();
    }
  }

  private captureEventsMoveSingle() {
    var pdfImg = document.getElementById("pdfImg");
    let newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeMoveAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    pdfImg.appendChild(newcreatedElement);
    // var canvasEl: HTMLCanvasElement = this.createElementChanged;
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    this.createDocumentStore.singlemoveElement = newcreatedElement.getContext("2d");
    let initialX: number, initialY: number, currentX = 0, currentY = 0;
    let mousedowntrigger = false, mousedrag = false;
    fromEvent(newcreatedElement, "mousedown")
      .pipe(
        switchMap((e: MouseEvent) => {
          if (this.isReadonly != true) {
            e.preventDefault();
            console.log(e);
            mousedowntrigger = true;
            mousedrag = false;
            this.annotationselectEnableDisable('enable');
            initialX = (e.offsetX);
            initialY = (e.offsetY);
            this.getSelectedElements = document.getElementById(this.currentSelectedAnnotationData.annotation_id);
            this.createDocumentStore.movelabelElement = document.getElementById('label' + this.currentSelectedAnnotationData.annotation_id);
            console.log(this.getSelectedElements);
            // disable drag scroll
            this.createDocumentStore.disable_drag_scroll = true;
            //jose added for rotation
            // if (this.currentSelectedAnnotationData.initial_rotation != undefined && this.currentSelectedAnnotationData.initial_rotation != 0) {
            //   let dx = this.currentSelectedAnnotationData.initial_rotation > 0 ? (this.getSelectedElements.width / 2) : (-15);
            //   let dy = this.currentSelectedAnnotationData.initial_rotation > 0 ? (-15) : this.getSelectedElements.height / 2;
            //   this.getSelectedElements.style.transform = 'matrix(' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + Math.sin(this.currentSelectedAnnotationData.initial_rotation) + ',' + -(Math.sin(this.currentSelectedAnnotationData.initial_rotation)) + ',' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + 0 + ',' + 0 + ')';
            //   console.log('matrix(' + Math.cos(this.currentSelectedAnnotationData.initial_rotation), Math.sin(this.currentSelectedAnnotationData.initial_rotation), -(Math.sin(this.currentSelectedAnnotationData.initial_rotation)), Math.cos(this.currentSelectedAnnotationData.initial_rotation), dx, dy + ')');
            //   // console.log(this.canvasElement.getTransform());
            //   // this.canvasElement.restore();
            // }
            // after a mouse down, we'll record all mouse moves
            return fromEvent(newcreatedElement, "mousemove").do(() => {
              mousedrag = true;
            }).pipe(
              // we'll stop (and unsubscribe) once the user releases the mouse
              // this will trigger a 'mouseup' event
              takeUntil(
                fromEvent(newcreatedElement, "mouseup").do(() => {
                  mouse_up_action_move(e);
                })
              ),
              // we'll also stop (and unsubscribe) once the mouse leaves the canvas (mouseleave event)
              takeUntil(fromEvent(newcreatedElement, "mouseleave").do(() => {
                mouse_up_action_move(e);
              })),
              // pairwise lets us get the previous value to draw a line from
              // the previous point to the current point
              pairwise()
            );

          }
        })
      )
      .subscribe((res: [MouseEvent, MouseEvent]) => {
        // const rect = newcreatedElement.getBoundingClientRect();
        const prevPos = {
          x: initialX,
          y: initialY,
        };

        const currentPos = {
          x: res[1].offsetX,
          y: res[1].offsetY,
        };
        // this method we'll implement soon to do the actual drawing
        let currentValue = this.drawOnCanvasMoveSingle(prevPos, currentPos);
        currentX = currentValue.x;
        currentY = currentValue.y;
      });

    const mouse_up_action_move = async (e) => {
      // disable drag scroll
      this.createDocumentStore.disable_drag_scroll = false;
      if (mousedowntrigger == true && mousedrag == true && this.getSelectedElements != null) {
        mousedowntrigger = false;
        console.log('mouse_up');
        this.getSelectedElements.style.transform = "translate3d(" + 0 + "px, " + 0 + "px, 0)";
        let getStyle = getComputedStyle(this.getSelectedElements);
        let getMarginLeft = getStyle.marginLeft;
        getMarginLeft = getMarginLeft.substring(getMarginLeft.length - 2, 0);
        let getMarginTop = getStyle.marginTop;
        getMarginTop = getMarginTop.substring(getMarginTop.length - 2, 0);
        console.log(getMarginLeft, getMarginTop);
        //get current annotation left and top
        let get_element_left = getStyle.left;
        get_element_left = get_element_left.substring(get_element_left.length - 2, 0);
        let get_element_top = getStyle.top;
        get_element_top = get_element_top.substring(get_element_top.length - 2, 0);
        // this.getSelectedElements.style.left = currentX < this.realWidth - this.getSelectedElements.clientWidth ? this.getSelectedElements.offsetLeft + currentX - Number(getMarginLeft) + "px" : this.realWidth - this.getSelectedElements.clientWidth + "px";
        // this.getSelectedElements.style.top = currentY < this.realHeight - this.getSelectedElements.clientHeight ? this.getSelectedElements.offsetTop + currentY - Number(getMarginTop) + "px" : this.realHeight - this.getSelectedElements.clientHeight + "px";
        this.getSelectedElements.style.left = currentX < this.realWidth - this.getSelectedElements.clientWidth ? Number(get_element_left) + currentX + "px" : this.realWidth - this.getSelectedElements.clientWidth + "px";
        this.getSelectedElements.style.top = currentY < this.realHeight - this.getSelectedElements.clientHeight ? Number(get_element_top) + currentY + "px" : this.realHeight - this.getSelectedElements.clientHeight + "px";
        this.getSelectedElements.style.zIndex = "1";
        //Annotation label element
        if (this.createDocumentStore.movelabelElement != null) {
          this.createDocumentStore.movelabelElement.style.transform = "translate3d(" + 0 + "px, " + 0 + "px, 0)";
          let getStylelabel = getComputedStyle(this.createDocumentStore.movelabelElement);
          let getMarginLeftlabel = getStylelabel.marginLeft;
          getMarginLeftlabel = getMarginLeftlabel.substring(getMarginLeftlabel.length - 2, 0);
          let getMarginToplabel = getStylelabel.marginTop;
          getMarginToplabel = getMarginToplabel.substring(getMarginToplabel.length - 2, 0);
          console.log(getMarginLeftlabel, getMarginToplabel)
          //get current annotation label left and top
          let get_label_element_left = getStylelabel.left;
          get_label_element_left = get_label_element_left.substring(get_label_element_left.length - 2, 0);
          let get_label_element_top = getStylelabel.top;
          get_label_element_top = get_label_element_top.substring(get_label_element_top.length - 2, 0);
          this.createDocumentStore.movelabelElement.style.left = currentX < this.realWidth - this.createDocumentStore.movelabelElement.clientWidth ? Number(get_label_element_left) + currentX - Number(getMarginLeftlabel) + "px" : this.realWidth - this.createDocumentStore.movelabelElement.clientWidth + "px";
          this.createDocumentStore.movelabelElement.style.top = currentY < this.realHeight - this.createDocumentStore.movelabelElement.clientHeight ? Number(get_label_element_top) + currentY - Number(getMarginToplabel) + "px" : this.realHeight - this.createDocumentStore.movelabelElement.clientHeight + "px";
          this.createDocumentStore.movelabelElement.style.zIndex = "2";
        }
        let currentLeftValue = currentX;
        let currentTopValue = currentY;
        currentX = 0;
        currentY = 0;
        initialY = 0;
        initialX = 0;
        console.log(currentLeftValue, currentTopValue);
        this.updateMoveAPI(this.currentSelectedAnnotationData.annotation_id, currentLeftValue, currentTopValue);
        this.annotationselectEnableDisable('remove');
      }
      else if (mousedrag == false) {
        let clickPosition = {
          x: initialX,
          y: initialY,
        };
        let clickPositionX = clickPosition.x;
        clickPositionX = clickPositionX + 10;
        let clickPositionY = clickPosition.y;
        clickPositionY = clickPositionY + 10;
        console.log(clickPositionX, clickPositionY, e);
        let getAllCanvasElements = document.querySelectorAll('svg.documentSVG');
        var filterCanvas = [];
        // console.log(getAllCanvasElements);
        for (let ma = 0; ma < getAllCanvasElements.length; ma++) {
          let getAllElementsXY: any = getAllCanvasElements[ma];
          let getStyle = getComputedStyle(getAllElementsXY);
          let getLeft: any = getStyle.left;
          getLeft = getLeft.substring(getLeft.length - 2, 0);
          let getTop: any = getStyle.top;
          getTop = getTop.substring(getTop.length - 2, 0);
          let getWidth: any = getStyle.width;
          getWidth = getWidth.substring(getWidth.length - 2, 0);
          let getHeight: any = getStyle.height;
          getHeight = getHeight.substring(getHeight.length - 2, 0);
          let checkBoundingBox = false;
          getLeft = Number(getLeft);
          getTop = Number(getTop);
          getWidth = Number(getWidth);
          getHeight = Number(getHeight);
          let EndPointX = getLeft + getWidth;
          let EndPointY = getTop + getHeight;
          // let annotId = getAllElementsXY.getAttribute('id');
          // let alreadySelected = this.createDocumentStore.selectedAnnotations.some((ids)=>ids===annotId);
          console.log(getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY)
          if (getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY) {
            // console.log('X:'+getLeft+'Y:'+getTop + '----' + 'width:' + getWidth + 'height:' + getHeight);
            // let markback:any = getAllCanvasElements[ma];
            // this.colorBorder(markback);
            // // markback.style.backgroundColor = "red";
            // this.createDocumentStore.selectedAnnotations.push(annotId);
            filterCanvas.push(getAllCanvasElements[ma]);
          }
          // else if(getLeft<=clickPositionX && EndPointX>=clickPositionX && getTop<=clickPositionY && EndPointY>=clickPositionY && alreadySelected==true){
          //   let removeIndex = this.createDocumentStore.selectedAnnotations.findIndex((ids)=>ids===annotId);
          //   this.createDocumentStore.selectedAnnotations.splice(removeIndex,1);
          //   let markback:any = getAllCanvasElements[ma];
          //   this.transparentBorder(markback);
          //   break;
          // }
        }
        let filter_canvas_anno = _.cloneDeep(filterCanvas);
        if (filter_canvas_anno.length > 0) {
          let is_locked_flag_value;
          for (let r = 0; r < filterCanvas.length; r++) {
            let annot_id_ = filterCanvas[r].getAttribute('id');
            for (let i = 0; i < this.layerDatas.length; i++) {
              let annotations = this.layerDatas[i]["annotations"].filter(annotation => annotation.annotation_id == annot_id_)
              if (annotations.length > 0) {
                let associated_pages = this.layerDatas[i].associated_pages
                let page_element = associated_pages.filter(ele => ele.page_id == this.currentPageId)
                this.activeLayerIdDraw = page_element[0].layer_id;
                is_locked_flag_value = page_element.length > 0 ? page_element[0].is_lock : "false"
              }
            }
            console.log(is_locked_flag_value)
            if (is_locked_flag_value == "true" || is_locked_flag_value == true || is_locked_flag_value == "1") {
              let itemIndex = filter_canvas_anno.findIndex(data => data.getAttribute('id') == annot_id_);
              if (itemIndex != -1) {
                filter_canvas_anno.splice(itemIndex, 1);
              }
            }
          }
        }
        filterCanvas = filter_canvas_anno;
        if (this.createDocumentStore.selectedAnnotations.length == 0 && filterCanvas.length > 0) {
          let annotId = filterCanvas[0].getAttribute('id');
          this.getId = annotId;
          this.createDocumentStore.selectedAnnotations.push(annotId);
          this.colorBorderSVG(filterCanvas[0]);
          this.getSelectedElements = filterCanvas[0];
          this.createDocumentStore.movelabelElement = document.getElementById('label' + annotId);
        }
        else if (this.createDocumentStore.selectedAnnotations.length != 0 && filterCanvas.length > 0) {
          var canExecute = true;
          let cloneFilterCVanvas = _.cloneDeep(filterCanvas)
          for (let f = 0; f < filterCanvas.length; f++) {
            if (canExecute == true) {
              for (let g = 0; g < this.createDocumentStore.selectedAnnotations.length; g++) {
                cloneFilterCVanvas = cloneFilterCVanvas.filter((canvas) => canvas.getAttribute('id') != this.createDocumentStore.selectedAnnotations[g])
              }
              if (cloneFilterCVanvas.length > 0) {
                let annotId = cloneFilterCVanvas[0].getAttribute('id');
                this.createDocumentStore.selectedAnnotations = [];
                this.getId = annotId;
                this.createDocumentStore.selectedAnnotations.push(annotId);
                this.colorBorderSVG(cloneFilterCVanvas[f]);
                this.getSelectedElements = cloneFilterCVanvas[f];
                this.createDocumentStore.movelabelElement = document.getElementById('label' + annotId);
                break;
              } else {
                this.transparentBorderSVG(filterCanvas[f]);
                this.createDocumentStore.selectedAnnotations.splice(f, 1);
                break;
              }
            }
          }
        }
        else if (filterCanvas.length == 0) {
          this.createDocumentStore.selectedAnnotations = [];
        }
        if (this.createDocumentStore.selectedAnnotations.length > 0) {
          let already_exist = false;
          for (let km = 0; km < this.layerDatas.length; km++) {
            let find_annotation = this.layerDatas[km].annotations.filter((data_annot) => data_annot.annotation_id === this.createDocumentStore.selectedAnnotations[0]);
            if (find_annotation.length > 0) {
              if (Array.isArray(find_annotation[0].annotation_forms)) {
                console.log('already select single annotation');
                this.newplotannotationSelection(find_annotation[0]);
              }
              else {
                debugger
                this.canvasClick(this.createDocumentStore.selectedAnnotations[0]);
              }
            }
          }
        }
        else {
          this.deselectAnnotation();
        }
        // reset click and drag move values
      }
      else if (mousedowntrigger == true && mousedrag == true && this.getSelectedElements == null) {
        currentX = 0;
        currentY = 0;
        initialY = 0;
        initialX = 0;
      }
      //jose added for rotation
      if (this.getSelectedElements != null) {
        if (this.currentSelectedAnnotationData.initial_rotation != undefined && this.currentSelectedAnnotationData.initial_rotation != 0 && this.currentSelectedAnnotationData.annotation_id == this.getSelectedElements.id && this.currentSelectedAnnotationData.toolbar_element_id <= 11) {
          console.log("First click", this.currentSelectedAnnotationData, this.getSelectedElements)
          let dx = this.currentSelectedAnnotationData.initial_rotation > 0 ? (this.getSelectedElements.width / 2) : (-15);
          let dy = this.currentSelectedAnnotationData.initial_rotation > 0 ? (-15) : this.getSelectedElements.height / 2;
          this.getSelectedElements.style.transform = 'matrix(' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + Math.sin(this.currentSelectedAnnotationData.initial_rotation) + ',' + -(Math.sin(this.currentSelectedAnnotationData.initial_rotation)) + ',' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + 0 + ',' + 0 + ')';
          // console.log(this.canvasElement.getTransform());
          // this.canvasElement.restore();
          // this.getSelectedElements.style.zIndex = "3";
        }
      }
      if (this.createDocumentStore.movelabelElement != null) {
        // this.createDocumentStore.movelabelElement.style.transform = "translate3d(" + newPointX + "px, " + newPointY + "px, 0)";
        if (this.currentSelectedAnnotationData.initial_rotation != undefined && this.currentSelectedAnnotationData.initial_rotation != 0 && this.currentSelectedAnnotationData.toolbar_element_id <= 11) {
          let dx = this.currentSelectedAnnotationData.initial_rotation > 0 ? (this.getSelectedElements.width / 2) : (-15);
          let dy = this.currentSelectedAnnotationData.initial_rotation > 0 ? (-15) : this.getSelectedElements.height / 2;
          this.createDocumentStore.movelabelElement.style.transform = 'matrix(' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + Math.sin(this.currentSelectedAnnotationData.initial_rotation) + ',' + -(Math.sin(this.currentSelectedAnnotationData.initial_rotation)) + ',' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + 0 + ',' + 0 + ')';
        }
        // this.createDocumentStore.movelabelElement.style.zIndex = "3";
      }
    }
  }

  private drawOnCanvasMoveSingle(
    prevPos: { x: number; y: number },
    currentPos: { x: number; y: number },
  ) {
    prevPos.x = prevPos.x;
    prevPos.y = prevPos.y;
    currentPos.x = currentPos.x;
    currentPos.y = currentPos.y;
    let newPointX = currentPos.x - prevPos.x;
    let newPointY = currentPos.y - prevPos.y;
    if (this.getSelectedElements != null) {
      if (this.currentSelectedAnnotationData.initial_rotation != undefined && this.currentSelectedAnnotationData.initial_rotation != 0 && this.currentSelectedAnnotationData.toolbar_element_id <= 11) {

        let deg = this.currentSelectedAnnotationData.initial_rotation;
        var h = this.getSelectedElements.height * Math.abs(Math.cos(deg)) + this.getSelectedElements.width * Math.abs(Math.sin(deg));
        var w = this.getSelectedElements.width * Math.abs(Math.cos(deg)) + this.getSelectedElements.height * Math.abs(Math.sin(deg));
        console.log('after rotate transform', w, h);
        console.log('before using width', this.getSelectedElements.width, this.getSelectedElements.height);
        let dx = this.currentSelectedAnnotationData.initial_rotation > 0 ? (this.getSelectedElements.width / 2) : (-15);
        let dy = this.currentSelectedAnnotationData.initial_rotation > 0 ? (-15) : this.getSelectedElements.height / 2;
        let get_points = this.checkBoundsMoving(this.getSelectedElements, newPointX, newPointY);
        console.log(get_points);
        newPointX = get_points.newPointX;
        newPointY = get_points.newPointY;
        this.getSelectedElements.style.transform = 'matrix(' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + Math.sin(this.currentSelectedAnnotationData.initial_rotation) + ',' + -(Math.sin(this.currentSelectedAnnotationData.initial_rotation)) + ',' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + newPointX + ',' + newPointY + ')';
      } else {
        let get_points = this.checkBoundsMoving(this.getSelectedElements, newPointX, newPointY);
        newPointX = get_points.newPointX;
        newPointY = get_points.newPointY;
        console.log(get_points);
        this.getSelectedElements.style.transform = "translate3d(" + newPointX + "px, " + newPointY + "px, 0)";
      }
      this.getSelectedElements.style.zIndex = "2";
    }
    if (this.createDocumentStore.movelabelElement != null) {
      // this.createDocumentStore.movelabelElement.style.transform = "translate3d(" + newPointX + "px, " + newPointY + "px, 0)";

      if (this.currentSelectedAnnotationData.initial_rotation != undefined && this.currentSelectedAnnotationData.initial_rotation != 0 && this.currentSelectedAnnotationData.toolbar_element_id <= 11) {
        let dx = this.currentSelectedAnnotationData.initial_rotation > 0 ? (this.getSelectedElements.width / 2) : (-15);
        let dy = this.currentSelectedAnnotationData.initial_rotation > 0 ? (-15) : this.getSelectedElements.height / 2;
        this.createDocumentStore.movelabelElement.style.transform = 'matrix(' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + Math.sin(this.currentSelectedAnnotationData.initial_rotation) + ',' + -(Math.sin(this.currentSelectedAnnotationData.initial_rotation)) + ',' + Math.cos(this.currentSelectedAnnotationData.initial_rotation) + ',' + newPointX + ',' + newPointY + ')';
      } else {
        this.createDocumentStore.movelabelElement.style.transform = "translate3d(" + newPointX + "px, " + newPointY + "px, 0)";
      }

      this.createDocumentStore.movelabelElement.style.zIndex = "3";
    }
    return { x: newPointX, y: newPointY };
  }

  checkBoundsMoving(moveelement: Element, newPointX: number, newPointY: number) {
    let get_element_Style = getComputedStyle(moveelement);
    let get_element_Left: any = get_element_Style.left;
    get_element_Left = get_element_Left.substring(get_element_Left.length - 2, 0);
    let get_element_Top: any = get_element_Style.top;
    get_element_Top = get_element_Top.substring(get_element_Top.length - 2, 0);
    let get_element_marleft: any = get_element_Style.marginLeft;
    get_element_marleft = get_element_marleft.substring(get_element_marleft.length - 2, 0);
    let get_element_martop: any = get_element_Style.marginTop;
    get_element_martop = get_element_martop.substring(get_element_martop.length - 2, 0);
    let get_element_Width: any = get_element_Style.width;
    get_element_Width = get_element_Width.substring(get_element_Width.length - 2, 0);
    let get_element_Height: any = get_element_Style.height;
    get_element_Height = get_element_Height.substring(get_element_Height.length - 2, 0);
    console.log(newPointX, newPointY);
    console.log(typeof get_element_Left, typeof newPointX, typeof get_element_marleft);

    // let deg = this.currentSelectedAnnotationData.initial_rotation;
    // var h = this.getSelectedElements.height * Math.abs(Math.cos(deg)) + this.getSelectedElements.width * Math.abs(Math.sin(deg));
    // var w = this.getSelectedElements.width * Math.abs(Math.cos(deg)) + this.getSelectedElements.height * Math.abs(Math.sin(deg));
    // get_element_Width = w;
    // get_element_Height = h;
    let checkBounds_left = Number(get_element_Left) + newPointX + Number(get_element_marleft);
    let checkBounds_top = Number(get_element_Top) + newPointY + Number(get_element_martop);
    let checkBounds_right = Number(get_element_Left) + newPointX + Number(get_element_Width) + Number(get_element_marleft);
    let checkBounds_bottom = Number(get_element_Top) + newPointY + Number(get_element_Height) + Number(get_element_martop);
    console.log(checkBounds_right, checkBounds_bottom);
    if (checkBounds_left < 0) {
      console.log(checkBounds_left, checkBounds_top);
      newPointX = newPointX - (checkBounds_left);
      this.moveOverBoundary = true;
    }
    else if (checkBounds_right > this.realWidth) {
      let difference = Number(checkBounds_right) - Number(this.realWidth);
      newPointX = newPointX - difference;
      console.log(newPointX);
      this.moveOverBoundary = true;
    }
    if (checkBounds_top < 0) {
      newPointY = newPointY - (checkBounds_top);
      this.moveOverBoundary = true;
    }
    else if (checkBounds_bottom > this.realHeight) {
      let difference = Number(checkBounds_bottom) - Number(this.realHeight);
      newPointY = newPointY - difference;
      this.moveOverBoundary = true;
    }
    return { "newPointX": newPointX, "newPointY": newPointY }
  }

  multipleAnnotationCallAPI() {
    let getAnnotationId = [];
    let getLastIndex = this.createDocumentStore.selectedAnnotations.length - 1;
    getAnnotationId.push(this.createDocumentStore.selectedAnnotations[getLastIndex]);
    let alreadyExitData = false;
    for (let layer = 0; layer < this.layerDatas.length; layer++) {
      let findAnnotationIndexSAlready = this.layerDatas[layer].annotations.findIndex((ADAta) => ADAta.annotation_id == getAnnotationId[0]);
      if (findAnnotationIndexSAlready != -1) {
        let get_annot_verify = this.layerDatas[layer].annotations[findAnnotationIndexSAlready];
        if (typeof get_annot_verify.annotation_forms == 'number') {
          console.log(getAnnotationId);
          this.documentService.getMultipleAnnotationData(getAnnotationId).subscribe((response) => {
            console.log(response);
            if (response["response_code"] == 200) {
              if (response["response_body"][0] != undefined) {
                // this.multiselectionList.push(response["response_body"]["annotation_data"][0]);
                this.multiselectionList.push(response["response_body"][0]);
                console.log(this.multiselectionList);
                this.selectedAnnotationLength = this.multiselectionList.length;
                this.optionClick = false;
                this.hideSelectForm = true;
                this.sampleFormObject = [];
                this.modelFieldsForm = [];
                this.extend_modelFieldsForm = [];
                this.annotationSelected = true;
                // let get_click_canvas_data = response["response_body"]["annotation_data"][0];
                let get_click_canvas_data = response["response_body"][0];
                let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == get_click_canvas_data.layer_id);
                if (findLayerIndex != -1) {
                  let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == get_click_canvas_data.annotation_id);
                  if (findAnnotationIndexS != -1) {
                    this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS] = get_click_canvas_data;
                    this.backup_annot_storage(this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS]) // call back up annotation function
                  }
                }
                this.getCounts();
                if (this.form == true) {
                  this.formiconClick();
                }
                else if (this.media == true) {
                  this.mediaIconClick();
                }
                else if (this.links == true) {
                  this.linkIconClick();
                }
                else if (this.tags == true) {
                  this.tagIconClick();
                }
                else if (this.properties == true) {
                  this.propertyIconClick();
                }
              }
            }
          });
        }
        else {
          let pushAnnotation = this.layerDatas[layer].annotations[findAnnotationIndexSAlready];
          let index = this.multiselectionList.findIndex((data) => data.annotation_id == pushAnnotation.annotation_id);
          if (index != 0) {
            this.multiselectionList.push(pushAnnotation);
            this.backup_annot_storage(pushAnnotation) // call back up annotation function
          }
          console.log(this.multiselectionList);
          this.get_Multiselection_Data_Count();
        }
        break;
      }
    }

  }

  // multipleAnnotationCallAPI(){
  //   let getAnnotationId = [];
  //   getAnnotationId.push(this.createDocumentStore.selectedAnnotations[0]);
  //   this.documentService.getMultipleAnnotationData(getAnnotationId).subscribe((response)=>{
  //     console.log(response);
  //     if(response["response_code"]==200){
  //       this.multiselectionList = response["response_body"]["annotation_data"];
  //       this.selectedAnnotationLength = this.multiselectionList.length;
  //       this.optionClick = false;
  //       this.hideSelectForm = true;
  //       this.sampleFormObject = [];
  //       this.modelFieldsForm = [];
  //       this.annotationSelected = true;
  //       for (let ma = 0; ma < this.multiselectionList.length; ma++) {
  //         let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.multiselectionList[ma].layer_id);
  //         if (findLayerIndex != -1) {
  //           let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == this.multiselectionList[ma].annotation_id);
  //           if (findAnnotationIndexS != -1) {
  //             this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS] = this.multiselectionList[ma];
  //           }
  //         }
  //       }
  //       this.getCounts();
  //       if (this.form == true) {
  //         this.formiconClick();
  //       }
  //       else if (this.media == true) {
  //         this.mediaIconClick();
  //       }
  //       else if (this.links == true) {
  //         this.linkIconClick();
  //       }
  //       else if (this.tags == true) {
  //         this.tagIconClick();
  //       }
  //       else if (this.properties == true) {
  //         this.propertyIconClick();
  //       }
  //     }
  //   });
  // }

  captureEventsMultiple() {
    var pdfImg = document.getElementById("pdfImg");
    let newcreatedElement = document.createElement("canvas");
    newcreatedElement.setAttribute("width", this.realWidth);
    newcreatedElement.setAttribute("height", this.realHeight);
    newcreatedElement.setAttribute("customeMultipleAttribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    pdfImg.appendChild(newcreatedElement);
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    var previousPosition: any = "";
    var currentPosition: any = "";
    // var canvasEl: HTMLCanvasElement = this.createElementChanged;
    this.createDocumentStore.multipleDragSelectCanvas = newcreatedElement.getContext("2d");
    let initialX: number, initialY: number, currentX = 0, currentY = 0;
    let mousedowntrigger = false;
    let mousedrag = false;
    newcreatedElement.addEventListener("contextmenu", (e: any) => {
      e.preventDefault();
    });
    fromEvent(newcreatedElement, "mousedown")
      .pipe(
        switchMap((e: MouseEvent) => {
          e.preventDefault();
          mousedowntrigger = true;
          mousedrag = false;
          initialX = (e.offsetX);
          initialY = (e.offsetY);
          previousPosition = "";
          currentPosition = "";
          // disable drag scroll
          this.createDocumentStore.disable_drag_scroll = true;
          // after a mouse down, we'll record all mouse moves
          return fromEvent(newcreatedElement, "mousemove").do(() => {
            mousedrag = true;
          }).pipe(
            // we'll stop (and unsubscribe) once the user releases the mouse
            // this will trigger a 'mouseup' event
            takeUntil(
              fromEvent(newcreatedElement, "mouseup").do(async () => {
                mouse_up_action(e);
              })
            ),
            // we'll also stop (and unsubscribe) once the mouse leaves the canvas (mouseleave event)
            takeUntil(fromEvent(newcreatedElement, "mouseleave").do(() => {
              mouse_up_action(e);
            })),
            // pairwise lets us get the previous value to draw a line from
            // the previous point to the current point
            pairwise()
          );
        })
      )
      .subscribe((res: [MouseEvent, MouseEvent]) => {
        const rect = newcreatedElement.getBoundingClientRect();
        // console.log(rect);
        const prevPos = {
          x: initialX,
          y: initialY,
        };

        const currentPos = {
          x: res[1].offsetX,
          y: res[1].offsetY,
        };
        // this method we'll implement soon to do the actual drawing
        this.createDocumentStore.multipleDragSelectCanvas.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height); //clear canvas
        this.createDocumentStore.multipleDragSelectCanvas.beginPath();
        let currentValue = this.drawOnCanvasMultiRectangle(prevPos, currentPos);
        previousPosition = currentValue.prevPosition;
        // console.log(previousPosition);
        currentPosition = currentValue.currPosition;
      });

    const mouse_up_action = async(e) => {
        let starttime = this.functionstarttime('multi mouse up');
        e.preventDefault();
        // disable drag scroll
        this.createDocumentStore.disable_drag_scroll = false;
        if (mousedowntrigger == true && mousedrag == true) {
          //jose drag select    
          mousedrag = false;
          mousedowntrigger = false;
          console.log('mouse_up');
          const rect = newcreatedElement.getBoundingClientRect();
          if (previousPosition.x > currentPosition.x) {
            let cloneCurrentX = previousPosition.x;
            previousPosition.x = currentPosition.x;
            currentPosition.x = cloneCurrentX;
          }
          if (previousPosition.y > currentPosition.y) {
            let cloneCurrentY = previousPosition.y;
            previousPosition.y = currentPosition.y;
            currentPosition.y = cloneCurrentY;
          }
          let startPositionX = previousPosition.x;
          let startPositionY = previousPosition.y;
          let getAllCanvasElements = document.querySelectorAll('svg.documentSVG');
          var filterCanvas = [];
          let canvasst = this.functionstarttime('multiple')
          for (let ma = 0; ma < getAllCanvasElements.length; ma++) {
            let getAllElementsXY: any = getAllCanvasElements[ma];
            let getStyle = getComputedStyle(getAllElementsXY);
            let getLeft: any = getStyle.left;
            getLeft = getLeft.substring(getLeft.length - 2, 0);
            let getTop: any = getStyle.top;
            getTop = getTop.substring(getTop.length - 2, 0);
            let getWidth: any = getStyle.width;
            getWidth = getWidth.substring(getWidth.length - 2, 0);
            let getHeight: any = getStyle.height;
            getHeight = getHeight.substring(getHeight.length - 2, 0);
            let checkBoundingBox = false;
            getLeft = Number(getLeft);
            getTop = Number(getTop);
            getWidth = Number(getWidth);
            getHeight = Number(getHeight);
            let get_transform = getStyle.transform;
            let EndPointX = currentPosition.x;
            let EndPointY = currentPosition.y;
            let get_full_width = getLeft + getWidth;
            let get_full_height = getTop + getHeight;
            let getatt = getAllCanvasElements[ma].getAttribute('id');
            // checking if rotation has the shape x and y changes 
            //if ((getLeft >= startPositionX && EndPointX >= getLeft && getTop >= startPositionY && EndPointY >= getTop)) {
            if ((getLeft > startPositionX && getLeft < EndPointX && getTop > startPositionY && getTop < EndPointY) || (getLeft < startPositionX && get_full_width > EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && getTop > startPositionY && getTop < EndPointY) || (getLeft > startPositionX && getLeft < EndPointX && get_full_height > startPositionY && get_full_height < EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && get_full_height > startPositionY && get_full_height < EndPointY) || (getLeft > startPositionX && getLeft < EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (get_full_width > startPositionX && get_full_width < EndPointX && getTop < startPositionY && get_full_height > EndPointY) || (getTop > startPositionY && getTop < EndPointY && getLeft < startPositionX && get_full_width > EndPointX) || (get_full_height > startPositionY && get_full_height < EndPointY && getLeft < startPositionX && get_full_width > EndPointX)) {
              if (getatt != null) {
                filterCanvas.push(getAllCanvasElements[ma]);
              }
            }
          }
          if ((filterCanvas.length == 1 && e.which == 3) || (filterCanvas.length == 1 && e.which == 1)) {
            //reference-group
            let getId = filterCanvas[0].getAttribute('id');
            if (getId.includes('GroupAnno-borderbox')) {
              if (filterCanvas.length == 1 && e.which == 1) {
                return
              }
              const dialogRef = this.dialogBox.open(ClayeralertComponent, {
                data: {
                  delete: true,
                  id: getId
                }
              });
              return
            }
          }
          if(filterCanvas.length > 1){
            for(let i = 0; i < filterCanvas.length; i++){
              // let getId = filterCanvas[i].getAttribute('id');
              filterCanvas = filterCanvas.filter(id => !id.getAttribute('id').includes('GroupAnno-borderbox'));
              console.log(filterCanvas)
            }
          }
          if (this.createDocumentStore.selectedAnnotations.length == 0 && filterCanvas.length > 0) {
            for (let fc = 0; fc < filterCanvas.length; fc++) {
              let annotId = filterCanvas[fc].getAttribute('id');
              let lock_layer_check = this.lock_condition_multiple(annotId);
              if (lock_layer_check == true) {
                let isAlreadyPresent = this.checkExistingInGroupAnnts(annotId);
                if(isAlreadyPresent == false){
                filterCanvas[fc].setAttribute('multimoving', '1');
                this.createDocumentStore.selectedAnnotations.push(annotId);
                this.colorBorderSVG(filterCanvas[fc]);
                this.getMultipleMovingLabelElement(annotId);
                }
              }
            }
          }
          else if (this.createDocumentStore.selectedAnnotations.length != 0 && filterCanvas.length > 0) {
            // await this.automatic_update_form();
            let get_response = await this.multi_func_handling();
            if (get_response == 201) {
              return; // stop the running method because previous data not updated in db
            }
            for (let f = 0; f < filterCanvas.length; f++) {
              let annotId = filterCanvas[f].getAttribute('id');
              let lock_layer_check = this.lock_condition_multiple(annotId);
              if (lock_layer_check == true) {
                let alreadySelected = this.createDocumentStore.selectedAnnotations.some((ids) => ids === annotId);
                if (alreadySelected == false) {
                  if (this.attribute_change == true) {
                    await this.attribute_value_changes();
                  }
                  let isAlreadyPresent = this.checkExistingInGroupAnnts(annotId);
                  if(isAlreadyPresent == false){
                  this.createDocumentStore.selectedAnnotations.push(annotId);
                  filterCanvas[f].setAttribute('multimoving', '1');
                  this.colorBorderSVG(filterCanvas[f]);
                  this.getMultipleMovingLabelElement(annotId);
                  }
                }
              }
            }
          }
          this.functionendtime('multiple',canvasst);
          let tempArray = this.createDocumentStore.selectedAnnotations;
          this.createDocumentStore.selectedAnnotations = tempArray.filter(function (elem, index, self) {
            return index === self.indexOf(elem);
          })
          this.createDocumentStore.multipleDragSelectCanvas.clearRect(0, 0, newcreatedElement.width, newcreatedElement.height);
          // get Multiple Annotations data from API
        }
        else if (mousedrag == false) {
          const rect = newcreatedElement.getBoundingClientRect();
          let clickPosition = {
            x: initialX,
            y: initialY,
          };
          let clickPositionX = clickPosition.x;
          clickPositionX = clickPositionX + 10;
          let clickPositionY = clickPosition.y;
          clickPositionY = clickPositionY + 10;
          let getAllCanvasElements = document.querySelectorAll('svg.documentSVG');
          var filterCanvas = [];
          for (let ma = 0; ma < getAllCanvasElements.length; ma++) {
            let getAllElementsXY: any = getAllCanvasElements[ma];
            let getStyle = getComputedStyle(getAllElementsXY);
            let getLeft: any = getStyle.left;
            getLeft = getLeft.substring(getLeft.length - 2, 0);
            let getTop: any = getStyle.top;
            getTop = getTop.substring(getTop.length - 2, 0);
            let getWidth: any = getStyle.width;
            getWidth = getWidth.substring(getWidth.length - 2, 0);
            let getHeight: any = getStyle.height;
            getHeight = getHeight.substring(getHeight.length - 2, 0);
            let checkBoundingBox = false;
            getLeft = Number(getLeft);
            getTop = Number(getTop);
            getWidth = Number(getWidth);
            getHeight = Number(getHeight);
            let EndPointX = getLeft + getWidth;
            let EndPointY = getTop + getHeight;
            let getatt = getAllCanvasElements[ma].getAttribute('id');
            if (getatt != null && getLeft <= clickPositionX && EndPointX >= clickPositionX && getTop <= clickPositionY && EndPointY >= clickPositionY) {
              filterCanvas.push(getAllCanvasElements[ma]);
            }
          }
          if ((filterCanvas.length == 1 && e.which == 3) || (filterCanvas.length == 1 && e.which == 1)) {
            let getId = filterCanvas[0].getAttribute('id');
            if (getId.includes('GroupAnno-borderbox')) {
              if (filterCanvas.length == 1 && e.which == 1) {
                return
              }
              const dialogRef = this.dialogBox.open(ClayeralertComponent, {
                data: {
                  delete: true,
                  id: getId
                }
              });
              return
            }
          }
          if(filterCanvas.length > 1){
            for(let i = 0; i < filterCanvas.length; i++){
              // let getId = filterCanvas[i].getAttribute('id');
              filterCanvas = filterCanvas.filter(id => !id.getAttribute('id').includes('GroupAnno-borderbox'));
              console.log(filterCanvas)
            }
          }
          if (this.createDocumentStore.selectedAnnotations.length == 0 && filterCanvas.length > 0) {
            let annotId = filterCanvas[0].getAttribute('id');
            let itemIndex = this.createDocumentStore.selectedAnnotations.findIndex(item => item == annotId);
            if (itemIndex != -1) {
              if (this.attribute_change == true) {
                await this.attribute_value_changes();
              }
              if (e.which == 3) {
                e.preventDefault();
                e.stopPropagation();
              
                this.getId = this.createDocumentStore.selectedAnnotations[this.createDocumentStore.selectedAnnotations.length - 1];
                this.canvasRightClick(e, this.getId);
              }
              else {
                var canExecute = true;
                let cloneFilterCVanvas = _.cloneDeep(filterCanvas)
                for (let f = 0; f < filterCanvas.length; f++) {
                  if (canExecute == true) {
                    for (let g = 0; g < this.createDocumentStore.selectedAnnotations.length; g++) {
                      cloneFilterCVanvas = cloneFilterCVanvas.filter((canvas) => canvas.getAttribute('id') != this.createDocumentStore.selectedAnnotations[g])
                    }
                    if (cloneFilterCVanvas.length > 0) {
                      let annotId = cloneFilterCVanvas[0].getAttribute('id');
                      let lock_layer_check = this.lock_condition_multiple(annotId);
                      if (lock_layer_check == true) {
                        let isAlreadyPresent = this.checkExistingInGroupAnnts(annotId);
                        if (isAlreadyPresent == false) {
                          this.createDocumentStore.selectedAnnotations.push(annotId);
                          cloneFilterCVanvas[f].setAttribute('multimoving', '1');
                          this.colorBorderSVG(cloneFilterCVanvas[f]);
                          canExecute = false;
                          this.getMultipleMovingLabelElement(annotId);
                        }
                      }
                    } else {
                      var iVal = 0;
                      do {
                        if (this.createDocumentStore.selectedAnnotations.length > iVal) {
                          let canvasfiltered = filterCanvas.filter((element) => element.getAttribute('id') === this.createDocumentStore.selectedAnnotations[iVal]);
                          if (canvasfiltered.length > 0) {
                            this.getMultipleMovingLabelElementRemove(this.createDocumentStore.selectedAnnotations[iVal]);
                            this.createDocumentStore.selectedAnnotations.splice(iVal, 1);
                            canvasfiltered[0].removeAttribute('multimoving');
                            this.transparentBorderSVG(canvasfiltered[0]);
                            //this.createDocumentStore.selectedAnnotations
                            canExecute = false
                          }
                          else {
                            iVal += 1
                          }
                        } else {
                          canExecute = false
                        }
                      } while (canExecute)
                    }
                  }
                }
              }
            } else {
              let lock_layer_check = this.lock_condition_multiple(annotId);
              if (lock_layer_check == true) {
                if (this.attribute_change == true) {
                  await this.attribute_value_changes();
                }
                let isAlreadyPresent = this.checkExistingInGroupAnnts(annotId);
                if (isAlreadyPresent == false) {
                  this.createDocumentStore.selectedAnnotations.push(annotId);
                  filterCanvas[0].setAttribute('multimoving', '1');
                  this.colorBorderSVG(filterCanvas[0]);
                  this.getMultipleMovingLabelElement(annotId);
                }
                // right click should call after api call
                // if (e.which == 3) {
                //   e.preventDefault();
                //   e.stopPropagation();
                //   if (this.multiclickdisabled == false) {
                //     this.multiclickdisabled = true;
                //     this.getId = this.createDocumentStore.selectedAnnotations[this.createDocumentStore.selectedAnnotations.length - 1];
                //     this.canvasRightClickBox();
                //   }
                // }
              }
            }
          }
          else if (this.createDocumentStore.selectedAnnotations.length != 0 && filterCanvas.length > 0) {
            // await this.multiannotation_automatic_update_form_rightclick(e, false);
            let get_response = await this.multi_func_handling();
            if (get_response == 201) {
              return; // stop the running method because previous data not updated in db
            }
            if (this.attribute_change == true) {
              await this.attribute_value_changes();
            }
            var canExecute = true;
            let cloneFilterCVanvas = _.cloneDeep(filterCanvas)
            for (let f = 0; f < filterCanvas.length; f++) {
              if (canExecute == true) {
                for (let g = 0; g < this.createDocumentStore.selectedAnnotations.length; g++) {
                  cloneFilterCVanvas = cloneFilterCVanvas.filter((canvas) => canvas.getAttribute('id') != this.createDocumentStore.selectedAnnotations[g])
                }
                if (cloneFilterCVanvas.length > 0) {
                  console.log(this.createJSON_grpAnnts)
                  let annotId = cloneFilterCVanvas[0].getAttribute('id');
                  let isAlreadyPresent = this.checkExistingInGroupAnnts(annotId);
                  if (isAlreadyPresent == false) {
                    this.createDocumentStore.selectedAnnotations.push(annotId);
                    cloneFilterCVanvas[f].setAttribute('multimoving', '1');
                    this.colorBorderSVG(cloneFilterCVanvas[f]);
                    canExecute = false;
                    this.getMultipleMovingLabelElement(annotId);
                  }
                } else {
                  var iVal = 0;
                  do {
                    if (this.createDocumentStore.selectedAnnotations.length > iVal) {
                      let canvasfiltered = filterCanvas.filter((element) => element.getAttribute('id') === this.createDocumentStore.selectedAnnotations[iVal]);
                      if (canvasfiltered.length > 0 && e.which != 3) {
                        this.getMultipleMovingLabelElementRemove(this.createDocumentStore.selectedAnnotations[iVal]);
                        this.createDocumentStore.selectedAnnotations.splice(iVal, 1);
                        canvasfiltered[0].removeAttribute('multimoving');
                        this.transparentBorderSVG(canvasfiltered[0]);
                        canExecute = false
                      }
                      else {
                        iVal += 1
                      }
                    } else {
                      canExecute = false
                    }
                  } while (canExecute)
                }
              }
            }
          }
        }
        if (this.createDocumentStore.selectedAnnotations.length > 0 && filterCanvas.length > 0) {
          this.show = true;
          let st_2 = this.functionstarttime('multi api');
          
          this.documentService.getMultipleAnnotationData(this.createDocumentStore.selectedAnnotations).subscribe((response) => {
            if (response["response_code"] == 200) {
              this.functionendtime('multi api',st_2);
              // this.multiselectionList = response["response_body"]["annotation_data"];
              this.multiselectionList = response["response_body"];
              console.log(this.multiselectionList);
              this.clonemultiselect_align = _.cloneDeep(this.multiselectionList);
              this.selectedAnnotationLength = this.multiselectionList.length;
              this.optionClick = false;
              this.hideSelectForm = true;
              this.sampleFormObject = [];
              this.modelFieldsForm = [];
              this.extend_modelFieldsForm = [];
              this.annotationSelected = true;
              for (let ma = 0; ma < this.multiselectionList.length; ma++) {
                let findLayerIndex = this.layerDatas.findIndex((LData) => LData.layer_id == this.multiselectionList[ma].layer_id);
                if (findLayerIndex != -1) {
                  let findAnnotationIndexS = this.layerDatas[findLayerIndex].annotations.findIndex((ADAta) => ADAta.annotation_id == this.multiselectionList[ma].annotation_id);
                  if (findAnnotationIndexS != -1) {
                    this.layerDatas[findLayerIndex].annotations[findAnnotationIndexS] = this.multiselectionList[ma];
                  }
                }
              }
              if (this.multiselectionList.length > 0) {
                this.getId = this.multiselectionList[this.multiselectionList.length - 1].annotation_id;
              }
              this.getCounts();
              if (this.form == true) {
                this.formiconClick();
              }
              else if (this.media == true) {
                this.mediaIconClick();
              }
              else if (this.links == true) {
                this.linkIconClick();
              }
              else if (this.tags == true) {
                this.tagIconClick();
              }
              else if (this.properties == true) {
                this.propertyIconClick();
              }
              // canvas right click function call after api calling done
              if (e.which == 3) {
                e.preventDefault();
                e.stopPropagation();
                console.log(e)
                this.getId = this.createDocumentStore.selectedAnnotations[this.createDocumentStore.selectedAnnotations.length - 1];
                this.canvasRightClick(e, this.getId)
              }
              else{
                this.show = false;
              }
            }
          })
        }
        else if (this.createDocumentStore.selectedAnnotations.length == 0) {
          this.selectAnnotationZero();
          this.multiselectionList = [];
          if (this.searchOption == true) {
            let multiple_clone = [];
            const myClonedArray_multiple = Object.assign([], multiple_clone);
            this.dataService.getannotationid.emit(myClonedArray_multiple);
          }
        }
        else if (this.createDocumentStore.selectedAnnotations.length > 0 && filterCanvas.length == 0) {
          await this.multiannotation_automatic_update_form_rightclick(e, true);
        }
        // this.functionstarttime('multi mouse up');
    }
  } 

  checkingAnnts(groupAnnts, id) {
    var filter = false;
    for (let i = 0; i < groupAnnts.length; i++) {
      if (groupAnnts[i].is_removed != true) {
        filter = groupAnnts[i].annotation_ids.includes(id);
        if (filter == true) {
          break;
        }
      }
    }
    if (filter == true) {
      return true;
    }
    return false
  }

  checkExistingInGroupAnnts(annotId) {
    let isAlreadyPresent = false;
    if(this.grpAnntsEnbled == false){
      return false;
    }
    if (this.createJSON_grpAnnts != undefined) {
      let group_Annts = this.createJSON_grpAnnts.group_data;
      isAlreadyPresent = this.checkingAnnts(group_Annts, annotId);
    }
    return isAlreadyPresent;
  }

  drawOnCanvasMultiRectangle(
    prevPos: { x: number; y: number },
    currentPos: { x: number; y: number },
  ) {
    prevPos.x = prevPos.x;
    prevPos.y = prevPos.y;
    currentPos.x = currentPos.x;
    currentPos.y = currentPos.y;
    let newPointX = currentPos.x - prevPos.x;
    let newPointY = currentPos.y - prevPos.y;
    this.createDocumentStore.multipleDragSelectCanvas.rect(prevPos.x, prevPos.y, newPointX, newPointY);
    this.createDocumentStore.multipleDragSelectCanvas.lineWidth = 3;
    this.createDocumentStore.multipleDragSelectCanvas.strokeStyle = "red";
    this.createDocumentStore.multipleDragSelectCanvas.stroke();
    return { prevPosition: prevPos, currPosition: currentPos };
  }

  checksetbaseiconINorNot() {
    this.show = true;
    this.documentService.getDocumentDetails(this.projectId, this.folderId).subscribe((response) => {
      if (response["response_code"] == 200) {
        this.documentDetails = response["response_body"]["document_list"];
        if (this.documentDetails != undefined) {
          let filter_Page = this.documentDetails[this.slideIndex];
          if (filter_Page.page_icon_data != null) {
            this.iconsize1 = filter_Page.page_icon_data;
            var stringify = JSON.parse(this.iconsize1);
            this.seticonheight = stringify.height;
            this.seticonwidth = stringify.width;
            this.show = false;
          }
          else {
            this.iconsize1 = null;
            this.seticonheight = 0;
            this.seticonwidth = 0;
            this.show = false;
          }
        }
      }
    });
  }

  annotationLabelTemplate() {
    if (this.currentSelectedItems != undefined) {
      if (this.currentSelectedItems.element_data != undefined) {
        if (this.currentSelectedItems.element_data.hasOwnProperty('shape')) {
          let enableDataCopyMode = this.currentSelectedItems.element_data.shape.is_stamp;
          if (enableDataCopyMode == '0' || enableDataCopyMode == 0) {
            let label_value = this.currentSelectedItems.element_data.shape.annotation_label;
            return label_value;
          }
        }
        else {
          return "";
        }
      }
      else {
        return "";
      }
    }
    else {
      return "";
    }
  }

  getMultipleMovingLabelElement(id) {
    let get_label_element = document.getElementById('label' + id);
    if (get_label_element != null) {
      get_label_element.setAttribute('multiMovinglabel', "1");
    }
  }

  getMultipleMovingLabelElementRemove(id) {
    let get_label_element = document.getElementById('label' + id);
    if (get_label_element != null) {
      get_label_element.removeAttribute('multiMovinglabel');
    }
  }

  get_disable_setting(elementId: any) {
    let ids = [12, 13, 14, 15, 16];

    for (let i = 0; i < ids.length; i++) {
      if (ids[i] == elementId) {
        this.createDocumentStore.disable_fill_color = true;
        break;
      }
      else {
        this.createDocumentStore.disable_fill_color = false;
      }
    }
  }


  //default value
  select: boolean = true;
  hour(id) {
    let end: any = document.getElementById(id);
    var len = end.value.length;
    if (end.setSelectionRange) {
      end.focus();
      end.setSelectionRange(len, len);
      end.select();
    }

    //   console.log(typeof end.select)
    //   if (end.setSelectionRange) {
    //     end.focus();
    //     end.setSelectionRange(len, len);
    // }
    // if(end.select && this.select){
    //   end.select();
    //   this.select = false;
    // }

    this.inputBox = document.getElementById(id);

    console.log(this.inputBox.value);

    this.inputBox.onkeypress = function (e) {
      e = e || window.event;
      var charCode = (typeof e.which == "number") ? e.which : e.keyCode;
      console.log(e.which, e.keyCode);
      // Allow non-printable keys
      if (!charCode || charCode == 8 || charCode == 46 /* Backspace */) {
        return;
      }

      var typedChar = String.fromCharCode(charCode);

      // Allow numeric characters
      if (/\d/.test(typedChar)) {
        return;
      }

      // Allow the minus sign (-) if the user enters it first
      if (typedChar == "-" && this.value == "") {
        return;
      }

      // In all other cases, suppress the event
      return false;
    };
  }

  onPaste(event: ClipboardEvent) {
    let clipboardData = event.clipboardData;
    let pastedText = clipboardData.getData('text');
    // let check = Number(pastedText);
    // console.log(check)

    // returns true if NaN, otherwise false
    if (isNaN(+pastedText)) {
      return false
    } else {
      return pastedText
    }
  }

  ext_hour(id) {
    let end: any = document.getElementById(id + 'ext');
    var len = end.value.length;
    if (end.setSelectionRange) {
      end.focus();
      end.setSelectionRange(len, len);
      end.select();
    }

    //   console.log(typeof end.select)
    //   if (end.setSelectionRange) {
    //     end.focus();
    //     end.setSelectionRange(len, len);
    // }
    // if(end.select && this.select){
    //   end.select();
    //   this.select = false;
    // }

    this.inputBox = document.getElementById(id + 'ext');

    this.inputBox.onkeypress = function (e) {
      e = e || window.event;
      var charCode = (typeof e.which == "number") ? e.which : e.keyCode;

      // Allow non-printable keys
      if (!charCode || charCode == 8 /* Backspace */) {
        return;
      }

      var typedChar = String.fromCharCode(charCode);

      // Allow numeric characters
      if (/\d/.test(typedChar)) {
        return;
      }

      // Allow the minus sign (-) if the user enters it first
      if (typedChar == "-" && this.value == "") {
        return;
      }

      // In all other cases, suppress the event
      return false;
    };
  }


  lock_condition_multiple(annotationid: string) {
    let check_lock_final = true;
    let allow_condition = ["false", false, 0, "0", undefined];
    for (let k = 0; k < this.layerDatas.length; k++) {
      //annotation data
      let filter_annotation_data = this.layerDatas[k].annotations.filter((a_data) => a_data.annotation_id == annotationid);
      if (filter_annotation_data.length > 0) {
        //layer associated pages
        let get_associated_pages = this.layerDatas[k].associated_pages;
        if (get_associated_pages.length > 0) {
          let filter_currentPage_assosciated_page = get_associated_pages.filter((page_data) => page_data.page_id === this.currentPageId);
          if (filter_currentPage_assosciated_page.length > 0) {
            let check_lock_condtion = filter_currentPage_assosciated_page[0].is_lock;
            check_lock_final = allow_condition.includes(check_lock_condtion);
          }
        }
      }
    }
    return check_lock_final;
  }
  
  async attribute_value_changes() {
    // attributes values updation checking
    if (this.attribute_change == true) {
      let getId = this.getId;
      const dialgoConfig = new MatDialogConfig();
      dialgoConfig.disableClose = true;
      dialgoConfig.autoFocus = true;
      let attributeDialog = this.dialogBox.open(AttributeconfromComponent, {
        width: "450px",
        panelClass: "my-class",
        data: { supportPageData: true }
      });
      await attributeDialog.afterClosed().toPromise().then(async (response) => {
        if (response != undefined) {
          if (response.publish == true) {
            await this.applySettingAPI("value");
            this.attribute_change = false;
          }
          if (response.publish == false) {
            let index=this.createDocumentStore.view_annotation_array.findIndex(item=>item.annotation_id==this.propertiesannotationDataCopy.annotation_id)
            
            // if(index!=-1){
            //   this.createDocumentStore.view_annotation_array[index].textfontSize = 0;
            // this.createDocumentStore.view_annotation_array[index].textfontSize = 13;
            // this.createDocumentStore.view_annotation_array[index].textshapetextx=this.backUpTextProperties.xPosition;
            // this.createDocumentStore.view_annotation_array[index].textshapetexty=this.backUpTextProperties.yPosition;
            // }
            
            let currentAttributeElement = document.getElementById("label" + this.createDocumentStore.view_annotation_array[index].annotation_id);
            console.log(this.backUpTextProperties,currentAttributeElement)
            if(this.backUpTextProperties != undefined && currentAttributeElement != null){
              currentAttributeElement.style.fontSize = (this.backUpTextProperties.size != undefined ? this.backUpTextProperties.size : 13) + "px";
              currentAttributeElement.style.top = (this.backUpTextProperties.yPosition) + "px";
              currentAttributeElement.style.left = (this.backUpTextProperties.xPosition)+ "px";
            }
            this.backUpTextProperties = undefined
            console.log(currentAttributeElement)
          }
        }
        this.attribute_change = false;
        //sync action flag changes
        if (this.synAction == true) {
          this.synAction = false;
          this.dataService.synActionCompleteNew.emit(false);
        }
        this.show = false;
        this.dialogBox.closeAll();
      });
    }
  }
  async automatic_update_form() {
    //If form values changes na we need update to the api.
    if (this.createDocumentStore.forms_changes_status == true) {
      this.createDocumentStore.forms_changes_status = false;
 
      await this.formSubmit(false, '');
    }
  }

  // when we hit the sync button If annotation form changes has the local value we call seperate function of update form 
  async automatic_update_form_sync(action: string) {

    //If form values changes na we need update to the api.
    if (this.createDocumentStore.forms_changes_status == true) {
      this.createDocumentStore.forms_changes_status = false;

      await this.formSubmit(false, action);
    }
    else {
      // forms does not changes anything
      const get_formlist = new Promise(async resolve => {
        let get_form_response = await this.getAnnotationForm();
        resolve(get_form_response);
      });
      get_formlist.then(responses => {
        console.log(responses)
        if (responses == 200) {
          this.getGroupAnnotationDatas();
        }
      });
    }
  }
  // when we hit the rightclick button If already selected annotation form changes has the local value we call seperate function of update form 
  async automatic_update_form_rightclick(event: any, deselectkey: boolean) {

    event.preventDefault();
    //If form values changes na we need update to the api.
    let action = 'leftclick';
    if (deselectkey == true) {
      action = 'deselect';
    }
    else if (event != undefined && event.which == 3) {
      action = 'rightclick';
    }
    else if (event != undefined && event.which != 3) {
      action = 'leftclick';
    }
    console.log(event, action);
    // start process
    if (this.createDocumentStore.forms_changes_status == true) {
      this.createDocumentStore.forms_changes_status = false;
   
      await this.formSubmit(false, action, event);
    }
    else if (action == "deselect") {
      this.deselectAnnotation();
    }
    else {
      // forms does not changes anything
      // right click option check if condition
      if (action == 'rightclick' && event != undefined && event.which == 3) {
        
        this.canvasRightClick(event, this.createDocumentStore.single_select_annotation[0]);
      }
      else if (action == 'leftclick' && event != undefined && event.which != 3) {
        this.canvasClick(this.createDocumentStore.single_select_annotation[0]);
      }
      else if (action == 'deselect' && event != undefined) {
        this.deselectAnnotation();
        this.show = false;
      }
    }
  }
  async multiannotation_automatic_update_form_rightclick(event: any, deselectkey: boolean) {
    event.preventDefault();
    //If form values changes na we need update to the api.
    let action = 'leftclick';
    if (deselectkey == true) {
      action = 'deselect1';
    }
    else if (event != undefined && event.which == 3) {
      action = 'rightclick';
    }
    else if (event != undefined && event.which != 3) {
      action = 'leftclick';
    }
    console.log(event, action);
    // start process
    if (this.createDocumentStore.forms_changes_status == true) {
      this.createDocumentStore.forms_changes_status = false;
 
      await this.formSubmit(false, action, event);
    }
    else {

    }
  }

  async automatic_update_form_deselect(action: string, event: any) {
    event.preventDefault();
    //If form values changes na we need update to the api.
    if (this.createDocumentStore.forms_changes_status == true) {
      this.createDocumentStore.forms_changes_status = false;
  
      await this.formSubmit(false, action, event);
    }
    else {
      // forms does not changes anything
      this.deselectAnnotation();
      this.show = false;
    }
  }


  // below function temprorily not using because of rotation not sending multiple annotations
  async storerotateresizeannotation() {
    if (this.rotateresizeAnnotationStore.length > 0) {
      let find_exist = this.rotateresizeAnnotationStore.findIndex((exist) => exist.annotation_id == this.propertiesannotationData.annotation_id);
      if (find_exist > -1) {
        this.rotateresizeAnnotationStore[find_exist] = this.propertiesannotationData;
      }
      else {
        this.rotateresizeAnnotationStore.push(this.propertiesannotationData);
      }
    }
    else {
      this.rotateresizeAnnotationStore.push(this.propertiesannotationData);
    }
  }


  async single_view_svg_drawing(singleannotationdata: any) {
    let currentSVG = await this.annotation_view_svg(singleannotationdata);
    if (currentSVG != null && currentSVG != undefined) {
      let lines = [13, 14, 15, 16];
      if (lines.includes(Number(currentSVG.toolbar_element_id))) {
        currentSVG.linewidth = currentSVG.linewidth * 2;

      }
      // check resize shapes line width increase simple shapes only

      currentSVG = linewidthchanges(currentSVG);
      this.single_view_svg = currentSVG;
      
    }
  }


  async replacecurrentChangeInSVG(annotationdata: any, border: boolean, resizetext?: any) {
    if (this.createDocumentStore.view_annotation_array.length > 0) {
      let clone_deep_json = _.cloneDeep(annotationdata);
      let change_svg_path = this.documentPage.changesvgpath(clone_deep_json, 'document', this.pngFormat);
      let find_current_annotation_data = this.createDocumentStore.view_annotation_array.findIndex((id) => id.annotation_id == annotationdata.annotation_id);
      if (find_current_annotation_data > -1) {
        this.createDocumentStore.view_annotation_array.splice(find_current_annotation_data, 1);
        this.createDocumentStore.view_annotation_array.push(change_svg_path);
        console.log(this.createDocumentStore.view_annotation_array);
        // this.repoint_AnnotationStoreFunction(annotationdata);
        // [find_current_annotation_data] = change_svg_path;
        // selectionbox
        console.log(this.createDocumentStore.view_annotation_array, find_current_annotation_data);
        if (border == true) {
          if(this.propertiesannotationData.toolbar_element_id == 15){
            let getAllCanvas = document.querySelectorAll("svg.svg-block");
            getAllCanvas.forEach((data) => {
              data.classList.remove('svg-block');
            });
            const rotateAnnProperty = _.cloneDeep(this.propertiesannotationData);
            var rotateObj = {rotate : "true", prop: rotateAnnProperty}
          }
          this.cdRef.detectChanges();
          let get_element = document.getElementById(clone_deep_json.annotation_id);
          this.colorBorderSVG(get_element,rotateObj);
        }
      }
    }
  }

  async single_view_Preview_svg_drawing(single_preview_annotationdata: any) {
    let currentSVG = await this.annotation_view_svg_copy(single_preview_annotationdata);
    if (currentSVG != null && currentSVG != undefined) {
      let lines = [13, 14, 15, 16];
      if (lines.includes(Number(currentSVG.toolbar_element_id))) {
        currentSVG.linewidth = currentSVG.linewidth * 2;
      }
      // check resize shapes line width increase simple shapes only
      currentSVG = linewidthchanges(currentSVG);
      this.single_view_preview_svg = currentSVG;
       
      if (this.single_view_preview_svg["annotation_label"] != null || this.single_view_preview_svg["annotation_label"] != "" || this.single_view_preview_svg["annotation_label"] != undefined) {
        this.getMultipleMovingLabelElement(this.single_view_preview_svg["annotation_id"]);
      }
    }

  }

  async annotation_view_svg(changedata: any) {
    let clone_deep_data = _.cloneDeep(changedata);
    let get_svgPath = this.documentPage.changesvgpath(clone_deep_data, 'document', this.pngFormat);
    return get_svgPath;
  }

  async annotation_view_svg_copy(changedata: any) {
    let clone_deep_data = _.cloneDeep(changedata);
    let get_svgPath = this.documentPage.changesvgpath(clone_deep_data, 'toolbar', this.pngFormat);
    return get_svgPath;
  }

  transparentBorderSVGSelected() {
    let getAllSVG = document.querySelectorAll("svg.svg-block");
    getAllSVG.forEach((data) => {
      data.classList.remove('svg-block');
    });

    const components = Array.prototype.filter.call(
      document.querySelectorAll('*'),
      e => e.id.toLowerCase().startsWith('media')
    )
    components.forEach((data) => {
      data.setAttribute("d", "");
    });
    
  }

  transparentBorderSVG(element: HTMLElement) {
    if (element != null) {
      let borderid = "media"+element.id;
      let getElementSelect = document.getElementById(borderid);
      if(getElementSelect != undefined){
        getElementSelect.setAttribute("d", "");
      }else{
        element.classList.remove('svg-block');
      }
    }
  }

  colorBorderSVG(element: HTMLElement,rotateAnn?) {
    if (element != null) {
      let borderid = "media"+element.id;
      let getElementSelect = document.getElementById(borderid);
      if(getElementSelect != undefined){
        let annotation_needtoChange;
        this.layerDatas.forEach((data) => {
          annotation_needtoChange = data.annotations.filter(ann=>ann.annotation_id==element.id)
        })
        if(rotateAnn != undefined && rotateAnn.rotate == "true"){
          annotation_needtoChange[0] = rotateAnn.prop;
        }
        if(annotation_needtoChange != undefined && annotation_needtoChange.length > 0){
          let path = this.drawBorderLineForLines(annotation_needtoChange[0].annotation_data,annotation_needtoChange[0]);
          console.log(this.resizebutton)
          if(path == "normalBorder" || this.resizebutton == true){
            element.classList.add('svg-block');
          }
          else{
            getElementSelect.setAttribute("d", path);
          }
        }
      }else{
        element.classList.add('svg-block');
      }
    }
  }

  colorBorderSVG_align(element: HTMLElement) {
    if (element != null) {
      element.classList.add('svg-block-orange');
    }
  }


  freehanddrawing() {
    
    var strokeWidth = 2;
    var bufferSize = 8;
    var pdfImg = document.getElementById("pdfImg");
    var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgElement.setAttribute("width", this.realWidth);
    svgElement.setAttribute("height", this.realHeight);
    svgElement.setAttribute("customepolylineattribute", "1");
    svgElement.style.position = "absolute";
    svgElement.style.top = "0px";
    svgElement.style.left = "0px";
    svgElement.style.zIndex = "999";
    pdfImg.appendChild(svgElement);
    var rect = svgElement.getBoundingClientRect();
    console.log(rect);
    var path = null;
    var strPath;
    var buffer = []; // Contains the last positions of the mouse cursor

    svgElement.addEventListener("mousedown", (e) => {
      var rect = svgElement.getBoundingClientRect();
      console.log(rect);
      path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute("fill", "none");
      path.setAttribute("stroke", "#000");
      path.setAttribute("stroke-width", strokeWidth);
      buffer = [];
      var pt: any = getMousePosition(e);
      appendToBuffer(pt);
      pt.x = pt.x / this.scale;
      pt.y = pt.y / this.scale;
      strPath = "M" + pt.x + " " + pt.y;
      path.setAttribute("d", strPath);
      svgElement.appendChild(path);
    });

    svgElement.addEventListener("mousemove", (e) => {
      if (path) {
        appendToBuffer(getMousePosition(e));
        updateSvgPath();
      }
    });

    svgElement.addEventListener("mouseup", () => {
      if (path) {
        path = null;
      }
    });

    var getMousePosition = (e) => {
      
      return {
        x: (e.clientX - rect.left),
        y: (e.clientY - rect.top)
      }
    };

    var appendToBuffer = (pt) => {
      buffer.push(pt);
      while (buffer.length > bufferSize) {
        buffer.shift();
      }
    };

    // Calculate the average point, starting at offset in the buffer
    var getAveragePoint = (offset) => {
      var len = buffer.length;
      if (len % 2 === 1 || len >= bufferSize) {
        var totalX = 0;
        var totalY = 0;
        var pt, i;
        var count = 0;
        for (i = offset; i < len; i++) {
          count++;
          pt = buffer[i];
          totalX += pt.x;
          totalY += pt.y;
        }
        return {
          x: totalX / count,
          y: totalY / count
        }
      }
      return null;
    };

    var updateSvgPath = () => {
      var pt = getAveragePoint(0);
      if (pt) {
        // Get the smoothed part of the path that will not change
        console.log('smooth point');
        pt.x = pt.x / this.scale;
        pt.y = pt.y / this.scale;
        strPath += " L" + pt.x + " " + pt.y;

        // Get the last part of the path (close to the current mouse position)
        // This part will change if the mouse moves again
        var tmpPath = "";
        for (var offset = 2; offset < buffer.length; offset += 2) {
          pt = getAveragePoint(offset);
          pt.x = pt.x / this.scale;
          pt.y = pt.y / this.scale;
          tmpPath += " L" + pt.x + " " + pt.y;
        }

        // Set the complete current path coordinates
        console.log('end path', strPath, '-', tmpPath)
        path.setAttribute("d", strPath + tmpPath);
      }
    };
  }

  async drawing_multiple_annotations() {
    let clone_multiple_list = _.cloneDeep(this.multiselectionList);
    this.multiselectionList_svg_view = [];
    for (let vj = 0; vj < clone_multiple_list.length; vj++) {
      let get_current_annot = clone_multiple_list[vj];
      let get_current_svg_changes = await this.annotation_view_svg(get_current_annot);
      //line shapes I have assigned extra 
      let lines = [13, 14, 15, 16];
      if (lines.includes(Number(get_current_svg_changes.toolbar_element_id))) {
        get_current_svg_changes.linewidth = get_current_svg_changes.linewidth * 2;
      }
      // check resize shapes line width increase simple shapes only
      get_current_svg_changes = linewidthchanges(get_current_svg_changes);
      // links true means
      if (this.links == true) {
        // multiple selection location value assigning
        if (Array.isArray(get_current_svg_changes.annotation_links)) {
          for (let l = 0; l < get_current_svg_changes.annotation_links.length; l++) {
            get_current_svg_changes.annotation_links[l]["location"] = this.getLocation(get_current_svg_changes.annotation_links[l]);
          }
        }
      }
      this.multiselectionList_svg_view.push(get_current_svg_changes);
    }
  }


  polylinemethodSVG() {
    this.getPositionString = "";
    this.stringPathArray = [];
    // this.annotationName = "Polyline";
    var coords = [];
    var pdfImg = document.getElementById("pdfImg");
    var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    newcreatedElement.setAttribute("width", (this.realWidth).toString());
    newcreatedElement.setAttribute("height", (this.realHeight).toString());
    newcreatedElement.setAttribute("customepolylineattribute", "1");
    newcreatedElement.style.position = "absolute";
    newcreatedElement.style.top = "0px";
    newcreatedElement.style.left = "0px";
    newcreatedElement.style.zIndex = "999";
    let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    // attribute purpose - zooming line width reduces handled
    create_path.setAttribute("customepolylineattributepath", "1");
    newcreatedElement.appendChild(create_path);
    pdfImg.appendChild(newcreatedElement);
    // add transform on svg If zoomin 1 above
    this.addZoom(newcreatedElement);
    this.polylineMethodReDrawSVG(newcreatedElement, create_path, coords);
  }

  polylineMethodReDrawSVG(svg_handler, path, coords) {
    path.setAttribute('stroke', "black");
    path.setAttribute('stroke-width', "2");
    path.setAttribute('fill', "none");
    //line and circles points zooming 
    this.checkZoomInorOut();
    let path_value = "";
    if (coords.length > 0) {
      for (let k = 0; k < coords.length; k++) {
        path_value = k == 0 ? `M${coords[k].x}  ${coords[k].y}` : (path_value + ` L${coords[k].x} ${coords[k].y}`);
      }
    }
    svg_handler.addEventListener("click", (event: any) => {
      console.log('polyline click method');
        if(this.showvisible==false || this.isReadonly == true){
      return
    }
    if(this.layerDatas.length==0){
      return
    }
    
    if((this.layerDatas.length!=0)){
var active=this.layerDatas;
active=active.filter(res=>res.layer_id==this.activeLayerIdDraw)
   }
   if(this.layerDatas.length!=0 && active.length==0){
     return
   }
      let circle = this.addredCirclesSVG(event.offsetX, event.offsetY);
      svg_handler.appendChild(circle);
      if (this.getPositionSetMove != 1) {
        this.getPositionString = " " + "line" + "-" + event.offsetX + ":" + event.offsetY;
        this.stringPathArray.push(this.getPositionString);
        path_value = path_value + ` L${event.offsetX} ${event.offsetY}`;
      }
      if (this.getPositionSetMove == 1) {
        this.getPositionString = "move" + "-" + event.offsetX + ":" + event.offsetY;
        coords = [];
        this.stringPathArray.push(this.getPositionString);
        this.getPositionSetMove++;
        path_value = `M${event.offsetX} ${event.offsetY}`;
      }
      this.accessPolylineMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      var coord = { x: event.offsetX, y: event.offsetY };
      coords.push(coord);
      var max = coords.length - 1;
      if (typeof coords[max - 1] !== "undefined") {
        path.setAttribute("d", path_value);
      }
    });
  }

  undoPolylineSVG() {
    this.stringPathArray.splice(-1, 1);
    this.removeredCirclesSVG();
    if (this.stringPathArray.length > 0) {
      this.accessPolylineMenuFeatureStop = this.stringPathArray.length <= 1 ? true : false;
      this.removesvgAttribute('customepolylineattribute');
      var convertAnnotationData = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        convertAnnotationData = convertAnnotationData + this.stringPathArray[i];
      }
      convertAnnotationData = convertAnnotationData.trim();
      console.log(convertAnnotationData);
      this.seperateDrawUndoPolylineSVG(convertAnnotationData);
    }
    if (this.stringPathArray.length == 0) {
      this.removesvgAttribute('customepolylineattribute');
      this.accessPolylineMenuFeatureStop = true;
      this.polylinemethodSVG();
      this.getPositionSetMove = 1;
    }
  }

  seperateDrawUndoPolylineSVG(convertAnnotationData) {
    var coords = [];
    if (this.stringPathArray.length > 0) {
      let path_value = "";
      for (var i = 0; i < this.stringPathArray.length; i++) {
        var hypenSplit = this.stringPathArray[i].split("-");
        var colonSplit = hypenSplit[1].split(":");
        var coord = {
          x: parseFloat(colonSplit[0]),
          y: parseFloat(colonSplit[1]),
        };
        coords.push(coord);
        path_value = i == 0 ? `M${coord.x} ${coord.y}` : (path_value + ` L${coord.x} ${coord.y}`);
      }
      console.log(coords);
      var pdfImg = document.getElementById("pdfImg");
      var newcreatedElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      newcreatedElement.setAttribute("width", this.realWidth);
      newcreatedElement.setAttribute("height", this.realHeight);
      newcreatedElement.setAttribute("customepolylineattribute", "1");
      newcreatedElement.style.position = "absolute";
      newcreatedElement.style.top = "0px";
      newcreatedElement.style.left = "0px";
      newcreatedElement.style.zIndex = "999";
      let create_path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      create_path.setAttribute("customepolylineattributepath", "1");
      newcreatedElement.appendChild(create_path);
      pdfImg.appendChild(newcreatedElement);
      // add transform on svg If zoomin 1 above
      this.addZoom(newcreatedElement);
      this.polylineMethodReDrawSVG(newcreatedElement, create_path, coords);
      var max = coords.length - 1;
      create_path.setAttribute('stroke', "black");
      create_path.setAttribute('stroke-width', "2");
      create_path.setAttribute('fill', "none");
      //line and circles points zooming 
      this.checkZoomInorOut();
      for (var l = 0; l < coords.length; l++) {
        let circle = this.addredCirclesSVG(coords[l].x, coords[l].y);
        newcreatedElement.appendChild(circle);
      }

      if (typeof coords[max - 1] !== "undefined") {
        create_path.setAttribute("d", path_value);
      }

    } else {
      this.accessPolylineMenuFeatureStop = true;
      this.polylinemethodSVG();
    }
  }

  //CreateDocument End


  // unsubscribe the subscribe methods start
  async ngOnDestroy(): Promise<void> {
    // localStorage.removeItem("toolbarId");
    this.encrptdecrpt.removeItem("toolbarId");//security
    // localStorage.removeItem('pagezoom');
    this.encrptdecrpt.removeItem("pagezoom");//security
    this.encrptdecrpt.removeItem("scale_allpages");//security
    await this.automatic_update_form();
    if (this.attribute_change == true) {
      await this.attribute_value_changes();
    }
    //remove class stored values
    this.documentService.createDocumentStore_values = new createDocumentVar();
    // Undo and Redo values cleared when syncing start
    this.documentService.createDocumentStore_values.undovaluesstore = [];
    this.documentService.createDocumentStore_values.redovaluesstore = [];
    this.createDocumentStore.undovaluesstore = [];
    this.createDocumentStore.redovaluesstore = [];
    // Undo and Redo values cleared when syncing end

    this.layerDatas = [];
    if (this.createDocument$ != undefined) {
      this.createDocument$.unsubscribe();
    }
    if (this.htmlelementtype1$ != undefined) {
      this.htmlelementtype1$.unsubscribe();
    }
    if (this.seticonheight$ != undefined || this.seticonheight$ != null) {
      this.seticonheight$.unsubscribe();
    }
    if(this.autocadresponse$!=undefined){
      this.autocadresponse$.unsubscribe();
    }
    if (this.htmlelementtype$ != undefined) {
      this.htmlelementtype$.unsubscribe();
    }
    if (this.searchOption$ != undefined) {
      this.searchOption$.unsubscribe();
    }
    if (this.layerDatas$ != undefined) {
      this.createDocument$.unsubscribe();
    }
    if (this.mediaTags$ != undefined) {
      this.mediaTags$.unsubscribe();
    }
    if (this.layerPage$ != undefined) {
      this.layerPage$.unsubscribe();
    }
    if (this.searchAnnotationId$ != undefined) {
      this.searchAnnotationId$.unsubscribe();
    }
    if (this.checkedAnnotationId$ != undefined) {
      this.checkedAnnotationId$.unsubscribe();
    }
    if (this.groupAnntsEnbled$ != undefined) {
      this.groupAnntsEnbled$.unsubscribe();
    }
    if (this.checkedAnnotationIdPage$ != undefined) {
      this.checkedAnnotationIdPage$.unsubscribe();
    }
    if (this.pageChange$ != undefined) {
      this.pageChange$.unsubscribe();
    }
    if (this.pageSync$ != undefined) {
      this.pageSync$.unsubscribe();
    }
    if (this.deleteAnnotation$ != undefined) {
      this.deleteAnnotation$.unsubscribe();
    }
    if (this.layerDataget$ != undefined) {
      this.layerDataget$.unsubscribe();
    }
    if (this.layerpageActive$ != undefined) {
      this.layerpageActive$.unsubscribe();
    }
    if (this.createDocumentStore.multiselection_$ != null) {
      this.createDocumentStore.multiselection_$.unsubscribe();
    }
    if (this.createDocumentStore.browser_refresh_subscription$ != undefined) {
      this.createDocumentStore.browser_refresh_subscription$.unsubscribe();
    }

    this.mediaTags$.unsubscribe();
    this.renameMediaSubscribe.unsubscribe();
    this.deleteMediaSubscribe.unsubscribe();
    this.tagsMediaSubscribe.unsubscribe();
    this.setScaleTriggerSubscribe.unsubscribe();
    // if (this.linkedpageDataSubscribe != undefined) {
    //   this.linkedpageDataSubscribe.unsubscribe();
    // }
    if (this.linkedpageAIdSubscribe != undefined) {
      this.linkedpageAIdSubscribe.unsubscribe();
    }
    if (this.useastoolbarUpdate$ != undefined) {
      this.useastoolbarUpdate$.unsubscribe();
    }
    if (this.undoActionService != undefined) {
      this.undoActionService.unsubscribe();
    }
    if (this.redoActionService != undefined) {
      this.redoActionService.unsubscribe();
    }
    if (this.addToolbarShapes$ != undefined) {
      this.addToolbarShapes$.unsubscribe();
    }
    if (this.layerPageUpdateAllData$ != undefined) {
      this.layerPageUpdateAllData$.unsubscribe();
    }
    if (this.changesSubscription$ != undefined) {
      this.changesSubscription$.unsubscribe();
    }
    if (this.moveAccess$ != undefined) {
      this.moveAccess$.unsubscribe();
    }
    if (this.copydataclose$ != undefined) {
      this.copydataclose$.unsubscribe();
    }
    if (this.filterdata$ != undefined) {
      this.filterdata$.unsubscribe();
    }
    if (this.encrptdecrpt.getItem("stub_prefix") != null) {
      // localStorage.removeItem("stub_prefix");
      this.encrptdecrpt.removeItem("stub_prefix");//security
    }
    if (this.rotateResize$ != undefined) {
      this.rotateResize$.unsubscribe();
    }
    if (this.removeGroupAnntsSingle$ != undefined) {
      this.removeGroupAnntsSingle$.unsubscribe();
    }
    if (this.removeGroupAnnts$ != undefined) {
      this.removeGroupAnnts$.unsubscribe();
    }
    if (this.alignAnnotations$ != undefined) {
      this.alignAnnotations$.unsubscribe();
    }
    if (this.copyannotation_single$ != undefined) {
      this.copyannotation_single$.unsubscribe();
    }
    if (this.copyannotation_multiple$ != undefined) {
      this.copyannotation_multiple$.unsubscribe();
    }
    if (this.copyannotation_multiple_option$ != undefined) {
      this.copyannotation_multiple_option$.unsubscribe();
    }
    if (this.setScaleOn == true) {
      this.setScaleOn = false;
      this.dataService2.setScaleTrigger.emit(false);
    }
    if (this.rotateandresize == true) {
      this.rotateandresize = false;
      this.dataService1.changeRotateandResizeMessage(this.rotateandresize);
    }
    window.removeEventListener("storage", this.functionlistner);
    // let deactivateFilterToolbar = {allChecked:true,pointsChecked:false,freehandChecked:false,vertexChecked:false,rectangleChecked:false};
    // localStorage.setItem("toolbarFilterItem", JSON.stringify(deactivateFilterToolbar));
  }

  lastseenToolbar_storage() {

    let get_toolbar_storage = this.encrptdecrpt.getItem('toolbarlastchange');
    if (get_toolbar_storage != null) {
      //toolbarlastchange already stored then find the same or different document
      let last_appear_toolbar = { project_id: this.projectId, document_id: this.folderId, toolbar_id: this.toolbarId };
      let convert_json = get_toolbar_storage;
      let find_document_index = convert_json.findIndex((data) => data.document_id == this.folderId);
      if (find_document_index > -1) {
        //toolbarlastchange already stored toolbar changes replace
        convert_json[find_document_index] = last_appear_toolbar;
        // localStorage.setItem('toolbarlastchange',JSON.stringify(convert_json));
        this.encrptdecrpt.setItem("toolbarlastchange", convert_json);//security
      }
      else {
        // new document open and store the showing toolbar
        convert_json.push(last_appear_toolbar);
        // localStorage.setItem('toolbarlastchange',JSON.stringify(convert_json));
        this.encrptdecrpt.setItem("toolbarlastchange", convert_json);//security
      }
    }
    //very first time setup the toolbarlastchange to localstorage 
    else {
      let make_toolbar_array = [];
      let last_appear_toolbar = { project_id: this.projectId, document_id: this.folderId, toolbar_id: this.toolbarId };
      make_toolbar_array.push(last_appear_toolbar);
      // localStorage.setItem('toolbarlastchange',JSON.stringify(make_toolbar_array));
      this.encrptdecrpt.setItem("toolbarlastchange", make_toolbar_array);//security
    }
  }


  lastseenToolbar_check() {
    let get_toolbar_storage = this.encrptdecrpt.getItem('toolbarlastchange');
    if (get_toolbar_storage != null) {
      let convert_json = get_toolbar_storage;
      let find_document_index = convert_json.findIndex((data) => data.document_id == this.folderId);
      if (find_document_index > -1) {
        let toolbarId = convert_json[find_document_index].toolbar_id;
        return toolbarId;
      }
      else {
        return null;
      }
    }
    else {
      return null;
    }
  }

  // sync time toolbar builder updates received function
  refreshToolbarListSync() {
    
    this.toolbarlistService.gettoolbarlist(this.projectId).subscribe((res) => {
      console.log(res);
      if (res["response_code"] == 200 && res["response_body"]["toolbar_listing"] != null) {
        this.show = false;
        var toolData = res["response_body"]["toolbar_listing"];
        let removeHiddenNum = toolData.filter((data) => { return data.is_hidden != 1 });
        let removeHiddenBoolean = removeHiddenNum.filter((data) => {
          data.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(data.toolbar_name);
          return data.is_hidden != true
        });
        this.toolbarListData = removeHiddenBoolean;

        if (this.toolbarListData.length > 0) {
          if(this.toolbarId==undefined){
            this.toolbarId=this.toolbar_id
          }
          this.toolbardesginService.get_toolbar_data(this.toolbarId).subscribe((data) => {
            if (data["response_code"] == 200 && data != null) {
              console.log(data);
              // this.dataService.sendMessagetoolbarDatas(data);
              this.toolbar_name = data["response_body"].toolbar_listing[0].toolbar_name;
              this.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(this.toolbar_name);
              this.sub = this.toolbar_name;
              if(this.copymultiannenabled == true){
                this.sub = this.toolbar_name;
                this.toolbar_name = "Copy mode Enabled";
              }
              this.toolbar_id = data["response_body"].toolbar_listing[0].toolbar_id;
              let get_toolbar_data = data["response_body"].toolbar_listing[0].toolbar_data;
              if (get_toolbar_data != null && get_toolbar_data != undefined) {
                let get_response_data = data["response_body"].toolbar_listing[0].toolbar_data;
                let convertJson_response = JSON.parse(get_response_data);
                if (get_toolbar_data.length > 0) {
                  this.toolbarData = data["response_body"].toolbar_listing[0].toolbar_data;
                  // converting the special characters
                  convertJson_response = this.dataService4.changeSpecialtokeyformatList(convertJson_response, 'toolbarbuilder');
                  this.modelFields = convertJson_response;
                  //remove Deleted Toolbar Shapes
                  let filterToolbarShape = this.modelFields.filter((TData) => TData.is_removed == false ||
                    TData.is_removed == "false" || TData.is_removed == 0 || TData.is_removed == "0")

                  this.modelFields = filterToolbarShape;
                  console.log(this.modelFields);
                  this.copyOfModelfield = this.modelFields;
                  this.tempModelFields = _.cloneDeep(this.modelFields);
                  this.toolbarFilter = this.encrptdecrpt.getItem("toolbarFilterItem");
                  this.toolbarFilterMethod();
                  if (this.modelFields.length > 0) {
                    // toolbar svg Drawing
                    this.ngForRendred1();
                  }
                }
              }
              this.toolbarList.push(data["response_body"].toolbar_listing[0]);
            }
          })
        }
      }
      else {
        this.errorMessage();
      }
    });
  }

  pagewisemaintainzoom() {
    //this.imageScalingReset();
    let get_local_values = this.encrptdecrpt.getItem('pagezoom');
    if (get_local_values != null) {
      var convert_json = get_local_values;
      // page already not entered - 1, already zooming means else part execute
      var filter_page = convert_json.findIndex((pages) => pages.page_id == this.currentPageId);
    }
    if (filter_page == -1 || convert_json == undefined || filter_page == undefined) {
      // initial time page entered
      this.imageScalingReset();
    }
    else {
      // zoom in and zoomout changes update
      let filter_page = convert_json.findIndex((pages) => pages.page_id == this.currentPageId);
      if (filter_page > -1) {
        let scale = convert_json[filter_page]["zoom"];
        this.pagewisemaintainzoom_func(scale, convert_json[filter_page]);
      }
    }
  }

  pagewisemaintainzoompdf() {
    let get_local_values = this.encrptdecrpt.getItem('pagezoom');
    if (get_local_values != null) {
      var convert_json = get_local_values;
      // page already not entered - 1, already zooming means else part execute
      var filter_page = convert_json.findIndex((pages) => pages.page_id == this.currentPageId);
    }
    if (filter_page == -1 || convert_json == undefined || filter_page == undefined) {
      // initial time page entered
      this.pdfPanzoomSample();
    }
    else {
      // zoom in and zoomout changes update
      let filter_page = convert_json.findIndex((pages) => pages.page_id == this.currentPageId);
      if (filter_page > -1) {
        let scale = convert_json[filter_page]["zoom"];
        this.pagewisemaintainzoompdf_func1(scale, convert_json[filter_page]);
      }
    }

  }

  pagewisemaintainzoom_func(scale, page_details) {
    var img = document.createElement("img");
    img.onload = () => {
      this.realWidth = img.width;
      this.realHeight = img.height;
      this.documentService.createDocumentStore_values.document_width = img.width;
      this.documentService.createDocumentStore_values.document_height = img.height;
      let getImageContainer = document.getElementById("Imagecontainer");
      var getImageElement = document.getElementById("pdfImg");
      this.scaleValue = scale;
      this.scale = scale;
      getImageElement.style.transform = "scale(" + this.scale + ")";
      console.log(this.scaleValue);
      if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
        || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
        if (this.scale >= 1.24049) {
          this.zoomingLineShapeHandle();
        }
      }
      let getImageContainerSize = getImageContainer.getBoundingClientRect();
      console.log(getImageContainerSize);
      let currentWidthHeight = getImageElement.getBoundingClientRect();
      console.log(currentWidthHeight);
      let currentViewX = currentWidthHeight.width;
      let currentViewY = currentWidthHeight.height;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      console.log(currentViewX, currentViewY);
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: this.scale,
      });
      let viewImageDiv = document.getElementById("pdfImg");
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      panZoomElement.pause();
      // In this page has some scroll value we need to call scroll function
      this.scrollPage_execute(page_details);
    };
    img.onerror = (error) => {
      this.show = false;
    }
    img.src = this.imgUrl;
  }

  pagewisemaintainzoompdf_func(scale, page_details_pdf) {

    let getImageContainer = document.getElementById("Imagecontainer");
    var getImageElement = document.getElementById("pdfImg");
    this.scaleValue = scale;
    this.scale = scale;
    getImageElement.style.transform = "scale(" + this.scale + ")";
    console.log(this.scaleValue);
    if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
      || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
      if (this.scale >= 1.24049) {
        this.zoomingLineShapeHandle();
      }
    }
    let getImageContainerSize = getImageContainer.getBoundingClientRect();
    console.log(getImageContainerSize);
    let currentWidthHeight = getImageElement.getBoundingClientRect();
    console.log(currentWidthHeight);
    let currentViewX = currentWidthHeight.width;
    let currentViewY = currentWidthHeight.height;
    let centerX = getImageContainerSize.width - currentViewX;
    let centerY = getImageContainerSize.height - currentViewY;
    console.log(currentViewX, currentViewY);
    let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
      initialZoom: this.scale,
    });
    let viewImageDiv = document.getElementById("pdfImg");
    viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
    viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
    panZoomElement.pause();
    // In this page has some scroll value we need to call scroll function
    this.scrollPage_execute(page_details_pdf);
  }

  pagewisemaintainzoompdf_func1(scale, page_details_pdf) {
    // let zoom_plus = this.pdfScaleValue / 0.8;
    // this.pdfScaleValue = zoom_plus;

    this.pdfScaleValue = scale;
    if (this.pdfScaleValue < 0.9) {
      // zoomin Function calling revert back to the pdf width and height in initial value because of annotation plotting issue fixes
      let get_pdfimg = document.getElementById('pdfImg');
      if (get_pdfimg != null) {
        get_pdfimg.style.width = this.realWidth + 'px';
        get_pdfimg.style.height = this.realHeight + 'px';
        get_pdfimg.style.removeProperty('transform');
      }
      let get_annotationhead = document.getElementById('pdfannotationhead');
      if (get_annotationhead != null) {
        get_annotationhead.style.removeProperty('top');
        get_annotationhead.style.removeProperty('left');
        get_annotationhead.style.removeProperty('transform');
      }
      this.pagewisemaintainzoompdf_func(this.pdfScaleValue, page_details_pdf);
    } else {
      this.textLayerRenderedTimer();
      // In this page has some scroll value we need to call scroll function
      this.scrollPage_execute(page_details_pdf);
      if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
        || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
        if (this.pdfScaleValue >= 1.24049) {
          this.zoomingLineShapeHandle();
        }
      }
    }
  }

  pagewise_zoom_storage() {

    let page_details = { page_id: this.currentPageId, zoom: this.scale, scrollx: 0, scrolly: 0 };
    let get_local_values = this.encrptdecrpt.getItem('pagezoom');
    // no values means if coniditon
    if (get_local_values == null) {
      let create_array: any = [];
      create_array.push(page_details);
      // localStorage.setItem('pagezoom', JSON.stringify(create_array));
      this.encrptdecrpt.setItem("pagezoom", create_array);//security
    }
    else {
      // zoom in and zoomout changes update
      let convert_json = get_local_values;
      let filter_page = convert_json.findIndex((pages) => pages.page_id == this.currentPageId);
      if (filter_page > -1) {
        let scalevalue = this.scale;
        // pdf zooming handle above or equal 1 
        if (this.pngFormat == false && this.pdfScaleValue >= 1) {
          scalevalue = this.pdfScaleValue;
        }
        convert_json[filter_page]["zoom"] = scalevalue;
        // localStorage.setItem('pagezoom',JSON.stringify(convert_json));
        this.encrptdecrpt.setItem("pagezoom", convert_json);//security
      }
      // new page zooming added.
      else {
        let scalevalue = this.scale;
        // pdf zooming handle above or equal 1 
        if (this.pngFormat == false && this.pdfScaleValue >= 1) {
          scalevalue = this.pdfScaleValue;
        }
        let page_details = { page_id: this.currentPageId, zoom: scalevalue, scrollx: 0, scrolly: 0 };
        convert_json.push(page_details);
        // localStorage.setItem('pagezoom',JSON.stringify(convert_json));
        this.encrptdecrpt.setItem("pagezoom", convert_json);//security
      }
      console.log(get_local_values);
    }
  }

  different_tab_function(event): void {
    // let getPreview_data = this.encrptdecrpt.getItem("preview_image_data");
    // console.log(getPreview_data);
    // console.log(event);
    // console.log(event.key);
    if (event.key == 'preview_image_data') {
      console.log('different tab trigger');
      let get_new_storage = event.newValue;
      if (typeof get_new_storage == 'string') {
        get_new_storage = JSON.parse(get_new_storage);
        console.log(get_new_storage);
        this.layerDatas = get_new_storage.LayerData;
        let get_deleted_stub_value: any = this.encrptdecrpt.getItem("deleted_stub");

        if (get_deleted_stub_value != null) {
          get_deleted_stub_value = (typeof get_deleted_stub_value == 'string') ? JSON.parse(get_deleted_stub_value) : get_deleted_stub_value;

          if (get_deleted_stub_value.type == 'delete') {
            let ids = {
              annotation_id: get_deleted_stub_value.annotation_id,
              stub_id: get_deleted_stub_value.stub_id
            };
            let pass_data = { layer_data: this.layerDatas, ids: ids };

            this.dataService.mediaTagsUpdate.emit(pass_data);
            // localStorage.removeItem("deleted_stub");
            this.encrptdecrpt.removeItem("deleted_stub");//security
          }
        }
      }
    }
  }

  lastseendocument_storage(check_loading_or_changing: string) {
    let get_document_lastpage_details = this.encrptdecrpt.getItem("document_last_page_view");
    if (get_document_lastpage_details != null) {
      let convert_JSON_details = (typeof get_document_lastpage_details == 'string') ? JSON.parse(get_document_lastpage_details) : get_document_lastpage_details;
      let find_current_document_index = convert_JSON_details.findIndex((document_dts) => document_dts.document_id == this.folderId);
      if (find_current_document_index > -1) {
        if (check_loading_or_changing == 'loading') {
          // page initial loading time check already page open or not. If open we can get the page number of last view
          let get_page_number = convert_JSON_details[find_current_document_index].page_number;
          this.slideIndex = Number(get_page_number) - 1;
        }
        else if (check_loading_or_changing == 'changing') {
          // page changes update here
          convert_JSON_details[find_current_document_index].page_number = Number(this.slideIndex) + 1;
          // localStorage.setItem('document_last_page_view',JSON.stringify(convert_JSON_details));
          this.encrptdecrpt.setItem("document_last_page_view", convert_JSON_details);//security

        }
      }
      // add new document last page view details
      else {
        this.slideIndex = 0;
        let make_document_last_view = { document_id: this.folderId, page_number: 1 };
        convert_JSON_details.push(make_document_last_view);
        // localStorage.setItem("document_last_page_view",JSON.stringify(convert_JSON_details));
        this.encrptdecrpt.setItem("document_last_page_view", convert_JSON_details);//security
      }
    }
    // set the localstorage for document last view value data storage
    else {
      this.slideIndex = 0;
      let page_details = [];
      let make_document_last_view = { document_id: this.folderId, page_number: 1 };
      page_details.push(make_document_last_view);
      // localStorage.setItem("document_last_page_view", JSON.stringify(page_details));
      this.encrptdecrpt.setItem("document_last_page_view", page_details);//security
    }
  }

  lastseendocument_storage_links(check_loading_or_changing: string) {
    if (this.documentDetails != undefined && this.documentDetails.length > 0) {
      let find_current_index = this.documentDetails.findIndex((page_details_link) => page_details_link.page_id == this.pageId);
      if (find_current_index > -1) {
        let current_page_details = this.documentDetails[find_current_index];
        this.slideIndex = current_page_details.page_number - 1;
      }
    }
  }

  isScrolling: any;

  scrollPage_storage() {
    let get_element_query_selector = document.getElementsByClassName('drag-scroll-content');
    console.log('get_container_head', get_element_query_selector)
    if (get_element_query_selector != null) {
      let get_container = get_element_query_selector[0];
      console.log('get_container', get_container);
      get_container.addEventListener("scroll", event => {
        clearTimeout(this.isScrolling);
        // Set a timeout to run after scrolling ends
        this.isScrolling = setTimeout(() => {
          let scroll_value = `scrollTop: ${get_container.scrollTop} <br>
                            scrollLeft: ${get_container.scrollLeft} `;
          console.log("scroll", scroll_value);
          let get_local_values = this.encrptdecrpt.getItem('pagezoom');
          if (get_local_values != null) {
            var convert_json = (typeof get_local_values == 'string') ? JSON.parse(get_local_values) : get_local_values;
            var find_page_index = convert_json.findIndex((pages) => pages.page_id == this.currentPageId);
            if (find_page_index > -1) {
              convert_json[find_page_index].scrollx = get_container.scrollLeft;
              convert_json[find_page_index].scrolly = get_container.scrollTop;
              // localStorage.setItem('pagezoom',JSON.stringify(convert_json));
              this.encrptdecrpt.setItem("pagezoom", convert_json);//security
            }
          }
        }, 66);
      }, { passive: true });
    }
  }

  scrollPage_execute(page_details) {
    if (page_details.hasOwnProperty('scrollx') && page_details.hasOwnProperty('scrolly') && (page_details.scrollx >= 0 || page_details.scrolly >= 0)) {
      let get_element_query_selector = document.getElementsByClassName('drag-scroll-content');
      if (get_element_query_selector != null) {
        let get_container = get_element_query_selector[0];
        get_container.scrollTo({
          top: page_details.scrolly,
          left: page_details.scrollx,
          behavior: 'smooth'
        });
      }
    }
  }
  UTIEntry_field_Wmata(fields, defaultvalues) {
    // make json field wise showing array
    let make_final_temp_array = [];
    let sample_object = { "location": "", "decibels": "", "previouscondition": "", "flagforrReview": "", "Condition": "", "Comment": "" };
    for (let j = 0; j < defaultvalues.length; j++) {
      sample_object.location = "";
      sample_object.decibels = "";
      sample_object.previouscondition = "";
      sample_object.flagforrReview = "";
      sample_object.Condition = "";
      sample_object.Comment = "";
      for (let key in defaultvalues[j]) {
        for (let k = 0; k < fields.length; k++) {
          if (fields[k].element_uuid == key) {
            switch (k) {
              case 0:
                defaultvalues[j][key] = this.dataService4.changeSpecialtoKeyFormat(defaultvalues[j][key]);
                sample_object.location = defaultvalues[j][key];
                break;
              case 1:
                defaultvalues[j][key] = this.dataService4.changeSpecialtoKeyFormat(defaultvalues[j][key]);
                sample_object.decibels = defaultvalues[j][key];
                break;
              case 2:
                defaultvalues[j][key] = this.dataService4.changeSpecialtoKeyFormat(defaultvalues[j][key]);
                sample_object.previouscondition = defaultvalues[j][key];
                break;
              case 3:
                defaultvalues[j][key] = this.dataService4.changeSpecialtoKeyFormat(defaultvalues[j][key]);
                sample_object.flagforrReview = defaultvalues[j][key];
                break;
              case 4:
                let get_field_option = fields[k].element_data.options;
                let find_name_index = get_field_option.findIndex((uuid) => uuid.element_uuid == defaultvalues[j][key]);
                if (find_name_index > -1) {
                  sample_object.Condition = get_field_option[find_name_index].name;
                }
                else {
                  sample_object.Condition = defaultvalues[j][key];
                }
                break;
              case 5:
                defaultvalues[j][key] = this.dataService4.changeSpecialtoKeyFormat(defaultvalues[j][key]);
                sample_object.Comment = defaultvalues[j][key];
                break;
            }
          }
        }
      }
      let clone_sample_object = _.cloneDeep(sample_object);
      make_final_temp_array.push(clone_sample_object);
    }
    this.finalArray2 = make_final_temp_array;
  }

  async formattributeChangesDrawWMata(currentAnnotation, shapedetails) {
    let getChangesAttributes = this.attibutesValueChangeWMata(shapedetails, currentAnnotation);
    currentAnnotation = getChangesAttributes;
    let cloneDeepShapeData = _.cloneDeep(currentAnnotation);
    await this.annotationClearDraw(cloneDeepShapeData);
    currentAnnotation = getChangesAttributes;
    let isnegativeCoordinates = false;
    this.coordinateX = Number(getChangesAttributes.initial_position_x);
    this.coordinateY = Number(getChangesAttributes.initial_position_y);
    if (this.coordinateX < 0 && this.coordinateY < 0) {
      this.coordinateX = -this.coordinateX;
      this.coordinateY = -this.coordinateY;
      isnegativeCoordinates = true;
    }
    if (this.multipleSelectOn == false) {
      // header svg drawing
      this.single_view_svg_drawing(getChangesAttributes);
    }
    return currentAnnotation;
  }

  attibutesValueChangeWMata(shapedetails, currentAnnotation) {
    let getDeepClone = _.cloneDeep(currentAnnotation.toolbar_element_id);
    console.log(currentAnnotation);
    var annoDataChange = "";
    var annotChangeShapeName = "";
    var toolbarNameCheck = shapedetails.icon;
    let toolbarElementId = 1;
    let makeOriginalPropertyJson: any = {
      annotation_data: "", fill_color: "", line_width: 5,
      opacity: 1, stroke_color: "", toolbar_id: 1, initial_position_x: 0, initial_position_y: 0,
      initial_width: 0, initial_height: 0
    };
    console.log(toolbarNameCheck);
    if (toolbarNameCheck == "Circle") {
      annoDataChange = "move-35:25 controlpoint1-35:30.5228 controlpoint2-30.5228:35 endCurve-25:35 controlpoint1-19.4772:35 controlpoint2-15:30.5228 endCurve-15:25 controlpoint1-15:19.4772 controlpoint2-19.4772:15 endCurve-25:15 controlpoint1-30.5228:15 controlpoint2-35:19.4772 endCurve-35:25";
      annotChangeShapeName = "Circle";
      toolbarElementId = 1;
    } else if (toolbarNameCheck == "Octagon") {
      annoDataChange = "move-15:25 line-18:18 line-25:15 line-32:18 line-35:25 line-32:32 line-25:35 line-18:32 line-15:25 line-18:18";
      annotChangeShapeName = "Octagon";
      toolbarElementId = 2;
    } else if (toolbarNameCheck == "Square") {
      annoDataChange = "move-15:15 line-35:15 line-35:35 line-15:35 line-15:15 line-35:15";
      annotChangeShapeName = "Square";
      toolbarElementId = 3;
    } else if (toolbarNameCheck == "Triangle") {
      annoDataChange = "move-25:15 line-35:35 line-15:35 line-25:15 line-35:35";
      annotChangeShapeName = "Triangle";
      toolbarElementId = 4;
    } else if (toolbarNameCheck == "Star") {
      annoDataChange = "move-25:12 line-30:22 line-38:22 line-32:30 line-35:40 line-25:34 line-15:40 line-18:30 line-12:22 line-20:22 line-25:12 line-30:22";
      annotChangeShapeName = "Star";
      toolbarElementId = 5;
    } else if (toolbarNameCheck == "Diamond") {
      annoDataChange = "move-25:15 line-32.5:25 line-25:35 line-17.5:25 line-25:15 line-32.5:25";
      annotChangeShapeName = "Diamond";
      toolbarElementId = 6;
    }
    else if (toolbarNameCheck == "Flag") {
      annoDataChange = "move-15:40 line-15:15 line-30:15 line-25:20 line-30:25 line-17:25 line-17:40 line-15:40 line-15:15";
      annotChangeShapeName = "Flag";
      toolbarElementId = 7;
    } else if (toolbarNameCheck == "Camera") {
      annoDataChange = "move-31:22 controlpoint1-31:25.3137 controlpoint2-28.3137:28 endCurve-25:28 controlpoint1-21.6863:28 controlpoint2-19:25.3137 endCurve-19:22 controlpoint1-19:18.6863 controlpoint2-21.6863:16 endCurve-25:16 controlpoint1-28.3137:16 controlpoint2-31:18.6863 endCurve-31:22 move-17.5:15 line-19.5:12.5 line-30.5:12.5 line-32.5:15 line-36:15 controlpoint-38:15 curveEnd-38:17 line-38:29 controlpoint-38:31 curveEnd-36:31 line-14:31 controlpoint-12:31 curveEnd-12:29 line-12:17 controlpoint-12:15 curveEnd-14:15 line-17.5:15 line-19.5:12.5 move-14:19 line-16:19 line-16:20 line-14:20 move-22:22 controlpoint-22:19 curveEnd-25:19 controlpoint-28:19 curveEnd-28:22 controlpoint-28:25 curveEnd-25:25 controlpoint-22.5:25 curveEnd-22:22";
      annotChangeShapeName = "Camera";
      toolbarElementId = 8;
    } else if (toolbarNameCheck == "Arrow" || toolbarNameCheck == "Right Wide Arrow") {
      annoDataChange = "move-10:22.5 line-25:22.5 line-25:15 line-40:25 line-25:35 line-25:27.5 line-10:27.5 line-10:22.5 line-25:22.5"
      annotChangeShapeName = "Arrow";
      toolbarElementId = 9;
    }
    let getNewAnnotationData;
    if (getNewAnnotationData == "" || getNewAnnotationData == undefined) {
      makeOriginalPropertyJson.annotation_data = currentAnnotation.annotation_data;
      makeOriginalPropertyJson.initial_position_x = Number(currentAnnotation.initial_position_x);
      makeOriginalPropertyJson.initial_position_y = Number(currentAnnotation.initial_position_y);
      makeOriginalPropertyJson.initial_width = Number(currentAnnotation.initial_width);
      makeOriginalPropertyJson.initial_height = Number(currentAnnotation.initial_height);
      makeOriginalPropertyJson.initial_height = Number(currentAnnotation.initial_height);
      let getWidthHeightRA = this.shapeService1.getCanvaswidthandHeight(currentAnnotation);
      let initial_width_value = Number(currentAnnotation.initial_width);
      let initial_height_value = Number(currentAnnotation.initial_height);
      let initial_position_X_value = Number(currentAnnotation.initial_position_x);
      let initial_position_Y_value = Number(currentAnnotation.initial_position_y);
      let initial_position: boolean = false;
      let move_check: boolean = false;
      let resize_check: boolean = false;
      let simple_shape_resize: boolean = false;
      //freehand shapes only allow if condition
      if (getDeepClone > 11) {
        if (initial_width_value == 0 && initial_height_value == 0 && initial_position_X_value == 0 && initial_position_Y_value == 0) {
          initial_position = true;
          currentAnnotation["initial_width"] = getWidthHeightRA.width;
          currentAnnotation["initial_height"] = getWidthHeightRA.height;
          // currentAnnotation["initial_position_x"] = getWidthHeightRA.left + move_adjust + line_width_value;
          // currentAnnotation["initial_position_y"] = getWidthHeightRA.top + move_adjust + line_width_value;
        }
        else if (initial_width_value == 0 && initial_height_value == 0 && initial_position_X_value != 0 && initial_position_Y_value != 0) {
          move_check = true;
          currentAnnotation["initial_width"] = getWidthHeightRA.width;
          currentAnnotation["initial_height"] = getWidthHeightRA.height;
        }
        else {
          resize_check = true;
          if (initial_width_value == 0 && initial_height_value == 0) {
            currentAnnotation["initial_width"] = getWidthHeightRA.width;
            currentAnnotation["initial_height"] = getWidthHeightRA.height;
          }
          // let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          // if (getElementStyle != null) {
          //   let getStyle = getComputedStyle(getElementStyle);
          //   let getLeft_A: any = getStyle.left;
          //   getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
          //   let getTop_B: any = getStyle.top;
          //   getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
          //   currentAnnotation["initial_position_x"] = Number(getLeft_A) + 17.5 + line_width_value;
          //   currentAnnotation["initial_position_y"] = Number(getTop_B) + 17.5 + line_width_value;
          // }
        }

        // currentAnnotation["initial_width"] = getWidthHeightRA.width;
        // currentAnnotation["initial_height"] = getWidthHeightRA.height;
      }
      else if (initial_width_value != 0 && initial_height_value != 0) {
        simple_shape_resize = true;
        // currentOption.line_width = Number(currentOption.line_width) ==0 ? 5 : currentOption.line_width;
        let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
        if (getElementStyle != null) {
          let getStyle = getComputedStyle(getElementStyle);
          let getLeft_A: any = getStyle.left;
          getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
          let getTop_B: any = getStyle.top;
          getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
          // comment out this line becuase line width increasing every changes of drawing function so adding the linewidthvalue here it is adjust that increasing line width every adding
          // currentAnnotation["initial_position_x"] = Number(getLeft_A) + line_width_value;
          // currentAnnotation["initial_position_y"] = Number(getTop_B) + line_width_value;
        }
      }
      let shapeWidth = currentAnnotation.initial_width;
      let shapeHeight = currentAnnotation.initial_height;
      if (shapeWidth != 0 || shapeHeight != 0) {
        shapeWidth = shapeWidth == 0 ? 35 : shapeWidth;
        shapeHeight = shapeHeight == 0 ? 35 : shapeHeight;
        let margin_reduces_left: any = 0;
        let margin_reduces_top: any = 0;
        let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
        if (getElementStyle != null) {
          let getStyle = getComputedStyle(getElementStyle);
          margin_reduces_left = getStyle.marginLeft;
          margin_reduces_left = margin_reduces_left.substring(margin_reduces_left.length - 2, 0);
          let margin_reduces_top: any = getStyle.marginTop;
          margin_reduces_top = margin_reduces_top.substring(margin_reduces_top.length - 2, 0);
        }
        let checkRound_width = Math.round(shapeWidth);
        let checkRound_height = Math.round(shapeHeight);
        if (shapeWidth < shapeHeight && (checkRound_height != checkRound_width)) {
          shapeHeight = shapeWidth;
        }
        else if (shapeWidth > shapeHeight && (checkRound_height != checkRound_width)) {
          shapeWidth = shapeHeight;
        }
        if (shapeWidth < 35 || shapeHeight < 35) {
          shapeWidth = 35;
          shapeHeight = 35;
        }
        if (initial_position == true) {
          // line_width_reduce added at 11.01.2022 reason initial_width 0 and x !=0 shapes mismatch position fixed by this code.
          // let line_width_reduce = (currentAnnotation.line_width/6)/2;
          currentAnnotation.initial_position_x = getWidthHeightRA.left + ((getWidthHeightRA.width - shapeWidth) / 2) + 17.5;
          currentAnnotation.initial_position_y = getWidthHeightRA.top + ((getWidthHeightRA.height - shapeHeight) / 2) + 17.5;
          console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((currentAnnotation.initial_height - shapeHeight) / 2), ((currentAnnotation.initial_width - shapeWidth) / 2))
        }
        else if (move_check == true) {
          let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          if (getElementStyle != null) {
            let getStyle = getComputedStyle(getElementStyle);
            let getLeft_A: any = getStyle.left;
            getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
            let getTop_B: any = getStyle.top;
            getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
            console.log(getLeft_A, getTop_B);
            let get_height: any = getElementStyle.getAttribute("height");
            get_height = Number(get_height);
            let get_width: any = getElementStyle.getAttribute("width");
            get_width = Number(get_width);
            console.log(get_width, get_height);
            currentAnnotation.initial_position_x = Number(getLeft_A) + ((get_width - shapeWidth) / 2) + 17.5;
            currentAnnotation.initial_position_y = Number(getTop_B) + ((get_height - shapeHeight) / 2) + 17.5;
            console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((currentAnnotation.initial_height - shapeHeight) / 2), ((currentAnnotation.initial_width - shapeWidth) / 2))
          }

        }
        else if (resize_check == true) {
          let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          if (getElementStyle != null) {
            let getStyle = getComputedStyle(getElementStyle);
            let getLeft_A: any = getStyle.left;
            getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
            let getTop_B: any = getStyle.top;
            getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
            console.log(getLeft_A, getTop_B);
            let get_height: any = getElementStyle.getAttribute("height");
            get_height = Number(get_height);
            let get_width: any = getElementStyle.getAttribute("width");
            get_width = Number(get_width);
            console.log(get_width, get_height);
            currentAnnotation.initial_position_x = Number(getLeft_A) + 17.5 + ((get_width - shapeWidth) / 2);
            currentAnnotation.initial_position_y = Number(getTop_B) + 17.5 + ((get_height - shapeHeight) / 2);
            console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((get_height - shapeHeight) / 2), ((get_width - shapeWidth) / 2))
          }

        }
        else if (simple_shape_resize == true) {
          let getElementStyle = document.getElementById(currentAnnotation.annotation_id);
          if (getElementStyle != null) {
            let getStyle = getComputedStyle(getElementStyle);
            let getLeft_A: any = getStyle.left;
            getLeft_A = getLeft_A.substring(getLeft_A.length - 2, 0);
            let getTop_B: any = getStyle.top;
            getTop_B = getTop_B.substring(getTop_B.length - 2, 0);
            console.log(getLeft_A, getTop_B);
            let get_height: any = getElementStyle.getAttribute("height");
            get_height = Number(get_height);
            let get_width: any = getElementStyle.getAttribute("width");
            get_width = Number(get_width);
            console.log(get_width, get_height);
            currentAnnotation.initial_position_x = Number(getLeft_A) + 17.5 + ((get_width - shapeWidth) / 2);
            currentAnnotation.initial_position_y = Number(getTop_B) + 17.5 + ((get_height - shapeHeight) / 2);
            console.log("initial_pos jose", currentAnnotation.initial_position_x, currentAnnotation.initial_position_y, ((get_height - shapeHeight) / 2), ((get_width - shapeWidth) / 2))
          }
        }
        // else if (simple_shape_resize == true) {

        // }
        // line shapes features width and height less than 20 
        // currentAnnotation.initial_width = shapeWidth;
        // currentAnnotation.initial_height = shapeHeight;
        currentAnnotation.initial_width = shapeWidth;
        currentAnnotation.initial_height = shapeHeight;
        annoDataChange = this.changeShapeStringForBaseicon(toolbarElementId, shapeWidth, shapeHeight, annoDataChange);
      }
      currentAnnotation.annotation_data = annoDataChange;
    }
    // ipad change shape name not mentioned.
    // currentAnnotation.annotation_name = annotChangeShapeName;
    makeOriginalPropertyJson.fill_color = currentAnnotation.fill_color;
    makeOriginalPropertyJson.stroke_color = currentAnnotation.stroke_color;
    makeOriginalPropertyJson.opacity = currentAnnotation.opacity;
    makeOriginalPropertyJson.line_width = currentAnnotation.line_width;

    //current annotation form based changes
    currentAnnotation.toolbar_element_id = toolbarElementId;
    currentAnnotation.fill_color = shapedetails.fill_color;
    currentAnnotation.stroke_color = shapedetails.stroke_color;
    if (currentAnnotation.original_property == undefined || currentAnnotation.original_property == "") {
      currentAnnotation.original_property = makeOriginalPropertyJson;
    }
    return currentAnnotation;
  }

  timber_form_changes(default_values) {
    let get_custom_field_Index = this.modelFieldsForm.findIndex((f_data) => f_data.element_type == "uti-entry-field-TIMBER");
    if (get_custom_field_Index > -1) {
      let send_new_values = default_values;
      let item = this.modelFieldsForm[get_custom_field_Index];
      console.log(item, item.element_uuid, send_new_values);
      
      this.formValuesUpdate(item, item.element_uuid, send_new_values, null);
    }
  }

  repointvalidcheck() {
    //rotate and resize option enable should be check repoint option annotation based disable enable
    if (this.propertiesannotationData["toolbar_element_id"] == 13 || this.propertiesannotationData["toolbar_element_id"] == 14 ||
      this.propertiesannotationData["toolbar_element_id"] == 15 || this.propertiesannotationData["toolbar_element_id"] == 16
      || this.propertiesannotationData["toolbar_element_id"] == 18 || this.propertiesannotationData["toolbar_element_id"] == 19 || this.propertiesannotationData["toolbar_element_id"] == 20) {
      this.createDocumentStore.repointAccessValid = false;
    }
    else {
      this.createDocumentStore.repointAccessValid = true;
    }
  }

  current_value_updateto_layer() {
    let get_document_file = new documentfunction_maintain();
    let get_layer_updated_value = get_document_file.layer_data_update(this.layerDatas, this.propertiesannotationData)
    console.log(get_layer_updated_value);
    console.log(this.layerDatas);
    this.layerDatas = get_layer_updated_value;

  }

  select_primary_form(sortedForms) {
    // which is the form should be display primary form
    if (sortedForms.length > 0) {
      let find_set_default_value = sortedForms.findIndex((d_value) => this.createDocumentStore.data_allow_conditionT.includes(d_value.is_default_flag));
      if (find_set_default_value > -1) {
        return find_set_default_value;
        // this.currentFormId = sortedForms[find_set_default_value].form_id;
        // this.currentFormName = sortedForms[find_set_default_value].form_name;    
      }
      else {
        let index_last_form = sortedForms.length - 1;
        return index_last_form;
        // this.currentFormId = sortedForms[sortedForms.length - 1].form_id;
        // this.currentFormName = sortedForms[sortedForms.length - 1].form_name;
      }
    }
  }
  merge_form_process(annotationform, actualform, whichside: string) {
    let get_changes_form = _.cloneDeep(annotationform);
    let default_form_value = _.cloneDeep(actualform);
    // value replace recent edit annotation attached forms
    for (let m = 0; m < default_form_value.length; m++) {
      let find_field_index = get_changes_form.findIndex((field) => field.element_uuid == default_form_value[m].element_uuid);
      if (find_field_index > -1) {
        if (default_form_value[m].is_removed == true || default_form_value[m].is_removed == "true") {
          get_changes_form = get_changes_form.filter(ele => ele['element_uuid'] != default_form_value[m]['element_uuid']);
        }
        // ganesh changed this line FieldFind.length > 0 && FieldFind.is_removed != true && FieldFind.is_removed != "true"
        // added line FieldFind.length > 0 && FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true" for this if condition
        if (default_form_value[m].is_removed != true && default_form_value[m].is_removed != "true") {
          if (default_form_value[m].element_type == 'single_choice' || default_form_value[m].element_type == 'dropdown' || default_form_value[m].element_type == 'group_field') {
            if (default_form_value[m].element_data.hasOwnProperty("options") && default_form_value[m].element_data.options.length > 0) {
              // this.cdRef.detectChanges();
              // default_form_value[m].element_data.options.forEach(element1 => {
              //   element1.default = false;
              // });
              let defaultOptionValue = get_changes_form[find_field_index].element_data.options.filter((ele => ele.default == true))
              if (defaultOptionValue.length > 0) {
                var currentOption = default_form_value[m].element_data.options.filter((ele => ele.element_uuid == defaultOptionValue[0].element_uuid))
                if(currentOption.length > 0){
                  default_form_value[m].element_data.options.forEach(element1 => {
                    element1.default = false;
                  });
                }
                currentOption[0].default = true;
              }
            }
          } else if (default_form_value[m].element_type == 'multiple_choice' || default_form_value[m].element_type == 'checkbox') {
            if (default_form_value[m].element_data.hasOwnProperty("options") && default_form_value[m].element_data.options.length > 0) {

            }
            // default_form_value[m].element_data.options.forEach(element1 => {
            //   element1.default = false;
            // });
            let UCitemDefault = get_changes_form[find_field_index].element_data.options.filter((ele => ele.default == true))
            if(UCitemDefault.length > 0){
              default_form_value[m].element_data.options.forEach(element1 => {
                element1.default = false;
              });
            }
            else{
              const annuuid = get_changes_form[find_field_index].element_data.options[0].element_uuid;
              let currentOption1 = default_form_value[m].element_data.options.filter((ele => ele.element_uuid == annuuid))
              if(currentOption1.length > 0){
                currentOption1[0].default = false;
              }
            }
            UCitemDefault.forEach(element2 => {
              var currentOption = default_form_value[m].element_data.options.filter((ele => ele.element_uuid == element2.element_uuid))
              if(currentOption.length > 0){
                currentOption[0].default = true;
              }
            });

          }
          else if (default_form_value[m].element_type == 'date' && get_changes_form[find_field_index].element_data.default_date_time != undefined) {
            if (get_changes_form[find_field_index].element_data.default_date_time != "" && get_changes_form[find_field_index].element_data.default_date_time != "none" && get_changes_form[find_field_index].element_data.default_date_time != "current") {
              default_form_value[m].element_data.default_value = new Date(get_changes_form[find_field_index].element_data.default_date_time).toISOString();
              default_form_value[m].element_data.default_date_time = new Date(get_changes_form[find_field_index].element_data.default_date_time).toISOString();
            }
            else if (default_form_value[m].element_data.default_date_time != "") {
              if (default_form_value[m].element_data.default_date_time == "none" || default_form_value[m].element_data.default_date_time == "current") {
                //FieldFind[0].element_data.default_value = this.assignDates(FieldFind[0].element_data.default_date_time)
              }
              else {
                default_form_value[m].element_data.default_date_time = new Date(default_form_value[m].element_data.default_date_time).toISOString();
              }
            }

            if (get_changes_form[find_field_index].element_data.default_date_time != "" &&
              get_changes_form[find_field_index].element_data.default_date_time != "none" &&
              get_changes_form[find_field_index].element_data.default_date_time != "current" &&
              get_changes_form[find_field_index].element_data.default_date_time != undefined) {
              //  FieldFind[0].element_data.default_value = new Date(element.element_data.default_date_time).toISOString();
              default_form_value[m].element_data.default_date_time = new Date(get_changes_form[find_field_index].element_data.default_date_time).toISOString();
            }
            else if (get_changes_form[find_field_index].element_data.default_date_time != "") {
              if (get_changes_form[find_field_index].element_data.default_date_time == "current") {
                default_form_value[m].element_data.default_date_time = get_changes_form[find_field_index].element_data.default_date_time
              }
              
              // else if ((get_changes_form[find_field_index].element_data.default_date_time == "none" ||
              //   get_changes_form[find_field_index].element_data.default_date_time == "") || (default_form_value[m].element_data.default_date_time=="" ||default_form_value[m].element_data.default_date_time=="none" || default_form_value[m].element_data.default_date_time!="current")) {
              //   default_form_value[m].element_data.default_date_time = get_changes_form[find_field_index].element_data.default_date_time;
              // }
            }
          }
          else if (default_form_value[m].element_type == 'uti-entry-field') {
            default_form_value[m].element_data.default_values = get_changes_form[find_field_index].element_data['default_values']
          }
          else if (default_form_value[m].element_type == 'uti-entry-field-WMATA' || default_form_value[m].element_type == 'uti-entry-field-TIMBER' ||
          default_form_value[m].element_type == 'uti-entry-field-WMATA_WELD') {
            default_form_value[m].element_data.default_values = get_changes_form[find_field_index].element_data['default_values']
          }
          else if (default_form_value[m].element_type == 'address') {

            default_form_value[m].element_data.street_address1 = get_changes_form[find_field_index].element_data.street_address1
            default_form_value[m].element_data.city = get_changes_form[find_field_index].element_data["city"]
            default_form_value[m].element_data.state = get_changes_form[find_field_index].element_data["state"]
            default_form_value[m].element_data.zip = get_changes_form[find_field_index].element_data["zip"]
            default_form_value[m].element_data.street_address2 = get_changes_form[find_field_index].element_data.street_address2
          } else {
            if (get_changes_form[find_field_index].element_data.default_value != undefined &&
              get_changes_form[find_field_index].element_data.default_value != null &&
              get_changes_form[find_field_index].element_data.default_value != '') {
              default_form_value[m].element_data.default_value = get_changes_form[find_field_index].element_data.default_value
            }
          }
        }
      }
      // if left and right after dragging multi-column below else condition should work
      else if (find_field_index == -1) {
        let extend_model_value = whichside == 'leftside' ? this.createDocumentStore.backupExtendFormData : this.createDocumentStore.backupFormData;
        let find_field_index_extend = extend_model_value.findIndex((field) => field.element_uuid == default_form_value[m].element_uuid);
        if (find_field_index_extend > -1) {
          if (default_form_value[m].is_removed == true || default_form_value[m].is_removed == "true") {
            extend_model_value = extend_model_value.filter(ele => ele['element_uuid'] != default_form_value[m]['element_uuid']);
          }
          if (default_form_value[m].is_removed != true && default_form_value[m].is_removed != "true") {
            if (default_form_value[m].element_type == 'single_choice' || default_form_value[m].element_type == 'dropdown' || default_form_value[m].element_type == 'group_field') {
              if (default_form_value[m].element_data.options.length > 0) {
                default_form_value[m].element_data.options.forEach(element1 => {
                  element1.default = false;
                });
                let defaultOptionValue = extend_model_value[find_field_index_extend].element_data.options.filter((ele => ele.default == true))
                if (defaultOptionValue.length > 0) {
                  var currentOption = default_form_value[m].element_data.options.filter((ele => ele.element_uuid == defaultOptionValue[0].element_uuid))
                  currentOption[0].default = true;
                }
              }
            }
            else if (default_form_value[m].element_type == 'multiple_choice' || default_form_value[m].element_type == 'checkbox') {
              default_form_value[m].element_data.options.forEach(element1 => {
                element1.default = false;
              });
              let UCitemDefault = extend_model_value[find_field_index_extend].element_data.options.filter((ele => ele.default == true))
              UCitemDefault.forEach(element2 => {
                var currentOption = default_form_value[m].element_data.options.filter((ele => ele.element_uuid == element2.element_uuid))
                if(currentOption.length > 0){
                  currentOption[0].default = true;
                }
              });
            }
            else if (default_form_value[m].element_type == 'date' && extend_model_value[find_field_index_extend].element_data.default_date_time != undefined) {
              if (extend_model_value[find_field_index_extend].element_data.default_date_time != "" &&
                extend_model_value[find_field_index_extend].element_data.default_date_time != "none" && extend_model_value[find_field_index_extend].element_data.default_date_time != "current") {
                default_form_value[m].element_data.default_value = new Date(extend_model_value[find_field_index_extend].element_data.default_date_time).toISOString();
                default_form_value[m].element_data.default_date_time = new Date(extend_model_value[find_field_index_extend].element_data.default_date_time).toISOString();
              }
              else if (default_form_value[m].element_data.default_date_time != "") {
                if (default_form_value[m].element_data.default_date_time == "none" || default_form_value[m].element_data.default_date_time == "current") {
                  //FieldFind[0].element_data.default_value = this.assignDates(FieldFind[0].element_data.default_date_time)
                }
                else {
                  default_form_value[m].element_data.default_date_time = new Date(default_form_value[m].element_data.default_date_time).toISOString();
                }
              }

              if (extend_model_value[find_field_index_extend].element_data.default_date_time != "" &&
                extend_model_value[find_field_index_extend].element_data.default_date_time != "none" &&
                extend_model_value[find_field_index_extend].element_data.default_date_time != "current" &&
                extend_model_value[find_field_index_extend].element_data.default_date_time != undefined) {
                //  FieldFind[0].element_data.default_value = new Date(element.element_data.default_date_time).toISOString();
                default_form_value[m].element_data.default_date_time = new Date(extend_model_value[find_field_index_extend].element_data.default_date_time).toISOString();
              }
              else if (extend_model_value[find_field_index_extend].element_data.default_date_time != "") {
                if (extend_model_value[find_field_index_extend].element_data.default_date_time == "current") {
                  default_form_value[m].element_data.default_date_time = extend_model_value[find_field_index_extend].element_data.default_date_time
                }
                else if (extend_model_value[find_field_index_extend].element_data.default_date_time == "none" ||
                  extend_model_value[find_field_index_extend].element_data.default_date_time == "") {
                  default_form_value[m].element_data.default_date_time = extend_model_value[find_field_index_extend].element_data.default_date_time;
                }
              }
            }
            else if (default_form_value[m].element_type == 'uti-entry-field') {
              default_form_value[m].element_data.default_values = extend_model_value[find_field_index_extend].element_data['default_values']
            }
            else if (default_form_value[m].element_type == 'uti-entry-field-WMATA' || default_form_value[m].element_type == 'uti-entry-field-TIMBER' ||
            default_form_value[m].element_type == 'uti-entry-field-WMATA_WELD') {
              default_form_value[m].element_data.default_values = extend_model_value[find_field_index_extend].element_data['default_values']
            }
            else if (default_form_value[m].element_type == 'address') {

              default_form_value[m].element_data.street_address1 = extend_model_value[find_field_index_extend].element_data.street_address1
              default_form_value[m].element_data.city = extend_model_value[find_field_index_extend].element_data["city"]
              default_form_value[m].element_data.state = extend_model_value[find_field_index_extend].element_data["state"]
              default_form_value[m].element_data.zip = extend_model_value[find_field_index_extend].element_data["zip"]
              default_form_value[m].element_data.street_address2 = extend_model_value[find_field_index_extend].element_data.street_address2
            } else {
              if (extend_model_value[find_field_index_extend].element_data.default_value != undefined &&
                extend_model_value[find_field_index_extend].element_data.default_value != null &&
                extend_model_value[find_field_index_extend].element_data.default_value != '') {
                default_form_value[m].element_data.default_value = extend_model_value[find_field_index_extend].element_data.default_value
              }
            }
          }
        }
      }

    }
    return default_form_value;

    // this.modelFieldsForm.forEach(element => {
    //   var FieldFind = newFormDataFelds.filter(ele => ele['element_uuid'] == element['element_uuid']);
    //   // var find_model_field = ext_newFormDataFelds.filter((ele) => ele['element_uuid'] == element['element_uuid']);
    //   //Fieldfind ==> overall form fields from form builder
    //   //element ==> edited form fields for the annotation 
    //   // if (FieldFind.length == 0 && find_model_field.length > 0) {
    //   //   FieldFind = find_model_field;
    //   // }
    //   if (FieldFind.length > 0) {
    //     if (FieldFind[0].is_removed == true || FieldFind[0].is_removed == "true") {
    //       newFormDataFelds = newFormDataFelds.filter(ele => ele['element_uuid'] != FieldFind[0]['element_uuid']);
    //     }
    //     // ganesh changed this line FieldFind.length > 0 && FieldFind.is_removed != true && FieldFind.is_removed != "true"
    //     // added line FieldFind.length > 0 && FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true" for this if condition
    //     if (FieldFind[0].is_removed != true && FieldFind[0].is_removed != "true") {
    //       if (FieldFind[0].element_type == 'single_choice' || FieldFind[0].element_type == 'dropdown') {
    //         this.cdRef.detectChanges();
    //         FieldFind[0].element_data.options.forEach(element1 => {
    //           element1.default = false
    //         });
    //         var defaultOptionValue:any;
    //         if(element.element_data.hasOwnProperty('options'))
    //             {
    //                defaultOptionValue = element.element_data.options.filter((ele => ele.default == true))
    //             }
    //         if (defaultOptionValue!=undefined && defaultOptionValue.length > 0) {
    //           var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == defaultOptionValue[0].element_uuid))
    //           currentOption[0].default = true;
    //         }
    //       } else if (FieldFind[0].element_type == 'multiple_choice' || FieldFind[0].element_type == 'checkbox') {

    //         FieldFind[0].element_data.options.forEach(element1 => {
    //           element1.default = false
    //         });
    //         var UCitemDefault:any;
    //         if(element.element_data.hasOwnProperty('options'))
    //          {
    //              UCitemDefault = element.element_data.options.filter((ele => ele.default == true))
    //          }
    //          if(UCitemDefault!=undefined){
    //           UCitemDefault.forEach(element2 => {
    //             var currentOption = FieldFind[0].element_data.options.filter((ele => ele.element_uuid == element2.element_uuid))
    //             currentOption[0].default = true;
    //           });
    //         }
    //       }
    //       else if (FieldFind[0].element_type == 'date') {
    //         if (element.element_data.default_date_time != "" && element.element_data.default_date_time != "none" && element.element_data.default_date_time != "current" && element.element_data.default_date_time != undefined) {
    //           //  FieldFind[0].element_data.default_value = new Date(element.element_data.default_date_time).toISOString();
    //           FieldFind[0].element_data.default_date_time = new Date(element.element_data.default_date_time).toISOString();
    //         }
    //         else if (element.element_data.default_date_time != "") {
    //           if (element.element_data.default_date_time == "current") {
    //             FieldFind[0].element_data.default_date_time = element.element_data.default_date_time
    //           }
    //           else if (element.element_data.default_date_time == "none" || element.element_data.default_date_time == "") {
    //             FieldFind[0].element_data.default_date_time = element.element_data.default_date_time;
    //           }
    //         }
    //       }
    //       else if (FieldFind[0].element_type == 'uti-entry-field') {
    //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
    //       }
    //       else if (FieldFind[0].element_type == "uti-entry-field-WMATA") {
    //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
    //       }
    //       else if(FieldFind[0].element_type == "uti-entry-field-TIMBER"){
    //         // element_data replacing changes new 16.02.2022
    //         FieldFind[0].element_data.default_values = element.element_data['default_values'];
    //       }
    //       else if (FieldFind[0].element_type == 'address') {

    //         FieldFind[0].element_data.street_address1 = element.element_data.street_address1
    //         FieldFind[0].element_data.city = element.element_data["city"]
    //         FieldFind[0].element_data.state = element.element_data["state"]
    //         FieldFind[0].element_data.zip = element.element_data["zip"]
    //         FieldFind[0].element_data.street_address2 = element.element_data.street_address2
    //       } else {
    //         if (element.element_data.default_value != undefined && element.element_data.default_value != "") {
    //           FieldFind[0].element_data.default_value = element.element_data.default_value
    //         }
    //       }
    //     }
    //   }
    // })
  }

  doubleclickZooming(event) {
    console.log('double click zooming')
    let access_double_click = true;
    if (this.rotateandresize == true) {
      if (this.createDocumentStore.enableresizeButtons == false && this.createDocumentStore.enablerotateButtons == false
        && this.createDocumentStore.enablerepointButtons == false) {
        access_double_click = true;
      }
      else {
        access_double_click = false;
      }
    }
    else {
      access_double_click = true;
    }

    if (access_double_click == true) {
      console.log('double click');
      this.createDocumentStore.isSingleClick = false;
      this.pngFormat ? this.zoomIn(event) : this.zoomInPdf(event)
    }
  }

  mouse_wheeling(event) {

    let access_mouse_wheeling = true;
    if (this.rotateandresize == true) {
      if (this.createDocumentStore.enableresizeButtons == false && this.createDocumentStore.enablerotateButtons == false
        && this.createDocumentStore.enablerepointButtons == false) {
        access_mouse_wheeling = true;
      }
      else {
        access_mouse_wheeling = false;
      }
    }
    else {
      access_mouse_wheeling = true;
    }
    // if (access_mouse_wheeling == true && this.createDocumentStore_1.zooming_button_disable == false) {
    if (access_mouse_wheeling == true) {
      // this.createDocumentStore_1.zooming_button_disable = true;
      console.log('mouuse wheeling', event.wheelDelta / 2000);
      let calculate_wheeling = event.wheelDelta / 2000;
      // this.createDocumentStore_1.typeofzoom = calculate_wheeling < 0 ? "Zooming Out..." : "Zooming In..."; 
      if (this.pngFormat == true) {
        let scale_changes = this.scale + calculate_wheeling;
        console.log('final_wheel_sheet', scale_changes);
        if (scale_changes > 0.02) {
          this.wheel_zoom(event, scale_changes);
        }
      }
      else {
        let scale_changes = this.pdfScaleValue + calculate_wheeling;
        console.log('final_wheel_pdf', scale_changes);
        if (scale_changes > 0.02) {
          this.wheel_zoomInPdf(event, scale_changes);
        }
      }
    }
  }

  wheel_zoom(event, scale) {
    event.preventDefault();
    event.stopPropagation();
    console.log('zoom In');
    let getImageElement = document.getElementById('pdfImg');
    // getImageElement.style.opacity = "0";
    // setTimeout(() => {

      let getImageContainer = document.getElementById("Imagecontainer");
      console.log(getImageContainer);
      // getImageElement = document.getElementById("pdfImg");
      this.scaleValue = scale;
      this.scale = scale;
      getImageElement.style.transform = "scale(" + this.scale + ")";
      console.log(this.scaleValue);
      if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
        || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
        if (this.scale >= 1.24049) {
          this.zoomingLineShapeHandle();
        }
      }
      let getImageContainerSize = getImageContainer.getBoundingClientRect();
      console.log(getImageContainerSize);
      let currentWidthHeight = getImageElement.getBoundingClientRect();
      console.log(currentWidthHeight);
      // let currentViewX = currentWidthHeight.width;
      // let currentViewY = currentWidthHeight.height;
      let currentViewX = this.realWidth * this.scale;
      let currentViewY = this.realHeight * this.scale;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      console.log(currentViewX, currentViewY);
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: this.scale,
      });
      panZoomElement.pause();
      let viewImageDiv = document.getElementById("pdfImg");
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      // panZoomElement.centerOn('pdfImg');
      // calling Page Zoom maintain function
      this.pagewise_zoom_storage();
    // }, 500);

    // setTimeout(() => {
    //   getImageElement.style.opacity = "1";
    //   this.createDocumentStore_1.zooming_button_disable = false;
    // }, 800);
  }

  wheel_zoomInPdf(event, scale) {
    let get_element_pdf_img = document.getElementById('pdfImg');
    // get_element_pdf_img.style.opacity = "0";
    // setTimeout(() => {
      if (scale <= 1) {
        console.log('image type zoom below 0.9', scale);
        this.pdfScaleValue = scale;
        // zoomin Function calling revert back to the pdf width and height in initial value because of annotation plotting issue fixes
        let get_pdfimg = document.getElementById('pdfImg');
        if (get_pdfimg != null) {
          get_pdfimg.style.width = this.realWidth + 'px';
          get_pdfimg.style.height = this.realHeight + 'px';
        }
        let get_annotationhead = document.getElementById('pdfannotationhead');
        if (get_annotationhead != null) {
          get_annotationhead.style.removeProperty('top');
          get_annotationhead.style.removeProperty('left');
          get_annotationhead.style.removeProperty('transform');
        }
        this.scaleValue = this.pdfScaleValue;
        this.scale = this.pdfScaleValue;
        this.wheel_zoom(event, this.scale);
      } else {
        console.log('image type zoom above 0.9', scale);
        this.pdfScaleValue = scale;
        this.textLayerRenderedTimer();
        if (this.createDocumentStore.enablerepointButtons == false && (this.drawShapeDonePolyline == true
          || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolygon == true)) {
          if (this.pdfScaleValue >= 1.24049) {
            this.zoomingLineShapeHandle();
          }
        }
      }
    // }, 500);
    // setTimeout(() => {
    //   get_element_pdf_img.style.opacity = "1";
    //   this.createDocumentStore_1.zooming_button_disable = false;
    // }, 1500);
  }

  rotaterestrict360() {
    var getinputElement = (<HTMLInputElement>document.getElementById("rotatelabel"));
    if (this.createDocumentStore_1.rotate_deg_input > 360) {
      if (getinputElement != null) {
        getinputElement.value = '360';
        this.createDocumentStore_1.rotate_deg_input = 360;
      }
    }
    else if (this.createDocumentStore_1.rotate_deg_input < -360) {
      if (getinputElement != null) {
        getinputElement.value = '-360';
        this.createDocumentStore_1.rotate_deg_input = -360;
      }
    }
  }
  resizerestrict100() {
    var count = (this.createDocumentStore_1.resize_per_input.match(/-/g) || []).length;
    console.log(count);

    var getinputElement = (<HTMLInputElement>document.getElementById("resizelabel"));
    console.log(getinputElement)
    if (this.createDocumentStore_1.resize_per_input > 100) {
      if (getinputElement != null) {
        getinputElement.value = '100';
        this.createDocumentStore_1.resize_per_input = 100;
      }
    }
    else if (this.createDocumentStore_1.resize_per_input < -90) {
      if (getinputElement != null) {
        getinputElement.value = '-90';
        this.createDocumentStore_1.resize_per_input = -90;
      }
    }
   
    else if((count>1 ||(count==1 && this.createDocumentStore_1.resize_per_input.charAt(0)!="-"))){
      if (getinputElement != null) {
        getinputElement.value = '-90';
        this.createDocumentStore_1.resize_per_input = -90;
      }
    }
  }
  resizerestrict100_label(size){
    //The below lines are to restrict the + and - in input numner field
    this.inputBox = document.getElementById("resizeAnnotationlabel");
    this.inputBox.onkeypress = function(e) {    e = e || window.event;
			var charCode = (typeof e.which == "number") ? e.which : e.keyCode;
			var typedChar = String.fromCharCode(charCode);
			if (typedChar == "-" && this.value == "") {
				return false;
			}
      if (typedChar == "+" && this.value == "") {
				return false;
			}
		};
    var getinputElement = (<HTMLInputElement>document.getElementById("resizeAnnotationlabel"));
    console.log(size)
    if(size > 100){
      this.textsize = 100;
      getinputElement.value = '100';
    }
    else if(size < 0){
      this.textsize = 1;
      getinputElement.value = '1';
    }
  }

  resize_percentage_apply(percentage?: boolean, resize_per_input?: number) {

    this.sizeincrease(percentage, resize_per_input);
  }

  rotateresizewaringpopup(event) {
    let closeDeleteBox = this.dialogBox.open(WarningrotateresizeComponent, {
      width: '420px',
      data: {
        check: true
      },
    });
    closeDeleteBox.afterClosed().subscribe(async (res) => {
      switch (res) {
        case 'done':
          await this.rotateResizeupdateAPI();
          this.single_annotation_selection(event)
          break;
        case 'cancel':
          this.closeRotateFooter(event);
          break;
      }
    });
  }

  async multi_func_handling() {
    return new Promise((resolve, reject) => {
      if (this.createDocumentStore.forms_changes_status == true) {
        this.createDocumentStore.forms_changes_status = false;
        const the_weather = new Promise(async resolve => {
          let get_response = await this.multiple_annot_updateform_api();
          resolve(get_response);
        });

        const the_tweets = new Promise(resolve => {
          setTimeout(() => {
            resolve(200);
          }, 1000);
        });

        // Using ES6 Promises
        Promise.all([the_weather, the_tweets]).then(responses => {
          const [weatherInfo, tweetInfo] = responses;
          console.log(weatherInfo, tweetInfo);
          if (weatherInfo == 200 && tweetInfo == 200) {
            resolve(200);
          }
          else if (weatherInfo == 201) {
            resolve(201);
          }
        });
      }
      else {
        resolve(200);
      }
    });
  }

  async multiple_annot_updateform_api() {
    return new Promise((resolve, reject) => {
      if (this.userrole != 'view') {
        this.show = true;
        if (this.multipleSelectOn === true) {
          this.undoDatataForForms = _.cloneDeep(this.usecaseCopyArray)
          let generateCloneLayer = _.cloneDeep(this.layerDatas);
          let annotation_ids = this.createDocumentStore.selectedAnnotations;
          let unique_ids = annotation_ids.filter((c, index) => { return annotation_ids.indexOf(c) === index; });
          console.log(unique_ids, this.createDocumentStore.selectedAnnotations);
          this.createDocumentStore.selectedAnnotations = unique_ids;
          console.log(this.multiselectionList);
          let clone_multi_selectionlist = _.cloneDeep(this.multiselectionList);
          this.documentService.annotationMultipleUpdate(generateCloneLayer, clone_multi_selectionlist,'form').subscribe((response) => {
            console.log(response);
            if (response["response_code"] == 200) {
              this.show = false;
              resolve(200);
            }
            else {
              this.errorMessage();
              resolve(201);
            }
            (error) => {
              resolve(201);
            }
          });
        }
      }
    });

  }

  clear_drawing_path() {
    if (this.drawFreehandMenu == true || this.drawShapeDonePolylineArrow == true || this.drawShapeDonePolyline == true ||
      this.drawShapeDoneLine == true || this.drawShapeDoneLineAxial == true || this.drawShapeDonePolygon == true
      || this.drawEllipseDone == true || this.drawRectangleDone == true) {
      // if (this.drawCanvasContext != null && this.drawCanvasContext != undefined) {
      //Freehand line and Freehand area canvas Context clear on next page moving
      this.stringPathArray = [];
      // Freehand line and Freehand Area
      this.stringPath = "";
      this.accessMenuFeatureStop = true;
      //Line and Line Axial
      this.getPositionString = "";
      this.accessLineMenuFeatureStop = true;
      // Line Axial
      this.accessLineAxialMenuFeatureStop = true;
      // Polyline
      this.getPositionSetMove = 1;
      this.accessPolylineMenuFeatureStop = true;
      this.removeredCirclesSVG();
      // Polyline Arrow
      this.accessPolylineArrowMenuFeatureStop = true;
      // Polygon
      this.accessPolygonMenuFeatureStop = true;
      // Ellipse
      this.accessdrawEllipseMenuStop = true;
      // Rectangle
      this.accessRectangleMenuFeatureStop = true;
      let attributeName = "";
      if (this.drawFreehandMenu == true) {
        attributeName = "customefreehandattributepath";
      }
      else if (this.drawShapeDonePolylineArrow == true) {
        attributeName = "customepolylinearrowattributepath";
      }
      else if (this.drawShapeDonePolyline == true) {
        attributeName = "customepolylineattributepath";
      }
      else if (this.drawShapeDoneLine == true) {
        attributeName = "customelineattributepath";
      }
      else if (this.drawShapeDoneLineAxial == true) {
        attributeName = "customelineaxialattributepath";
      }
      else if (this.drawShapeDonePolygon == true) {
        attributeName = "customepolygonattributepath";
      }
      else if (this.drawEllipseDone == true) {
        attributeName = "customeellipseattributepath";
      }
      else if (this.drawRectangleDone == true) {
        attributeName = "customerectangleattributepath";
      }
      var empty_path_element = document.querySelector(`[${attributeName}]`);
      console.log(empty_path_element);
      if (empty_path_element != null && this.drawFreehandMenu == true) {
        let empty_path_elements = document.querySelectorAll(`[${attributeName}]`);
        if (empty_path_elements != null) {
          for (let k = 0; k < empty_path_elements.length; k++) {
            empty_path_elements[k].remove();
          }
        }
      }
      else if (empty_path_element != null && this.drawEllipseDone != true && this.drawRectangleDone != true) {
        empty_path_element.setAttribute("d", "");
      }
      else if (empty_path_element != null && this.drawEllipseDone == true) {
        empty_path_element.setAttribute('cx', "0");
        empty_path_element.setAttribute('cy', "0");
        empty_path_element.setAttribute('rx', "0");
        empty_path_element.setAttribute('ry', "0");
      }
      else if (empty_path_element != null && this.drawRectangleDone == true) {
        empty_path_element.setAttribute('x', "0");
        empty_path_element.setAttribute('y', "0");
        empty_path_element.setAttribute('width', "0");
        empty_path_element.setAttribute('height', "0");
      }
    }
  }

  functionstarttime(apiname) {
    var start = new Date().getTime();
    console.log(apiname + ' Start time: ' + start);
    return start
  }

  functionendtime(apiname, start) {
    var end = new Date().getTime();
    var time = end - start;
    console.log(apiname + ' end time: ' + end);
    console.log(apiname + ' Execution time: ' + time);
  }

  image_fit() {
    var start1 = new Date().getTime();
    console.log('image' + ' Start time: ' + start1);
    let getImageContainer = document.getElementById("Imagecontainer");
    let getImageContainerSize = getImageContainer.getBoundingClientRect();
    if (this.realWidth > getImageContainerSize.width || this.realHeight > getImageContainerSize.height) {
      let disableScale = false;
      var scale_val = Math.min(getImageContainerSize.width / (this.realWidth), getImageContainerSize.height / (this.realHeight))
      console.log(scale_val);
      // this.getAnnotationForm();
      this.scale = scale_val;
      let currentViewX = this.realWidth * scale_val;
      let currentViewY = this.realHeight * scale_val;
      let centerX = getImageContainerSize.width - currentViewX;
      let centerY = getImageContainerSize.height - currentViewY;
      let panZoomElement = panzoom(document.querySelector('#pdfImg'), {
        initialZoom: scale_val,
      });
      let viewImageDiv = document.getElementById("pdfImg");
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      panZoomElement.pause();
      // calling Page Zoom maintain function
      this.pagewise_zoom_storage();
    }
    else {
      let centerX = getImageContainerSize.width - this.realWidth;
      let centerY = getImageContainerSize.height - this.realHeight;
      let viewImageDiv = document.getElementById("pdfImg");
      this.scale = 1;
      this.scaleValue = 1;
      // this.getAnnotationForm();
      viewImageDiv.style.left = centerX > 0 ? centerX / 2 + 'px' : '0px';
      viewImageDiv.style.top = centerY > 0 ? centerY / 2 + 'px' : '0px';
      // calling Page Zoom maintain function
      this.pagewise_zoom_storage();
    }
    var end1 = new Date().getTime();
    var time = end1 - start1;
    console.log('image' + ' end time: ' + end1);
    console.log('image' + ' execution time: ' + time);
    this.createDocumentStore_1.pdf_or_image_load_complete = true;
    if (this.createDocumentStore_1.annotation_draw_complete == true && this.createDocumentStore_1.pdf_or_image_load_complete == true) {
      this.show = false;
    }
  }

  changeImageType() {
    // image path error handling main document image
    console.log(this.imgUrl);
    if (this.imgUrl != undefined && this.imgUrl != "") {
      fetch(this.imgUrl)
        .then((res) => res.blob())
        .then((blob) => heic2any({
          blob,
          toType: "image/jpeg",
        }).catch((e) => {
          console.log(e);
        }))
        .then((conversionResult: any) => {
          var url = URL.createObjectURL(conversionResult);
          let element: any = document.getElementById('scene');
          element.src = url;
        })
        .catch((e) => {
          console.log(e);
        });
    }
  }

  async enbl_cpy_mv_betweendocument(annotation_data, copy_type) {
    this.copytoolhead = true;
    this.toolcopyname('copy');
    if (copy_type == "move_with_data" || copy_type == "copy_with_data") {
      this.copyMode = "withData";
    }
    else if (copy_type == "move_without_data" || copy_type == "copy_without_data") {
      this.copyMode = "withoutData";
    }

    let clone_copy_data = annotation_data;
    this.copyAnnotationDatas = _.cloneDeep(clone_copy_data);
    this.createDocumentStore.copy_move_btw_doc = true;
    this.copyAnnotation_svg_view = [];
    this.copyAnnotationCreatePage();
    let svg_view_selected_annot = annotation_data;
    // convert SVG method view UI

    for (let ch = 0; ch < svg_view_selected_annot.length; ch++) {
      let svg_changes = await this.annotation_view_svg_copy(svg_view_selected_annot[ch]);
      //line shapes I have assigned extra 
      let lines = [13, 14, 15, 16];
      if (lines.includes(Number(svg_changes.toolbar_element_id))) {
        svg_changes.linewidth = svg_changes.linewidth * 2;
      }
      // check resize shapes line width increase simple shapes only
      svg_changes = linewidthchanges(svg_changes);
      this.copyAnnotation_svg_view.push(svg_changes);
    }
  }

  async document_usage_api_calls() {
    const the_toolbar = new Promise(async resolve => {
      let get_response = await this.current_toolbar_view_api();
      resolve(get_response);
    });

    const the_formlist = new Promise(async resolve => {
      let get_form_response = await this.getFormList();
      resolve(get_form_response);
    });

    const the_projectfolderlist = new Promise(async resolve => {
      let get_folder_response = await this.getProjectfolderlist(false);
      resolve(get_folder_response);
    });

    const the_getalldocumentpage = new Promise(async resolve => {
      let get_folder_response = await this.getAllDocumentPages();
      resolve(get_folder_response);
    });

    // const get_Grouping_Ann_form = new Promise(async resolve => {
    //   let get_response = await this.getGroupAnnotationDatas();
    //   resolve(get_response);
    // })

    the_formlist.then(responses => {
      console.log(responses)
      if (responses == 200) {
        this.getGroupAnnotationDatas();
      }
    });

    // Using ES6 Promises
    Promise.all([the_toolbar, the_formlist, the_projectfolderlist, the_getalldocumentpage]).then(responses => {
      const [toolbarinfo, forminfo, the_projectfolderlist] = responses;
      console.log(toolbarinfo, forminfo, the_projectfolderlist);
      if (toolbarinfo == 200 && forminfo == 200) {
        // do next function
        console.log('all api call complete')
      }
      else if (toolbarinfo == 201) {
        // do next function
      }
    });
  }

  convertArrtoJson(copyFormList){
    copyFormList.forEach(data =>{
      let arrayCheck = Array.isArray(data.form_data);
      if(arrayCheck == false){
          data.form_data = JSON.parse(data.form_data);
      }
      if(this.createDocumentStore.data_allow_conditionT.includes(data.is_extend)){
        let arrayCheckExtend = Array.isArray(data.ext_form_data);
        if(arrayCheckExtend == false){
          data.ext_form_data = JSON.parse(data.ext_form_data);
      }
      }
    })
    return copyFormList;
  }

  getGroupAnnotationDatas(){
    const ids = {
      folder_id: this.folderId,
      user_id: this.su.user_id,
    }
    this.show = true;
    const second = this.documentService.getGroupAnnts(ids).subscribe((response) => {
      console.log(response);
      console.log(this.formList);
      if (response["response_body"].length != 0) {
        let copyFormList = _.cloneDeep(this.formList);
        let cloneFormList = this.convertArrtoJson(copyFormList);
        let dropDownColorPresent;
        let JsonCheck = Array.isArray(response["response_body"][0].group_data);
        if (JsonCheck == false) {
          let data = JSON.parse(response["response_body"][0].group_data);
          console.log(this.currentPageId);
          let cloneGroupDatas = _.cloneDeep(data.group_data);
          cloneGroupDatas = cloneGroupDatas.filter(id => id.page_id == this.currentPageId)
          for (let z = 0; z < cloneGroupDatas.length; z++) {
            let groupDatas = cloneGroupDatas[z];
            this.createJSON_grpAnnts = data;
            let cloneGrpAnnList = _.cloneDeep(groupDatas.annotation_ids);
            let filterlist = this.checkAnnIDfromDOM(cloneGrpAnnList, groupDatas.annotation_ids);
            if(groupDatas.is_removed != true){
              let pathBox = this.calcMinandMaxforGrpAnnts_getAnns(filterlist);
              console.log(pathBox);
              let getBorderBoxWidthandHeight: any = this.getAnnotationWidthandHeightAction(pathBox);
              let groupColorCode = groupDatas.group_state;
              let groupId = groupDatas.group_annotation_id;
              let groupFormUUId = groupDatas.formfield_details.checkbox_field_id;
              let dropDownProp = this.toCheckDropDownispresent(groupFormUUId,cloneFormList)
              dropDownColorPresent = dropDownProp.isDropdownPresent;
              let groupStateColor;
              let lineWidth = null;
              if(dropDownProp.isDropdownPresent == true){
                groupStateColor = this.findAnnColor_FormBuilder(groupColorCode,dropDownProp.properties);
                if(dropDownProp.properties.hasOwnProperty('line_width')){
                  lineWidth = Number(dropDownProp.properties.line_width);
                }
              }
              else{
                groupStateColor = this.findColor(groupColorCode)
              }
              let getsvgpath_borderBox = {
                linewidth: lineWidth,
                annotation_id: groupId + "-borderbox",
                grouping_border_id: groupId,
                annotation_type: "groupingBox",
                annotation_data: pathBox,
                groupingEnable: true,
                opacity: 1,
                width: (getBorderBoxWidthandHeight.width),
                height: (getBorderBoxWidthandHeight.height),
                left: getBorderBoxWidthandHeight.left,
                top: getBorderBoxWidthandHeight.top,
                fill_color: "transparent",
                stroke_color: groupStateColor
              }
              console.log(getsvgpath_borderBox);
              let filter_colorDetails = groupDatas.color_details.filter(id => id.is_removed == false);
              let filter_colorDetails_basedonDOM = filter_colorDetails.filter(id => document.getElementById(id.annotation_id) != null);
              this.changeAnnColorbasedOnstate(groupColorCode,filter_colorDetails_basedonDOM,dropDownColorPresent,groupDatas,dropDownProp.properties);
            
              this.createDocumentStore.view_annotation_array.push(getsvgpath_borderBox);
            }
          }
          this.show = false;
        }
      }
      else{
        this.show = false;
      }
    })
  }
  toCheckDropDownispresent(groupFormUUId,cloneFormList){
    let findCurGropForm = cloneFormList.findIndex((data)=>{
      let curAnn = data.form_data.filter(id => id.element_uuid == groupFormUUId);
      if(curAnn.length > 0){
        return true;
      }
      else{
        return false;
      }
    })
    if (findCurGropForm == -1) {
      findCurGropForm = cloneFormList.findIndex((data) => {
        if (this.createDocumentStore.data_allow_conditionT.includes(data.is_extend)) {
          let curAnn = data.ext_form_data.filter(id => id.element_uuid == groupFormUUId);
          if (curAnn.length > 0) {
            return true;
          }
          else {
            return false;
          }
        }
      })
    }
    if(findCurGropForm != -1){
      let groupFormfilter;
      if(this.createDocumentStore.data_allow_conditionT.includes(cloneFormList[findCurGropForm].is_extend)){
        let combined_array = [...cloneFormList[findCurGropForm].form_data,...cloneFormList[findCurGropForm].ext_form_data];
        groupFormfilter = combined_array.filter(id => id.element_uuid == groupFormUUId);
      }
      else{
        groupFormfilter = cloneFormList[findCurGropForm].form_data.filter(id => id.element_uuid == groupFormUUId);
      }
      if(groupFormfilter.length > 0){
        let dropDownColorPresent = false;
        let dropdownDetails;
        if(groupFormfilter[0].element_data.hasOwnProperty('group_color_details')){
          dropDownColorPresent = true;
          dropdownDetails = groupFormfilter[0].element_data.group_color_details;
        }
        const dropDownDetails = {
          isDropdownPresent: dropDownColorPresent,
          properties: dropdownDetails
        }
        return dropDownDetails;
      }
    }
    else{
      const dropDownDetails = {
        isDropdownPresent: false,
        properties: null
      }
      return dropDownDetails;
    }
  }
  changeAnnColorbasedOnstate(groupColorCode,filter_colorDetails_basedonDOM,dropDownColorPresent,groupDatas,properties?){
    let groupStateColor = this.findColor(groupColorCode);
    if(dropDownColorPresent == true){
      groupStateColor = this.findAnnColor_FormBuilder(groupColorCode,properties);
    }
    else{
      groupStateColor = this.findColor(groupColorCode);
    }
    if(groupColorCode == 2){
      filter_colorDetails_basedonDOM.forEach(data => {
        let filterAnnDOM = this.createDocumentStore.view_annotation_array.filter(id => id.annotation_id == data.annotation_id);
        if (filterAnnDOM.length > 0) {
          let colorName;
          if (dropDownColorPresent == true) {
            colorName = this.findAnnColor_FormBuilder(groupColorCode,properties)
          }
          else {
            colorName = groupStateColor;
          }
          if (filterAnnDOM[0].toolbar_element_id != 11 && filterAnnDOM[0].toolbar_element_id != 12 && filterAnnDOM[0].toolbar_element_id != 13 && filterAnnDOM[0].toolbar_element_id != 14) {
            filterAnnDOM[0].fill_color = colorName;
          }
          filterAnnDOM[0].stroke_color = colorName;
          filterAnnDOM[0].opacity = 0.5;
        }
      })
    }
    else{
      filter_colorDetails_basedonDOM.forEach(data => {
        let filterAnnDOM = this.createDocumentStore.view_annotation_array.filter(id => id.annotation_id == data.annotation_id);
        let groupfilterAnn = groupDatas.color_details.filter(id => id.annotation_id == data.annotation_id);
        let annColorState = groupfilterAnn[0].color_state;
        if (filterAnnDOM.length > 0) {
          let findColorName;
          if(dropDownColorPresent == true){
            findColorName = this.findAnnColor_FormBuilder(annColorState,properties);
          }
          else{
            findColorName = this.findColor(annColorState);
          }
          if(filterAnnDOM[0].toolbar_element_id != 11 && filterAnnDOM[0].toolbar_element_id != 12 && filterAnnDOM[0].toolbar_element_id != 13 && filterAnnDOM[0].toolbar_element_id != 14){
            filterAnnDOM[0].fill_color = findColorName;
          }
          filterAnnDOM[0].stroke_color = findColorName;
          filterAnnDOM[0].opacity = 0.5;
        }
      })

    }
  }

  async sequence_api_calling() {
    const layer_api_call = new Promise(async resolve => {
      let get_response = await this.getAnnotationForm();
      resolve(get_response);
    });

    // const annotation_drawing = new Promise(async resolve => {
    //   let get_form_response = await this.getActiveLayerId();
    //   resolve(get_form_response);
    // });

    // Using ES6 Promises
    Promise.all([layer_api_call]).then(responses => {
      const [layerinfo] = responses;
      console.log(layerinfo);
      if (layerinfo == 200) {
        // disable the loader once drawing finished initial_time
        this.getActiveLayerIdMain();
        this.createDocumentStore_1.annotation_draw_complete = true;
        if (this.createDocumentStore_1.annotation_draw_complete == true && this.createDocumentStore_1.pdf_or_image_load_complete == true) {
          this.show = false;
          console.log('remainder');
          let get_ramainder_stop_flag = this.encrptdecrpt.getItem("remainderStop");
          if (get_ramainder_stop_flag != true && this.previousRoute != '/index') {
            this.remainder();
          }
        }
        this.document_usage_api_calls();
        console.log('all api call complete')
      }
    });
  }

  current_toolbar_view_api() {
    
    return new Promise(async resolve => {
      this.document_service_2.get_current_toolbar(this.projectId).subscribe((data) => {
        if (data["response_code"] == 200) {
          console.log(data);
          resolve(200);
          let get_response = data["response_body"];
          this.toolbarListData = data["response_body"];
          this.toolbar_detail=data["response_body"];
          let find_current_toolbar = get_response.findIndex((data_toolbar) => data_toolbar.toolbar_data != undefined && data_toolbar.toolbar_data  != null && data_toolbar.toolbar_data.length > 0);
          if (find_current_toolbar > -1) {
            this.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(get_response[find_current_toolbar].toolbar_name);
            this.toolbar_id = get_response[find_current_toolbar].toolbar_id;
            let get_toolbar_data = get_response[find_current_toolbar].toolbar_data;
            // set last toolbar appear data
            // this.lastseenToolbar_storage();
            // this.toolbarData = data["response_body"][find_current_toolbar].toolbar_data;
            // converting the special characters
            get_toolbar_data = this.dataService4.changeSpecialtokeyformatList(get_toolbar_data, 'toolbarbuilder');
            const filteredToolbar = get_toolbar_data.filter((id)=>this.createDocumentStore.data_allow_condition.includes(id.is_removed))
            this.modelFields = filteredToolbar;
            console.log(this.modelFields);
            this.copyOfModelfield = this.modelFields;
            this.tempModelFields = _.cloneDeep(this.modelFields);
            this.toolbarFilter = this.encrptdecrpt.getItem("toolbarFilterItem");
            this.toolbarFilterMethod();
            if (this.modelFields.length > 0) {
              // toolbar svg Drawing
              this.ngForRendred1();
            }
            // this.toolbarList.push(data["response_body"].toolbar_listing[0]);
            // check the enable of copy or move annotation to another document
            let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
            if (get_copy_move_ano_doc != null && get_copy_move_ano_doc.copyandmoveMode == true) {
              let clone_copy_data = _.cloneDeep(get_copy_move_ano_doc.annotations);
              this.enbl_cpy_mv_betweendocument(clone_copy_data, get_copy_move_ano_doc.mode);
            }
            // this.getProjectfolderlist(false);
            // make switch toolbar list
            for (let k = 0; k < get_response.length; k++) {
              let create_toolbar_ins = new switch_toolbar(get_response[k].toolbar_id, get_response[k].toolbar_name);
              this.createDocumentStore_1.switch_toolbar_list.push(create_toolbar_ins);
            }
          }
          else{
        
            // let find_current_toolbar = get_response.findIndex((data_toolbar) => data_toolbar.toolbar_data.length != 0  );
            this.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(get_response[0].toolbar_name);
            this.toolbar_id = get_response[0].toolbar_id;
            let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
            if (get_copy_move_ano_doc != null && get_copy_move_ano_doc.copyandmoveMode == true) {
              let clone_copy_data = _.cloneDeep(get_copy_move_ano_doc.annotations);
              this.enbl_cpy_mv_betweendocument(clone_copy_data, get_copy_move_ano_doc.mode);
            }
            for (let k = 0; k < get_response.length; k++) {
              let create_toolbar_ins = new switch_toolbar(get_response[k].toolbar_id, get_response[k].toolbar_name);
              this.createDocumentStore_1.switch_toolbar_list.push(create_toolbar_ins);
            }
          }
        }
        else {
          resolve(201);
        }
      });
    });
  }

  formlist_view_api() {
    this.document_service_2.get_formlist(this.projectId).subscribe((data) => {
      if (data["response_code"] == 200) {
        console.log(data);
        let getform_list = data["response_body"]["form_listing"];
        for (let k = 0; k < getform_list.length; k++) {
          let create_form_ins = new switch_form(getform_list[k].form_id, getform_list[k].form_name);
          this.createDocumentStore_1.switch_form_list.push(create_form_ins);
        }
      }
    });
  }

  switch_toolbar_api(toolbarId) {
    this.toolbarElements_view_svg = [];
    if (this.createDocumentStore_1.switch_toolbar_list.length > 0) {
      var start = new Date().getTime();
      console.log('toolbar data' + ' Start time: ' + start);
      this.toolbardesginService.get_toolbar_data(toolbarId).subscribe((data) => {
        if (data["response_code"] == 200) {
          var end = new Date().getTime();
          var time = end - start;
          console.log('toolbar data' + ' end time: ' + end);
          console.log('toolbar data' + ' Execution time: ' + time);
          this.toolbar_name = data["response_body"].toolbar_listing[0].toolbar_name;
          this.toolbar_name = this.dataService4.changeSpecialtoKeyFormat(this.toolbar_name);
          this.sub = this.toolbar_name;
          if(this.isRapidmode == true){
            this.toolbar_name = "Rapid Shot Mode Enabled";
          }
          this.toolbar_id = data["response_body"].toolbar_listing[0].toolbar_id;
          let get_toolbar_data = data["response_body"].toolbar_listing[0].toolbar_data;
          // set last toolbar appear data
          this.lastseenToolbar_storage();
          if (get_toolbar_data != null && get_toolbar_data != undefined) {
            let get_response_data = data["response_body"].toolbar_listing[0].toolbar_data;
            let convertJson_response = JSON.parse(get_response_data);
            if (get_toolbar_data.length > 0) {
              this.toolbarData = data["response_body"].toolbar_listing[0].toolbar_data;
              // converting the special characters
              convertJson_response = this.dataService4.changeSpecialtokeyformatList(convertJson_response, 'toolbarbuilder');
              this.modelFields = convertJson_response;
              //remove Deleted Toolbar Shapes
              let filterToolbarShape = this.modelFields.filter((TData) => TData.is_removed == false ||
                TData.is_removed == "false" || TData.is_removed == 0 || TData.is_removed == "0")

              this.modelFields = filterToolbarShape;
              console.log(this.modelFields);
              this.copyOfModelfield = this.modelFields;
              this.tempModelFields = _.cloneDeep(this.modelFields);
              this.toolbarFilter = this.encrptdecrpt.getItem("toolbarFilterItem");
              this.toolbarFilterMethod();
              if (this.modelFields.length > 0) {
                // toolbar svg Drawing
                this.ngForRendred1();
              }
            }
          }
          this.toolbarList.push(data["response_body"].toolbar_listing[0]);
          // check the enable of copy or move annotation to another document
          let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
          if (get_copy_move_ano_doc != null && get_copy_move_ano_doc.copyandmoveMode == true) {
            let clone_copy_data = _.cloneDeep(get_copy_move_ano_doc.annotations);
            this.enbl_cpy_mv_betweendocument(clone_copy_data, get_copy_move_ano_doc.mode);
          }
        }
      })
    }
    else {
      // check the enable of copy or move annotation to another document
      let get_copy_move_ano_doc = this.encrptdecrpt.getItem("cpy_mve_btw_doc");
      if (get_copy_move_ano_doc != null && get_copy_move_ano_doc.copyandmoveMode == true) {
        let clone_copy_data = _.cloneDeep(get_copy_move_ano_doc.annotations);
        this.enbl_cpy_mv_betweendocument(clone_copy_data, get_copy_move_ano_doc.mode);
      }
    }
  }

  // getannotation_list(){
  //   console.log(this.projectId, this.folderId);
  //   var start = new Date().getTime();
  //   console.log('getAnnotation api' + ' Start time: ' + start);
  //   this.layerDatas$ = this.documentService.getAnnotationFormlist(this.projectId, this.folderId, this.currentPageId)
  //     .subscribe((response) => {
  //       if(response["response_code"]==200){
  //         console.log(response);
  //         var end = new Date().getTime();
  //         var time = end - start;
  //         console.log('getAnnotation api' + ' end time: ' + end);
  //         console.log('getAnnotation api' + ' Execution time: ' + time);
  //         let layers = response["response_body"]["layer_data"];
  //         var start_a = new Date().getTime();
  //         console.log('draw annotation' + ' Start time: ' + start_a);
  //         for(let a=0;a<layers.length;a++){
  //           //draw document annotation loop
  //           for(let b=0;b<layers[a].annotations.length;b++){
  //             let current_annotation = layers[a].annotations[b];
  //             let getsvg_path = this.documentPage.changesvgpath(current_annotation, 'document', this.pngFormat);
  //             this.createDocumentStore.view_annotation_array.push(getsvg_path);
  //           }
  //         }
  //         var end_a = new Date().getTime();
  //         var time_a = end_a - start_a;
  //         console.log('draw annotation' + ' end time: ' + end_a);
  //         console.log('draw annotation' + ' Execution time: ' + time_a);
  //         this.createDocumentStore_1.annotation_draw_complete = true;
  //         if(this.createDocumentStore_1.annotation_draw_complete == true && this.createDocumentStore_1.pdf_or_image_load_complete == true){
  //           this.show = false;
  //         }
  //         this.document_usage_api_calls();
  //       }
  //     });
  // }

  // backup annotation storage area for move and rotate and resize
  backup_annot_storage(annotation_data) {
    if (this.createDocumentStore.backup_annot_Store.length > 0) {
      console.log(this.createDocumentStore.backup_annot_Store);
      let filter_already_stored_items = this.createDocumentStore.backup_annot_Store.findIndex((resize_value) => resize_value.annotation_object.annotation_id == annotation_data.annotation_id);
      console.log(filter_already_stored_items)
      if (filter_already_stored_items == -1) {
        let get_model_keys = get_annot_draw_model(annotation_data);
        let annotation_model = new annotation_keys(get_model_keys);
        this.createDocumentStore.backup_annot_Store.push(annotation_model);
      }
      else{
        let get_model_keys = get_annot_draw_model(annotation_data);
        let annotation_model = new annotation_keys(get_model_keys);
        this.createDocumentStore.backup_annot_Store.splice(filter_already_stored_items,1,annotation_model);
      }
    }
    else {
      let get_model_keys = get_annot_draw_model(annotation_data);
      let annotation_model = new annotation_keys(get_model_keys);
      this.createDocumentStore.backup_annot_Store.push(annotation_model);
    }
  }
  
  loaderStop_after_response(get_response) {
    if (get_response == 200) {
      this.show = false;
    }
  }

  ondragaction(value: boolean) {
    this.createDocumentStore_1.slideDrag = value;
    if (value == true) {
      this.slideAfterScale();
    }
  }
cancel(){
  this.select_autocad=false;
  this.autocad_import=[]
  this.layerDatas=[]
  this.document_load()
  this.service.autocademit.emit({"response":[],"selected":false,"process_id":""})
}
save(){
this.autocad.save(this.process_id).subscribe((response) => {
  console.log(response)
  if(response["response_code"]==200){
    this.document_load()
    this.service.autocademit.emit({"response":[],"selected":false,"process_id":""})
  }
})
}
  //welddata
  // To delete the row of the table in weld wmata form
  deleterow(index,item){
    if(this.multipleSelectOn == true){
      this.useCaseEmptycellIds = []
    }
    console.log(index);
    console.log(this.right)
    let copyFormLeft = _.cloneDeep(this.formContentleft);
    if(this.formContentleft.length > index){
     this.formContentleft = [];
     copyFormLeft.splice(index,1);
     this.formContentleft = copyFormLeft;
    }
    if(this.formContentright.length > index){
     this.formContentright.splice(index,1)
    }
    if(item.element_data.hasOwnProperty('default_values')){
     let defaultValues = item.element_data.default_values;
     if(defaultValues.length > 0){
       let copy = _.cloneDeep(defaultValues);
       copy.splice(index,1);
       this.formValuesUpdate(item, item.element_uuid, copy, "delete");
     }
    }
   }
  // To add new row in tha table in weld wmata form
  add(){
    this.formShow = true;
    console.log(this.weld_FormStructure);
    this.setDefault();
  }
  // To split the user enetered table values of the row into two columns in weld wmata form
  splitarray(value){
    if(value != undefined){
      for(let v = 0;v < value.length;v++){
        let dataleft = {
          Weld: value[v].weld_Id,
          Repair: value[v].repair,
          Entire : value[v].area_Entire,
          uuid : value[v].element_uuid,
        }
        let dataright = {
          Specific: value[v].area_Specific,
          Interpretation: value[v].interpretation,
          Remarks: value[v].remarks,
          uuid : value[v].element_uuid,
        }
        this.formContentleft.push(dataleft);
        this.formContentright.push(dataright);
      }
    }
  }
  // To update the form values of weld wmata form.
  onSubmit(formdata,item){
    if (this.multipleSelectOn == true) {
      this.useCaseEmptycellIds = []
    }    
    this.formShow = false;
    const result = this.checkemptyornot(formdata.value);
    if(result === true){
      return;
    }
    this.fieldsWeld = item.element_data.fields;
    console.log(formdata.value);
    const formValues = formdata.value;
    let cloneFormValue = _.cloneDeep(formValues);
    let convertUUID = this.custom_form_make_uuid_weld(cloneFormValue); 
    let convert_formStructure = this.defaultAPI_structure_maintain(formValues);
    let formValuesArray = []
    formValuesArray.push(convertUUID)
    this.formValuesUpdate(item, item.element_uuid, formValuesArray, null);
    let formvalueobject = [];
    formvalueobject.push(convert_formStructure)
    this.splitarray(formvalueobject);
  }
  // To check whether user entered any values in table
  checkemptyornot(rowvalues){
    const values = _.cloneDeep(rowvalues);
    const valuesAll = Object.keys(values).map(key => values[key] == "");
    const abc = valuesAll.includes(false)
    const entire = rowvalues.areaEntire;
    if(entire === true || entire === false){
        return false
    }
    if (abc === false){
     return true;
    }
    return false;
 }
  defaultAPI_structure_maintain(formValues){
    let defaultstructure = new weld_form_main();
    defaultstructure["weld_Id"] = formValues.weldId.toString()
    defaultstructure["area_Entire"] = formValues.areaEntire.toString()
    defaultstructure["interpretation"] = formValues.interpretation.toString()
    defaultstructure["repair"] = formValues.repairType.toString()
    defaultstructure["area_Specific"] = formValues.areaSpecific.toString()
    defaultstructure["remarks"] = formValues.remarks.toString()
    defaultstructure["element_uuid"] = this.dataService4.generateUUID();
    return defaultstructure;
  }
  // To convert the values(which is in UUID) form API to normal values
  convertUUIDtoNormal(formValues) {
    let finalArray = [];
    let sampleObject = {
      weld_Id: "", area_Entire: "", interpretation: "", repair: "", area_Specific: "", remarks: "",
    }
    for (let i in formValues) {
      sampleObject.weld_Id = "";
      sampleObject.area_Entire = "";
      sampleObject.interpretation = "";
      sampleObject.repair = "";
      sampleObject.area_Specific = "";
      sampleObject.remarks = "";
      for (let key in formValues[i]) {
        for (let j in this.fieldsWeld) {
          if (this.fieldsWeld[j].element_uuid == key) {
            const name = this.fieldsWeld[j].table_name;
            switch (name) {
              case 'Weld ID':
                sampleObject.weld_Id = formValues[i][key];
                break;
              case 'Repair Type':
                sampleObject.repair = formValues[i][key];
                break;
              case 'Specific':
                sampleObject.area_Specific = formValues[i][key];
                break;
              case 'Remarks':
                sampleObject.remarks = formValues[i][key];
                break;
              case 'Entire':
                const value = formValues[i][key];
                if(value === true){
                  sampleObject.area_Entire = "true";
                }
                else{
                  sampleObject.area_Entire = "";
                }
                break;
              case 'Interpretation':
                let getOptions = this.fieldsWeld[j].options;
                let index = getOptions.findIndex((id) => id.element_uuid == formValues[i][key]);
                if (index > -1) {
                  sampleObject.interpretation = getOptions[index].name;
                }
                else {
                  sampleObject.interpretation = formValues[i][key];
                }
                break;
            }
          }
        }
      }
      let clone_sample_object = _.cloneDeep(sampleObject);
      finalArray.push(clone_sample_object);
    }
    return finalArray;
  }
  // To convert the normal values to UUID values(Before sending to server)
  custom_form_make_uuid_weld(formValue){
    const formFields = _.cloneDeep(this.fieldsWeld);
    for(let data in formValue){
      switch (data) {
        case 'weldId':
          const index1 = formFields.findIndex((id) => id.table_name == "Weld ID");
          formValue[formFields[index1].element_uuid] = formValue[data];
          delete formValue[data];
          break;
        case 'repairType':
          const index2 = formFields.findIndex((id) => id.table_name == "Repair Type");
          formValue[formFields[index2].element_uuid] = formValue[data];
          delete formValue[data];
          break;
        case 'remarks':
          const index3 = formFields.findIndex((id) => id.table_name == "Remarks");
          formValue[formFields[index3].element_uuid] = formValue[data];
          delete formValue[data];
          break;
        case 'areaSpecific':
          const index4 = formFields.findIndex((id) => id.table_name == "Specific");
          formValue[formFields[index4].element_uuid] = formValue[data];
          delete formValue[data];
          break;
        case 'interpretation':
          const index5 = formFields.findIndex((id) => id.table_name == "Interpretation");
          formValue[formFields[index5].element_uuid] = formValue[data];
          // let options = formFields[index5].options;
          // let optionIndex = options.findIndex((id)=>id.name == formValue[data]);
          // if(optionIndex > -1){
          //   formValue[formFields[index5].element_uuid] = options[optionIndex].element_uuid;
          // }
          delete formValue[data];
          break;
        case  'areaEntire':
          const index6 = formFields.findIndex((id) => id.table_name == "Entire");
          let checkBoxBoolean = false;
          if(formValue[data] == true){
            checkBoxBoolean = true;
          }
          formValue[formFields[index6].element_uuid] = checkBoxBoolean;
          delete formValue[data];
      } 
    }
    return formValue;
  }
  // To set the variables to null in weld wmata form.
  setDefault(){
    let formsetnull = {
      weldId: "",
      areaEntire: "",
      interpretation: "",
      remarks: "",
      repairType: "",
      areaSpecific: "",
    }
    this.weld_FormStructure.setValue(formsetnull);
    this.weld_form_table = []
  }
}

